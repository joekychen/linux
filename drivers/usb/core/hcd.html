<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › core › hcd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hcd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * (C) Copyright Linus Torvalds 1999</span>
<span class="cm"> * (C) Copyright Johannes Erdfelt 1999-2001</span>
<span class="cm"> * (C) Copyright Andreas Gal 1999</span>
<span class="cm"> * (C) Copyright Gregory P. Smith 1999</span>
<span class="cm"> * (C) Copyright Deti Fliegl 1999</span>
<span class="cm"> * (C) Copyright Randy Dunlap 2000</span>
<span class="cm"> * (C) Copyright David Brownell 2000-2002</span>
<span class="cm"> * </span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/version.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * USB Host Controller Driver framework</span>
<span class="cm"> *</span>
<span class="cm"> * Plugs into usbcore (usb_bus) and lets HCDs share code, minimizing</span>
<span class="cm"> * HCD-specific behaviors/bugs.</span>
<span class="cm"> *</span>
<span class="cm"> * This does error checks, tracks devices and urbs, and delegates to a</span>
<span class="cm"> * &quot;hc_driver&quot; only for code (and data) that really needs to know about</span>
<span class="cm"> * hardware differences.  That includes root hub registers, i/o queues,</span>
<span class="cm"> * and so on ... but as little else as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * Shared code includes most of the &quot;root hub&quot; code (these are emulated,</span>
<span class="cm"> * though each HC&#39;s hardware works differently) and PCI glue, plus request</span>
<span class="cm"> * tracking overhead.  The HCD code should only block on spinlocks or on</span>
<span class="cm"> * hardware handshaking; blocking on software events (such as other kernel</span>
<span class="cm"> * threads releasing resources, or completing actions) is all generic.</span>
<span class="cm"> *</span>
<span class="cm"> * Happens the USB 2.0 spec says this would be invisible inside the &quot;USBD&quot;,</span>
<span class="cm"> * and includes mostly a &quot;HCDI&quot; (HCD Interface) along with some APIs used</span>
<span class="cm"> * only by the hub driver ... and that neither should be seen or used by</span>
<span class="cm"> * usb client device drivers.</span>
<span class="cm"> *</span>
<span class="cm"> * Contributors of ideas or unattributed patches include: David Brownell,</span>
<span class="cm"> * Roman Weissgaerber, Rory Bolt, Greg Kroah-Hartman, ...</span>
<span class="cm"> *</span>
<span class="cm"> * HISTORY:</span>
<span class="cm"> * 2002-02-21	Pull in most of the usb_bus support from usb.c; some</span>
<span class="cm"> *		associated cleanup.  &quot;usb_hcd&quot; still != &quot;usb_bus&quot;.</span>
<span class="cm"> * 2001-12-12	Initial patch version for Linux 2.5.1 kernel.</span>
<span class="cm"> */</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Keep track of which host controller drivers are loaded */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usb_hcds_loaded</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcds_loaded</span><span class="p">);</span>

<span class="cm">/* host controllers we manage */</span>
<span class="n">LIST_HEAD</span> <span class="p">(</span><span class="n">usb_bus_list</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span> <span class="p">(</span><span class="n">usb_bus_list</span><span class="p">);</span>

<span class="cm">/* used when allocating bus numbers */</span>
<span class="cp">#define USB_MAXBUS		64</span>
<span class="k">struct</span> <span class="n">usb_busmap</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">busmap</span> <span class="p">[</span><span class="n">USB_MAXBUS</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="k">sizeof</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))];</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_busmap</span> <span class="n">busmap</span><span class="p">;</span>

<span class="cm">/* used when updating list of hcds */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>	<span class="cm">/* exported only for usbfs */</span>
<span class="n">EXPORT_SYMBOL_GPL</span> <span class="p">(</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>

<span class="cm">/* used for controlling access to virtual root hubs */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>

<span class="cm">/* used when updating an endpoint&#39;s URB list */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>

<span class="cm">/* used to protect against unlinking URBs after the device is gone */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hcd_urb_unlink_lock</span><span class="p">);</span>

<span class="cm">/* wait queue for synchronous unlinks */</span>
<span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">usb_kill_urb_queue</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_root_hub</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Sharable chunks of root hub code.</span>
<span class="cm"> */</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define KERNEL_REL	((LINUX_VERSION_CODE &gt;&gt; 16) &amp; 0x0ff)</span>
<span class="cp">#define KERNEL_VER	((LINUX_VERSION_CODE &gt;&gt; 8) &amp; 0x0ff)</span>

<span class="cm">/* usb 3.0 root hub device descriptor */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">usb3_rh_dev_descriptor</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x12</span><span class="p">,</span>       <span class="cm">/*  __u8  bLength; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bDescriptorType; Device */</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="cm">/*  __le16 bcdUSB; v3.0 */</span>

	<span class="mh">0x09</span><span class="p">,</span>	    <span class="cm">/*  __u8  bDeviceClass; HUB_CLASSCODE */</span>
	<span class="mh">0x00</span><span class="p">,</span>	    <span class="cm">/*  __u8  bDeviceSubClass; */</span>
	<span class="mh">0x03</span><span class="p">,</span>       <span class="cm">/*  __u8  bDeviceProtocol; USB 3.0 hub */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  bMaxPacketSize0; 2^9 = 512 Bytes */</span>

	<span class="mh">0x6b</span><span class="p">,</span> <span class="mh">0x1d</span><span class="p">,</span> <span class="cm">/*  __le16 idVendor; Linux Foundation 0x1d6b */</span>
	<span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*  __le16 idProduct; device 0x0003 */</span>
	<span class="n">KERNEL_VER</span><span class="p">,</span> <span class="n">KERNEL_REL</span><span class="p">,</span> <span class="cm">/*  __le16 bcdDevice */</span>

	<span class="mh">0x03</span><span class="p">,</span>       <span class="cm">/*  __u8  iManufacturer; */</span>
	<span class="mh">0x02</span><span class="p">,</span>       <span class="cm">/*  __u8  iProduct; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  iSerialNumber; */</span>
	<span class="mh">0x01</span>        <span class="cm">/*  __u8  bNumConfigurations; */</span>
<span class="p">};</span>

<span class="cm">/* usb 2.0 root hub device descriptor */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">usb2_rh_dev_descriptor</span> <span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x12</span><span class="p">,</span>       <span class="cm">/*  __u8  bLength; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bDescriptorType; Device */</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="cm">/*  __le16 bcdUSB; v2.0 */</span>

	<span class="mh">0x09</span><span class="p">,</span>	    <span class="cm">/*  __u8  bDeviceClass; HUB_CLASSCODE */</span>
	<span class="mh">0x00</span><span class="p">,</span>	    <span class="cm">/*  __u8  bDeviceSubClass; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  bDeviceProtocol; [ usb 2.0 no TT ] */</span>
	<span class="mh">0x40</span><span class="p">,</span>       <span class="cm">/*  __u8  bMaxPacketSize0; 64 Bytes */</span>

	<span class="mh">0x6b</span><span class="p">,</span> <span class="mh">0x1d</span><span class="p">,</span> <span class="cm">/*  __le16 idVendor; Linux Foundation 0x1d6b */</span>
	<span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*  __le16 idProduct; device 0x0002 */</span>
	<span class="n">KERNEL_VER</span><span class="p">,</span> <span class="n">KERNEL_REL</span><span class="p">,</span> <span class="cm">/*  __le16 bcdDevice */</span>

	<span class="mh">0x03</span><span class="p">,</span>       <span class="cm">/*  __u8  iManufacturer; */</span>
	<span class="mh">0x02</span><span class="p">,</span>       <span class="cm">/*  __u8  iProduct; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  iSerialNumber; */</span>
	<span class="mh">0x01</span>        <span class="cm">/*  __u8  bNumConfigurations; */</span>
<span class="p">};</span>

<span class="cm">/* no usb 2.0 root hub &quot;device qualifier&quot; descriptor: one speed only */</span>

<span class="cm">/* usb 1.1 root hub device descriptor */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">usb11_rh_dev_descriptor</span> <span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x12</span><span class="p">,</span>       <span class="cm">/*  __u8  bLength; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bDescriptorType; Device */</span>
	<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="cm">/*  __le16 bcdUSB; v1.1 */</span>

	<span class="mh">0x09</span><span class="p">,</span>	    <span class="cm">/*  __u8  bDeviceClass; HUB_CLASSCODE */</span>
	<span class="mh">0x00</span><span class="p">,</span>	    <span class="cm">/*  __u8  bDeviceSubClass; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  bDeviceProtocol; [ low/full speeds only ] */</span>
	<span class="mh">0x40</span><span class="p">,</span>       <span class="cm">/*  __u8  bMaxPacketSize0; 64 Bytes */</span>

	<span class="mh">0x6b</span><span class="p">,</span> <span class="mh">0x1d</span><span class="p">,</span> <span class="cm">/*  __le16 idVendor; Linux Foundation 0x1d6b */</span>
	<span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*  __le16 idProduct; device 0x0001 */</span>
	<span class="n">KERNEL_VER</span><span class="p">,</span> <span class="n">KERNEL_REL</span><span class="p">,</span> <span class="cm">/*  __le16 bcdDevice */</span>

	<span class="mh">0x03</span><span class="p">,</span>       <span class="cm">/*  __u8  iManufacturer; */</span>
	<span class="mh">0x02</span><span class="p">,</span>       <span class="cm">/*  __u8  iProduct; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  iSerialNumber; */</span>
	<span class="mh">0x01</span>        <span class="cm">/*  __u8  bNumConfigurations; */</span>
<span class="p">};</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Configuration descriptors for our root hubs */</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">fs_rh_config_descriptor</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>

	<span class="cm">/* one configuration */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  bLength; */</span>
	<span class="mh">0x02</span><span class="p">,</span>       <span class="cm">/*  __u8  bDescriptorType; Configuration */</span>
	<span class="mh">0x19</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*  __le16 wTotalLength; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bNumInterfaces; (1) */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bConfigurationValue; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  iConfiguration; */</span>
	<span class="mh">0xc0</span><span class="p">,</span>       <span class="cm">/*  __u8  bmAttributes; </span>
<span class="cm">				 Bit 7: must be set,</span>
<span class="cm">				     6: Self-powered,</span>
<span class="cm">				     5: Remote wakeup,</span>
<span class="cm">				     4..0: resvd */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  MaxPower; */</span>
      
	<span class="cm">/* USB 1.1:</span>
<span class="cm">	 * USB 2.0, single TT organization (mandatory):</span>
<span class="cm">	 *	one interface, protocol 0</span>
<span class="cm">	 *</span>
<span class="cm">	 * USB 2.0, multiple TT organization (optional):</span>
<span class="cm">	 *	two interfaces, protocols 1 (like single TT)</span>
<span class="cm">	 *	and 2 (multiple TT mode) ... config is</span>
<span class="cm">	 *	sometimes settable</span>
<span class="cm">	 *	NOT IMPLEMENTED</span>
<span class="cm">	 */</span>

	<span class="cm">/* one interface */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bLength; */</span>
	<span class="mh">0x04</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bDescriptorType; Interface */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceNumber; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bAlternateSetting; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bNumEndpoints; */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceSubClass; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceProtocol; [usb1.1 or single tt] */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_iInterface; */</span>
     
	<span class="cm">/* one endpoint (status change endpoint) */</span>
	<span class="mh">0x07</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bLength; */</span>
	<span class="mh">0x05</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bDescriptorType; Endpoint */</span>
	<span class="mh">0x81</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */</span>
 	<span class="mh">0x03</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bmAttributes; Interrupt */</span>
 	<span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*  __le16 ep_wMaxPacketSize; 1 + (MAX_ROOT_PORTS / 8) */</span>
	<span class="mh">0xff</span>        <span class="cm">/*  __u8  ep_bInterval; (255ms -- usb 2.0 spec) */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">hs_rh_config_descriptor</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>

	<span class="cm">/* one configuration */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  bLength; */</span>
	<span class="mh">0x02</span><span class="p">,</span>       <span class="cm">/*  __u8  bDescriptorType; Configuration */</span>
	<span class="mh">0x19</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*  __le16 wTotalLength; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bNumInterfaces; (1) */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bConfigurationValue; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  iConfiguration; */</span>
	<span class="mh">0xc0</span><span class="p">,</span>       <span class="cm">/*  __u8  bmAttributes; </span>
<span class="cm">				 Bit 7: must be set,</span>
<span class="cm">				     6: Self-powered,</span>
<span class="cm">				     5: Remote wakeup,</span>
<span class="cm">				     4..0: resvd */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  MaxPower; */</span>
      
	<span class="cm">/* USB 1.1:</span>
<span class="cm">	 * USB 2.0, single TT organization (mandatory):</span>
<span class="cm">	 *	one interface, protocol 0</span>
<span class="cm">	 *</span>
<span class="cm">	 * USB 2.0, multiple TT organization (optional):</span>
<span class="cm">	 *	two interfaces, protocols 1 (like single TT)</span>
<span class="cm">	 *	and 2 (multiple TT mode) ... config is</span>
<span class="cm">	 *	sometimes settable</span>
<span class="cm">	 *	NOT IMPLEMENTED</span>
<span class="cm">	 */</span>

	<span class="cm">/* one interface */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bLength; */</span>
	<span class="mh">0x04</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bDescriptorType; Interface */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceNumber; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bAlternateSetting; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bNumEndpoints; */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceSubClass; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceProtocol; [usb1.1 or single tt] */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_iInterface; */</span>
     
	<span class="cm">/* one endpoint (status change endpoint) */</span>
	<span class="mh">0x07</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bLength; */</span>
	<span class="mh">0x05</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bDescriptorType; Endpoint */</span>
	<span class="mh">0x81</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */</span>
 	<span class="mh">0x03</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bmAttributes; Interrupt */</span>
		    <span class="cm">/* __le16 ep_wMaxPacketSize; 1 + (MAX_ROOT_PORTS / 8)</span>
<span class="cm">		     * see hub.c:hub_configure() for details. */</span>
	<span class="p">(</span><span class="n">USB_MAXCHILDREN</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="mh">0x0c</span>        <span class="cm">/*  __u8  ep_bInterval; (256ms -- usb 2.0 spec) */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">ss_rh_config_descriptor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* one configuration */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  bLength; */</span>
	<span class="mh">0x02</span><span class="p">,</span>       <span class="cm">/*  __u8  bDescriptorType; Configuration */</span>
	<span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*  __le16 wTotalLength; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bNumInterfaces; (1) */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  bConfigurationValue; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  iConfiguration; */</span>
	<span class="mh">0xc0</span><span class="p">,</span>       <span class="cm">/*  __u8  bmAttributes;</span>
<span class="cm">				 Bit 7: must be set,</span>
<span class="cm">				     6: Self-powered,</span>
<span class="cm">				     5: Remote wakeup,</span>
<span class="cm">				     4..0: resvd */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  MaxPower; */</span>

	<span class="cm">/* one interface */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bLength; */</span>
	<span class="mh">0x04</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bDescriptorType; Interface */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceNumber; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bAlternateSetting; */</span>
	<span class="mh">0x01</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bNumEndpoints; */</span>
	<span class="mh">0x09</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceSubClass; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_bInterfaceProtocol; */</span>
	<span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/*  __u8  if_iInterface; */</span>

	<span class="cm">/* one endpoint (status change endpoint) */</span>
	<span class="mh">0x07</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bLength; */</span>
	<span class="mh">0x05</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bDescriptorType; Endpoint */</span>
	<span class="mh">0x81</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */</span>
	<span class="mh">0x03</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bmAttributes; Interrupt */</span>
		    <span class="cm">/* __le16 ep_wMaxPacketSize; 1 + (MAX_ROOT_PORTS / 8)</span>
<span class="cm">		     * see hub.c:hub_configure() for details. */</span>
	<span class="p">(</span><span class="n">USB_MAXCHILDREN</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="mh">0x0c</span><span class="p">,</span>       <span class="cm">/*  __u8  ep_bInterval; (256ms -- usb 2.0 spec) */</span>

	<span class="cm">/* one SuperSpeed endpoint companion descriptor */</span>
	<span class="mh">0x06</span><span class="p">,</span>        <span class="cm">/* __u8 ss_bLength */</span>
	<span class="mh">0x30</span><span class="p">,</span>        <span class="cm">/* __u8 ss_bDescriptorType; SuperSpeed EP Companion */</span>
	<span class="mh">0x00</span><span class="p">,</span>        <span class="cm">/* __u8 ss_bMaxBurst; allows 1 TX between ACKs */</span>
	<span class="mh">0x00</span><span class="p">,</span>        <span class="cm">/* __u8 ss_bmAttributes; 1 packet per service interval */</span>
	<span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span>   <span class="cm">/* __le16 ss_wBytesPerInterval; 15 bits for max 15 ports */</span>
<span class="p">};</span>

<span class="cm">/* authorized_default behaviour:</span>
<span class="cm"> * -1 is authorized for all devices except wireless (old behaviour)</span>
<span class="cm"> * 0 is unauthorized for all devices</span>
<span class="cm"> * 1 is authorized for all devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">authorized_default</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">authorized_default</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">authorized_default</span><span class="p">,</span>
		<span class="s">&quot;Default USB device authorization: 0 is not authorized, 1 is &quot;</span>
		<span class="s">&quot;authorized, -1 is authorized except for wireless USB (default, &quot;</span>
		<span class="s">&quot;old behaviour&quot;</span><span class="p">);</span>
<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * ascii2desc() - Helper routine for producing UTF-16LE string descriptors</span>
<span class="cm"> * @s: Null-terminated ASCII (actually ISO-8859-1) string</span>
<span class="cm"> * @buf: Buffer for USB string descriptor (header + UTF-16LE)</span>
<span class="cm"> * @len: Length (in bytes; may be odd) of descriptor buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the number of bytes filled in: 2 + 2*strlen(s) or</span>
<span class="cm"> * buflen, whichever is less.</span>
<span class="cm"> *</span>
<span class="cm"> * USB String descriptors can contain at most 126 characters; input</span>
<span class="cm"> * strings longer than that are truncated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">ascii2desc</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">254</span><span class="p">)</span>
		<span class="n">t</span> <span class="o">=</span> <span class="mi">254</span><span class="p">;</span>	<span class="cm">/* Longest possible UTF string descriptor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">+=</span> <span class="n">USB_DT_STRING</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* Now t is first 16 bits to store */</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rh_string() - provides string descriptors for root hub</span>
<span class="cm"> * @id: the string ID number (0: langids, 1: serial #, 2: product, 3: vendor)</span>
<span class="cm"> * @hcd: the host controller for this root hub</span>
<span class="cm"> * @data: buffer for output packet</span>
<span class="cm"> * @len: length of the provided buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Produces either a manufacturer, product or serial number string for the</span>
<span class="cm"> * virtual root hub device.</span>
<span class="cm"> * Returns the number of bytes filled in: the length of the descriptor or</span>
<span class="cm"> * of the provided buffer, whichever is less.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">rh_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="k">const</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
	<span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">langids</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="n">USB_DT_STRING</span><span class="p">,</span> <span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">};</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>language ids</p></td><td class="code"><div class="highlight"><pre>	<span class="k">switch</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* Array of LANGID codes (0x0409 is MSFT-speak for &quot;en-us&quot;) */</span>
		<span class="cm">/* See http://www.usb.org/developers/docs/USB_LANGIDs.pdf */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">langids</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="cm">/* Serial number */</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bus_name</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="cm">/* Product name */</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">product_desc</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="cm">/* Manufacturer */</span>
		<span class="n">snprintf</span> <span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s %s %s&quot;</span><span class="p">,</span> <span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sysname</span><span class="p">,</span>
			<span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">,</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">);</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Can&#39;t happen; caller guarantees it */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ascii2desc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Root hub control transfers execute synchronously */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rh_call_control</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
 	<span class="n">u16</span>		<span class="n">typeReq</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">wLength</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">ubuf</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * tbuf should be as big as the BOS descriptor and</span>
<span class="cm">	 * the USB hub descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>		<span class="n">tbuf</span><span class="p">[</span><span class="n">USB_DT_BOS_SIZE</span> <span class="o">+</span> <span class="n">USB_DT_USB_SS_CAP_SIZE</span><span class="p">]</span>
		<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>
	<span class="k">const</span> <span class="n">u8</span>	<span class="o">*</span><span class="n">bufp</span> <span class="o">=</span> <span class="n">tbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">patch_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">patch_protocol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">hcd</span><span class="p">;</span>	<span class="cm">/* Indicate it&#39;s queued */</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">;</span>
	<span class="n">typeReq</span>  <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">;</span>
	<span class="n">wValue</span>   <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">);</span>
	<span class="n">wIndex</span>   <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">);</span>
	<span class="n">wLength</span>  <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wLength</span> <span class="o">&gt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* DEVICE REQUESTS */</span>

	<span class="cm">/* The root hub&#39;s remote wakeup enable bit is implemented using</span>
<span class="cm">	 * driver model wakeup flags.  If this system supports wakeup</span>
<span class="cm">	 * through USB, userspace may change the default &quot;allow wakeup&quot;</span>
<span class="cm">	 * policy through sysfs or these calls.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Most root hubs support wakeup from downstream devices, for</span>
<span class="cm">	 * runtime power management (disabling USB clocks and reducing</span>
<span class="cm">	 * VBUS power usage).  However, not all of them do so; silicon,</span>
<span class="cm">	 * board, and BIOS bugs here are not uncommon, so these can&#39;t</span>
<span class="cm">	 * be treated quite like external hubs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Likewise, not all root hubs will pass wakeup events upstream,</span>
<span class="cm">	 * to wake up the whole system.  So don&#39;t assume root hub and</span>
<span class="cm">	 * controller capabilities are identical.</span>
<span class="cm">	 */</span>

	<span class="k">case</span> <span class="n">DeviceRequest</span> <span class="o">|</span> <span class="n">USB_REQ_GET_STATUS</span>:
		<span class="n">tbuf</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
					<span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">)</span>
				<span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_SELF_POWERED</span><span class="p">);</span>
		<span class="n">tbuf</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DeviceOutRequest</span> <span class="o">|</span> <span class="n">USB_REQ_CLEAR_FEATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">)</span>
			<span class="n">device_set_wakeup_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DeviceOutRequest</span> <span class="o">|</span> <span class="n">USB_REQ_SET_FEATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">device_can_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">)</span>
			<span class="n">device_set_wakeup_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DeviceRequest</span> <span class="o">|</span> <span class="n">USB_REQ_GET_CONFIGURATION</span>:
		<span class="n">tbuf</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">DeviceOutRequest</span> <span class="o">|</span> <span class="n">USB_REQ_SET_CONFIGURATION</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DeviceRequest</span> <span class="o">|</span> <span class="n">USB_REQ_GET_DESCRIPTOR</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_DT_DEVICE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">HCD_USB3</span>:
				<span class="n">bufp</span> <span class="o">=</span> <span class="n">usb3_rh_dev_descriptor</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">HCD_USB2</span>:
				<span class="n">bufp</span> <span class="o">=</span> <span class="n">usb2_rh_dev_descriptor</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">HCD_USB11</span>:
				<span class="n">bufp</span> <span class="o">=</span> <span class="n">usb11_rh_dev_descriptor</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">has_tt</span><span class="p">)</span>
				<span class="n">patch_protocol</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_DT_CONFIG</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">HCD_USB3</span>:
				<span class="n">bufp</span> <span class="o">=</span> <span class="n">ss_rh_config_descriptor</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">ss_rh_config_descriptor</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">HCD_USB2</span>:
				<span class="n">bufp</span> <span class="o">=</span> <span class="n">hs_rh_config_descriptor</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">hs_rh_config_descriptor</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">HCD_USB11</span>:
				<span class="n">bufp</span> <span class="o">=</span> <span class="n">fs_rh_config_descriptor</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">fs_rh_config_descriptor</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">device_can_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
				<span class="n">patch_wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_DT_STRING</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">wValue</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">rh_string</span><span class="p">(</span><span class="n">wValue</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>
						<span class="n">hcd</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
			<span class="k">else</span> <span class="cm">/* unsupported IDs --&gt; &quot;protocol stall&quot; */</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_DT_BOS</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>:
			<span class="k">goto</span> <span class="n">nongeneric</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DeviceRequest</span> <span class="o">|</span> <span class="n">USB_REQ_GET_INTERFACE</span>:
		<span class="n">tbuf</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">DeviceOutRequest</span> <span class="o">|</span> <span class="n">USB_REQ_SET_INTERFACE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DeviceOutRequest</span> <span class="o">|</span> <span class="n">USB_REQ_SET_ADDRESS</span>:</pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>wValue == urb->dev->devaddr</p></td><td class="code"><div class="highlight"><pre>		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;root hub device address %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">wValue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* INTERFACE REQUESTS (no defined feature/status flags) */</span>

	<span class="cm">/* ENDPOINT REQUESTS */</span>

	<span class="k">case</span> <span class="n">EndpointRequest</span> <span class="o">|</span> <span class="n">USB_REQ_GET_STATUS</span>:</pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>ENDPOINT_HALT flag</p></td><td class="code"><div class="highlight"><pre>		<span class="n">tbuf</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tbuf</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">EndpointOutRequest</span> <span class="o">|</span> <span class="n">USB_REQ_CLEAR_FEATURE</span>:
	<span class="k">case</span> <span class="n">EndpointOutRequest</span> <span class="o">|</span> <span class="n">USB_REQ_SET_FEATURE</span>:
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;no endpoint features yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* CLASS REQUESTS (and errors) */</span>

	<span class="nl">default:</span>
<span class="nl">nongeneric:</span>
		<span class="cm">/* non-generic request */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">GetHubStatus</span>:
		<span class="k">case</span> <span class="n">GetPortStatus</span>:
			<span class="n">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DeviceRequest</span> <span class="o">|</span> <span class="n">USB_REQ_GET_DESCRIPTOR</span>:
			<span class="cm">/* len is returned by hub_control */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">hub_control</span> <span class="p">(</span><span class="n">hcd</span><span class="p">,</span>
			<span class="n">typeReq</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
			<span class="n">tbuf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="nl">error:</span>
		<span class="cm">/* &quot;protocol stall&quot; on error */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
				<span class="s">&quot;CTRL: TypeReq=0x%x val=0x%x &quot;</span>
				<span class="s">&quot;idx=0x%x len=%d ==&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">typeReq</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
				<span class="n">wLength</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* hub_control may return the length of data copied. */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>always USB<em>DIR</em>IN, toward host</p></td><td class="code"><div class="highlight"><pre>		<span class="n">memcpy</span> <span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">bufp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="cm">/* report whether RH hardware supports remote wakeup */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">patch_wakeup</span> <span class="o">&amp;&amp;</span>
				<span class="n">len</span> <span class="o">&gt;</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_config_descriptor</span><span class="p">,</span>
						<span class="n">bmAttributes</span><span class="p">))</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">usb_config_descriptor</span> <span class="o">*</span><span class="p">)</span><span class="n">ubuf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmAttributes</span>
				<span class="o">|=</span> <span class="n">USB_CONFIG_ATT_WAKEUP</span><span class="p">;</span>

		<span class="cm">/* report whether RH hardware has an integrated TT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">patch_protocol</span> <span class="o">&amp;&amp;</span>
				<span class="n">len</span> <span class="o">&gt;</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_descriptor</span><span class="p">,</span>
						<span class="n">bDeviceProtocol</span><span class="p">))</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">ubuf</span><span class="p">)</span><span class="o">-&gt;</span>
				<span class="n">bDeviceProtocol</span> <span class="o">=</span> <span class="n">USB_HUB_PR_HS_SINGLE_TT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* any errors get returned through the urb completion */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

	<span class="cm">/* This peculiar use of spinlocks echoes what real HC drivers do.</span>
<span class="cm">	 * Avoiding calls to local_irq_disable/enable makes the code</span>
<span class="cm">	 * RT-friendly.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Root Hub interrupt transfers are polled using a timer if the</span>
<span class="cm"> * driver requests it; otherwise the driver is responsible for</span>
<span class="cm"> * calling usb_hcd_poll_rh_status() when an event occurs.</span>
<span class="cm"> *</span>
<span class="cm"> * Completions are called in_interrupt(), but they may or may not</span>
<span class="cm"> * be in_irq().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="n">buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>	<span class="cm">/* Any root hubs with &gt; 31 ports? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_pollable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">hub_status_data</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* try to complete the status urb */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

			<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
			<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The USB 2.0 spec says 256 ms.  This is close enough and won&#39;t</span>
<span class="cm">	 * exceed that limit if HZ is 100. The math is more clunky than</span>
<span class="cm">	 * maybe expected, this is to make sure that all timers for USB devices</span>
<span class="cm">	 * fire at the same time to give the CPU a break in between */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">?</span> <span class="n">HCD_POLL_RH</span><span class="p">(</span><span class="n">hcd</span><span class="p">)</span> <span class="o">:</span>
			<span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">mod_timer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span><span class="o">/</span><span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_poll_rh_status</span><span class="p">);</span>

<span class="cm">/* timer callback */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rh_timer_func</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_hcd_poll_rh_status</span><span class="p">((</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">_hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rh_queue_status</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">maxchild</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span> <span class="o">||</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;not queuing rh status urb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">hcd</span><span class="p">;</span>	<span class="cm">/* indicate it&#39;s queued */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span><span class="o">/</span><span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">4</span><span class="p">));</span>

	<span class="cm">/* If a status change has already occurred, report it ASAP */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">HCD_POLL_PENDING</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rh_urb_enqueue</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rh_queue_status</span> <span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rh_call_control</span> <span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Unlinks of root-hub control URBs are legal, but they don&#39;t do anything</span>
<span class="cm"> * since these URBs always execute synchronously.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_rh_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Control URB */</span>
		<span class="p">;</span>	<span class="cm">/* Do nothing */</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>				<span class="cm">/* Status URB */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span><span class="p">)</span>
			<span class="n">del_timer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">status_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
			<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Show &amp; store the current value of authorized_default</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">usb_host_authorized_default_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
						<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rh_usb_dev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">usb_bus</span> <span class="o">=</span> <span class="n">rh_usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_bus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>	<span class="cm">/* FIXME: not sure if this case is possible */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">usb_hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">usb_bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usb_hcd</span><span class="o">-&gt;</span><span class="n">authorized_default</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">usb_host_authorized_default_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
						 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rh_usb_dev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">usb_bus</span> <span class="o">=</span> <span class="n">rh_usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_bus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>	<span class="cm">/* FIXME: not sure if this case is possible */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">usb_hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">usb_bus</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_hcd</span><span class="o">-&gt;</span><span class="n">authorized_default</span> <span class="o">=</span> <span class="n">val</span><span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">authorized_default</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
	    <span class="n">usb_host_authorized_default_show</span><span class="p">,</span>
	    <span class="n">usb_host_authorized_default_store</span><span class="p">);</span>


<span class="cm">/* Group all the USB bus attributes */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">usb_bus_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="o">&amp;</span><span class="n">dev_attr_authorized_default</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">usb_bus_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>	<span class="cm">/* we want them in the same directory */</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">usb_bus_attrs</span><span class="p">,</span>
<span class="p">};</span>



<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_bus_init - shared initialization code</span>
<span class="cm"> * @bus: the bus structure being initialized</span>
<span class="cm"> *</span>
<span class="cm"> * This code is used to initialize a usb_bus structure, memory for which is</span>
<span class="cm"> * separately managed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_bus_init</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_devmap</span><span class="p">));</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">devnum_next</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">root_hub</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">bandwidth_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">bandwidth_int_reqs</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">bandwidth_isoc_reqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_register_bus - registers the USB host controller with the usb core</span>
<span class="cm"> * @bus: pointer to the bus to register</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Assigns a bus number, and links the controller into usbcore data</span>
<span class="cm"> * structures so that it can be seen by scanning the bus list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_register_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busnum</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
	<span class="n">busnum</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span> <span class="p">(</span><span class="n">busmap</span><span class="p">.</span><span class="n">busmap</span><span class="p">,</span> <span class="n">USB_MAXBUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busnum</span> <span class="o">&gt;=</span> <span class="n">USB_MAXBUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: too many buses</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usbcore_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_find_busnum</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_bit</span> <span class="p">(</span><span class="n">busnum</span><span class="p">,</span> <span class="n">busmap</span><span class="p">.</span><span class="n">busmap</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span> <span class="o">=</span> <span class="n">busnum</span><span class="p">;</span>

	<span class="cm">/* Add it to the local list of buses */</span>
	<span class="n">list_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_bus_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>

	<span class="n">usb_notify_add_bus</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">dev_info</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;new USB bus registered, assigned bus &quot;</span>
		  <span class="s">&quot;number %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_find_busnum:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_deregister_bus - deregisters the USB host controller</span>
<span class="cm"> * @bus: pointer to the bus to deregister</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Recycles the bus number, and unlinks the controller from usbcore data</span>
<span class="cm"> * structures so that it won&#39;t be seen by scanning the bus list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_deregister_bus</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;USB bus %d deregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: make sure that all the devices are removed by the</span>
<span class="cm">	 * controller code, as well as having it call this when cleaning</span>
<span class="cm">	 * itself up</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
	<span class="n">list_del</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>

	<span class="n">usb_notify_remove_bus</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">clear_bit</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">busmap</span><span class="p">.</span><span class="n">busmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * register_root_hub - called by usb_add_hcd() to register a root hub</span>
<span class="cm"> * @hcd: host controller for this root hub</span>
<span class="cm"> *</span>
<span class="cm"> * This function registers the root hub with the USB subsystem.  It sets up</span>
<span class="cm"> * the device properly in the device tree and then calls usb_new_device()</span>
<span class="cm"> * to register the usb device.  It also assigns the root hub&#39;s USB address</span>
<span class="cm"> * (always 1).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_root_hub</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent_dev</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">devnum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">=</span> <span class="n">devnum</span><span class="p">;</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devnum_next</span> <span class="o">=</span> <span class="n">devnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">);</span>
	<span class="n">set_bit</span> <span class="p">(</span><span class="n">devnum</span><span class="p">,</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devmap</span><span class="p">.</span><span class="n">devicemap</span><span class="p">);</span>
	<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>

	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_device_descriptor</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">USB_DT_DEVICE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">parent_dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t read %s device descriptor %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_bos_descriptor</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">parent_dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t read %s bos descriptor %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">retval</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_new_device</span> <span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span> <span class="p">(</span><span class="n">parent_dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t register root hub for %s, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>

		<span class="cm">/* Did the HC die before the root hub was registered? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HCD_DEAD</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
			<span class="n">usb_hc_died</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>	<span class="cm">/* This time clean up */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_calc_bus_time - approximate periodic transaction time in nanoseconds</span>
<span class="cm"> * @speed: from dev-&gt;speed; USB_SPEED_{LOW,FULL,HIGH}</span>
<span class="cm"> * @is_input: true iff the transaction sends data to the host</span>
<span class="cm"> * @isoc: true for isochronous transactions, false for interrupt ones</span>
<span class="cm"> * @bytecount: how many bytes in the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns approximate bus time in nanoseconds for a periodic transaction.</span>
<span class="cm"> * See USB 2.0 spec section 5.11.3; only periodic transfers need to be</span>
<span class="cm"> * scheduled in software, this function is only used for such scheduling.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">usb_calc_bus_time</span> <span class="p">(</span><span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isoc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytecount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tmp</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>: 	<span class="cm">/* INTR only */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">67667L</span> <span class="o">*</span> <span class="p">(</span><span class="mi">31L</span> <span class="o">+</span> <span class="mi">10L</span> <span class="o">*</span> <span class="n">BitTime</span> <span class="p">(</span><span class="n">bytecount</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">1000L</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">64060L</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">BW_HUB_LS_SETUP</span><span class="p">)</span> <span class="o">+</span> <span class="n">BW_HOST_DELAY</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">66700L</span> <span class="o">*</span> <span class="p">(</span><span class="mi">31L</span> <span class="o">+</span> <span class="mi">10L</span> <span class="o">*</span> <span class="n">BitTime</span> <span class="p">(</span><span class="n">bytecount</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">1000L</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">64107L</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">BW_HUB_LS_SETUP</span><span class="p">)</span> <span class="o">+</span> <span class="n">BW_HOST_DELAY</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:	<span class="cm">/* ISOC or INTR */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8354L</span> <span class="o">*</span> <span class="p">(</span><span class="mi">31L</span> <span class="o">+</span> <span class="mi">10L</span> <span class="o">*</span> <span class="n">BitTime</span> <span class="p">(</span><span class="n">bytecount</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">1000L</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">(((</span><span class="n">is_input</span><span class="p">)</span> <span class="o">?</span> <span class="mi">7268L</span> <span class="o">:</span> <span class="mi">6265L</span><span class="p">)</span> <span class="o">+</span> <span class="n">BW_HOST_DELAY</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8354L</span> <span class="o">*</span> <span class="p">(</span><span class="mi">31L</span> <span class="o">+</span> <span class="mi">10L</span> <span class="o">*</span> <span class="n">BitTime</span> <span class="p">(</span><span class="n">bytecount</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">1000L</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">9107L</span> <span class="o">+</span> <span class="n">BW_HOST_DELAY</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:	<span class="cm">/* ISOC or INTR */</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>FIXME adjust for input vs output</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">isoc</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">HS_NSECS_ISO</span> <span class="p">(</span><span class="n">bytecount</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">HS_NSECS</span> <span class="p">(</span><span class="n">bytecount</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span> <span class="p">(</span><span class="s">&quot;%s: bogus device speed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usbcore_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_calc_bus_time</span><span class="p">);</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Generic HC operations.</span>
<span class="cm"> */</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_link_urb_to_ep - add an URB to its endpoint queue</span>
<span class="cm"> * @hcd: host controller to which @urb was submitted</span>
<span class="cm"> * @urb: URB being submitted</span>
<span class="cm"> *</span>
<span class="cm"> * Host controller drivers should call this routine in their enqueue()</span>
<span class="cm"> * method.  The HCD&#39;s private spinlock must be held and interrupts must</span>
<span class="cm"> * be disabled.  The actions carried out here are required for URB</span>
<span class="cm"> * submission, as well as for endpoint shutdown and for usb_kill_urb.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for no error, otherwise a negative error code (in which case</span>
<span class="cm"> * the enqueue() method must fail).  If no error occurs but enqueue() fails</span>
<span class="cm"> * anyway, it must call usb_hcd_unlink_urb_from_ep() before releasing</span>
<span class="cm"> * the private spinlock and returning.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>

	<span class="cm">/* Check that the URB isn&#39;t being killed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">can_submit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the host controller&#39;s state and add the URB to the</span>
<span class="cm">	 * endpoint&#39;s queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCD_RH_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">done:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_link_urb_to_ep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_check_unlink_urb - check whether an URB may be unlinked</span>
<span class="cm"> * @hcd: host controller to which @urb was submitted</span>
<span class="cm"> * @urb: URB being checked for unlinkability</span>
<span class="cm"> * @status: error code to store in @urb if the unlink succeeds</span>
<span class="cm"> *</span>
<span class="cm"> * Host controller drivers should call this routine in their dequeue()</span>
<span class="cm"> * method.  The HCD&#39;s private spinlock must be held and interrupts must</span>
<span class="cm"> * be disabled.  The actions carried out here are required for making</span>
<span class="cm"> * sure than an unlink is valid.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for no error, otherwise a negative error code (in which case</span>
<span class="cm"> * the dequeue() method must fail).  The possible error codes are:</span>
<span class="cm"> *</span>
<span class="cm"> *	-EIDRM: @urb was not submitted or has already completed.</span>
<span class="cm"> *		The completion function may not have been called yet.</span>
<span class="cm"> *</span>
<span class="cm"> *	-EBUSY: @urb has already been unlinked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* insist the urb is still queued */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>

	<span class="cm">/* Any status except -EINPROGRESS means something already started to</span>
<span class="cm">	 * unlink this URB from the hardware.  So there&#39;s no more work to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_check_unlink_urb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_unlink_urb_from_ep - remove an URB from its endpoint queue</span>
<span class="cm"> * @hcd: host controller to which @urb was submitted</span>
<span class="cm"> * @urb: URB being unlinked</span>
<span class="cm"> *</span>
<span class="cm"> * Host controller drivers should call this routine before calling</span>
<span class="cm"> * usb_hcd_giveback_urb().  The HCD&#39;s private spinlock must be held and</span>
<span class="cm"> * interrupts must be disabled.  The actions carried out here are required</span>
<span class="cm"> * for URB completion.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* clear all state linking urb to this dev (and hcd) */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Some usb host controllers can only perform dma using a small SRAM area.</span>
<span class="cm"> * The usb core itself is however optimized for host controllers that can dma</span>
<span class="cm"> * using regular system memory - like pci devices doing bus mastering.</span>
<span class="cm"> *</span>
<span class="cm"> * To support host controllers with limited dma capabilites we provide dma</span>
<span class="cm"> * bounce buffers. This feature can be enabled using the HCD_LOCAL_MEM flag.</span>
<span class="cm"> * For this to work properly the host controller code must first use the</span>
<span class="cm"> * function dma_declare_coherent_memory() to point out which memory area</span>
<span class="cm"> * that should be used for dma allocations.</span>
<span class="cm"> *</span>
<span class="cm"> * The HCD_LOCAL_MEM flag then tells the usb code to allocate all data for</span>
<span class="cm"> * dma using dma_alloc_coherent() which in turn allocates from the memory</span>
<span class="cm"> * area pointed out with dma_declare_coherent_memory().</span>
<span class="cm"> *</span>
<span class="cm"> * So, to summarize...</span>
<span class="cm"> *</span>
<span class="cm"> * - We need &quot;local&quot; memory, canonical example being</span>
<span class="cm"> *   a small SRAM on a discrete controller being the</span>
<span class="cm"> *   only memory that the controller can read ...</span>
<span class="cm"> *   (a) &quot;normal&quot; kernel memory is no good, and</span>
<span class="cm"> *   (b) there&#39;s not enough to share</span>
<span class="cm"> *</span>
<span class="cm"> * - The only *portable* hook for such stuff in the</span>
<span class="cm"> *   DMA framework is dma_declare_coherent_memory()</span>
<span class="cm"> *</span>
<span class="cm"> * - So we use that, even though the primary requirement</span>
<span class="cm"> *   is that the memory be &quot;local&quot; (hence addressible</span>
<span class="cm"> *   by that device), not &quot;coherent&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hcd_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">vaddr_handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">vaddr_handle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">hcd_buffer_alloc</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span>
				 <span class="n">mem_flags</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store the virtual address of the buffer at the end</span>
<span class="cm">	 * of the allocated dma buffer. The size of the buffer</span>
<span class="cm">	 * may be uneven so use unaligned functions instead</span>
<span class="cm">	 * of just rounding up. It makes sense to optimize for</span>
<span class="cm">	 * memory footprint over access speed since the amount</span>
<span class="cm">	 * of memory available for dma may be limited.</span>
<span class="cm">	 */</span>
	<span class="n">put_unaligned</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">vaddr_handle</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="o">*</span><span class="n">vaddr_handle</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="o">*</span><span class="n">vaddr_handle</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hcd_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">vaddr_handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="o">*</span><span class="n">vaddr_handle</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_unaligned</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="o">*</span><span class="n">vaddr_handle</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">hcd_buffer_free</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span> <span class="o">*</span><span class="n">vaddr_handle</span><span class="p">,</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">);</span>

	<span class="o">*</span><span class="n">vaddr_handle</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_hcd_unmap_urb_setup_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SETUP_MAP_SINGLE</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_dma</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">),</span>
				<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SETUP_MAP_LOCAL</span><span class="p">)</span>
		<span class="n">hcd_free_coherent</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_dma</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">),</span>
				<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="cm">/* Make it safe to call this routine more than once */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">URB_SETUP_MAP_SINGLE</span> <span class="o">|</span> <span class="n">URB_SETUP_MAP_LOCAL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_unmap_urb_setup_for_dma</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unmap_urb_for_dma</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unmap_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usb_hcd_unmap_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_hcd_unmap_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">;</span>

	<span class="n">usb_hcd_unmap_urb_setup_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="o">?</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">:</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_DMA_MAP_SG</span><span class="p">)</span>
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span><span class="p">,</span>
				<span class="n">dir</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_DMA_MAP_PAGE</span><span class="p">)</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
				<span class="n">dir</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_DMA_MAP_SINGLE</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
				<span class="n">dir</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_MAP_LOCAL</span><span class="p">)</span>
		<span class="n">hcd_free_coherent</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
				<span class="n">dir</span><span class="p">);</span>

	<span class="cm">/* Make it safe to call this routine more than once */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">URB_DMA_MAP_SG</span> <span class="o">|</span> <span class="n">URB_DMA_MAP_PAGE</span> <span class="o">|</span>
			<span class="n">URB_DMA_MAP_SINGLE</span> <span class="o">|</span> <span class="n">URB_MAP_LOCAL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_unmap_urb_for_dma</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			   <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">map_urb_for_dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">map_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">usb_hcd_map_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usb_hcd_map_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			    <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Map the URB&#39;s buffers for DMA access.</span>
<span class="cm">	 * Lower level HCD code should use *_dma exclusively,</span>
<span class="cm">	 * unless it uses pio or talks to another transport,</span>
<span class="cm">	 * or uses the provided scatter gather list for bulk.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">uses_pio_for_control</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">uses_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span>
					<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">),</span>
					<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_dma</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_SETUP_MAP_SINGLE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_LOCAL_MEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd_alloc_coherent</span><span class="p">(</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_dma</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">),</span>
					<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_SETUP_MAP_LOCAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="o">?</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">:</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">!=</span> <span class="mi">0</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">uses_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span>
						<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span><span class="p">,</span>
						<span class="n">dir</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_DMA_MAP_SG</span><span class="p">;</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_mapped_sgs</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span><span class="p">)</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span>
							<span class="n">URB_DMA_SG_COMBINED</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span>
						<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span>
						<span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
						<span class="n">dir</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">))</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_DMA_MAP_PAGE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span>
						<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
						<span class="n">dir</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">))</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_DMA_MAP_SINGLE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_LOCAL_MEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd_alloc_coherent</span><span class="p">(</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
					<span class="n">dir</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_MAP_LOCAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">URB_SETUP_MAP_SINGLE</span> <span class="o">|</span>
				<span class="n">URB_SETUP_MAP_LOCAL</span><span class="p">)))</span>
			<span class="n">usb_hcd_unmap_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_map_urb_for_dma</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* may be called in any context with a valid urb-&gt;dev usecount</span>
<span class="cm"> * caller surrenders &quot;ownership&quot; of urb</span>
<span class="cm"> * expects usb_submit_urb() to have sanity checked and conditioned all</span>
<span class="cm"> * inputs in the urb</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_hcd_submit_urb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/* increment urb&#39;s reference count as part of giving it to the HCD</span>
<span class="cm">	 * (which will control it).  HCD guarantees that it either returns</span>
<span class="cm">	 * an error or calls giveback(), but not both.</span>
<span class="cm">	 */</span>
	<span class="n">usb_get_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbnum</span><span class="p">);</span>
	<span class="n">usbmon_urb_submit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

	<span class="cm">/* NOTE requirements on root-hub callers (usbfs and the hub</span>
<span class="cm">	 * driver, for now):  URBs&#39; urb-&gt;transfer_buffer must be</span>
<span class="cm">	 * valid and usb_buffer_{sync,unmap}() not be needed, since</span>
<span class="cm">	 * they could clobber root hub response data.  Also, control</span>
<span class="cm">	 * URBs must be submitted in process context with interrupts</span>
<span class="cm">	 * enabled.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_root_hub</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">rh_urb_enqueue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">map_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">urb_enqueue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
				<span class="n">unmap_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usbmon_urb_submit_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">))</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_kill_urb_queue</span><span class="p">);</span>
		<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* this makes the hcd giveback() the urb more quickly, by kicking it</span>
<span class="cm"> * off hardware queues (which may take a while) and returning it as</span>
<span class="cm"> * soon as practical.  we&#39;ve already set up the urb&#39;s return status,</span>
<span class="cm"> * but we can&#39;t know if the callback completed already.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlink1</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_root_hub</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">usb_rh_urb_dequeue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* The only reason an HCD might fail this call is if</span>
<span class="cm">		 * it has not yet fully queued the urb to begin with.</span>
<span class="cm">		 * Such failures should be harmless. */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">urb_dequeue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called in any context</span>
<span class="cm"> *</span>
<span class="cm"> * caller guarantees urb won&#39;t be recycled till both unlink()</span>
<span class="cm"> * and the urb&#39;s completion function return</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_hcd_unlink_urb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Prevent the device and bus from going away while</span>
<span class="cm">	 * the unlink is carried out.  If they are already gone</span>
<span class="cm">	 * then urb-&gt;use_count must be 0, since disconnected</span>
<span class="cm">	 * devices can&#39;t have any active URBs.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_unlink_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">usb_get_dev</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_unlink_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">unlink1</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIDRM</span> <span class="o">&amp;&amp;</span> <span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hcd_unlink_urb %p fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urb</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_giveback_urb - return URB from HCD to device driver</span>
<span class="cm"> * @hcd: host controller returning the URB</span>
<span class="cm"> * @urb: urb being returned to the USB device driver.</span>
<span class="cm"> * @status: completion status code for the URB.</span>
<span class="cm"> * Context: in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * This hands the URB from HCD to its USB device driver, using its</span>
<span class="cm"> * completion function.  The HCD has freed all per-urb resources</span>
<span class="cm"> * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;</span>
<span class="cm"> * the device driver won&#39;t cause problems if it frees, modifies,</span>
<span class="cm"> * or resubmits this URB.</span>
<span class="cm"> *</span>
<span class="cm"> * If @urb was unlinked, the value of @status will be overridden by</span>
<span class="cm"> * @urb-&gt;unlinked.  Erroneous short transfers are detected in case</span>
<span class="cm"> * the HCD hasn&#39;t checked for them.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_giveback_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">status</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>

	<span class="n">unmap_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">usbmon_urb_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">usb_unanchor_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>

	<span class="cm">/* pass ownership to the completion handler */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="n">atomic_dec</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">)))</span>
		<span class="n">wake_up</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">usb_kill_urb_queue</span><span class="p">);</span>
	<span class="n">usb_put_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_giveback_urb</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Cancel all URBs pending on this endpoint and wait for the endpoint&#39;s</span>
<span class="cm"> * queue to drain completely.  The caller must first insure that no more</span>
<span class="cm"> * URBs can be submitted for this endpoint.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_flush_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/* No more submits can occur */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>
<span class="nl">rescan:</span>
	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">,</span> <span class="n">urb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">is_in</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">usb_get_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">is_in</span> <span class="o">=</span> <span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>

		<span class="cm">/* kick hcd */</span>
		<span class="n">unlink1</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
			<span class="s">&quot;shutdown urb %p ep%d%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="p">,</span> <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span>
			<span class="n">is_in</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			<span class="p">({</span>	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

				 <span class="k">switch</span> <span class="p">(</span><span class="n">usb_endpoint_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
				 <span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
					<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				 <span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
					<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;-bulk&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				 <span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
					<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;-intr&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				 <span class="nl">default:</span>
			 		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;-iso&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="p">};</span>
				<span class="n">s</span><span class="p">;</span>
			<span class="p">}));</span>
		<span class="n">usb_put_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>

		<span class="cm">/* list contents may have changed */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>

	<span class="cm">/* Wait until the endpoint queue is completely empty */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>

		<span class="cm">/* The list may have changed while we acquired the spinlock */</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">urb</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span><span class="p">,</span>
					<span class="n">urb_list</span><span class="p">);</span>
			<span class="n">usb_get_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_list_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_kill_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
			<span class="n">usb_put_urb</span> <span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_alloc_bandwidth - check whether a new bandwidth setting exceeds</span>
<span class="cm"> *				the bus bandwidth</span>
<span class="cm"> * @udev: target &amp;usb_device</span>
<span class="cm"> * @new_config: new configuration to install</span>
<span class="cm"> * @cur_alt: the current alternate interface setting</span>
<span class="cm"> * @new_alt: alternate interface setting that is being installed</span>
<span class="cm"> *</span>
<span class="cm"> * To change configurations, pass in the new configuration in new_config,</span>
<span class="cm"> * and pass NULL for cur_alt and new_alt.</span>
<span class="cm"> *</span>
<span class="cm"> * To reset a device&#39;s configuration (put the device in the ADDRESSED state),</span>
<span class="cm"> * pass in NULL for new_config, cur_alt, and new_alt.</span>
<span class="cm"> *</span>
<span class="cm"> * To change alternate interface settings, pass in NULL for new_config,</span>
<span class="cm"> * pass in the current alternate interface setting in cur_alt,</span>
<span class="cm"> * and pass in the new alternate interface setting in new_alt.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an error if the requested bandwidth change exceeds the</span>
<span class="cm"> * bus bandwidth or host controller internal resources.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">new_config</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">cur_alt</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">new_alt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_intfs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">check_bandwidth</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Configuration is being removed - set configuration 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_config</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cur_alt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
				<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drop_endpoint</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
				<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drop_endpoint</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">check_bandwidth</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check if the HCD says there&#39;s enough bandwidth.  Enable all endpoints</span>
<span class="cm">	 * each interface&#39;s alt setting 0 and ask the HCD to check the bandwidth</span>
<span class="cm">	 * of the bus.  There will always be bandwidth for endpoint 0, so it&#39;s</span>
<span class="cm">	 * ok to exclude it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_config</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_intfs</span> <span class="o">=</span> <span class="n">new_config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span>
		<span class="cm">/* Remove endpoints (except endpoint 0, which is always on the</span>
<span class="cm">		 * schedule) from the old config from the schedule</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drop_endpoint</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drop_endpoint</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_intfs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">first_alt</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">iface_num</span><span class="p">;</span>

			<span class="n">first_alt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_config</span><span class="o">-&gt;</span><span class="n">intf_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">iface_num</span> <span class="o">=</span> <span class="n">first_alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
			<span class="cm">/* Set up endpoints for alternate interface setting 0 */</span>
			<span class="n">alt</span> <span class="o">=</span> <span class="n">usb_find_alt_setting</span><span class="p">(</span><span class="n">new_config</span><span class="p">,</span> <span class="n">iface_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span><span class="p">)</span>
				<span class="cm">/* No alt setting 0? Pick the first setting. */</span>
				<span class="n">alt</span> <span class="o">=</span> <span class="n">first_alt</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">add_endpoint</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_alt</span> <span class="o">&amp;&amp;</span> <span class="n">new_alt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
				<span class="n">cur_alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iface</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">resetting_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The USB core just reset the device, so the xHCI host</span>
<span class="cm">			 * and the device will think alt setting 0 is installed.</span>
<span class="cm">			 * However, the USB core will pass in the alternate</span>
<span class="cm">			 * setting installed before the reset as cur_alt.  Dig</span>
<span class="cm">			 * out the alternate setting 0 structure, or the first</span>
<span class="cm">			 * alternate setting if a broken device doesn&#39;t have alt</span>
<span class="cm">			 * setting 0.</span>
<span class="cm">			 */</span>
			<span class="n">cur_alt</span> <span class="o">=</span> <span class="n">usb_altnum_to_altsetting</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur_alt</span><span class="p">)</span>
				<span class="n">cur_alt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="cm">/* Drop all the endpoints in the current alt setting */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cur_alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drop_endpoint</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cur_alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Add all the endpoints in the new alt setting */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">new_alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">add_endpoint</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">new_alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">check_bandwidth</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
<span class="nl">reset:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset_bandwidth</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Disables the endpoint: synchronizes with the hcd to make sure all</span>
<span class="cm"> * endpoint state is gone from hardware.  usb_hcd_flush_endpoint() must</span>
<span class="cm"> * have been called previously.  Use for set_configuration, set_interface,</span>
<span class="cm"> * driver removal, physical disconnect.</span>
<span class="cm"> *</span>
<span class="cm"> * example:  a qh stored in ep-&gt;hcpriv, holding state related to endpoint</span>
<span class="cm"> * type, maxpacket size, toggle, halt status, and scheduling.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_disable_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">endpoint_disable</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">endpoint_disable</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_reset_endpoint - reset host endpoint state</span>
<span class="cm"> * @udev: USB device.</span>
<span class="cm"> * @ep:   the endpoint to reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Resets any host endpoint state such as the toggle bit, sequence</span>
<span class="cm"> * number and current window.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_reset_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">endpoint_reset</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">endpoint_reset</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">epnum</span> <span class="o">=</span> <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">is_out</span> <span class="o">=</span> <span class="n">usb_endpoint_dir_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">is_control</span> <span class="o">=</span> <span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>

		<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">is_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_control</span><span class="p">)</span>
			<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="o">!</span><span class="n">is_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_alloc_streams - allocate bulk endpoint stream IDs.</span>
<span class="cm"> * @interface:		alternate setting that includes all endpoints.</span>
<span class="cm"> * @eps:		array of endpoints that need streams.</span>
<span class="cm"> * @num_eps:		number of endpoints in the array.</span>
<span class="cm"> * @num_streams:	number of streams to allocate.</span>
<span class="cm"> * @mem_flags:		flags hcd should use to allocate memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Sets up a group of bulk endpoints to have num_streams stream IDs available.</span>
<span class="cm"> * Drivers may queue multiple transfers to different stream IDs, which may</span>
<span class="cm"> * complete in a different order than they were queued.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_alloc_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_streams</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">alloc_streams</span> <span class="o">||</span> <span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">free_streams</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Streams only apply to bulk endpoints. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_endpoint_xfer_bulk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">alloc_streams</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">,</span>
			<span class="n">num_streams</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_alloc_streams</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_free_streams - free bulk endpoint stream IDs.</span>
<span class="cm"> * @interface:	alternate setting that includes all endpoints.</span>
<span class="cm"> * @eps:	array of endpoints to remove streams from.</span>
<span class="cm"> * @num_eps:	number of endpoints in the array.</span>
<span class="cm"> * @mem_flags:	flags hcd should use to allocate memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Reverts a group of bulk endpoints back to not using stream IDs.</span>
<span class="cm"> * Can fail if we are given bad arguments, or HCD is broken.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_free_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Streams only apply to bulk endpoints. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">usb_endpoint_xfer_bulk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">free_streams</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_free_streams</span><span class="p">);</span>

<span class="cm">/* Protect against drivers that try to unlink URBs after the device</span>
<span class="cm"> * is gone, by waiting until all unlinks for @udev are finished.</span>
<span class="cm"> * Since we don&#39;t currently track URBs by device, simply wait until</span>
<span class="cm"> * nothing is running in the locked region of usb_hcd_unlink_urb().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_synchronize_unlinks</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_unlink_lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_urb_unlink_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* called in any context */</span>
<span class="kt">int</span> <span class="nf">usb_hcd_get_frame_number</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>	<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_RH_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_frame_number</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef	CONFIG_PM</span>

<span class="kt">int</span> <span class="nf">hcd_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>	<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">old_state</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bus %ssuspend, wakeup %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;auto-&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
			<span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCD_DEAD</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;skipped %s of dead bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;suspend&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bus_suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_RH_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_QUIESCING</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bus_suspend</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">rhdev</span><span class="p">,</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">);</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">;</span>

		<span class="cm">/* Did we race with a root-hub wakeup event? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span>	<span class="n">buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">hub_status_data</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;suspend raced with wakeup event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">hcd_bus_resume</span><span class="p">(</span><span class="n">rhdev</span><span class="p">,</span> <span class="n">PMSG_AUTO_RESUME</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_DEAD</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_RH_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">old_state</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bus %s fail, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="s">&quot;suspend&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">hcd_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>	<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">old_state</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb %sresume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">PMSG_IS_AUTO</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;auto-&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCD_DEAD</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;skipped %s of dead bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;resume&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bus_resume</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCD_RH_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RESUMING</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bus_resume</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_WAKEUP_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TRSMRCY = 10 msec */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_DEAD</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">rhdev</span><span class="p">,</span> <span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">actconfig</span>
					<span class="o">?</span> <span class="n">USB_STATE_CONFIGURED</span>
					<span class="o">:</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_RH_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">old_state</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bus %s fail, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="s">&quot;resume&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span>
			<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#ifdef	CONFIG_USB_SUSPEND</span>

<span class="cm">/* Workqueue routine for root-hub remote wakeup */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hcd_resume_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">wakeup_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">;</span>

	<span class="n">usb_lock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_remote_wakeup</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_resume_root_hub - called by HCD to resume its root hub </span>
<span class="cm"> * @hcd: host controller for this root hub</span>
<span class="cm"> *</span>
<span class="cm"> * The USB host controller calls this function when its root hub is</span>
<span class="cm"> * suspended (with the remote wakeup feature enabled) and a remote</span>
<span class="cm"> * wakeup request is received.  The routine submits a workqueue request</span>
<span class="cm"> * to resume the root hub (that is, manage its downstream ports again).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hcd_resume_root_hub</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_WAKEUP_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">pm_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">wakeup_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_resume_root_hub</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_USB_SUSPEND */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef	CONFIG_USB_OTG</span>

<span class="cm">/**</span>
<span class="cm"> * usb_bus_start_enum - start immediate enumeration (for OTG)</span>
<span class="cm"> * @bus: the bus (must use hcd framework)</span>
<span class="cm"> * @port_num: 1-based number of port; usually bus-&gt;otg_port</span>
<span class="cm"> * Context: in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Starts enumeration, with an immediate reset followed later by</span>
<span class="cm"> * khubd identifying and possibly configuring the device.</span>
<span class="cm"> * This is needed by OTG controller drivers, where it helps meet</span>
<span class="cm"> * HNP protocol timing requirements for starting a port reset.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_bus_start_enum</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* NOTE: since HNP can&#39;t start by grabbing the bus&#39;s address0_sem,</span>
<span class="cm">	 * boards with root hubs hooked up to internal devices (instead of</span>
<span class="cm">	 * just the OTG port) may need more attention to resetting...</span>
<span class="cm">	 */</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">container_of</span> <span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_num</span> <span class="o">&amp;&amp;</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">start_port_reset</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">start_port_reset</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">port_num</span><span class="p">);</span>

	<span class="cm">/* run khubd shortly after (first) root port reset finishes;</span>
<span class="cm">	 * it may issue others, until at least 50 msecs have passed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_bus_start_enum</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hcd_irq - hook IRQs to HCD framework (bus glue)</span>
<span class="cm"> * @irq: the IRQ being raised</span>
<span class="cm"> * @__hcd: pointer to the HCD whose IRQ is being signaled</span>
<span class="cm"> *</span>
<span class="cm"> * If the controller isn&#39;t HALTed, calls the driver&#39;s irq handler.</span>
<span class="cm"> * Checks whether the controller is now dead.</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">usb_hcd_irq</span> <span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">__hcd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="n">irqreturn_t</span>		<span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* IRQF_DISABLED doesn&#39;t work correctly with shared IRQs</span>
<span class="cm">	 * when the first handler doesn&#39;t use it.  So let&#39;s just</span>
<span class="cm">	 * assume it&#39;s never used.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">HCD_DEAD</span><span class="p">(</span><span class="n">hcd</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">(</span><span class="n">hcd</span><span class="p">)</span> <span class="o">==</span> <span class="n">IRQ_NONE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_irq</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_hc_died - report abnormal shutdown of a host controller (bus glue)</span>
<span class="cm"> * @hcd: pointer to the HCD representing the controller</span>
<span class="cm"> *</span>
<span class="cm"> * This is called by bus glue to report a USB host controller that died</span>
<span class="cm"> * while operations may still have been pending.  It&#39;s called automatically</span>
<span class="cm"> * by the PCI glue, so only glue for non-PCI busses should need to call it.</span>
<span class="cm"> *</span>
<span class="cm"> * Only call this function with the primary HCD.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_hc_died</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_err</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;HC died; cleaning up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_RH_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_DEAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* make khubd clean up old urbs and devices */</span>
		<span class="n">usb_set_device_state</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">,</span>
				<span class="n">USB_STATE_NOTATTACHED</span><span class="p">);</span>
		<span class="n">usb_kick_khubd</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hcd</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_registered</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* make khubd clean up old urbs and devices */</span>
			<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">,</span>
					<span class="n">USB_STATE_NOTATTACHED</span><span class="p">);</span>
			<span class="n">usb_kick_khubd</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Make sure that the other roothub is also deallocated. */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span> <span class="p">(</span><span class="n">usb_hc_died</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_create_shared_hcd - create and initialize an HCD structure</span>
<span class="cm"> * @driver: HC driver that will use this hcd</span>
<span class="cm"> * @dev: device for this HC, stored in hcd-&gt;self.controller</span>
<span class="cm"> * @bus_name: value to store in hcd-&gt;self.bus_name</span>
<span class="cm"> * @primary_hcd: a pointer to the usb_hcd structure that is sharing the</span>
<span class="cm"> *              PCI device.  Only allocate certain resources for the primary HCD</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a struct usb_hcd, with extra space at the end for the</span>
<span class="cm"> * HC driver&#39;s private data.  Initialize the generic members of the</span>
<span class="cm"> * hcd structure.</span>
<span class="cm"> *</span>
<span class="cm"> * If memory is unavailable, returns NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">usb_create_shared_hcd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_name</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">primary_hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hcd</span><span class="p">)</span> <span class="o">+</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">hcd_priv_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hcd alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary_hcd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hcd bandwidth mutex alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
		<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hcd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span> <span class="o">=</span> <span class="n">primary_hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">;</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">primary_hcd</span> <span class="o">=</span> <span class="n">primary_hcd</span><span class="p">;</span>
		<span class="n">primary_hcd</span><span class="o">-&gt;</span><span class="n">primary_hcd</span> <span class="o">=</span> <span class="n">primary_hcd</span><span class="p">;</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">shared_hcd</span> <span class="o">=</span> <span class="n">primary_hcd</span><span class="p">;</span>
		<span class="n">primary_hcd</span><span class="o">-&gt;</span><span class="n">shared_hcd</span> <span class="o">=</span> <span class="n">hcd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>

	<span class="n">usb_bus_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bus_name</span> <span class="o">=</span> <span class="n">bus_name</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">uses_dma</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">rh_timer_func</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hcd</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">wakeup_work</span><span class="p">,</span> <span class="n">hcd_resume_work</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_MASK</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">product_desc</span> <span class="o">=</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">product_desc</span><span class="p">)</span> <span class="o">?</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">product_desc</span> <span class="o">:</span>
			<span class="s">&quot;USB Host Controller&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hcd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_create_shared_hcd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_create_hcd - create and initialize an HCD structure</span>
<span class="cm"> * @driver: HC driver that will use this hcd</span>
<span class="cm"> * @dev: device for this HC, stored in hcd-&gt;self.controller</span>
<span class="cm"> * @bus_name: value to store in hcd-&gt;self.bus_name</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a struct usb_hcd, with extra space at the end for the</span>
<span class="cm"> * HC driver&#39;s private data.  Initialize the generic members of the</span>
<span class="cm"> * hcd structure.</span>
<span class="cm"> *</span>
<span class="cm"> * If memory is unavailable, returns NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">usb_create_hcd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_create_shared_hcd</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">bus_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_create_hcd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Roothubs that share one PCI device must also share the bandwidth mutex.</span>
<span class="cm"> * Don&#39;t deallocate the bandwidth_mutex until the last shared usb_hcd is</span>
<span class="cm"> * deallocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure to only deallocate the bandwidth_mutex when the primary HCD is</span>
<span class="cm"> * freed.  When hcd_release() is called for the non-primary HCD, set the</span>
<span class="cm"> * primary_hcd&#39;s shared_hcd pointer to null (since the non-primary HCD will be</span>
<span class="cm"> * freed shortly).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hcd_release</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">container_of</span> <span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">bandwidth_mutex</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="o">-&gt;</span><span class="n">shared_hcd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">usb_get_hcd</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="p">)</span>
		<span class="n">kref_get</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hcd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_get_hcd</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usb_put_hcd</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="p">)</span>
		<span class="n">kref_put</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">hcd_release</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_put_hcd</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">primary_hcd</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hcd</span> <span class="o">==</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">primary_hcd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_hcd_request_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* IRQF_DISABLED doesn&#39;t work as advertised when used together</span>
<span class="cm">		 * with IRQF_SHARED. As usb_hcd_irq() will always disable</span>
<span class="cm">		 * interrupts we can remove it here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqflags</span> <span class="o">&amp;</span> <span class="n">IRQF_SHARED</span><span class="p">)</span>
			<span class="n">irqflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRQF_DISABLED</span><span class="p">;</span>

		<span class="n">snprintf</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq_descr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq_descr</span><span class="p">),</span> <span class="s">&quot;%s:usb%d&quot;</span><span class="p">,</span>
				<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">busnum</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irqnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcd_irq</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">,</span>
				<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq_descr</span><span class="p">,</span> <span class="n">hcd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
					<span class="s">&quot;request interrupt %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">irqnum</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irqnum</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;irq %d, %s 0x%08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqnum</span><span class="p">,</span>
				<span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_MEMORY</span><span class="p">)</span> <span class="o">?</span>
					<span class="s">&quot;io mem&quot;</span> <span class="o">:</span> <span class="s">&quot;io base&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_start</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_start</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s 0x%08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_MEMORY</span><span class="p">)</span> <span class="o">?</span>
					<span class="s">&quot;io mem&quot;</span> <span class="o">:</span> <span class="s">&quot;io base&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_start</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_add_hcd - finish generic HCD structure initialization and register</span>
<span class="cm"> * @hcd: the usb_hcd structure to initialize</span>
<span class="cm"> * @irqnum: Interrupt line to allocate</span>
<span class="cm"> * @irqflags: Interrupt type flags</span>
<span class="cm"> *</span>
<span class="cm"> * Finish the remaining parts of generic HCD initialization: allocate the</span>
<span class="cm"> * buffers of consistent memory, register the bus, request the IRQ line,</span>
<span class="cm"> * and call the driver&#39;s reset() and start() routines.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_add_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">product_desc</span><span class="p">);</span>

	<span class="cm">/* Keep old behaviour if authorized_default is not in [0, 1]. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">authorized_default</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">authorized_default</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">authorized_default</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">wireless</span><span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">authorized_default</span> <span class="o">=</span> <span class="n">authorized_default</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* HC is in reset state, but accessible.  Now do the one-time init,</span>
<span class="cm">	 * bottom up so that hcds can customize the root hubs before khubd</span>
<span class="cm">	 * starts talking to them.  (Note, bus id is assigned early too.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">hcd_buffer_create</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;pool alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">usb_register_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register_bus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rhdev</span> <span class="o">=</span> <span class="n">usb_alloc_dev</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;unable to allocate root hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_allocate_root_hub</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span> <span class="o">=</span> <span class="n">rhdev</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HCD_USB11</span>:
		<span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HCD_USB2</span>:
		<span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HCD_USB3</span>:
		<span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_set_rh_speed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wakeup flag init defaults to &quot;everything works&quot; for root hubs,</span>
<span class="cm">	 * but drivers can override it in reset() if needed, along with</span>
<span class="cm">	 * recording the overall controller&#39;s system wakeup capability.</span>
<span class="cm">	 */</span>
	<span class="n">device_set_wakeup_capable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* HCD_FLAG_RH_RUNNING doesn&#39;t matter until the root hub is</span>
<span class="cm">	 * registered.  But since the controller can die at any time,</span>
<span class="cm">	 * let&#39;s initialize the flag before touching the hardware.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_RH_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* &quot;reset&quot; is misnamed; its role is now one-time init. the controller</span>
<span class="cm">	 * should already have been reset (and boot firmware kicked off etc).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;can&#39;t setup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_hcd_driver_setup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_pollable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* NOTE: root hub and controller capabilities may not be the same */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_can_wakeup</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">device_can_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;supports USB remote wakeup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* enable irqs just before we start the controller,</span>
<span class="cm">	 * if the BIOS provides legacy PCI irqs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">irqnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_hcd_request_irqs</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">irqnum</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_request_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;startup error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_hcd_driver_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* starting here, usbcore will pay attention to this root hub */</span>
	<span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">500u</span><span class="p">,</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">power_budget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">register_root_hub</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register_root_hub</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_bus_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Cannot register USB bus sysfs attributes: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_create_attr_group</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">&amp;&amp;</span> <span class="n">HCD_POLL_RH</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Host controllers don&#39;t generate their own wakeup requests;</span>
<span class="cm">	 * they only forward requests from the root hub.  Therefore</span>
<span class="cm">	 * controllers should always be enabled for remote wakeup.</span>
<span class="cm">	 */</span>
	<span class="n">device_wakeup_enable</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">error_create_attr_group:</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_RH_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_QUIESCING</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">wakeup_work</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
	<span class="n">usb_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="p">);</span>		<span class="cm">/* Sets rhdev to NULL */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
<span class="nl">err_register_root_hub:</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_pollable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">);</span>
<span class="nl">err_hcd_driver_start:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">irqnum</span><span class="p">,</span> <span class="n">hcd</span><span class="p">);</span>
<span class="nl">err_request_irq:</span>
<span class="nl">err_hcd_driver_setup:</span>
<span class="nl">err_set_rh_speed:</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">);</span>
<span class="nl">err_allocate_root_hub:</span>
	<span class="n">usb_deregister_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>
<span class="nl">err_register_bus:</span>
	<span class="n">hcd_buffer_destroy</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span> 
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_add_hcd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_remove_hcd - shutdown processing for generic HCDs</span>
<span class="cm"> * @hcd: the usb_hcd structure to remove</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Disconnects the root hub, then reverses the effects of usb_add_hcd(),</span>
<span class="cm"> * invoking the HCD&#39;s stop() method.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_remove_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;remove, state %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">usb_get_dev</span><span class="p">(</span><span class="n">rhdev</span><span class="p">);</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_bus_attr_group</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_RH_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HC_IS_RUNNING</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_QUIESCING</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;roothub graceful disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hcd_root_hub_lock</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">wakeup_work</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>
	<span class="n">usb_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhdev</span><span class="p">);</span>		<span class="cm">/* Sets rhdev to NULL */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_bus_list_lock</span><span class="p">);</span>

	<span class="cm">/* Prevent any more root-hub status calls from the timer.</span>
<span class="cm">	 * The HCD might still restart the timer (if a port status change</span>
<span class="cm">	 * interrupt occurs), but usb_hcd_poll_rh_status() won&#39;t invoke</span>
<span class="cm">	 * the hub_status_data() callback.</span>
<span class="cm">	 */</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_pollable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">);</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>

	<span class="cm">/* In case the HCD restarted the timer, stop it again. */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">hcd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">);</span>
	<span class="n">usb_deregister_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>
	<span class="n">hcd_buffer_destroy</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_remove_hcd</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">usb_hcd_platform_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_hcd_platform_shutdown</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)</span>

<span class="k">struct</span> <span class="n">usb_mon_operations</span> <span class="o">*</span><span class="n">mon_ops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The registration is unlocked.</span>
<span class="cm"> * We do it this way because we do not want to lock in hot paths.</span>
<span class="cm"> *</span>
<span class="cm"> * Notice that the code is minimally error-proof. Because usbmon needs</span>
<span class="cm"> * symbols from usbcore, usbcore gets referenced and cannot be unloaded first.</span>
<span class="cm"> */</span>
 
<span class="kt">int</span> <span class="nf">usb_mon_register</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_mon_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mon_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">mon_ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span> <span class="p">(</span><span class="n">usb_mon_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usb_mon_deregister</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mon_ops</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;USB: monitor was not registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mon_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span> <span class="p">(</span><span class="n">usb_mon_deregister</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_MON || CONFIG_USB_MON_MODULE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
