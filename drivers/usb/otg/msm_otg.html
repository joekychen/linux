<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › otg › msm_otg.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>msm_otg.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 and</span>
<span class="cm"> * only version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/otg.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ulpi.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/usb/msm_hsusb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/msm_hsusb_hw.h&gt;</span>
<span class="cp">#include &lt;linux/regulator/consumer.h&gt;</span>

<span class="cp">#include &lt;mach/clk.h&gt;</span>

<span class="cp">#define MSM_USB_BASE	(motg-&gt;regs)</span>
<span class="cp">#define DRIVER_NAME	&quot;msm_otg&quot;</span>

<span class="cp">#define ULPI_IO_TIMEOUT_USEC	(10 * 1000)</span>

<span class="cp">#define USB_PHY_3P3_VOL_MIN	3050000 </span><span class="cm">/* uV */</span><span class="cp"></span>
<span class="cp">#define USB_PHY_3P3_VOL_MAX	3300000 </span><span class="cm">/* uV */</span><span class="cp"></span>
<span class="cp">#define USB_PHY_3P3_HPM_LOAD	50000	</span><span class="cm">/* uA */</span><span class="cp"></span>
<span class="cp">#define USB_PHY_3P3_LPM_LOAD	4000	</span><span class="cm">/* uA */</span><span class="cp"></span>

<span class="cp">#define USB_PHY_1P8_VOL_MIN	1800000 </span><span class="cm">/* uV */</span><span class="cp"></span>
<span class="cp">#define USB_PHY_1P8_VOL_MAX	1800000 </span><span class="cm">/* uV */</span><span class="cp"></span>
<span class="cp">#define USB_PHY_1P8_HPM_LOAD	50000	</span><span class="cm">/* uA */</span><span class="cp"></span>
<span class="cp">#define USB_PHY_1P8_LPM_LOAD	4000	</span><span class="cm">/* uA */</span><span class="cp"></span>

<span class="cp">#define USB_PHY_VDD_DIG_VOL_MIN	1000000 </span><span class="cm">/* uV */</span><span class="cp"></span>
<span class="cp">#define USB_PHY_VDD_DIG_VOL_MAX	1320000 </span><span class="cm">/* uV */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">hsusb_3p3</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">hsusb_1p8</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">hsusb_vddcx</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hsusb_init_vddcx</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hsusb_vddcx</span> <span class="o">=</span> <span class="n">regulator_get</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HSUSB_VDDCX&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get hsusb vddcx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">,</span>
				<span class="n">USB_PHY_VDD_DIG_VOL_MIN</span><span class="p">,</span>
				<span class="n">USB_PHY_VDD_DIG_VOL_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to set the voltage &quot;</span>
					<span class="s">&quot;for hsusb vddcx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">regulator_put</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_enable</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to enable hsusb vddcx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">regulator_put</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">USB_PHY_VDD_DIG_VOL_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to set the voltage &quot;</span>
					<span class="s">&quot;for hsusb vddcx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_disable</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to disable hsusb vddcx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">regulator_put</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hsusb_ldo_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hsusb_3p3</span> <span class="o">=</span> <span class="n">regulator_get</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HSUSB_3p3&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get hsusb 3p3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">,</span> <span class="n">USB_PHY_3P3_VOL_MIN</span><span class="p">,</span>
				<span class="n">USB_PHY_3P3_VOL_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to set voltage level &quot;</span>
					<span class="s">&quot;for hsusb 3p3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">put_3p3</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">regulator_enable</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to enable the hsusb 3p3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">put_3p3</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hsusb_1p8</span> <span class="o">=</span> <span class="n">regulator_get</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HSUSB_1p8&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get hsusb 1p8</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">disable_3p3</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">,</span> <span class="n">USB_PHY_1P8_VOL_MIN</span><span class="p">,</span>
				<span class="n">USB_PHY_1P8_VOL_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to set voltage level &quot;</span>
					<span class="s">&quot;for hsusb 1p8</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">put_1p8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">regulator_enable</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to enable the hsusb 1p8</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">put_1p8</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">regulator_disable</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">);</span>
<span class="nl">put_1p8:</span>
	<span class="n">regulator_put</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">);</span>
<span class="nl">disable_3p3:</span>
	<span class="n">regulator_disable</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">);</span>
<span class="nl">put_3p3:</span>
	<span class="n">regulator_put</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="cp">#define USB_PHY_SUSP_DIG_VOL  500000</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hsusb_config_vddcx</span><span class="p">(</span><span class="kt">int</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_vol</span> <span class="o">=</span> <span class="n">USB_PHY_VDD_DIG_VOL_MAX</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_vol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">high</span><span class="p">)</span>
		<span class="n">min_vol</span> <span class="o">=</span> <span class="n">USB_PHY_VDD_DIG_VOL_MIN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">min_vol</span> <span class="o">=</span> <span class="n">USB_PHY_SUSP_DIG_VOL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">hsusb_vddcx</span><span class="p">,</span> <span class="n">min_vol</span><span class="p">,</span> <span class="n">max_vol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: unable to set the voltage for regulator &quot;</span>
			<span class="s">&quot;HSUSB_VDDCX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: min_vol:%d max_vol:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">min_vol</span><span class="p">,</span> <span class="n">max_vol</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hsusb_ldo_set_mode</span><span class="p">(</span><span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hsusb_1p8</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: HSUSB_1p8 is not initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hsusb_3p3</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: HSUSB_3p3 is not initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_set_optimum_mode</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">,</span>
				<span class="n">USB_PHY_1P8_HPM_LOAD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to set HPM of the regulator &quot;</span>
				<span class="s">&quot;HSUSB_1p8</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_set_optimum_mode</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">,</span>
				<span class="n">USB_PHY_3P3_HPM_LOAD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to set HPM of the regulator &quot;</span>
				<span class="s">&quot;HSUSB_3p3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">regulator_set_optimum_mode</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">,</span>
				<span class="n">USB_PHY_1P8_LPM_LOAD</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_set_optimum_mode</span><span class="p">(</span><span class="n">hsusb_1p8</span><span class="p">,</span>
				<span class="n">USB_PHY_1P8_LPM_LOAD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to set LPM of the regulator &quot;</span>
				<span class="s">&quot;HSUSB_1p8</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_set_optimum_mode</span><span class="p">(</span><span class="n">hsusb_3p3</span><span class="p">,</span>
				<span class="n">USB_PHY_3P3_LPM_LOAD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to set LPM of the regulator &quot;</span>
				<span class="s">&quot;HSUSB_3p3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;reg (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">on</span> <span class="o">?</span> <span class="s">&quot;HPM&quot;</span> <span class="o">:</span> <span class="s">&quot;LPM&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ulpi_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* initiate read operation */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ULPI_RUN</span> <span class="o">|</span> <span class="n">ULPI_READ</span> <span class="o">|</span> <span class="n">ULPI_ADDR</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
	       <span class="n">USB_ULPI_VIEWPORT</span><span class="p">);</span>

	<span class="cm">/* wait for completion */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">ULPI_IO_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_ULPI_VIEWPORT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ULPI_RUN</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">ULPI_IO_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ulpi_read: timeout %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">USB_ULPI_VIEWPORT</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ULPI_DATA_READ</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_ULPI_VIEWPORT</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ulpi_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* initiate write operation */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ULPI_RUN</span> <span class="o">|</span> <span class="n">ULPI_WRITE</span> <span class="o">|</span>
	       <span class="n">ULPI_ADDR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">ULPI_DATA</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
	       <span class="n">USB_ULPI_VIEWPORT</span><span class="p">);</span>

	<span class="cm">/* wait for completion */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">ULPI_IO_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_ULPI_VIEWPORT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ULPI_RUN</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">ULPI_IO_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ulpi_write: timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_phy_io_ops</span> <span class="n">msm_otg_io_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">ulpi_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ulpi_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_init_seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_vdbg</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ulpi: write 0x%02x to 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">seq</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_link_clk_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">assert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">assert</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">,</span> <span class="n">CLK_RESET_ASSERT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb hs_clk assert failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">,</span> <span class="n">CLK_RESET_DEASSERT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb hs_clk deassert failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_phy_clk_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy_reset_clk</span><span class="p">,</span> <span class="n">CLK_RESET_ASSERT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb phy clk assert failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">12000</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy_reset_clk</span><span class="p">,</span> <span class="n">CLK_RESET_DEASSERT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb phy clk deassert failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_phy_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_link_clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_phy_clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_link_clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORTSC_PTS_MASK</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">|</span> <span class="n">PORTSC_PTS_ULPI</span><span class="p">,</span> <span class="n">USB_PORTSC</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">retries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ulpi_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">ULPI_FUNC_CTRL_SUSPENDM</span><span class="p">,</span>
				<span class="n">ULPI_CLR</span><span class="p">(</span><span class="n">ULPI_FUNC_CTRL</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_phy_clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="cm">/* This reset calibrates the phy, if the above write succeeded */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_phy_clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">retries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">ULPI_DEBUG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_phy_clk_reset</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;phy_reset: success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define LINK_RESET_TIMEOUT_USEC		(250 * 1000)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msm_otg_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulpi_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_phy_reset</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;phy_reset failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ulpi_init</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">USBCMD_RESET</span><span class="p">,</span> <span class="n">USB_USBCMD</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">LINK_RESET_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_USBCMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USBCMD_RESET</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">LINK_RESET_TIMEOUT_USEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="cm">/* select ULPI phy */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="n">USB_PORTSC</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">USB_AHBBURST</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">USB_AHBMODE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_PHY_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USB_OTGSC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">USB_OTG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ulpi_val</span> <span class="o">=</span> <span class="n">ULPI_INT_IDGRD</span> <span class="o">|</span> <span class="n">ULPI_INT_SESS_VALID</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">OTGSC_IDIE</span> <span class="o">|</span> <span class="n">OTGSC_BSVIE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">USB_PERIPHERAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ulpi_val</span> <span class="o">=</span> <span class="n">ULPI_INT_SESS_VALID</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">OTGSC_BSVIE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">USB_OTGSC</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">ulpi_val</span><span class="p">,</span> <span class="n">ULPI_USB_INT_EN_RISE</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">ulpi_val</span><span class="p">,</span> <span class="n">ULPI_USB_INT_EN_FALL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PHY_SUSPEND_TIMEOUT_USEC	(500 * 1000)</span>
<span class="cp">#define PHY_RESUME_TIMEOUT_USEC	(100 * 1000)</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_otg_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">in_lpm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Chipidea 45-nm PHY suspend sequence:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Interrupt Latch Register auto-clear feature is not present</span>
<span class="cm">	 * in all PHY versions. Latch register is clear on read type.</span>
<span class="cm">	 * Clear latch register to avoid spurious wakeup from</span>
<span class="cm">	 * low power mode (LPM).</span>
<span class="cm">	 *</span>
<span class="cm">	 * PHY comparators are disabled when PHY enters into low power</span>
<span class="cm">	 * mode (LPM). Keep PHY comparators ON in LPM only when we expect</span>
<span class="cm">	 * VBUS/Id notifications from USB PHY. Otherwise turn off USB</span>
<span class="cm">	 * PHY comparators. This save significant amount of power.</span>
<span class="cm">	 *</span>
<span class="cm">	 * PLL is not turned off when PHY enters into low power mode (LPM).</span>
<span class="cm">	 * Disable PLL for maximum power savings.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">CI_45NM_INTEGRATED_PHY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_PHY_CONTROL</span><span class="p">)</span>
			<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x09</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PHY may take some time or even fail to enter into low power</span>
<span class="cm">	 * mode (LPM). Hence poll for 500 msec and reset the PHY and link</span>
<span class="cm">	 * in failure case.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">|</span> <span class="n">PORTSC_PHCD</span><span class="p">,</span> <span class="n">USB_PORTSC</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">PHY_SUSPEND_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORTSC_PHCD</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">PHY_SUSPEND_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to suspend PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">msm_otg_reset</span><span class="p">(</span><span class="n">phy</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PHY has capability to generate interrupt asynchronously in low</span>
<span class="cm">	 * power mode (LPM). This interrupt is level triggered. So USB IRQ</span>
<span class="cm">	 * line must be disabled till async interrupt enable bit is cleared</span>
<span class="cm">	 * in USBCMD register. Assert STP (ULPI interface STOP signal) to</span>
<span class="cm">	 * block data communication from PHY.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_USBCMD</span><span class="p">)</span> <span class="o">|</span> <span class="n">ASYNC_INTR_CTRL</span> <span class="o">|</span> <span class="n">ULPI_STP_CTRL</span><span class="p">,</span> <span class="n">USB_USBCMD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span> <span class="o">&amp;&amp;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_PMIC_CONTROL</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PHY_CTRL</span><span class="p">)</span> <span class="o">|</span> <span class="n">PHY_RETEN</span><span class="p">,</span> <span class="n">USB_PHY_CTRL</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">)</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">))</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span> <span class="o">&amp;&amp;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_PMIC_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_hsusb_ldo_set_mode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">msm_hsusb_config_vddcx</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">enable_irq_wake</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">in_lpm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB in low power mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">in_lpm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">))</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">)</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span> <span class="o">&amp;&amp;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_PMIC_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_hsusb_ldo_set_mode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">msm_hsusb_config_vddcx</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PHY_CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PHY_RETEN</span><span class="p">,</span> <span class="n">USB_PHY_CTRL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USB_USBCMD</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASYNC_INTR_CTRL</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ULPI_STP_CTRL</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">USB_USBCMD</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * PHY comes out of low power mode (LPM) in case of wakeup</span>
<span class="cm">	 * from asynchronous interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORTSC_PHCD</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">skip_phy_resume</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORTSC_PHCD</span><span class="p">,</span> <span class="n">USB_PORTSC</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">PHY_RESUME_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORTSC_PHCD</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">PHY_RESUME_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a fatal error. Reset the link and</span>
<span class="cm">		 * PHY. USB state can not be restored. Re-insertion</span>
<span class="cm">		 * of USB cable is the only way to get USB working.</span>
<span class="cm">		 */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to resume USB.&quot;</span>
				<span class="s">&quot;Re-plugin the cable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">msm_otg_reset</span><span class="p">(</span><span class="n">phy</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">skip_phy_resume:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">disable_irq_wake</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">in_lpm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">async_int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">async_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pm_runtime_put</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB exited from low power mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_otg_notify_charger</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mA</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">cur_power</span> <span class="o">==</span> <span class="n">mA</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* TODO: Notify PMIC about available current */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Avail curr from USB = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mA</span><span class="p">);</span>
	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">cur_power</span> <span class="o">=</span> <span class="n">mA</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_set_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mA</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Gadget driver uses set_power method to notify about the</span>
<span class="cm">	 * available current based on suspend/configured states.</span>
<span class="cm">	 *</span>
<span class="cm">	 * IDEV_CHG can be drawn irrespective of suspend/un-configured</span>
<span class="cm">	 * states when CDP/ACA is connected.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span> <span class="o">==</span> <span class="n">USB_SDP_CHARGER</span><span class="p">)</span>
		<span class="n">msm_otg_notify_charger</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="n">mA</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_otg_start_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msm_otg_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;host on</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus_power</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus_power</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some boards have a switch cotrolled by gpio</span>
<span class="cm">		 * to enable/disable internal HUB. Enable internal</span>
<span class="cm">		 * HUB before kicking the host.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">(</span><span class="n">OTG_STATE_A_HOST</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB</span>
		<span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;host off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB</span>
		<span class="n">usb_remove_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">(</span><span class="n">OTG_STATE_UNDEFINED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus_power</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus_power</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_set_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_otg</span> <span class="o">*</span><span class="n">otg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fail host registration if this board can support</span>
<span class="cm">	 * only peripheral configuration.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">USB_PERIPHERAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Host mode is not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">OTG_STATE_A_HOST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">msm_otg_start_host</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">OTG_STATE_UNDEFINED</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">power_budget</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_budget</span><span class="p">;</span>

	<span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;host driver registered w/ tranceiver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kick the state machine work, if peripheral is not supported</span>
<span class="cm">	 * or peripheral is already registered with us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">USB_HOST</span> <span class="o">||</span> <span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_otg_start_peripheral</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msm_otg_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gadget on</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some boards have a switch cotrolled by gpio</span>
<span class="cm">		 * to enable/disable internal HUB. Disable internal</span>
<span class="cm">		 * HUB before kicking the gadget.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">(</span><span class="n">OTG_STATE_B_PERIPHERAL</span><span class="p">);</span>
		<span class="n">usb_gadget_vbus_connect</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gadget off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_gadget_vbus_disconnect</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setup_gpio</span><span class="p">(</span><span class="n">OTG_STATE_UNDEFINED</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_set_peripheral</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_otg</span> <span class="o">*</span><span class="n">otg</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">phy</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fail peripheral registration if this board can support</span>
<span class="cm">	 * only host configuration.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">USB_HOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Peripheral mode is not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">OTG_STATE_B_PERIPHERAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">msm_otg_start_peripheral</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">OTG_STATE_UNDEFINED</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">gadget</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;peripheral driver registered w/ tranceiver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kick the state machine work, if host is not supported</span>
<span class="cm">	 * or host is already registered with us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">USB_PERIPHERAL</span> <span class="o">||</span> <span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">msm_chg_check_secondary_det</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chg_det</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">chg_det</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">chg_det</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_chg_enable_secondary_det</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chg_det</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* Turn off charger block */</span>
		<span class="n">chg_det</span> <span class="o">|=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="cm">/* control chg block via ULPI */</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* put it in host mode for enabling D- source */</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* Turn on chg detect block */</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="cm">/* enable chg detection */</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Configure DM as current source, DP as current sink</span>
<span class="cm">		 * and enable battery charging comparators.</span>
<span class="cm">		 */</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">msm_chg_check_primary_det</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chg_det</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">chg_det</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">chg_det</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_chg_enable_primary_det</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chg_det</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* enable chg detection */</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Configure DP as current source, DM as current sink</span>
<span class="cm">		 * and enable battery charging comparators.</span>
<span class="cm">		 */</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">msm_chg_check_dcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">line_state</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">line_state</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x15</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">line_state</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="n">line_state</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">line_state</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_chg_disable_dcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chg_det</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_chg_enable_dcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chg_det</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* Turn on D+ current source */</span>
		<span class="n">chg_det</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="cm">/* Data contact detection enable */</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_chg_block_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">func_ctrl</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">;</span>

	<span class="cm">/* put the controller in non-driving mode */</span>
	<span class="n">func_ctrl</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">ULPI_FUNC_CTRL</span><span class="p">);</span>
	<span class="n">func_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ULPI_FUNC_CTRL_OPMODE_MASK</span><span class="p">;</span>
	<span class="n">func_ctrl</span> <span class="o">|=</span> <span class="n">ULPI_FUNC_CTRL_OPMODE_NONDRIVING</span><span class="p">;</span>
	<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">func_ctrl</span><span class="p">,</span> <span class="n">ULPI_FUNC_CTRL</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* control chg block via ULPI */</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* Turn on chg detect block */</span>
		<span class="n">chg_det</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="cm">/* Clear charger detecting control bits */</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">);</span>
		<span class="cm">/* Clear alt interrupt latch and enable bits */</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x92</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_chg_block_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">func_ctrl</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CI_45NM_INTEGRATED_PHY</span>:
		<span class="n">chg_det</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="cm">/* Turn off charger block */</span>
		<span class="n">chg_det</span> <span class="o">|=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">chg_det</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNPS_28NM_INTEGRATED_PHY</span>:
		<span class="cm">/* Clear charger detecting control bits */</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">);</span>
		<span class="cm">/* Clear alt interrupt latch and enable bits */</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x92</span><span class="p">);</span>
		<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* put the controller in normal mode */</span>
	<span class="n">func_ctrl</span> <span class="o">=</span> <span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">ULPI_FUNC_CTRL</span><span class="p">);</span>
	<span class="n">func_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ULPI_FUNC_CTRL_OPMODE_MASK</span><span class="p">;</span>
	<span class="n">func_ctrl</span> <span class="o">|=</span> <span class="n">ULPI_FUNC_CTRL_OPMODE_NORMAL</span><span class="p">;</span>
	<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="n">func_ctrl</span><span class="p">,</span> <span class="n">ULPI_FUNC_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define MSM_CHG_DCD_POLL_TIME		(100 * HZ/1000) </span><span class="cm">/* 100 msec */</span><span class="cp"></span>
<span class="cp">#define MSM_CHG_DCD_MAX_RETRIES		6 </span><span class="cm">/* Tdcd_tmout = 6 * 100 msec */</span><span class="cp"></span>
<span class="cp">#define MSM_CHG_PRIMARY_DET_TIME	(40 * HZ/1000) </span><span class="cm">/* TVDPSRC_ON */</span><span class="cp"></span>
<span class="cp">#define MSM_CHG_SECONDARY_DET_TIME	(40 * HZ/1000) </span><span class="cm">/* TVDMSRC_ON */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_chg_detect_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">chg_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_dcd</span><span class="p">,</span> <span class="n">tmout</span><span class="p">,</span> <span class="n">vout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;chg detection work</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_CHG_STATE_UNDEFINED</span>:
		<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">msm_chg_block_on</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="n">msm_chg_enable_dcd</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_WAIT_FOR_DCD</span><span class="p">;</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">dcd_retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">MSM_CHG_DCD_POLL_TIME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_CHG_STATE_WAIT_FOR_DCD</span>:
		<span class="n">is_dcd</span> <span class="o">=</span> <span class="n">msm_chg_check_dcd</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="n">tmout</span> <span class="o">=</span> <span class="o">++</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">dcd_retries</span> <span class="o">==</span> <span class="n">MSM_CHG_DCD_MAX_RETRIES</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_dcd</span> <span class="o">||</span> <span class="n">tmout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msm_chg_disable_dcd</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
			<span class="n">msm_chg_enable_primary_det</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">MSM_CHG_PRIMARY_DET_TIME</span><span class="p">;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_DCD_DONE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">MSM_CHG_DCD_POLL_TIME</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_CHG_STATE_DCD_DONE</span>:
		<span class="n">vout</span> <span class="o">=</span> <span class="n">msm_chg_check_primary_det</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msm_chg_enable_secondary_det</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">MSM_CHG_SECONDARY_DET_TIME</span><span class="p">;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_PRIMARY_DONE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span> <span class="o">=</span> <span class="n">USB_SDP_CHARGER</span><span class="p">;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_DETECTED</span><span class="p">;</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_CHG_STATE_PRIMARY_DONE</span>:
		<span class="n">vout</span> <span class="o">=</span> <span class="n">msm_chg_check_secondary_det</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vout</span><span class="p">)</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span> <span class="o">=</span> <span class="n">USB_DCP_CHARGER</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span> <span class="o">=</span> <span class="n">USB_CDP_CHARGER</span><span class="p">;</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_SECONDARY_DONE</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">USB_CHG_STATE_SECONDARY_DONE</span>:
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_DETECTED</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_CHG_STATE_DETECTED</span>:
		<span class="n">msm_chg_block_off</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;charger = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_work</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We support OTG, Peripheral only and Host only configurations. In case</span>
<span class="cm"> * of OTG, mode switch (host--&gt;peripheral/peripheral--&gt;host) can happen</span>
<span class="cm"> * via Id pin status or user request (debugfs). Id/BSV interrupts are not</span>
<span class="cm"> * enabled when switch is controlled by user and default mode is supplied</span>
<span class="cm"> * by board file, which can be changed by userspace later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_otg_init_sm</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">otgsc</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USB_OTGSC</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_OTG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_PHY_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_ID</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_BSV</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_USER_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">default_mode</span> <span class="o">==</span> <span class="n">USB_HOST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">default_mode</span> <span class="o">==</span> <span class="n">USB_PERIPHERAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_HOST</span>:
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PERIPHERAL</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_BSV</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_otg_sm_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_otg</span><span class="p">,</span> <span class="n">sm_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_otg</span> <span class="o">*</span><span class="n">otg</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OTG_STATE_UNDEFINED</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG_STATE_UNDEFINED state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">msm_otg_reset</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
		<span class="n">msm_otg_init_sm</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">OTG_STATE_B_IDLE</span><span class="p">;</span>
		<span class="cm">/* FALL THROUGH */</span>
	<span class="k">case</span> <span class="n">OTG_STATE_B_IDLE</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG_STATE_B_IDLE state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* disable BSV bit */</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_OTGSC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">OTGSC_BSVIE</span><span class="p">,</span> <span class="n">USB_OTGSC</span><span class="p">);</span>
			<span class="n">msm_otg_start_host</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">OTG_STATE_A_HOST</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">USB_CHG_STATE_UNDEFINED</span>:
				<span class="n">msm_chg_detect_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">USB_CHG_STATE_DETECTED</span>:
				<span class="k">switch</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">USB_DCP_CHARGER</span>:
					<span class="n">msm_otg_notify_charger</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span>
							<span class="n">IDEV_CHG_MAX</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">USB_CDP_CHARGER</span>:
					<span class="n">msm_otg_notify_charger</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span>
							<span class="n">IDEV_CHG_MAX</span><span class="p">);</span>
					<span class="n">msm_otg_start_peripheral</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span>
						<span class="o">=</span> <span class="n">OTG_STATE_B_PERIPHERAL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">USB_SDP_CHARGER</span>:
					<span class="n">msm_otg_notify_charger</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="n">IUNIT</span><span class="p">);</span>
					<span class="n">msm_otg_start_peripheral</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span>
						<span class="o">=</span> <span class="n">OTG_STATE_B_PERIPHERAL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If charger detection work is pending, decrement</span>
<span class="cm">			 * the pm usage counter to balance with the one that</span>
<span class="cm">			 * is incremented in charger detection work.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_work</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">msm_otg_reset</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">msm_otg_notify_charger</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_UNDEFINED</span><span class="p">;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span> <span class="o">=</span> <span class="n">USB_INVALID_CHARGER</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OTG_STATE_B_PERIPHERAL</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG_STATE_B_PERIPHERAL state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">msm_otg_notify_charger</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">msm_otg_start_peripheral</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_state</span> <span class="o">=</span> <span class="n">USB_CHG_STATE_UNDEFINED</span><span class="p">;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_type</span> <span class="o">=</span> <span class="n">USB_INVALID_CHARGER</span><span class="p">;</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">OTG_STATE_B_IDLE</span><span class="p">;</span>
			<span class="n">msm_otg_reset</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OTG_STATE_A_HOST</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG_STATE_A_HOST state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">msm_otg_start_host</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">OTG_STATE_B_IDLE</span><span class="p">;</span>
			<span class="n">msm_otg_reset</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">msm_otg_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">otgsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">in_lpm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">async_int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pm_runtime_get</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">otgsc</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USB_OTGSC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">OTGSC_IDIS</span> <span class="o">|</span> <span class="n">OTGSC_BSVIS</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_IDIS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_IDIE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_ID</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ID set/clear</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_BSVIS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_BSVIE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">otgsc</span> <span class="o">&amp;</span> <span class="n">OTGSC_BSV</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BSV set/clear</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">otgsc</span><span class="p">,</span> <span class="n">USB_OTGSC</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_mode_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_otg</span> <span class="o">*</span><span class="n">otg</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OTG_STATE_A_HOST</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OTG_STATE_B_PERIPHERAL</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;peripheral</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_mode_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">msm_otg_mode_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">msm_otg_mode_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">usb_otg</span> <span class="o">*</span><span class="n">otg</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_mode_type</span> <span class="n">req_mode</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;host&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req_mode</span> <span class="o">=</span> <span class="n">USB_HOST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;peripheral&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req_mode</span> <span class="o">=</span> <span class="n">USB_PERIPHERAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req_mode</span> <span class="o">=</span> <span class="n">USB_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">req_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_NONE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">OTG_STATE_A_HOST</span>:
		<span class="k">case</span> <span class="n">OTG_STATE_B_PERIPHERAL</span>:
			<span class="n">set_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PERIPHERAL</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">OTG_STATE_B_IDLE</span>:
		<span class="k">case</span> <span class="n">OTG_STATE_A_HOST</span>:
			<span class="n">set_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">B_SESS_VLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_HOST</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">OTG_STATE_B_IDLE</span>:
		<span class="k">case</span> <span class="n">OTG_STATE_B_PERIPHERAL</span>:
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">inputs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">msm_otg_mode_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">msm_otg_mode_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">msm_otg_mode_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">msm_otg_dbg_root</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">msm_otg_dbg_mode</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msm_otg_dbg_root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;msm_otg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msm_otg_dbg_root</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">msm_otg_dbg_root</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">msm_otg_dbg_mode</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;mode&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
				<span class="n">msm_otg_dbg_root</span><span class="p">,</span> <span class="n">motg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msm_otg_mode_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msm_otg_dbg_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">msm_otg_dbg_root</span><span class="p">);</span>
		<span class="n">msm_otg_dbg_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_otg_debugfs_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">msm_otg_dbg_mode</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">msm_otg_dbg_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">msm_otg_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;msm_otg probe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No platform data given. Bailing out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">motg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_otg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">motg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to allocate msm_otg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_otg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to allocate msm_otg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy_reset_clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb_phy_clk&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy_reset_clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get usb_phy_clk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy_reset_clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_motg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb_hs_clk&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get usb_hs_clk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">put_phy_reset_clk</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clk_set_rate</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">,</span> <span class="mi">60000000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If USB Core is running its protocol engine based on CORE CLK,</span>
<span class="cm">	 * CORE CLK  must be running at &gt;55Mhz for correct HSUSB</span>
<span class="cm">	 * operation and USB core cannot tolerate frequency changes on</span>
<span class="cm">	 * CORE CLK. For such USB cores, vote for maximum clk frequency</span>
<span class="cm">	 * on pclk source</span>
<span class="cm">	 */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">pclk_src_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">pclk_src_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">put_clk</span><span class="p">;</span>
		<span class="n">clk_set_rate</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>


	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb_hs_pclk&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get usb_hs_pclk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">put_pclk_src</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * USB core clock is not present on all MSM chips. This</span>
<span class="cm">	 * clock is introduced to remove the dependency on AXI</span>
<span class="cm">	 * bus frequency.</span>
<span class="cm">	 */</span>
	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb_hs_core_clk&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">))</span>
		<span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get platform resource mem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">put_core_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioremap failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">put_core_clk</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG regs = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;platform_get_irq failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_regs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_hsusb_init_vddcx</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hsusb vddcx configuration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_regs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_hsusb_ldo_init</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hsusb vreg configuration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">vddcx_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_hsusb_ldo_set_mode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hsusb vreg enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">ldo_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">)</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USB_USBINTR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USB_OTGSC</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">,</span> <span class="n">msm_otg_sm_work</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_work</span><span class="p">,</span> <span class="n">msm_chg_detect_work</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">msm_otg_irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
					<span class="s">&quot;msm_otg&quot;</span><span class="p">,</span> <span class="n">motg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request irq failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">disable_clks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">=</span> <span class="n">msm_otg_reset</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">set_power</span> <span class="o">=</span> <span class="n">msm_otg_set_power</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">io_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_otg_io_ops</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">set_host</span> <span class="o">=</span> <span class="n">msm_otg_set_host</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">set_peripheral</span> <span class="o">=</span> <span class="n">msm_otg_set_peripheral</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_set_transceiver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb_set_transceiver failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">motg</span><span class="p">);</span>
	<span class="n">device_init_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">USB_OTG</span> <span class="o">&amp;&amp;</span>
			<span class="n">motg</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">otg_control</span> <span class="o">==</span> <span class="n">OTG_USER_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_debugfs_init</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mode debugfs file is&quot;</span>
					<span class="s">&quot;not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">motg</span><span class="p">);</span>
<span class="nl">disable_clks:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">ldo_exit:</span>
	<span class="n">msm_hsusb_ldo_init</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">vddcx_exit:</span>
	<span class="n">msm_hsusb_init_vddcx</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">free_regs:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">put_core_clk:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">)</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>
<span class="nl">put_pclk_src:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">put_clk:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">put_phy_reset_clk:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy_reset_clk</span><span class="p">);</span>
<span class="nl">free_motg:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">msm_otg_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">||</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">msm_otg_debugfs_cleanup</span><span class="p">();</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">chg_work</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">sm_work</span><span class="p">);</span>

	<span class="n">pm_runtime_resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">device_init_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">usb_set_transceiver</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">motg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Put PHY in low power mode.</span>
<span class="cm">	 */</span>
	<span class="n">ulpi_read</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">);</span>
	<span class="n">ulpi_write</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x09</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">|</span> <span class="n">PORTSC_PHCD</span><span class="p">,</span> <span class="n">USB_PORTSC</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">PHY_SUSPEND_TIMEOUT_USEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_PORTSC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORTSC_PHCD</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">PHY_SUSPEND_TIMEOUT_USEC</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to suspend PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">)</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk_src</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">msm_hsusb_ldo_init</span><span class="p">(</span><span class="n">motg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">pm_runtime_set_suspended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy_reset_clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">pclk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">)</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">core_clk</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_otg</span> <span class="o">*</span><span class="n">otg</span> <span class="o">=</span> <span class="n">motg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">otg</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG runtime idle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is observed some times that a spurious interrupt</span>
<span class="cm">	 * comes when PHY is put into LPM immediately after PHY reset.</span>
<span class="cm">	 * This 1 sec delay also prevents entering into LPM immediately</span>
<span class="cm">	 * after asynchronous interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">otg</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">OTG_STATE_UNDEFINED</span><span class="p">)</span>
		<span class="n">pm_schedule_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG runtime suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">msm_otg_suspend</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG runtime resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">msm_otg_resume</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_pm_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG PM suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">msm_otg_suspend</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_otg_pm_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_otg</span> <span class="o">*</span><span class="n">motg</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OTG PM resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_otg_resume</span><span class="p">(</span><span class="n">motg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Runtime PM Documentation recommends bringing the</span>
<span class="cm">	 * device to full powered state upon resume.</span>
<span class="cm">	 */</span>
	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">msm_otg_dev_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SET_SYSTEM_SLEEP_PM_OPS</span><span class="p">(</span><span class="n">msm_otg_pm_suspend</span><span class="p">,</span> <span class="n">msm_otg_pm_resume</span><span class="p">)</span>
	<span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span><span class="n">msm_otg_runtime_suspend</span><span class="p">,</span> <span class="n">msm_otg_runtime_resume</span><span class="p">,</span>
				<span class="n">msm_otg_runtime_idle</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">msm_otg_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">msm_otg_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
		<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_otg_dev_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">msm_otg_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_otg_driver</span><span class="p">,</span> <span class="n">msm_otg_probe</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">msm_otg_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_otg_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">msm_otg_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">msm_otg_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MSM USB transceiver driver&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
