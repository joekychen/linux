<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › fsl_udc_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fsl_udc_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2004-2007,2011-2012 Freescale Semiconductor, Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Li Yang &lt;leoli@freescale.com&gt;</span>
<span class="cm"> *         Jiang Bo &lt;tanya.jiang@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Freescale high-speed USB SOC DR module device controller driver.</span>
<span class="cm"> * This can be found on MPC8349E/MPC8313E/MPC5121E cpus.</span>
<span class="cm"> * The driver is previously named as mpc_udc.  Based on bare board</span>
<span class="cm"> * code from Dave Liu and Shlomi Gridish.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#undef VERBOSE</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &lt;linux/usb/otg.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/fsl_devices.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>

<span class="cp">#include &quot;fsl_usb2_udc.h&quot;</span>

<span class="cp">#define	DRIVER_DESC	&quot;Freescale High-Speed USB SOC Device Controller driver&quot;</span>
<span class="cp">#define	DRIVER_AUTHOR	&quot;Li Yang/Jiang Bo&quot;</span>
<span class="cp">#define	DRIVER_VERSION	&quot;Apr 20, 2007&quot;</span>

<span class="cp">#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;fsl-usb2-udc&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_desc</span><span class="p">[]</span> <span class="o">=</span> <span class="n">DRIVER_DESC</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_dr_device</span> <span class="o">*</span><span class="n">dr_regs</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_sys_interface</span> <span class="o">*</span><span class="n">usb_sys_regs</span><span class="p">;</span>

<span class="cm">/* it is initialized in probe()  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc_controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>
<span class="n">fsl_ep0_desc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bLength</span> <span class="o">=</span>		<span class="n">USB_DT_ENDPOINT_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span>	<span class="n">USB_DT_ENDPOINT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>	<span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmAttributes</span> <span class="o">=</span>		<span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span>	<span class="n">USB_MAX_CTRL_PAYLOAD</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fsl_ep_fifo_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC32</span>
<span class="cm">/*</span>
<span class="cm"> * On some SoCs, the USB controller registers can be big or little endian,</span>
<span class="cm"> * depending on the version of the chip. In order to be able to run the</span>
<span class="cm"> * same kernel binary on 2 different versions of an SoC, the BE/LE decision</span>
<span class="cm"> * must be made at run time. _fsl_readl and fsl_writel are pointers to the</span>
<span class="cm"> * BE or LE readl() and writel() functions, and fsl_readl() and fsl_writel()</span>
<span class="cm"> * call through those pointers. Platform code for SoCs that have BE USB</span>
<span class="cm"> * registers should set pdata-&gt;big_endian_mmio flag.</span>
<span class="cm"> *</span>
<span class="cm"> * This also applies to controller-to-cpu accessors for the USB descriptors,</span>
<span class="cm"> * since their endianness is also SoC dependant. Platform code for SoCs that</span>
<span class="cm"> * have BE USB descriptors should set pdata-&gt;big_endian_desc flag.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">_fsl_readl_be</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">_fsl_readl_le</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_le32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_fsl_writel_be</span><span class="p">(</span><span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_fsl_writel_le</span><span class="p">(</span><span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">_fsl_readl</span><span class="p">)(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">_fsl_writel</span><span class="p">)(</span><span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#define fsl_readl(p)		(*_fsl_readl)((p))</span>
<span class="cp">#define fsl_writel(v, p)	(*_fsl_writel)((v), (p))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fsl_set_accessors</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_usb2_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">big_endian_mmio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_fsl_readl</span> <span class="o">=</span> <span class="n">_fsl_readl_be</span><span class="p">;</span>
		<span class="n">_fsl_writel</span> <span class="o">=</span> <span class="n">_fsl_writel_be</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">_fsl_readl</span> <span class="o">=</span> <span class="n">_fsl_readl_le</span><span class="p">;</span>
		<span class="n">_fsl_writel</span> <span class="o">=</span> <span class="n">_fsl_writel_le</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">cpu_to_hc32</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">big_endian_desc</span>
		<span class="o">?</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpu</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">big_endian_desc</span>
		<span class="o">?</span> <span class="n">be32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span><span class="p">)</span><span class="n">x</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">le32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_PPC32 */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fsl_set_accessors</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_usb2_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#define fsl_readl(addr)		readl(addr)</span>
<span class="cp">#define fsl_writel(val32, addr) writel(val32, addr)</span>
<span class="cp">#define cpu_to_hc32(x)		cpu_to_le32(x)</span>
<span class="cp">#define hc32_to_cpu(x)		le32_to_cpu(x)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>

<span class="cm">/********************************************************************</span>
<span class="cm"> *	Internal Used Function</span>
<span class="cm">********************************************************************/</span>
<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * done() - retire a request; caller blocked irqs</span>
<span class="cm"> * @status : request status to be set, only works when</span>
<span class="cm"> *	request is still in progress.</span>
<span class="cm"> *--------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">done</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">stopped</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="n">curr_td</span><span class="p">,</span> <span class="o">*</span><span class="n">next_td</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="cm">/* Removed the req from fsl_ep-&gt;queue */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* req.status should be set as -EINPROGRESS in ep_queue() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Free dtd for the request */</span>
	<span class="n">next_td</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_td</span> <span class="o">=</span> <span class="n">next_td</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next_td</span> <span class="o">=</span> <span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">next_td_virt</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">td_pool</span><span class="p">,</span> <span class="n">curr_td</span><span class="p">,</span> <span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">td_dma</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
			<span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">DMA_TO_DEVICE</span>
				<span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
			<span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">DMA_TO_DEVICE</span>
				<span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">))</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;complete %s req %p stat %d len %u/%u&quot;</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* complete() is from gadget layer,</span>
<span class="cm">	 * eg fsg-&gt;bulk_in_complete() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="n">stopped</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * nuke(): delete all requests related to this ep</span>
<span class="cm"> * called with spinlock held</span>
<span class="cm"> *--------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nuke</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Flush fifo */</span>
	<span class="n">fsl_ep_fifo_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Whether this eq has request linked */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------</span>
<span class="cm">	Internal Hardware related function</span>
<span class="cm"> ------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dr_controller_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">portctrl</span><span class="p">,</span> <span class="n">ep_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_no_of_ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

<span class="cp">#define FSL_UDC_RESET_TIMEOUT 1000</span>

	<span class="cm">/* Config PHY interface */</span>
	<span class="n">portctrl</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">);</span>
	<span class="n">portctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORTSCX_PHY_TYPE_SEL</span> <span class="o">|</span> <span class="n">PORTSCX_PORT_WIDTH</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FSL_USB2_PHY_ULPI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">have_sysif_regs</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">controller_ver</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* controller version 1.6 or above */</span>
				<span class="n">ctrl</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
				<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_CTRL_UTMI_PHY_EN</span><span class="p">;</span>
				<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">USB_CTRL_USB_EN</span><span class="p">;</span>
				<span class="n">__raw_writel</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">portctrl</span> <span class="o">|=</span> <span class="n">PORTSCX_PTS_ULPI</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_USB2_PHY_UTMI_WIDE</span>:
		<span class="n">portctrl</span> <span class="o">|=</span> <span class="n">PORTSCX_PTW_16BIT</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FSL_USB2_PHY_UTMI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">have_sysif_regs</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">controller_ver</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* controller version 1.6 or above */</span>
				<span class="n">ctrl</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
				<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">USB_CTRL_UTMI_PHY_EN</span> <span class="o">|</span>
					<span class="n">USB_CTRL_USB_EN</span><span class="p">);</span>
				<span class="n">__raw_writel</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="n">FSL_UTMI_PHY_DLY</span><span class="p">);</span> <span class="cm">/* Delay for UTMI</span>
<span class="cm">					PHY CLK to become stable - 10ms*/</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">portctrl</span> <span class="o">|=</span> <span class="n">PORTSCX_PTS_UTMI</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_USB2_PHY_SERIAL</span>:
		<span class="n">portctrl</span> <span class="o">|=</span> <span class="n">PORTSCX_PTS_FSLS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">portctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">);</span>

	<span class="cm">/* Stop and reset the usb controller */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_CMD_RUN_STOP</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USB_CMD_CTRL_RESET</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

	<span class="cm">/* Wait for reset to complete */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">FSL_UDC_RESET_TIMEOUT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USB_CMD_CTRL_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;udc reset timeout!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Set the controller as device mode */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_MODE_CTRL_MODE_MASK</span><span class="p">;</span>	<span class="cm">/* clear mode bits */</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USB_MODE_CTRL_MODE_DEVICE</span><span class="p">;</span>
	<span class="cm">/* Disable Setup Lockout */</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USB_MODE_SETUP_LOCK_OFF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">es</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USB_MODE_ES</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>

	<span class="cm">/* Clear the setup status */</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbsts</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh_dma</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="n">USB_EP_LIST_ADDRESS_MASK</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endpointlistaddr</span><span class="p">);</span>

	<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x&quot;</span><span class="p">,</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tmp</span><span class="p">,</span>
		<span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endpointlistaddr</span><span class="p">));</span>

	<span class="n">max_no_of_ep</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x0000001F</span> <span class="o">&amp;</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">dccparams</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ep_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ep_num</span> <span class="o">&lt;</span> <span class="n">max_no_of_ep</span><span class="p">;</span> <span class="n">ep_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EPCTRL_TX_TYPE</span> <span class="o">|</span> <span class="n">EPCTRL_RX_TYPE</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EPCTRL_EP_TYPE_BULK</span> <span class="o">&lt;&lt;</span> <span class="n">EPCTRL_TX_EP_TYPE_SHIFT</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">EPCTRL_EP_TYPE_BULK</span> <span class="o">&lt;&lt;</span> <span class="n">EPCTRL_RX_EP_TYPE_SHIFT</span><span class="p">);</span>
		<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/* Config control enable i/o output, cpu endian register */</span>
<span class="cp">#ifndef CONFIG_ARCH_MXC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">have_sysif_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">USB_CTRL_IOENB</span><span class="p">;</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_PPC32) &amp;&amp; !defined(CONFIG_NOT_COHERENT_CACHE)</span>
	<span class="cm">/* Turn on cache snooping hardware, since some PowerPC platforms</span>
<span class="cm">	 * wholly rely on hardware to deal with cache coherent. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">have_sysif_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Setup Snooping for all the 4GB space */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">SNOOP_SIZE_2GB</span><span class="p">;</span>	<span class="cm">/* starts from 0x0, size 2G */</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">snoop1</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x80000000</span><span class="p">;</span>	<span class="cm">/* starts from 0x8000000, size 2G */</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">snoop2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Enable DR irq and set controller to run state */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dr_controller_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* Enable DR irq reg */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">USB_INTR_INT_EN</span> <span class="o">|</span> <span class="n">USB_INTR_ERR_INT_EN</span>
		<span class="o">|</span> <span class="n">USB_INTR_PTC_DETECT_EN</span> <span class="o">|</span> <span class="n">USB_INTR_RESET_EN</span>
		<span class="o">|</span> <span class="n">USB_INTR_DEVICE_SUSPEND</span> <span class="o">|</span> <span class="n">USB_INTR_SYS_ERR_EN</span><span class="p">;</span>

	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>

	<span class="cm">/* Clear stopped bit */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the controller as device mode */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="n">USB_MODE_CTRL_MODE_DEVICE</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>

	<span class="cm">/* Set controller to Run */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="n">USB_CMD_RUN_STOP</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dr_controller_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* if we&#39;re in OTG mode, and the Host is currently using the port,</span>
<span class="cm">	 * stop now and don&#39;t rip the controller out from under the</span>
<span class="cm">	 * ehci driver</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">is_otg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">otgsc</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OTGSC_STS_USB_ID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;udc: Leaving early</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* disable all INTR */</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>

	<span class="cm">/* Set stopped bit for isr */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* disable IO output */</span>
<span class="cm">/*	usb_sys_regs-&gt;control = 0; */</span>

	<span class="cm">/* set controller to Stop */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_CMD_RUN_STOP</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dr_ep_setup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ep_num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dir</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ep_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp_epctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp_epctrl</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_num</span><span class="p">)</span>
			<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_DATA_TOGGLE_RST</span><span class="p">;</span>
		<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_ENABLE</span><span class="p">;</span>
		<span class="n">tmp_epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_TX_TYPE</span><span class="p">;</span>
		<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">ep_type</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_TX_EP_TYPE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_num</span><span class="p">)</span>
			<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_DATA_TOGGLE_RST</span><span class="p">;</span>
		<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_ENABLE</span><span class="p">;</span>
		<span class="n">tmp_epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_RX_TYPE</span><span class="p">;</span>
		<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">ep_type</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_RX_EP_TYPE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp_epctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dr_ep_change_stall</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ep_num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp_epctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp_epctrl</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set the stall bit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span>
			<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_EP_STALL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_EP_STALL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* clear the stall bit and reset data toggle */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp_epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_TX_EP_STALL</span><span class="p">;</span>
			<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_DATA_TOGGLE_RST</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tmp_epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_RX_EP_STALL</span><span class="p">;</span>
			<span class="n">tmp_epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_DATA_TOGGLE_RST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp_epctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Get stall status of a specific ep</span>
<span class="cm">   Return: 0: not stalled; 1:stalled */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dr_ep_get_stall</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ep_num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">epctrl</span><span class="p">;</span>

	<span class="n">epctrl</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">epctrl</span> <span class="o">&amp;</span> <span class="n">EPCTRL_TX_EP_STALL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">epctrl</span> <span class="o">&amp;</span> <span class="n">EPCTRL_RX_EP_STALL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************************************************************</span>
<span class="cm">	Internal Structure Build up functions</span>
<span class="cm">********************************************************************/</span>

<span class="cm">/*------------------------------------------------------------------</span>
<span class="cm">* struct_ep_qh_setup(): set the Endpoint Capabilites field of QH</span>
<span class="cm"> * @zlt: Zero Length Termination Select (1: disable; 0: enable)</span>
<span class="cm"> * @mult: Mult field</span>
<span class="cm"> ------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">struct_ep_qh_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ep_num</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ep_type</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_pkt_len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zlt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mult</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="o">*</span><span class="n">p_QH</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ep_num</span> <span class="o">+</span> <span class="n">dir</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set the Endpoint Capabilites in QH */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ep_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
		<span class="cm">/* Interrupt On Setup (IOS). for control ep  */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_pkt_len</span> <span class="o">&lt;&lt;</span> <span class="n">EP_QUEUE_HEAD_MAX_PKT_LEN_POS</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EP_QUEUE_HEAD_IOS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_pkt_len</span> <span class="o">&lt;&lt;</span> <span class="n">EP_QUEUE_HEAD_MAX_PKT_LEN_POS</span><span class="p">)</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">mult</span> <span class="o">&lt;&lt;</span> <span class="n">EP_QUEUE_HEAD_MULT_POS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">max_pkt_len</span> <span class="o">&lt;&lt;</span> <span class="n">EP_QUEUE_HEAD_MAX_PKT_LEN_POS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;error ep type is %d&quot;</span><span class="p">,</span> <span class="n">ep_type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zlt</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">EP_QUEUE_HEAD_ZLT_SEL</span><span class="p">;</span>

	<span class="n">p_QH</span><span class="o">-&gt;</span><span class="n">max_pkt_length</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">p_QH</span><span class="o">-&gt;</span><span class="n">next_dtd_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p_QH</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup qh structure and ep register for ep0. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* the intialization of an ep includes: fields in QH, Regs,</span>
<span class="cm">	 * fsl_ep struct */</span>
	<span class="n">struct_ep_qh_setup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_RECV</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">,</span>
			<span class="n">USB_MAX_CTRL_PAYLOAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">struct_ep_qh_setup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_SEND</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">,</span>
			<span class="n">USB_MAX_CTRL_PAYLOAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dr_ep_setup</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USB_RECV</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">);</span>
	<span class="n">dr_ep_setup</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USB_SEND</span><span class="p">,</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm">		Endpoint Management Functions</span>
<span class="cm">***********************************************************************/</span>

<span class="cm">/*-------------------------------------------------------------------------</span>
<span class="cm"> * when configurations are set, or when interface settings change</span>
<span class="cm"> * for example the do_set_interface() in gadget layer,</span>
<span class="cm"> * the driver will enable or disable the relevant endpoints</span>
<span class="cm"> * ep0 doesn&#39;t use this routine. It is always enabled.</span>
<span class="cm">-------------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zlt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* catch various bogus parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="cm">/* Disable automatic zlp generation.  Driver is responsible to indicate</span>
<span class="cm">	 * explicitly through req-&gt;req.zero.  This is needed to enable multi-td</span>
<span class="cm">	 * request. */</span>
	<span class="n">zlt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Assume the max packet size from gadget is always correct */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="cm">/* mult = 0.  Execute N Transactions as demonstrated by</span>
<span class="cm">		 * the USB variable length packet protocol where N is</span>
<span class="cm">		 * computed using the Maximum Packet Length (dQH) and</span>
<span class="cm">		 * the Total Bytes field (dTD) */</span>
		<span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="cm">/* Calculate transactions needed for high bandwidth iso */</span>
		<span class="n">mult</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">max</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">));</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">max</span> <span class="o">&amp;</span> <span class="mh">0x7ff</span><span class="p">;</span>	<span class="cm">/* bit 0~10 */</span>
		<span class="cm">/* 3 transactions at most */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mult</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">en_done</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">en_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Controller related setup */</span>
	<span class="cm">/* Init EPx Queue Head (Ep Capabilites field in QH</span>
<span class="cm">	 * according to max, zlt, mult) */</span>
	<span class="n">struct_ep_qh_setup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
					<span class="o">?</span>  <span class="n">USB_SEND</span> <span class="o">:</span> <span class="n">USB_RECV</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span>
					<span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">),</span>
			<span class="n">max</span><span class="p">,</span> <span class="n">zlt</span><span class="p">,</span> <span class="n">mult</span><span class="p">);</span>

	<span class="cm">/* Init endpoint ctrl register */</span>
	<span class="n">dr_ep_setup</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
					<span class="o">?</span> <span class="n">USB_SEND</span> <span class="o">:</span> <span class="n">USB_RECV</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span>
					<span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;enabled %s (ep%d%s) maxpacket %d&quot;</span><span class="p">,</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span>
			<span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
				<span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="nl">en_done:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*---------------------------------------------------------------------</span>
<span class="cm"> * @ep : the ep being unconfigured. May not be ep0</span>
<span class="cm"> * Any pending and uncomplete req will complete with status (-ESHUTDOWN)</span>
<span class="cm">*---------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">epctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_num</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;%s not enabled&quot;</span><span class="p">,</span> <span class="n">_ep</span> <span class="o">?</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* disable ep on controller */</span>
	<span class="n">ep_num</span> <span class="o">=</span> <span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">epctrl</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EPCTRL_TX_ENABLE</span> <span class="o">|</span> <span class="n">EPCTRL_TX_TYPE</span><span class="p">);</span>
		<span class="n">epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_EP_TYPE_BULK</span> <span class="o">&lt;&lt;</span> <span class="n">EPCTRL_TX_EP_TYPE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EPCTRL_RX_ENABLE</span> <span class="o">|</span> <span class="n">EPCTRL_TX_TYPE</span><span class="p">);</span>
		<span class="n">epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_EP_TYPE_BULK</span> <span class="o">&lt;&lt;</span> <span class="n">EPCTRL_RX_EP_TYPE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">epctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* nuke all pending requests (does flush) */</span>
	<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;disabled %s OK&quot;</span><span class="p">,</span> <span class="n">_ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*---------------------------------------------------------------------</span>
<span class="cm"> * allocate a request object used by this endpoint</span>
<span class="cm"> * the main operation is to insert the req-&gt;queue to the eq-&gt;queue</span>
<span class="cm"> * Returns the request, or null if one could not be allocated</span>
<span class="cm">*---------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span>
<span class="nf">fsl_alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_req</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Actually add a dTD chain to an empty dQH and let go */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_prime_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="n">td</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">get_qh_by_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Write dQH next pointer and terminate bit to 0 */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">next_dtd_ptr</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">td_dma</span>
			<span class="o">&amp;</span> <span class="n">EP_QUEUE_HEAD_NEXT_POINTER_MASK</span><span class="p">);</span>

	<span class="cm">/* Clear active and halt bit */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">&amp;=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">EP_QUEUE_HEAD_STATUS_ACTIVE</span>
					<span class="o">|</span> <span class="n">EP_QUEUE_HEAD_STATUS_HALT</span><span class="p">));</span>

	<span class="cm">/* Ensure that updates to the QH will occur before priming. */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* Prime endpoint by writing correct bit to ENDPTPRIME */</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">))</span>
			<span class="o">:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">))),</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endpointprime</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add dTD chain to the dQH of an EP */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_queue_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">tmp_stat</span><span class="p">;</span>

	<span class="cm">/* VDBG(&quot;QH addr Register 0x%8x&quot;, dr_regs-&gt;endpointlistaddr);</span>
<span class="cm">	VDBG(&quot;ep_qh[%d] addr is 0x%8x&quot;, i, (u32)&amp;(ep-&gt;udc-&gt;ep_qh[i])); */</span>

	<span class="n">bitmask</span> <span class="o">=</span> <span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
		<span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">))</span>
		<span class="o">:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)));</span>

	<span class="cm">/* check if the pipe is empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Add td to the end */</span>
		<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">lastreq</span><span class="p">;</span>
		<span class="n">lastreq</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">lastreq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next_td_ptr</span> <span class="o">=</span>
			<span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">td_dma</span> <span class="o">&amp;</span> <span class="n">DTD_ADDR_MASK</span><span class="p">);</span>
		<span class="cm">/* Ensure dTD&#39;s next dtd pointer to be updated */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="cm">/* Read prime bit, if 1 goto done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endpointprime</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/* Set ATDTW bit in USBCMD */</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
			<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="n">USB_CMD_ATDTW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

			<span class="cm">/* Read correct status bit */</span>
			<span class="n">tmp_stat</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USB_CMD_ATDTW</span><span class="p">));</span>

		<span class="cm">/* Write ATDTW bit to 0 */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
		<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_CMD_ATDTW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_stat</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fsl_prime_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Fill in the dTD structure</span>
<span class="cm"> * @req: request that the transfer belongs to</span>
<span class="cm"> * @length: return actually data length of the dTD</span>
<span class="cm"> * @dma: return dma address of the dTD</span>
<span class="cm"> * @is_last: return flag if it is the last dTD of the request</span>
<span class="cm"> * return: pointer to the built dTD */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="nf">fsl_build_dtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">is_last</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">swap_temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="n">dtd</span><span class="p">;</span>

	<span class="cm">/* how big will this transfer be? */</span>
	<span class="o">*</span><span class="n">length</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">EP_MAX_LENGTH_TRANSFER</span><span class="p">);</span>

	<span class="n">dtd</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">td_pool</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dtd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dtd</span><span class="p">;</span>

	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">td_dma</span> <span class="o">=</span> <span class="o">*</span><span class="n">dma</span><span class="p">;</span>
	<span class="cm">/* Clear reserved field */</span>
	<span class="n">swap_temp</span> <span class="o">=</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">dtd</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span><span class="p">);</span>
	<span class="n">swap_temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DTD_RESERVED_FIELDS</span><span class="p">;</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">swap_temp</span><span class="p">);</span>

	<span class="cm">/* Init all of buffer page pointers */</span>
	<span class="n">swap_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr0</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">swap_temp</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr1</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">swap_temp</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr2</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">swap_temp</span> <span class="o">+</span> <span class="mh">0x2000</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr3</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">swap_temp</span> <span class="o">+</span> <span class="mh">0x3000</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr4</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">swap_temp</span> <span class="o">+</span> <span class="mh">0x4000</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">+=</span> <span class="o">*</span><span class="n">length</span><span class="p">;</span>

	<span class="cm">/* zlp is needed if req-&gt;req.zero is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">length</span> <span class="o">%</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">)</span>
		<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">is_last</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;multi-dtd request!&quot;</span><span class="p">);</span>
	<span class="cm">/* Fill in the transfer size; set active bit */</span>
	<span class="n">swap_temp</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="n">DTD_LENGTH_BIT_POS</span><span class="p">)</span> <span class="o">|</span> <span class="n">DTD_STATUS_ACTIVE</span><span class="p">);</span>

	<span class="cm">/* Enable interrupt for the last dtd of a request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">is_last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">no_interrupt</span><span class="p">)</span>
		<span class="n">swap_temp</span> <span class="o">|=</span> <span class="n">DTD_IOC</span><span class="p">;</span>

	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">swap_temp</span><span class="p">);</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;length = %d address= 0x%x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">dma</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dtd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Generate dtd chain for a request */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_req_to_dtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">is_last</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">is_first</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_td_struct</span>	<span class="o">*</span><span class="n">last_dtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">dtd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">dtd</span> <span class="o">=</span> <span class="n">fsl_build_dtd</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is_last</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_first</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">is_first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">last_dtd</span><span class="o">-&gt;</span><span class="n">next_td_ptr</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">last_dtd</span><span class="o">-&gt;</span><span class="n">next_td_virt</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_dtd</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>

		<span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_last</span><span class="p">);</span>

	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">next_td_ptr</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">DTD_NEXT_TERMINATE</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* queues (submits) an I/O request to an endpoint */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">fsl_ep_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* catch various bogus parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_req</span> <span class="o">||</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span> <span class="o">||</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;%s, bad params&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;%s, bad ep&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* map virtual address to hardware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">==</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
						<span class="o">?</span> <span class="n">DMA_TO_DEVICE</span>
						<span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
					<span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
						<span class="o">?</span> <span class="n">DMA_TO_DEVICE</span>
						<span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* build dtds and push them to device queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsl_req_to_dtd</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">fsl_queue_td</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* irq handler advances the queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* dequeues (cancels, unlinks) an I/O request from an endpoint */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_ep_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">stopped</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">epctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">_req</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">stopped</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">;</span>

	<span class="cm">/* Stop the ep before we deal with the queue */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ep_num</span> <span class="o">=</span> <span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">epctrl</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="n">epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_TX_ENABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">epctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_RX_ENABLE</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">epctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="cm">/* make sure it&#39;s actually queued on this endpoint */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">==</span> <span class="n">_req</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">!=</span> <span class="n">_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The request is in progress, or completed but not dequeued */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
		<span class="n">fsl_ep_fifo_flush</span><span class="p">(</span><span class="n">_ep</span><span class="p">);</span>	<span class="cm">/* flush current transfer */</span>

		<span class="cm">/* The request isn&#39;t the last request in this ep queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">next_req</span><span class="p">;</span>

			<span class="n">next_req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span><span class="p">,</span>
					<span class="n">queue</span><span class="p">);</span>

			<span class="cm">/* prime with dTD of next request */</span>
			<span class="n">fsl_prime_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">next_req</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="cm">/* The request hasn&#39;t been processed, patch up the TD chain */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">prev_req</span><span class="p">;</span>

		<span class="n">prev_req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_req</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">prev_req</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next_td_ptr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next_td_ptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">);</span>

	<span class="cm">/* Enable EP */</span>
<span class="nl">out:</span>	<span class="n">epctrl</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="n">epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_ENABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">epctrl</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_ENABLE</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">epctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="n">stopped</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * modify the endpoint halt feature</span>
<span class="cm"> * @ep: the non-isochronous endpoint being stalled</span>
<span class="cm"> * @value: 1--set halt  0--clear halt</span>
<span class="cm"> * Returns zero, or a negative error code.</span>
<span class="cm">*----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_ep_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>	<span class="cm">/* operation not supported */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ep_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ep_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Attempt to halt IN ep will fail if any transfer requests</span>
<span class="cm">	 * are still queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep_dir</span> <span class="o">=</span> <span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">?</span> <span class="n">USB_SEND</span> <span class="o">:</span> <span class="n">USB_RECV</span><span class="p">;</span>
	<span class="n">ep_num</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">));</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dr_ep_change_stall</span><span class="p">(</span><span class="n">ep_num</span><span class="p">,</span> <span class="n">ep_dir</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot; %s %s halt stat %d&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">value</span> <span class="o">?</span>  <span class="s">&quot;set&quot;</span> <span class="o">:</span> <span class="s">&quot;clear&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_ep_fifo_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bitmask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">get_qh_by_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="n">bitmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">))</span> <span class="o">:</span>
	    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">&amp;</span> <span class="n">DTD_PACKET_SIZE</span><span class="p">)</span>
		    <span class="o">&gt;&gt;</span> <span class="n">DTD_LENGTH_BIT_POS</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_ep_fifo_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">ep_dir</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
<span class="cp">#define FSL_UDC_FLUSH_TIMEOUT 1000</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep_num</span> <span class="o">=</span> <span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">ep_dir</span> <span class="o">=</span> <span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">?</span> <span class="n">USB_SEND</span> <span class="o">:</span> <span class="n">USB_RECV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ep_dir</span> <span class="o">==</span> <span class="n">USB_SEND</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">ep_num</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep_num</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">FSL_UDC_FLUSH_TIMEOUT</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">fsl_writel</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptflush</span><span class="p">);</span>

		<span class="cm">/* Wait until flush complete */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptflush</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;ep flush timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="cm">/* See if we need to flush again */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_ep_ops</span> <span class="n">fsl_ep_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span> <span class="o">=</span> <span class="n">fsl_ep_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span> <span class="o">=</span> <span class="n">fsl_ep_disable</span><span class="p">,</span>

	<span class="p">.</span><span class="n">alloc_request</span> <span class="o">=</span> <span class="n">fsl_alloc_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_request</span> <span class="o">=</span> <span class="n">fsl_free_request</span><span class="p">,</span>

	<span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">fsl_ep_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue</span> <span class="o">=</span> <span class="n">fsl_ep_dequeue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_halt</span> <span class="o">=</span> <span class="n">fsl_ep_set_halt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_status</span> <span class="o">=</span> <span class="n">fsl_ep_fifo_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_flush</span> <span class="o">=</span> <span class="n">fsl_ep_fifo_flush</span><span class="p">,</span>	<span class="cm">/* flush fifo */</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------</span>
<span class="cm">		Gadget Driver Layer Operations</span>
<span class="cm">-------------------------------------------------------------------------*/</span>

<span class="cm">/*----------------------------------------------------------------------</span>
<span class="cm"> * Get the current frame number (from DR frame_index Reg )</span>
<span class="cm"> *----------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">frindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USB_FRINDEX_MASKS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------------</span>
<span class="cm"> * Tries to wake up the host connected to this gadget</span>
<span class="cm"> -----------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">portsc</span><span class="p">;</span>

	<span class="cm">/* Remote wakeup feature not enabled by host */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">portsc</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">);</span>
	<span class="cm">/* not suspended? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SUSPEND</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* trigger force resume */</span>
	<span class="n">portsc</span> <span class="o">|=</span> <span class="n">PORTSCX_PORT_FORCE_RESUME</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">portsc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">can_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Notify controller that VBUS is powered, Called by whatever</span>
<span class="cm">   detects VBUS sessions */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_vbus_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span>	<span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;VBUS %s&quot;</span><span class="p">,</span> <span class="n">is_active</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_active</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">fsl_writel</span><span class="p">((</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">|</span> <span class="n">USB_CMD_RUN_STOP</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fsl_writel</span><span class="p">((</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_CMD_RUN_STOP</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* constrain controller&#39;s VBUS power usage</span>
<span class="cm"> * This call is used by gadget drivers during SET_CONFIGURATION calls,</span>
<span class="cm"> * reporting how much power the device may consume.  For example, this</span>
<span class="cm"> * could affect how quickly batteries are recharged.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_vbus_draw</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mA</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">usb_phy_set_power</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">,</span> <span class="n">mA</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Change Data+ pullup status</span>
<span class="cm"> * this func is used by usb_gadget_connect/disconnet</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_on</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">fsl_writel</span><span class="p">((</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">|</span> <span class="n">USB_CMD_RUN_STOP</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fsl_writel</span><span class="p">((</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_CMD_RUN_STOP</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fsl_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">));</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fsl_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="cm">/* defined in gadget.h */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_gadget_ops</span> <span class="n">fsl_gadget_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_frame</span> <span class="o">=</span> <span class="n">fsl_get_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="n">fsl_wakeup</span><span class="p">,</span>
<span class="cm">/*	.set_selfpowered = fsl_set_selfpowered,	*/</span> <span class="cm">/* Always selfpowered */</span>
	<span class="p">.</span><span class="n">vbus_session</span> <span class="o">=</span> <span class="n">fsl_vbus_session</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vbus_draw</span> <span class="o">=</span> <span class="n">fsl_vbus_draw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pullup</span> <span class="o">=</span> <span class="n">fsl_pullup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">fsl_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">fsl_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Set protocol stall on ep0, protocol stall will automatically be cleared</span>
<span class="cm">   on new transaction */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* must set tx and rx to stall at the same time */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_EP_STALL</span> <span class="o">|</span> <span class="n">EPCTRL_RX_EP_STALL</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Prime a status phase for ep0 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep0_prime_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">USB_DIR_OUT</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">!=</span> <span class="n">DATA_STATE_XMIT</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_OUT_STATUS</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
			<span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">?</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsl_req_to_dtd</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fsl_queue_td</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_reset_ep_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">get_ep_by_pipe</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ch9 Set address</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ch9setaddress</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save the new address to device struct */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">device_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">value</span><span class="p">;</span>
	<span class="cm">/* Update usb state */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">;</span>
	<span class="cm">/* Status phase */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep0_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">))</span>
		<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ch9 Get status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ch9getstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request_type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Status, cpu endian */</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">request_type</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get device status */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_SELF_POWERED</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">request_type</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get interface status */</span>
		<span class="cm">/* We don&#39;t have interface information in udc driver */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">request_type</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get endpoint status */</span>
		<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">target_ep</span><span class="p">;</span>

		<span class="n">target_ep</span> <span class="o">=</span> <span class="n">get_ep_by_pipe</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">get_pipe_by_windex</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>

		<span class="cm">/* stall if endpoint doesn&#39;t exist */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">stall</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">dr_ep_get_stall</span><span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">target_ep</span><span class="p">),</span> <span class="n">ep_is_in</span><span class="p">(</span><span class="n">target_ep</span><span class="p">))</span>
				<span class="o">&lt;&lt;</span> <span class="n">USB_ENDPOINT_HALT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>
	<span class="cm">/* Borrow the per device status_req */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">;</span>
	<span class="cm">/* Fill in the reqest structure */</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
				<span class="n">ep_is_in</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">?</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* prime the data phase */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fsl_req_to_dtd</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">fsl_queue_td</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">else</span>			<span class="cm">/* no mem */</span>
		<span class="k">goto</span> <span class="n">stall</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">DATA_STATE_XMIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep0_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_OUT</span><span class="p">))</span>
		<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="nl">stall:</span>
	<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_received_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">wValue</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">wIndex</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">wLength</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">);</span>

	<span class="n">udc_reset_ep_queue</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* We process some stardard setup requests here */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_REQ_GET_STATUS</span>:
		<span class="cm">/* Data+Status phase from udc */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_MASK</span><span class="p">))</span>
					<span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ch9getstatus</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_REQ_SET_ADDRESS</span>:
		<span class="cm">/* Status phase from udc */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span>
						<span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ch9setaddress</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_REQ_CLEAR_FEATURE</span>:
	<span class="k">case</span> <span class="n">USB_REQ_SET_FEATURE</span>:
		<span class="cm">/* Status phase from udc */</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">ptc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_RECIP_MASK</span> <span class="o">|</span> <span class="n">USB_TYPE_MASK</span><span class="p">))</span>
				<span class="o">==</span> <span class="p">(</span><span class="n">USB_RECIP_ENDPOINT</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">pipe</span> <span class="o">=</span> <span class="n">get_pipe_by_windex</span><span class="p">(</span><span class="n">wIndex</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wValue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">wLength</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pipe</span> <span class="o">&gt;=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_ep</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">get_ep_by_pipe</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">fsl_ep_set_halt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span>
					<span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">==</span> <span class="n">USB_REQ_SET_FEATURE</span><span class="p">)</span>
						<span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_RECIP_MASK</span>
				<span class="o">|</span> <span class="n">USB_TYPE_MASK</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">USB_RECIP_DEVICE</span>
				<span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Note: The driver has not include OTG support yet.</span>
<span class="cm">			 * This will be set when OTG support is added */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_DEVICE_TEST_MODE</span><span class="p">)</span>
				<span class="n">ptc</span> <span class="o">=</span> <span class="n">wIndex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_otg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">==</span>
				    <span class="n">USB_DEVICE_B_HNP_ENABLE</span><span class="p">)</span>
					<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">b_hnp_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">==</span>
					 <span class="n">USB_DEVICE_A_HNP_SUPPORT</span><span class="p">)</span>
					<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">a_hnp_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">==</span>
					 <span class="n">USB_DEVICE_A_ALT_HNP_SUPPORT</span><span class="p">)</span>
					<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">a_alt_hnp_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep0_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">))</span>
				<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

			<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ptc</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">fsl_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;udc: switch to test mode %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptc</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Requests handled by gadget */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wLength</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Data phase from gadget, status phase from udc */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
				<span class="o">?</span>  <span class="n">USB_DIR_IN</span> <span class="o">:</span> <span class="n">USB_DIR_OUT</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
				<span class="o">?</span>  <span class="n">DATA_STATE_XMIT</span> <span class="o">:</span> <span class="n">DATA_STATE_RECV</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the data stage is IN, send status prime immediately.</span>
<span class="cm">		 * See 2.0 Spec chapter 8.5.3.3 for detail.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">==</span> <span class="n">DATA_STATE_XMIT</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep0_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_OUT</span><span class="p">))</span>
				<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* No data phase, IN status from gadget */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_OUT_STATUS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Process request for Data or Status phase of ep0</span>
<span class="cm"> * prime status phase if needed */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_req_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep0</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">==</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the new address */</span>
		<span class="n">u32</span> <span class="n">new_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">device_address</span><span class="p">;</span>
		<span class="n">fsl_writel</span><span class="p">(</span><span class="n">new_address</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_ADDRESS_BIT_POS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">deviceaddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">done</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DATA_STATE_XMIT</span>:
		<span class="cm">/* already primed at setup_received_irq */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_OUT_STATUS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DATA_STATE_RECV</span>:
		<span class="cm">/* send status phase */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep0_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">))</span>
			<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WAIT_FOR_OUT_STATUS</span>:
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WAIT_FOR_SETUP</span>:
		<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;Unexpect ep0 packets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ep0stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Tripwire mechanism to ensure a setup packet payload is extracted without</span>
<span class="cm"> * being corrupted by another incoming setup packet */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tripwire_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_usb2_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">[</span><span class="n">ep_num</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">EP_DIR_OUT</span><span class="p">];</span>

	<span class="cm">/* Clear bit in ENDPTSETUPSTAT */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptsetupstat</span><span class="p">);</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep_num</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptsetupstat</span><span class="p">);</span>

	<span class="cm">/* while a hazard exists when setup package arrives */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Set Setup Tripwire */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
		<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="n">USB_CMD_SUTW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

		<span class="cm">/* Copy the setup packet to local buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">le_setup_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer_ptr</span><span class="p">;</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">setup_buffer</span><span class="p">;</span>

			<span class="cm">/* Convert little endian setup buffer to CPU endian */</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">++</span><span class="p">);</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">setup_buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USB_CMD_SUTW</span><span class="p">));</span>

	<span class="cm">/* Clear Setup Tripwire */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_CMD_SUTW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* process-ep_req(): free the completed Tds for this req */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_ep_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">curr_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="n">curr_td</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">td_complete</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">remaining_length</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span>  <span class="n">ep_queue_head</span> <span class="o">*</span><span class="n">curr_qh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">[</span><span class="n">pipe</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">pipe</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">curr_td</span> <span class="o">=</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">td_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">actual</span> <span class="o">=</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">dtd_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remaining_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span><span class="p">)</span>
					<span class="o">&amp;</span> <span class="n">DTD_PACKET_SIZE</span><span class="p">)</span>
				<span class="o">&gt;&gt;</span> <span class="n">DTD_LENGTH_BIT_POS</span><span class="p">;</span>
		<span class="n">actual</span> <span class="o">-=</span> <span class="n">remaining_length</span><span class="p">;</span>

		<span class="n">errors</span> <span class="o">=</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">DTD_ERROR_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">DTD_STATUS_HALTED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;dTD error %08x QH=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
				<span class="cm">/* Clear the errors and Halt condition */</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">curr_qh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span><span class="p">);</span>
				<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">errors</span><span class="p">;</span>
				<span class="n">curr_qh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
				<span class="cm">/* FIXME: continue with next queued TD? */</span>

				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">DTD_STATUS_DATA_BUFF_ERR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Transfer overflow&quot;</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">DTD_STATUS_TRANSACTION_ERR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;ISO error&quot;</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;Unknown error has occurred (0x%x)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">errors</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">DTD_STATUS_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Request not complete&quot;</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">REQ_UNCOMPLETE</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remaining_length</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Transmit dTD remaining length not zero&quot;</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">td_complete</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">td_complete</span><span class="o">++</span><span class="p">;</span>
			<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;dTD transmitted successful&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">curr_td</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">next_td_virt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="n">actual</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process a DTD completion interrupt */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtd_complete_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bit_pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">bit_mask</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">curr_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">curr_req</span><span class="p">,</span> <span class="o">*</span><span class="n">temp_req</span><span class="p">;</span>

	<span class="cm">/* Clear the bits in the register */</span>
	<span class="n">bit_pos</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptcomplete</span><span class="p">);</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">bit_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptcomplete</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bit_pos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_ep</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">bit_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_num</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">direction</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bit_pos</span> <span class="o">&amp;</span> <span class="n">bit_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">curr_ep</span> <span class="o">=</span> <span class="n">get_ep_by_pipe</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* If the ep is configured */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_ep</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="s">&quot;Invalid EP?&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* process the req queue until an uncomplete request */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">curr_req</span><span class="p">,</span> <span class="n">temp_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr_ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
				<span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">process_ep_req</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">curr_req</span><span class="p">);</span>

			<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;status of process_ep_req= %d, ep = %d&quot;</span><span class="p">,</span>
					<span class="n">status</span><span class="p">,</span> <span class="n">ep_num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">REQ_UNCOMPLETE</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* write back status to req */</span>
			<span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ep_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ep0_req_complete</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">curr_ep</span><span class="p">,</span> <span class="n">curr_req</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">done</span><span class="p">(</span><span class="n">curr_ep</span><span class="p">,</span> <span class="n">curr_req</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">usb_device_speed</span> <span class="nf">portscx_device_speed</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SPEED_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PORTSCX_PORT_SPEED_HIGH</span>:
		<span class="k">return</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PORTSCX_PORT_SPEED_FULL</span>:
		<span class="k">return</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PORTSCX_PORT_SPEED_LOW</span>:
		<span class="k">return</span> <span class="n">USB_SPEED_LOW</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Process a port change interrupt */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_change_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">bus_reset</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">bus_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Bus resetting is finished */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_RESET</span><span class="p">))</span>
		<span class="cm">/* Get the speed */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span>
			<span class="n">portscx_device_speed</span><span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">));</span>

	<span class="cm">/* Update USB state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process suspend interrupt */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">suspend_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">;</span>

	<span class="cm">/* report suspend to the driver, serial.c does not support this */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* report resume to the driver, serial.c does not support this */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Clear up all ep queues */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pipe</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_pipes</span><span class="p">;</span> <span class="n">pipe</span><span class="o">++</span><span class="p">)</span>
		<span class="n">udc_reset_ep_queue</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>

	<span class="cm">/* report disconnect; the driver is already quiesced */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process reset interrupt */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* Clear the device address */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">deviceaddr</span><span class="p">);</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_DEVICE_ADDRESS_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">deviceaddr</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">device_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear usb state */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* default to 0 on reset */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">b_hnp_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">a_hnp_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">a_alt_hnp_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear all the setup token semaphores */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptsetupstat</span><span class="p">);</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptsetupstat</span><span class="p">);</span>

	<span class="cm">/* Clear all the endpoint complete status bits */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptcomplete</span><span class="p">);</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptcomplete</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endpointprime</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Wait until all endptprime bits cleared */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;Timeout for reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Write 1s to the flush register */</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptflush</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Bus reset&quot;</span><span class="p">);</span>
		<span class="cm">/* Bus is reseting */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">bus_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Reset all the queues, include XD, dTD, EP queue</span>
<span class="cm">		 * head and TR Queue */</span>
		<span class="n">reset_queues</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_DEFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Controller reset&quot;</span><span class="p">);</span>
		<span class="cm">/* initialize usb hw reg except for regs for EP, not</span>
<span class="cm">		 * touch usbintr reg */</span>
		<span class="n">dr_controller_setup</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="cm">/* Reset all internal used Queues */</span>
		<span class="n">reset_queues</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="n">ep0_setup</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="cm">/* Enable DR IRQ reg, Set Run bit, change udc state */</span>
		<span class="n">dr_controller_run</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ATTACHED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * USB device controller interrupt handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">fsl_udc_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">_udc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_src</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Disable ISR for OTG host mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">irq_src</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbsts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>
	<span class="cm">/* Clear notification bits */</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">irq_src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbsts</span><span class="p">);</span>

	<span class="cm">/* VDBG(&quot;irq_src [0x%8x]&quot;, irq_src); */</span>

	<span class="cm">/* Need to resume? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SUSPEND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">bus_resume</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="cm">/* USB Interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_src</span> <span class="o">&amp;</span> <span class="n">USB_STS_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Packet int&quot;</span><span class="p">);</span>
		<span class="cm">/* Setup package, we only support ep0 as control ep */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptsetupstat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EP_SETUP_STATUS_EP0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tripwire_handler</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">));</span>
			<span class="n">setup_received_irq</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* completion of dtd */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptcomplete</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dtd_complete_irq</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* SOF (for ISO transfer) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_src</span> <span class="o">&amp;</span> <span class="n">USB_STS_SOF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Port Change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_src</span> <span class="o">&amp;</span> <span class="n">USB_STS_PORT_CHANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_change_irq</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reset Received */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_src</span> <span class="o">&amp;</span> <span class="n">USB_STS_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;reset int&quot;</span><span class="p">);</span>
		<span class="n">reset_irq</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Sleep Enable (Suspend) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_src</span> <span class="o">&amp;</span> <span class="n">USB_STS_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">suspend_irq</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_STS_ERR</span> <span class="o">|</span> <span class="n">USB_STS_SYS_ERR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Error IRQ %x&quot;</span><span class="p">,</span> <span class="n">irq_src</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*</span>
<span class="cm"> * Hook to gadget drivers</span>
<span class="cm"> * Called by initialization code of gadget drivers</span>
<span class="cm">*----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc_controller</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">max_speed</span> <span class="o">&lt;</span> <span class="n">USB_SPEED_FULL</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">bind</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* lock is needed but whether should use this lock or another */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* hook up the driver */</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* bind udc driver to gadget driver */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;bind to %s --&gt; %d&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Suspend the controller until OTG enable it */</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Suspend udc for OTG auto detect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* connect to bus through transceiver */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">otg_set_peripheral</span><span class="p">(</span>
					<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;can&#39;t bind to transceiver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
				<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Enable DR IRQ reg and set USBCMD reg Run bit */</span>
		<span class="n">dr_controller_run</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ATTACHED</span><span class="p">;</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: bind to driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;gadget driver register failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Disconnect from gadget driver */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">loop_ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc_controller</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="n">driver</span> <span class="o">!=</span> <span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="n">otg_set_peripheral</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* stop DR, disable intr */</span>
	<span class="n">dr_controller_stop</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>

	<span class="cm">/* in fact, no needed */</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ATTACHED</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* stand operation */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">nuke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">loop_ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span>
			<span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">)</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">loop_ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* report disconnect; the controller is already quiesced */</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>

	<span class="cm">/* unbind gadget and unhook driver. */</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;unregistered gadget driver &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------</span>
<span class="cm">		PROC File System Support</span>
<span class="cm">-------------------------------------------------------------------------*/</span>
<span class="cp">#ifdef CONFIG_USB_GADGET_DEBUG_FILES</span>

<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">proc_filename</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;driver/fsl_usb2_udc&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_proc_read</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">udc_controller</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* ------basic driver information ---- */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">DRIVER_DESC</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;%s version: %s</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;Gadget driver: %s</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">driver_name</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;(none)&quot;</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* ------ DR Registers ----- */</span>
	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;USBCMD reg:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;SetupTW: %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;Run/Stop: %s</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_CMD_SUTW</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_CMD_RUN_STOP</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Run&quot;</span> <span class="o">:</span> <span class="s">&quot;Stop&quot;</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbsts</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;USB Status Reg:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;Dr Suspend: %d Reset Received: %d System Error: %s &quot;</span>
			<span class="s">&quot;USB Error Interrupt: %s</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_STS_SUSPEND</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_STS_RESET</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_STS_SYS_ERR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Err&quot;</span> <span class="o">:</span> <span class="s">&quot;Normal&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_STS_ERR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Err detected&quot;</span> <span class="o">:</span> <span class="s">&quot;No err&quot;</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;USB Intrrupt Enable Reg:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;Sleep Enable: %d SOF Received Enable: %d &quot;</span>
			<span class="s">&quot;Reset Enable: %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;System Error Enable: %d &quot;</span>
			<span class="s">&quot;Port Change Dectected Enable: %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;USB Error Intr Enable: %d USB Intr Enable: %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_INTR_DEVICE_SUSPEND</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_INTR_SOF_EN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_INTR_RESET_EN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_INTR_SYS_ERR_EN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_INTR_PTC_DETECT_EN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_INTR_ERR_INT_EN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_INTR_INT_EN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">frindex</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;USB Frame Index Reg: Frame Number is 0x%x</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_FRINDEX_MASKS</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">deviceaddr</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;USB Device Address Reg: Device Addr is 0x%x</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ADDRESS_MASK</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endpointlistaddr</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;USB Endpoint List Address Reg: &quot;</span>
			<span class="s">&quot;Device Addr is 0x%x</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_EP_LIST_ADDRESS_MASK</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">portsc1</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
		<span class="s">&quot;USB Port Status&amp;Control Reg:</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Port Transceiver Type : %s Port Speed: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;PHY Low Power Suspend: %s Port Reset: %s &quot;</span>
		<span class="s">&quot;Port Suspend Mode: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Over-current Change: %s &quot;</span>
		<span class="s">&quot;Port Enable/Disable Change: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Port Enabled/Disabled: %s &quot;</span>
		<span class="s">&quot;Current Connect Status: %s</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PTS_FSLS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">PORTSCX_PTS_UTMI</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;UTMI&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PORTSCX_PTS_ULPI</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;ULPI &quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PORTSCX_PTS_FSLS</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;FS/LS Serial&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;None&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">s</span><span class="p">;}</span> <span class="p">),</span>
		<span class="n">usb_speed_string</span><span class="p">(</span><span class="n">portscx_device_speed</span><span class="p">(</span><span class="n">tmp_reg</span><span class="p">)),</span>
		<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PHY_LOW_POWER_SPD</span><span class="p">)</span> <span class="o">?</span>
		<span class="s">&quot;Normal PHY mode&quot;</span> <span class="o">:</span> <span class="s">&quot;Low power mode&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_RESET</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;In Reset&quot;</span> <span class="o">:</span>
		<span class="s">&quot;Not in Reset&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SUSPEND</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;In &quot;</span> <span class="o">:</span> <span class="s">&quot;Not in&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_OVER_CURRENT_CHG</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Dected&quot;</span> <span class="o">:</span>
		<span class="s">&quot;No&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_EN_DIS_CHANGE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Disable&quot;</span> <span class="o">:</span>
		<span class="s">&quot;Not change&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_ENABLE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Enable&quot;</span> <span class="o">:</span>
		<span class="s">&quot;Not correct&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">PORTSCX_CURRENT_CONNECT_STATUS</span><span class="p">)</span> <span class="o">?</span>
		<span class="s">&quot;Attached&quot;</span> <span class="o">:</span> <span class="s">&quot;Not-Att&quot;</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;USB Mode Reg: Controller Mode is: %s</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">USB_MODE_CTRL_MODE_HOST</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">USB_MODE_CTRL_MODE_IDLE</span>:
					<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Idle&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">USB_MODE_CTRL_MODE_DEVICE</span>:
					<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Device Controller&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">USB_MODE_CTRL_MODE_HOST</span>:
					<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Host Controller&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;None&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">s</span><span class="p">;</span>
			<span class="p">}</span> <span class="p">));</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptsetupstat</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="s">&quot;Endpoint Setup Status Reg: SETUP on ep 0x%x</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">tmp_reg</span> <span class="o">&amp;</span> <span class="n">EP_SETUP_STATUS_MASK</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_ep</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endptctrl</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;EP Ctrl Reg [0x%x]: = [0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">tmp_reg</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">endpointprime</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;EP Prime Reg = [0x%x]</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp_reg</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_ARCH_MXC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">have_sysif_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">snoop1</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;Snoop1 Reg : = [0x%x]</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp_reg</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

		<span class="n">tmp_reg</span> <span class="o">=</span> <span class="n">usb_sys_regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;General Control Reg : = [0x%x]</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tmp_reg</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;For %s Maxpkt is 0x%x index is 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ep_maxpacket</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span> <span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;its req queue is empty</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				<span class="s">&quot;req %p actual 0x%x length 0x%x buf %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* other gadget-&gt;eplist ep */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					<span class="s">&quot;</span><span class="se">\n</span><span class="s">For %s Maxpkt is 0x%x &quot;</span>
					<span class="s">&quot;index is 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ep_maxpacket</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span>
					<span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">));</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						<span class="s">&quot;its req queue is empty</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
				<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">t</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						<span class="s">&quot;req %p actual 0x%x length &quot;</span>
						<span class="s">&quot;0x%x  buf %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span>
						<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
					<span class="n">size</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
					<span class="n">next</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
					<span class="p">}</span>	<span class="cm">/* end for each_entry of ep req */</span>
				<span class="p">}</span>	<span class="cm">/* end for else */</span>
			<span class="p">}</span>	<span class="cm">/* end for if(ep-&gt;queue) */</span>
		<span class="p">}</span>		<span class="cm">/* end (ep-&gt;desc) */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define create_proc_file()	create_proc_read_entry(proc_filename, \</span>
<span class="cp">				0, NULL, fsl_proc_read, NULL)</span>

<span class="cp">#define remove_proc_file()	remove_proc_entry(proc_filename, NULL)</span>

<span class="cp">#else				</span><span class="cm">/* !CONFIG_USB_GADGET_DEBUG_FILES */</span><span class="cp"></span>

<span class="cp">#define create_proc_file()	do {} while (0)</span>
<span class="cp">#define remove_proc_file()	do {} while (0)</span>

<span class="cp">#endif				</span><span class="cm">/* CONFIG_USB_GADGET_DEBUG_FILES */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Release udc structures */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_udc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep_qh_size</span><span class="p">,</span>
			<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">,</span> <span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep_qh_dma</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************</span>
<span class="cm">	Internal structure setup functions</span>
<span class="cm">*******************************************************************/</span>
<span class="cm">/*------------------------------------------------------------------</span>
<span class="cm"> * init resource for globle controller</span>
<span class="cm"> * Return the udc handle on success or NULL on failure</span>
<span class="cm"> ------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">struct_udc_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_usb2_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_mode</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_mode</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_ep</span><span class="p">)</span> <span class="o">*</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_ep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;malloc fsl_ep failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialized QHs, take care of alignment */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_ep</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep_queue_head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">QH_ALIGNMENT</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">QH_ALIGNMENT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">%</span> <span class="n">QH_ALIGNMENT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">QH_ALIGNMENT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">QH_ALIGNMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;malloc QHs for udc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Initialize ep0 status request structure */</span>
	<span class="cm">/* FIXME: fsl_alloc_request() ignores ep argument */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fsl_alloc_request</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">),</span>
			<span class="k">struct</span> <span class="n">fsl_req</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="cm">/* allocate a small amount of memory to get valid address */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_POWERED</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* default to 0 on reset */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm"> * Setup the fsl_ep struct for eps</span>
<span class="cm"> * Link fsl_ep-&gt;ep to gadget-&gt;ep_list</span>
<span class="cm"> * ep0out is not used so do nothing here</span>
<span class="cm"> * ep0in should be taken care</span>
<span class="cm"> *--------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">struct_ep_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">index</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span> <span class="o">=</span> <span class="n">udc</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsl_ep_ops</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* for ep0: maxP defined in desc</span>
<span class="cm">	 * for other eps, maxP is set by epautoconfig() called by gadget layer</span>
<span class="cm">	 */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the queue lists any req for this ep */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* gagdet.ep_list used for ep_autoconfig so no ep0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">qh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Driver probe function</span>
<span class="cm"> * all intialization operations implemented here except enabling usb_intr reg</span>
<span class="cm"> * board setup should have been done in the platform code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fsl_udc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_usb2_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dccparams</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="s">&quot;Wrong device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc_controller</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_udc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;malloc udc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdata</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_USB_OTG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">operating_mode</span> <span class="o">==</span> <span class="n">FSL_USB2_DR_OTG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">usb_get_transceiver</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t find OTG driver!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_kfree</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_kfree</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">operating_mode</span> <span class="o">==</span> <span class="n">FSL_USB2_DR_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
					<span class="n">driver_name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;request mem region for %s failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_kfree</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dr_regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dr_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_release_mem_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dr_regs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * do platform specific init: check the clock, grab/config pins, etc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">&amp;&amp;</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_iounmap_noclk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set accessors only after pdata-&gt;init() ! */</span>
	<span class="n">fsl_set_accessors</span><span class="p">(</span><span class="n">pdata</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_ARCH_MXC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">have_sysif_regs</span><span class="p">)</span>
		<span class="n">usb_sys_regs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dr_regs</span> <span class="o">+</span> <span class="n">USB_DR_SYS_OFFSET</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Initialize USB clocks */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fsl_udc_clk_init</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_iounmap_noclk</span><span class="p">;</span>

	<span class="cm">/* Read Device Controller Capability Parameters register */</span>
	<span class="n">dccparams</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">dccparams</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dccparams</span> <span class="o">&amp;</span> <span class="n">DCCPARAMS_DC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;This SOC doesn&#39;t support device role</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_iounmap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Get max device endpoints */</span>
	<span class="cm">/* DEN is bidirectional ep number, max_ep doubles the number */</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">max_ep</span> <span class="o">=</span> <span class="p">(</span><span class="n">dccparams</span> <span class="o">&amp;</span> <span class="n">DCCPARAMS_DEN_MASK</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">fsl_udc_irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">driver_name</span><span class="p">,</span> <span class="n">udc_controller</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;cannot request irq %d err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the udc structure including QH member and other member */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">struct_udc_setup</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t initialize udc data structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* initialize usb hw reg except for regs for EP,</span>
<span class="cm">		 * leave usbintr reg untouched */</span>
		<span class="n">dr_controller_setup</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fsl_udc_clk_finalize</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Setup gadget structure */</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsl_gadget_ops</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">max_speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">driver_name</span><span class="p">;</span>

	<span class="cm">/* Setup gadget.dev and register with kernel */</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gadget&quot;</span><span class="p">);</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">fsl_udc_release</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">is_otg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* setup QH and epctrl for ep0 */</span>
	<span class="n">ep0_setup</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>

	<span class="cm">/* setup udc-&gt;eps[] for ep0 */</span>
	<span class="n">struct_ep_setup</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ep0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* for ep0: the desc defined here;</span>
<span class="cm">	 * for other eps, gadget layer called ep_enable with defined desc</span>
<span class="cm">	 */</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsl_ep0_desc</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">USB_MAX_CTRL_PAYLOAD</span><span class="p">;</span>

	<span class="cm">/* setup the udc-&gt;eps[] for non-control endpoints and link</span>
<span class="cm">	 * to gadget.ep_list */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">max_ep</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>

		<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ep%dout&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">struct_ep_setup</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ep%din&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">struct_ep_setup</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* use dma_pool for TD management */</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">td_pool</span> <span class="o">=</span> <span class="n">dma_pool_create</span><span class="p">(</span><span class="s">&quot;udc_td&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep_td_struct</span><span class="p">),</span>
			<span class="n">DTD_ALIGNMENT</span><span class="p">,</span> <span class="n">UDC_DMA_BOUNDARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">td_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_unregister</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_del_udc</span><span class="p">;</span>

	<span class="n">create_proc_file</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_del_udc:</span>
	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">td_pool</span><span class="p">);</span>
<span class="nl">err_unregister:</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">udc_controller</span><span class="p">);</span>
<span class="nl">err_iounmap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">fsl_udc_clk_release</span><span class="p">();</span>
<span class="nl">err_iounmap_noclk:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">dr_regs</span><span class="p">);</span>
<span class="nl">err_release_mem_region:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">operating_mode</span> <span class="o">==</span> <span class="n">FSL_USB2_DR_DEVICE</span><span class="p">)</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
<span class="nl">err_kfree:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>
	<span class="n">udc_controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Driver removal function</span>
<span class="cm"> * Free resources and finish pending transactions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">fsl_udc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsl_usb2_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc_controller</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">usb_del_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">;</span>

	<span class="n">fsl_udc_clk_release</span><span class="p">();</span>

	<span class="cm">/* DR has been stopped in usb_gadget_unregister_driver() */</span>
	<span class="n">remove_proc_file</span><span class="p">();</span>

	<span class="cm">/* Free allocated memory */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">);</span>

	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">td_pool</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">udc_controller</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">dr_regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">operating_mode</span> <span class="o">==</span> <span class="n">FSL_USB2_DR_DEVICE</span><span class="p">)</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* free udc --wait for the release() finished */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * do platform specific un-initialization:</span>
<span class="cm">	 * release iomux pins, etc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Modify Power management attributes</span>
<span class="cm"> * Used by OTG statemachine to disable gadget temporarily</span>
<span class="cm"> -----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_udc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dr_controller_stop</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------</span>
<span class="cm"> * Invoked on USB resume. May be called in_interrupt.</span>
<span class="cm"> * Here we start the DR controller and enable the irq</span>
<span class="cm"> *-----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_udc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Enable DR irq reg and set controller Run */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dr_controller_setup</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>
		<span class="n">dr_controller_run</span><span class="p">(</span><span class="n">udc_controller</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ATTACHED</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_udc_otg_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">udc_controller</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">,</span> <span class="n">usbcmd</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USB_MODE_CTRL_MODE_MASK</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(): mode 0x%x stopped %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the controller is already stopped, then this must be a</span>
<span class="cm">	 * PM suspend.  Remember this fact, so that we will leave the</span>
<span class="cm">	 * controller stopped at PM resume time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;gadget already stopped, leaving early</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">already_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">USB_MODE_CTRL_MODE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;gadget not in device mode, leaving early</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* stop the controller */</span>
	<span class="n">usbcmd</span> <span class="o">=</span> <span class="n">fsl_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_CMD_RUN_STOP</span><span class="p">;</span>
	<span class="n">fsl_writel</span><span class="p">(</span><span class="n">usbcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;USB Gadget suspended</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_udc_otg_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(): stopped %d  already_stopped %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		 <span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">,</span> <span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">already_stopped</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the controller was stopped at suspend time, then</span>
<span class="cm">	 * don&#39;t resume it now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">already_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_controller</span><span class="o">-&gt;</span><span class="n">already_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;gadget was already stopped, leaving early</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;USB Gadget resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fsl_udc_resume</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------</span>
<span class="cm">	Register entry point for the peripheral controller driver</span>
<span class="cm">--------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">udc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">remove</span>  <span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">fsl_udc_remove</span><span class="p">),</span>
	<span class="cm">/* these suspend and resume are not usb suspend and resume */</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">fsl_udc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>  <span class="o">=</span> <span class="n">fsl_udc_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>  <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">driver_name</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="cm">/* udc suspend/resume called from OTG driver */</span>
		<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">fsl_udc_otg_suspend</span><span class="p">,</span>
		<span class="p">.</span><span class="n">resume</span>  <span class="o">=</span> <span class="n">fsl_udc_otg_resume</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">udc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_desc</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_driver</span><span class="p">,</span> <span class="n">fsl_udc_probe</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">udc_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">udc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_driver</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">udc_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:fsl-usb2-udc&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
