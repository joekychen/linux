<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › f_fs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>f_fs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * f_fs.c -- user mode file system API for USB composite function controllers</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010 Samsung Electronics</span>
<span class="cm"> * Author: Michal Nazarewicz &lt;mina86@mina86.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on inode.c (GadgetFS) which was:</span>
<span class="cm"> * Copyright (C) 2003-2004 David Brownell</span>
<span class="cm"> * Copyright (C) 2003 Agilent Technologies</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>


<span class="cm">/* #define DEBUG */</span>
<span class="cm">/* #define VERBOSE_DEBUG */</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &lt;linux/usb/composite.h&gt;</span>
<span class="cp">#include &lt;linux/usb/functionfs.h&gt;</span>


<span class="cp">#define FUNCTIONFS_MAGIC	0xa647361 </span><span class="cm">/* Chosen by a honest dice roll ;) */</span><span class="cp"></span>


<span class="cm">/* Debugging ****************************************************************/</span>

<span class="cp">#ifdef VERBOSE_DEBUG</span>
<span class="cp">#  define pr_vdebug pr_debug</span>
<span class="cp">#  define ffs_dump_mem(prefix, ptr, len) \</span>
<span class="cp">	print_hex_dump_bytes(pr_fmt(prefix &quot;: &quot;), DUMP_PREFIX_NONE, ptr, len)</span>
<span class="cp">#else</span>
<span class="cp">#  define pr_vdebug(...)                 do { } while (0)</span>
<span class="cp">#  define ffs_dump_mem(prefix, ptr, len) do { } while (0)</span>
<span class="cp">#endif </span><span class="cm">/* VERBOSE_DEBUG */</span><span class="cp"></span>

<span class="cp">#define ENTER()    pr_vdebug(&quot;%s()\n&quot;, __func__)</span>


<span class="cm">/* The data structure and setup file ****************************************/</span>

<span class="k">enum</span> <span class="n">ffs_state</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Waiting for descriptors and strings.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In this state no open(2), read(2) or write(2) on epfiles</span>
<span class="cm">	 * may succeed (which should not be the problem as there</span>
<span class="cm">	 * should be no such files opened in the first place).</span>
<span class="cm">	 */</span>
	<span class="n">FFS_READ_DESCRIPTORS</span><span class="p">,</span>
	<span class="n">FFS_READ_STRINGS</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve got descriptors and strings.  We are or have called</span>
<span class="cm">	 * functionfs_ready_callback().  functionfs_bind() may have</span>
<span class="cm">	 * been called but we don&#39;t know.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is the only state in which operations on epfiles may</span>
<span class="cm">	 * succeed.</span>
<span class="cm">	 */</span>
	<span class="n">FFS_ACTIVE</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * All endpoints have been closed.  This state is also set if</span>
<span class="cm">	 * we encounter an unrecoverable error.  The only</span>
<span class="cm">	 * unrecoverable error is situation when after reading strings</span>
<span class="cm">	 * from user space we fail to initialise epfiles or</span>
<span class="cm">	 * functionfs_ready_callback() returns with error (&lt;0).</span>
<span class="cm">	 *</span>
<span class="cm">	 * In this state no open(2), read(2) or write(2) (both on ep0</span>
<span class="cm">	 * as well as epfile) may succeed (at this point epfiles are</span>
<span class="cm">	 * unlinked and all closed so this is not a problem; ep0 is</span>
<span class="cm">	 * also closed but ep0 file exists and so open(2) on ep0 must</span>
<span class="cm">	 * fail).</span>
<span class="cm">	 */</span>
	<span class="n">FFS_CLOSING</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="n">ffs_setup_state</span> <span class="p">{</span>
	<span class="cm">/* There is no setup request pending. */</span>
	<span class="n">FFS_NO_SETUP</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * User has read events and there was a setup request event</span>
<span class="cm">	 * there.  The next read/write on ep0 will handle the</span>
<span class="cm">	 * request.</span>
<span class="cm">	 */</span>
	<span class="n">FFS_SETUP_PENDING</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * There was event pending but before user space handled it</span>
<span class="cm">	 * some other event was introduced which canceled existing</span>
<span class="cm">	 * setup.  If this state is set read/write on ep0 return</span>
<span class="cm">	 * -EIDRM.  This state is only set when adding event.</span>
<span class="cm">	 */</span>
	<span class="n">FFS_SETUP_CANCELED</span>
<span class="p">};</span>



<span class="k">struct</span> <span class="n">ffs_epfile</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ffs_function</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ffs_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>		<span class="o">*</span><span class="n">gadget</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protect access read/write operations, only one read/write</span>
<span class="cm">	 * at a time.  As a consequence protects ep0req and company.</span>
<span class="cm">	 * While setup request is being processed (queued) this is</span>
<span class="cm">	 * held.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">mutex</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protect access to endpoint related structures (basically</span>
<span class="cm">	 * usb_ep_queue(), usb_ep_dequeue(), etc. calls) except for</span>
<span class="cm">	 * endpoint zero.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>			<span class="n">eps_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX REVISIT do we need our own request? Since we are not</span>
<span class="cm">	 * handling setup requests immediately user space may be so</span>
<span class="cm">	 * slow that another setup will be sent to the gadget but this</span>
<span class="cm">	 * time not to us but another function and then there could be</span>
<span class="cm">	 * a race.  Is that the case? Or maybe we can use cdev-&gt;req</span>
<span class="cm">	 * after all, maybe we just need some spinlock for that?</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">usb_request</span>		<span class="o">*</span><span class="n">ep0req</span><span class="p">;</span>		<span class="cm">/* P: mutex */</span>
	<span class="k">struct</span> <span class="n">completion</span>		<span class="n">ep0req_completion</span><span class="p">;</span>	<span class="cm">/* P: mutex */</span>
	<span class="kt">int</span>				<span class="n">ep0req_status</span><span class="p">;</span>		<span class="cm">/* P: mutex */</span>

	<span class="cm">/* reference counter */</span>
	<span class="n">atomic_t</span>			<span class="n">ref</span><span class="p">;</span>
	<span class="cm">/* how many files are opened (EP0 and others) */</span>
	<span class="n">atomic_t</span>			<span class="n">opened</span><span class="p">;</span>

	<span class="cm">/* EP0 state */</span>
	<span class="k">enum</span> <span class="n">ffs_state</span>			<span class="n">state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Possible transitions:</span>
<span class="cm">	 * + FFS_NO_SETUP       -&gt; FFS_SETUP_PENDING  -- P: ev.waitq.lock</span>
<span class="cm">	 *               happens only in ep0 read which is P: mutex</span>
<span class="cm">	 * + FFS_SETUP_PENDING  -&gt; FFS_NO_SETUP       -- P: ev.waitq.lock</span>
<span class="cm">	 *               happens only in ep0 i/o  which is P: mutex</span>
<span class="cm">	 * + FFS_SETUP_PENDING  -&gt; FFS_SETUP_CANCELED -- P: ev.waitq.lock</span>
<span class="cm">	 * + FFS_SETUP_CANCELED -&gt; FFS_NO_SETUP       -- cmpxchg</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">ffs_setup_state</span>		<span class="n">setup_state</span><span class="p">;</span>

<span class="cp">#define FFS_SETUP_STATE(ffs)					\</span>
<span class="cp">	((enum ffs_setup_state)cmpxchg(&amp;(ffs)-&gt;setup_state,	\</span>
<span class="cp">				       FFS_SETUP_CANCELED, FFS_NO_SETUP))</span>

	<span class="cm">/* Events &amp; such. */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u8</span>				<span class="n">types</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">count</span><span class="p">;</span>
		<span class="cm">/* XXX REVISIT need to update it in some places, or do we? */</span>
		<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">can_stall</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>		<span class="n">setup</span><span class="p">;</span>

		<span class="n">wait_queue_head_t</span>		<span class="n">waitq</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ev</span><span class="p">;</span> <span class="cm">/* the whole structure, P: ev.waitq.lock */</span>

	<span class="cm">/* Flags */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FFS_FL_CALL_CLOSED_CALLBACK 0</span>
<span class="cp">#define FFS_FL_BOUND                1</span>

	<span class="cm">/* Active function */</span>
	<span class="k">struct</span> <span class="n">ffs_function</span>		<span class="o">*</span><span class="n">func</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device name, write once when file system is mounted.</span>
<span class="cm">	 * Intended for user to read if she wants.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="cm">/* Private data for our user (ie. gadget).  Managed by user. */</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* filled by __ffs_data_got_descs() */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Real descriptors are 16 bytes after raw_descs (so you need</span>
<span class="cm">	 * to skip 16 bytes (ie. ffs-&gt;raw_descs + 16) to get to the</span>
<span class="cm">	 * first full speed descriptor).  raw_descs_length and</span>
<span class="cm">	 * raw_fs_descs_length do not have those 16 bytes added.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">void</span>			<span class="o">*</span><span class="n">raw_descs</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">raw_descs_length</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">raw_fs_descs_length</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">fs_descs_count</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">hs_descs_count</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">strings_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">interfaces_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">eps_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>			<span class="n">_pad1</span><span class="p">;</span>

	<span class="cm">/* filled by __ffs_data_got_strings() */</span>
	<span class="cm">/* ids in stringtabs are set in functionfs_bind() */</span>
	<span class="k">const</span> <span class="kt">void</span>			<span class="o">*</span><span class="n">raw_strings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_strings</span>	<span class="o">**</span><span class="n">stringtabs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * File system&#39;s super block, write once when file system is</span>
<span class="cm">	 * mounted.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">super_block</span>		<span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="cm">/* File permissions, written once when fs is mounted */</span>
	<span class="k">struct</span> <span class="n">ffs_file_perms</span> <span class="p">{</span>
		<span class="n">umode_t</span>				<span class="n">mode</span><span class="p">;</span>
		<span class="n">uid_t</span>				<span class="n">uid</span><span class="p">;</span>
		<span class="n">gid_t</span>				<span class="n">gid</span><span class="p">;</span>
	<span class="p">}</span>				<span class="n">file_perms</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The endpoint files, filled by ffs_epfiles_create(),</span>
<span class="cm">	 * destroyed by ffs_epfiles_destroy().</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span>		<span class="o">*</span><span class="n">epfiles</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Reference counter handling */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_data_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_data_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">);</span>
<span class="cm">/* Creates new ffs_data object. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">__must_check</span> <span class="n">ffs_data_new</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">malloc</span><span class="p">));</span>

<span class="cm">/* Opened counter handling. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_data_opened</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_data_closed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">);</span>

<span class="cm">/* Called with ffs-&gt;mutex held; take over ownership of data. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">__ffs_data_got_descs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">__ffs_data_got_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>


<span class="cm">/* The function structure ***************************************************/</span>

<span class="k">struct</span> <span class="n">ffs_ep</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ffs_function</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_configuration</span>	<span class="o">*</span><span class="n">conf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>		<span class="o">*</span><span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_data</span>			<span class="o">*</span><span class="n">ffs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ffs_ep</span>			<span class="o">*</span><span class="n">eps</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">eps_revmap</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">short</span>				<span class="o">*</span><span class="n">interfaces_nums</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_function</span>		<span class="n">function</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="nf">ffs_func_from_usb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ffs_function</span><span class="p">,</span> <span class="n">function</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_func_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_func_eps_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">ffs_func_eps_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ffs_func_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_func_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ffs_func_set_alt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_func_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ffs_func_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_func_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_func_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">ffs_func_revmap_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">u8</span> <span class="n">num</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ffs_func_revmap_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">u8</span> <span class="n">intf</span><span class="p">);</span>


<span class="cm">/* The endpoints structures *************************************************/</span>

<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>			<span class="o">*</span><span class="n">ep</span><span class="p">;</span>	<span class="cm">/* P: ffs-&gt;eps_lock */</span>
	<span class="k">struct</span> <span class="n">usb_request</span>		<span class="o">*</span><span class="n">req</span><span class="p">;</span>	<span class="cm">/* P: epfile-&gt;mutex */</span>

	<span class="cm">/* [0]: full speed, [1]: high speed */</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>	<span class="o">*</span><span class="n">descs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">u8</span>				<span class="n">num</span><span class="p">;</span>

	<span class="kt">int</span>				<span class="n">status</span><span class="p">;</span>	<span class="cm">/* P: epfile-&gt;mutex */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="p">{</span>
	<span class="cm">/* Protects ep-&gt;ep and ep-&gt;req. */</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">mutex</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>		<span class="n">wait</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ffs_data</span>			<span class="o">*</span><span class="n">ffs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_ep</span>			<span class="o">*</span><span class="n">ep</span><span class="p">;</span>	<span class="cm">/* P: ffs-&gt;eps_lock */</span>

	<span class="k">struct</span> <span class="n">dentry</span>			<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="kt">char</span>				<span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">in</span><span class="p">;</span>	<span class="cm">/* P: ffs-&gt;eps_lock */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">isoc</span><span class="p">;</span>	<span class="cm">/* P: ffs-&gt;eps_lock */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">_pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>  <span class="n">__must_check</span> <span class="n">ffs_epfiles_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_epfiles_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfiles</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">__must_check</span>
<span class="n">ffs_sb_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">dentry_p</span><span class="p">);</span>


<span class="cm">/* Misc helper functions ****************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ffs_mutex_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nonblock</span><span class="p">)</span>
	<span class="n">__attribute__</span><span class="p">((</span><span class="n">warn_unused_result</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">));</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ffs_prepare_buffer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">__user</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
	<span class="n">__attribute__</span><span class="p">((</span><span class="n">warn_unused_result</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">));</span>


<span class="cm">/* Control file aka ep0 *****************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_ep0_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">complete_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req_completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ffs_ep0_queue_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">zero</span>     <span class="o">=</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span><span class="p">.</span><span class="n">wLength</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span>      <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span>   <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * UDC layer requires to provide a buffer even for ZLP, but should</span>
<span class="cm">	 * not use it at all. Let&#39;s provide some poisoned pointer to catch</span>
<span class="cm">	 * possible bug in the driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xDEADBABE</span><span class="p">;</span>

	<span class="n">INIT_COMPLETION</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req_completion</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_ep_queue</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req_completion</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">FFS_NO_SETUP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ffs_ep0_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">can_stall</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;ep0 stall</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_ep_set_halt</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">);</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">FFS_NO_SETUP</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EL2HLT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bogus ep0 stall!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ffs_ep0_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Fast check if setup was canceled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">FFS_SETUP_STATE</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span> <span class="o">==</span> <span class="n">FFS_SETUP_CANCELED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>

	<span class="cm">/* Acquire mutex */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Check state */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FFS_READ_DESCRIPTORS</span>:
	<span class="k">case</span> <span class="n">FFS_READ_STRINGS</span>:
		<span class="cm">/* Copy data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">ffs_prepare_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Handle data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FFS_READ_DESCRIPTORS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;read descriptors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__ffs_data_got_descs</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FFS_READ_STRINGS</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;read strings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__ffs_data_got_strings</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_epfiles_create</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FFS_CLOSING</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FFS_ACTIVE</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">functionfs_ready_callback</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FFS_CLOSING</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">set_bit</span><span class="p">(</span><span class="n">FFS_FL_CALL_CLOSED_CALLBACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_ACTIVE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re called from user space, we can use _irq</span>
<span class="cm">		 * rather then _irqsave</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">FFS_SETUP_STATE</span><span class="p">(</span><span class="n">ffs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FFS_SETUP_CANCELED</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done_spin</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">FFS_NO_SETUP</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done_spin</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">FFS_SETUP_PENDING</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* FFS_SETUP_PENDING */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__ffs_ep0_stall</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* FFS_SETUP_PENDING and not stall */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span><span class="p">.</span><span class="n">wLength</span><span class="p">));</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">ffs_prepare_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We are guaranteed to be still in FFS_ACTIVE state</span>
<span class="cm">		 * but the state of setup could have changed from</span>
<span class="cm">		 * FFS_SETUP_PENDING to FFS_SETUP_CANCELED so we need</span>
<span class="cm">		 * to check for that.  If that happened we copied data</span>
<span class="cm">		 * from user space in vain but it&#39;s unlikely.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For sure we are not in FFS_NO_SETUP since this is</span>
<span class="cm">		 * the only place FFS_SETUP_PENDING -&gt; FFS_NO_SETUP</span>
<span class="cm">		 * transition can be performed and it&#39;s protected by</span>
<span class="cm">		 * mutex.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FFS_SETUP_STATE</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span> <span class="o">==</span> <span class="n">FFS_SETUP_CANCELED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
<span class="nl">done_spin:</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* unlocks spinlock */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__ffs_ep0_queue_wait</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__ffs_ep0_read_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are holding ffs-&gt;ev.waitq.lock and ffs-&gt;mutex and we need</span>
<span class="cm">	 * to release them.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">usb_functionfs_event</span> <span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">events</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">FUNCTIONFS_SETUP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">.</span><span class="n">setup</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span><span class="p">;</span>
			<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">FFS_SETUP_PENDING</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">types</span><span class="p">,</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">types</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span>
			<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">types</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">events</span><span class="p">))</span>
		<span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="k">sizeof</span> <span class="n">events</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ffs_ep0_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Fast check if setup was canceled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">FFS_SETUP_STATE</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span> <span class="o">==</span> <span class="n">FFS_SETUP_CANCELED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>

	<span class="cm">/* Acquire mutex */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Check state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FFS_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re called from user space, we can use _irq rather then</span>
<span class="cm">	 * _irqsave</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">FFS_SETUP_STATE</span><span class="p">(</span><span class="n">ffs</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FFS_SETUP_CANCELED</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_NO_SETUP</span>:
		<span class="n">n</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_functionfs_event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible_exclusive_locked_irq</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">,</span>
							<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">__ffs_ep0_read_events</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
					     <span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>

	<span class="k">case</span> <span class="n">FFS_SETUP_PENDING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__ffs_ep0_stall</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done_mutex</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span><span class="p">.</span><span class="n">wLength</span><span class="p">));</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done_mutex</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* See ffs_ep0_write() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FFS_SETUP_STATE</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span> <span class="o">==</span> <span class="n">FFS_SETUP_CANCELED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* unlocks spinlock */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__ffs_ep0_queue_wait</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done_mutex</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">done_mutex:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_ep0_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FFS_CLOSING</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">;</span>
	<span class="n">ffs_data_opened</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_ep0_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">ffs_data_closed</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">ffs_ep0_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">FUNCTIONFS_INTERFACE_REVMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">func</span> <span class="o">?</span> <span class="n">ffs_func_revmap_intf</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gadget</span> <span class="o">&amp;&amp;</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ffs_ep0_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>

	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">ffs_ep0_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">ffs_ep0_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">ffs_ep0_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">ffs_ep0_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span>	<span class="n">ffs_ep0_ioctl</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* &quot;Normal&quot; endpoints operations ********************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_epfile_io_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">_ep</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">?</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">:</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">;</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ffs_epfile_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">halt</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">first_try</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

<span class="nl">first_try:</span>
		<span class="cm">/* Are we still active? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FFS_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for endpoint to be enabled */</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span>
						     <span class="p">(</span><span class="n">ep</span> <span class="o">=</span> <span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Do we halt? */</span>
		<span class="n">halt</span> <span class="o">=</span> <span class="o">!</span><span class="n">read</span> <span class="o">==</span> <span class="o">!</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">halt</span> <span class="o">&amp;&amp;</span> <span class="n">epfile</span><span class="o">-&gt;</span><span class="n">isoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Allocate &amp; copy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">halt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read</span> <span class="o">&amp;&amp;</span>
			    <span class="n">unlikely</span><span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* We will be using request */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span>
				     <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re called from user space, we can use _irq rather then</span>
<span class="cm">		 * _irqsave</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * While we were acquiring mutex endpoint got disabled</span>
<span class="cm">		 * or changed?</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">!=</span> <span class="n">ep</span><span class="p">));</span>

	<span class="cm">/* Halt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">halt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">==</span> <span class="n">ep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">))</span>
			<span class="n">usb_ep_set_halt</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Fire the request */</span>
		<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>

		<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">ffs_epfile_io_complete</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span>      <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span>   <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_ep_queue</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* nop */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">unlikely</span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">)))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ffs_epfile_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		 <span class="n">loff_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ffs_epfile_io</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ffs_epfile_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ffs_epfile_io</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ffs_epfile_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FFS_ACTIVE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">epfile</span><span class="p">;</span>
	<span class="n">ffs_data_opened</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ffs_epfile_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">ffs_data_closed</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">ffs_epfile_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">code</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FFS_ACTIVE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FUNCTIONFS_FIFO_STATUS</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_ep_fifo_status</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FUNCTIONFS_FIFO_FLUSH</span>:
			<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FUNCTIONFS_CLEAR_HALT</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_ep_clear_halt</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FUNCTIONFS_ENDPOINT_REVMAP</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ffs_epfile_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>

	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">ffs_epfile_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">ffs_epfile_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">ffs_epfile_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">ffs_epfile_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span>	<span class="n">ffs_epfile_ioctl</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* File system and super block operations ***********************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Mounting the file system creates a controller file, used first for</span>
<span class="cm"> * function configuration then later for event monitoring.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">__must_check</span>
<span class="nf">ffs_sb_make_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		  <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">,</span>
		  <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="o">*</span><span class="n">iops</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ffs_file_perms</span> <span class="o">*</span><span class="n">perms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">current_time</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span>	 <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span>    <span class="o">=</span> <span class="n">perms</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span>     <span class="o">=</span> <span class="n">perms</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span>     <span class="o">=</span> <span class="n">perms</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span>   <span class="o">=</span> <span class="n">current_time</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span>   <span class="o">=</span> <span class="n">current_time</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span>   <span class="o">=</span> <span class="n">current_time</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fops</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="n">fops</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iops</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span>  <span class="o">=</span> <span class="n">iops</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create &quot;regular&quot; file */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ffs_sb_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">dentry_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span>	<span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc_name</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ffs_sb_make_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">file_perms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry_p</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dentry_p</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Super block */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">ffs_sb_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">statfs</span> <span class="o">=</span>	<span class="n">simple_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">drop_inode</span> <span class="o">=</span>	<span class="n">generic_delete_inode</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ffs_sb_fill_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_file_perms</span> <span class="n">perms</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">root_mode</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* set by ffs_fs_mount(), read by ffs_sb_fill() */</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
		<span class="cm">/* set by ffs_sb_fill(), read by ffs_fs_mount */</span>
		<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs_data</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_sb_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_sb_fill_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_data</span>	<span class="o">*</span><span class="n">ffs</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Initialise data */</span>
	<span class="n">ffs</span> <span class="o">=</span> <span class="n">ffs_data_new</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ffs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">sb</span>              <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">dev_name</span>        <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">file_perms</span>      <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">private_data</span>    <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* used by the caller of this function */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">ffs_data</span>       <span class="o">=</span> <span class="n">ffs</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span>        <span class="o">=</span> <span class="n">ffs</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span>      <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span>          <span class="o">=</span> <span class="n">FUNCTIONFS_MAGIC</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">ffs_sb_operations</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Root inode */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">root_mode</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">ffs_sb_make_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">simple_dir_operations</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">simple_dir_inode_operations</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>

	<span class="cm">/* EP0 file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ffs_sb_create_file</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ep0&quot;</span><span class="p">,</span> <span class="n">ffs</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">ffs_ep0_operations</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">Enomem:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_fs_parse_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_sb_fill_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span> <span class="o">||</span> <span class="o">!*</span><span class="n">opts</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="o">*</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">comma</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>

		<span class="cm">/* Option limit */</span>
		<span class="n">comma</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">comma</span><span class="p">)</span>
			<span class="o">*</span><span class="n">comma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Value limit */</span>
		<span class="n">eq</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">eq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;&#39;=&#39; missing in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">eq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Parse value */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">eq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">end</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">end</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: invalid value: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">eq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Interpret option */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">eq</span> <span class="o">-</span> <span class="n">opts</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">5</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="s">&quot;rmode&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">root_mode</span>  <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mo">0555</span><span class="p">)</span> <span class="o">|</span> <span class="n">S_IFDIR</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="s">&quot;fmode&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mo">0666</span><span class="p">)</span> <span class="o">|</span> <span class="n">S_IFREG</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="s">&quot;mode&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">root_mode</span>  <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mo">0555</span><span class="p">)</span> <span class="o">|</span> <span class="n">S_IFDIR</span><span class="p">;</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mo">0666</span><span class="p">)</span> <span class="o">|</span> <span class="n">S_IFREG</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="s">&quot;uid&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="s">&quot;gid&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">perms</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
<span class="nl">invalid:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: invalid option</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Next iteration */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comma</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">opts</span> <span class="o">=</span> <span class="n">comma</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* &quot;mount -t functionfs dev_name /dev/function&quot; ends up here */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">ffs_fs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
	      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_sb_fill_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">perms</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0600</span><span class="p">,</span>
			<span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">root_mode</span> <span class="o">=</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="mo">0500</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ffs_dev</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_fs_parse_opts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">ffs_dev</span> <span class="o">=</span> <span class="n">functionfs_acquire_dev_callback</span><span class="p">(</span><span class="n">dev_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ffs_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ffs_dev</span><span class="p">;</span>

	<span class="n">data</span><span class="p">.</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">dev_name</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ffs_dev</span><span class="p">;</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mount_nodev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">ffs_sb_fill</span><span class="p">);</span>

	<span class="cm">/* data.ffs_data is set by ffs_sb_fill */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rv</span><span class="p">))</span>
		<span class="n">functionfs_release_dev_callback</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">ffs_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ffs_fs_kill_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">kill_litter_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">functionfs_release_dev_callback</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">);</span>
		<span class="n">ffs_data_put</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">ffs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;functionfs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>		<span class="o">=</span> <span class="n">ffs_fs_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">ffs_fs_kill_sb</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* Driver&#39;s main init/cleanup functions *************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">functionfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;file system registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed registering file system (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">functionfs_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;unloading</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs_fs_type</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* ffs_data and ffs_function construction and destruction code **************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_data_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ffs_data_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_data_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_data_opened</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_data_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s(): freeing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ffs_data_clear</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">)</span> <span class="o">||</span>
		       <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req_completion</span><span class="p">.</span><span class="n">wait</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_data_closed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FFS_CLOSING</span><span class="p">;</span>
		<span class="n">ffs_data_reset</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ffs_data_put</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="nf">ffs_data_new</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ffs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FFS_READ_DESCRIPTORS</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req_completion</span><span class="p">);</span>

	<span class="cm">/* XXX REVISIT need to update it in some places, or do we? */</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">can_stall</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ffs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_data_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">FFS_FL_CALL_CLOSED_CALLBACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">functionfs_closed_callback</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">epfiles</span><span class="p">)</span>
		<span class="n">ffs_epfiles_destroy</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">epfiles</span><span class="p">,</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_strings</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">stringtabs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_data_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">ffs_data_clear</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">epfiles</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_descs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_strings</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">stringtabs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_descs_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_fs_descs_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">fs_descs_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">hs_descs_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">strings_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">interfaces_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FFS_READ_DESCRIPTORS</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">FFS_NO_SETUP</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">functionfs_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget_strings</span> <span class="o">**</span><span class="n">lang</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_id</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FFS_ACTIVE</span>
		 <span class="o">||</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">FFS_FL_BOUND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>

	<span class="n">first_id</span> <span class="o">=</span> <span class="n">usb_string_ids_n</span><span class="p">(</span><span class="n">cdev</span><span class="p">,</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">strings_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">first_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">first_id</span><span class="p">;</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req</span> <span class="o">=</span> <span class="n">usb_ep_alloc_request</span><span class="p">(</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">ffs_ep0_complete</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">;</span>

	<span class="n">lang</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">stringtabs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lang</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">stringtabs</span><span class="p">;</span> <span class="o">*</span><span class="n">lang</span><span class="p">;</span> <span class="o">++</span><span class="n">lang</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_string</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">lang</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">strings</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">first_id</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">str</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">id</span><span class="p">,</span> <span class="o">++</span><span class="n">str</span><span class="p">)</span>
			<span class="n">str</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">cdev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">;</span>
	<span class="n">ffs_data_get</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">functionfs_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">);</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ep0req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ffs_data_put</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">FFS_FL_BOUND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_epfiles_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span><span class="p">,</span> <span class="o">*</span><span class="n">epfiles</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">;</span>
	<span class="n">epfiles</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">epfiles</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epfiles</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">epfile</span> <span class="o">=</span> <span class="n">epfiles</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">epfile</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">;</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">epfiles</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ep%u&quot;</span><span class="p">,</span>  <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ffs_sb_create_file</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">epfiles</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">epfile</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">ffs_epfile_operations</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ffs_epfiles_destroy</span><span class="p">(</span><span class="n">epfiles</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">epfiles</span> <span class="o">=</span> <span class="n">epfiles</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_epfiles_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfiles</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span> <span class="o">=</span> <span class="n">epfiles</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">count</span><span class="p">;</span> <span class="o">--</span><span class="n">count</span><span class="p">,</span> <span class="o">++</span><span class="n">epfile</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">)</span> <span class="o">||</span>
		       <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d_delete</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">epfile</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">epfiles</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">functionfs_bind_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">func</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">func</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="s">&quot;Function FS Gadget&quot;</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">strings</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">stringtabs</span><span class="p">;</span>

	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">bind</span>    <span class="o">=</span> <span class="n">ffs_func_bind</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">unbind</span>  <span class="o">=</span> <span class="n">ffs_func_unbind</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">set_alt</span> <span class="o">=</span> <span class="n">ffs_func_set_alt</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">disable</span> <span class="o">=</span> <span class="n">ffs_func_disable</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">setup</span>   <span class="o">=</span> <span class="n">ffs_func_setup</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">ffs_func_suspend</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">resume</span>  <span class="o">=</span> <span class="n">ffs_func_resume</span><span class="p">;</span>

	<span class="n">func</span><span class="o">-&gt;</span><span class="n">conf</span>   <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">cdev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">;</span>
	<span class="n">ffs_data_get</span><span class="p">(</span><span class="n">ffs</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_add_function</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">ffs_func_free</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_func_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="o">*</span><span class="n">ep</span>         <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span>            <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* cleanup after autoconfig */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span>
			<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">++</span><span class="n">ep</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ffs_data_put</span><span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * eps and interfaces_nums are allocated in the same chunk so</span>
<span class="cm">	 * only one free is required.  Descriptors are also allocated</span>
<span class="cm">	 * in the same chunk.</span>
<span class="cm">	 */</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_func_eps_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="o">*</span><span class="n">ep</span>         <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">epfiles</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span>            <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* pending requests get nuked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">))</span>
			<span class="n">usb_ep_disable</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="o">++</span><span class="n">ep</span><span class="p">;</span>
		<span class="o">++</span><span class="n">epfile</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_func_eps_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span>      <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="o">*</span><span class="n">ep</span>         <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_epfile</span> <span class="o">*</span><span class="n">epfile</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">epfiles</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span>            <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ds</span><span class="p">;</span>
		<span class="n">ds</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">descs</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">descs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">];</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">ds</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_ep_enable</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">epfile</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="n">epfile</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">=</span> <span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
			<span class="n">epfile</span><span class="o">-&gt;</span><span class="n">isoc</span> <span class="o">=</span> <span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epfile</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

		<span class="o">++</span><span class="n">ep</span><span class="p">;</span>
		<span class="o">++</span><span class="n">epfile</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Parsing and building descriptors and strings *****************************/</span>

<span class="cm">/*</span>
<span class="cm"> * This validates if data pointed by data is a valid USB descriptor as</span>
<span class="cm"> * well as record how many interfaces, endpoints and strings are</span>
<span class="cm"> * required by given configuration.  Returns address after the</span>
<span class="cm"> * descriptor or NULL if data is invalid.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">ffs_entity_type</span> <span class="p">{</span>
	<span class="n">FFS_DESCRIPTOR</span><span class="p">,</span> <span class="n">FFS_INTERFACE</span><span class="p">,</span> <span class="n">FFS_STRING</span><span class="p">,</span> <span class="n">FFS_ENDPOINT</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ffs_entity_callback</span><span class="p">)(</span><span class="k">enum</span> <span class="n">ffs_entity_type</span> <span class="n">entity</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">valuep</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">ffs_do_desc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
				    <span class="n">ffs_entity_callback</span> <span class="n">entity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">_ds</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* At least two bytes are required: length and type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;descriptor too short</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we have at least as many bytes as the descriptor takes? */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">_ds</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;descriptor longer then available data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#define __entity_check_INTERFACE(val)  1</span>
<span class="cp">#define __entity_check_STRING(val)     (val)</span>
<span class="cp">#define __entity_check_ENDPOINT(val)   ((val) &amp; USB_ENDPOINT_NUMBER_MASK)</span>
<span class="cp">#define __entity(type, val) do {					\</span>
<span class="cp">		pr_vdebug(&quot;entity &quot; #type &quot;(%02x)\n&quot;, (val));		\</span>
<span class="cp">		if (unlikely(!__entity_check_ ##type(val))) {		\</span>
<span class="cp">			pr_vdebug(&quot;invalid entity&#39;s value\n&quot;);		\</span>
<span class="cp">			return -EINVAL;					\</span>
<span class="cp">		}							\</span>
<span class="cp">		ret = entity(FFS_ ##type, &amp;val, _ds, priv);		\</span>
<span class="cp">		if (unlikely(ret &lt; 0)) {				\</span>
<span class="cp">			pr_debug(&quot;entity &quot; #type &quot;(%02x); ret = %d\n&quot;,	\</span>
<span class="cp">				 (val), ret);				\</span>
<span class="cp">			return ret;					\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>

	<span class="cm">/* Parse descriptor depending on type. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">_ds</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_DT_DEVICE</span>:
	<span class="k">case</span> <span class="n">USB_DT_CONFIG</span>:
	<span class="k">case</span> <span class="n">USB_DT_STRING</span>:
	<span class="k">case</span> <span class="n">USB_DT_DEVICE_QUALIFIER</span>:
		<span class="cm">/* function can&#39;t have any of those */</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;descriptor reserved for gadget: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">_ds</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_DT_INTERFACE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface_descriptor</span> <span class="o">*</span><span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_ds</span><span class="p">;</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;interface descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">inv_length</span><span class="p">;</span>

		<span class="n">__entity</span><span class="p">(</span><span class="n">INTERFACE</span><span class="p">,</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">bInterfaceNumber</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">iInterface</span><span class="p">)</span>
			<span class="n">__entity</span><span class="p">(</span><span class="n">STRING</span><span class="p">,</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">iInterface</span><span class="p">);</span>
	<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_DT_ENDPOINT</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_ds</span><span class="p">;</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;endpoint descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT_SIZE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">length</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT_AUDIO_SIZE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">inv_length</span><span class="p">;</span>
		<span class="n">__entity</span><span class="p">(</span><span class="n">ENDPOINT</span><span class="p">,</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">);</span>
	<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_DT_OTG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_otg_descriptor</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">inv_length</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_DT_INTERFACE_ASSOCIATION</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_interface_assoc_descriptor</span> <span class="o">*</span><span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_ds</span><span class="p">;</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;interface association descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">inv_length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">iFunction</span><span class="p">)</span>
			<span class="n">__entity</span><span class="p">(</span><span class="n">STRING</span><span class="p">,</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">iFunction</span><span class="p">);</span>
	<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_DT_OTHER_SPEED_CONFIG</span>:
	<span class="k">case</span> <span class="n">USB_DT_INTERFACE_POWER</span>:
	<span class="k">case</span> <span class="n">USB_DT_DEBUG</span>:
	<span class="k">case</span> <span class="n">USB_DT_SECURITY</span>:
	<span class="k">case</span> <span class="n">USB_DT_CS_RADIO_CONTROL</span>:
		<span class="cm">/* TODO */</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;unimplemented descriptor: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">_ds</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* We should never be here */</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;unknown descriptor: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">_ds</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">inv_length:</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;invalid length: %d (descriptor %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">_ds</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">,</span> <span class="n">_ds</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#undef __entity</span>
<span class="cp">#undef __entity_check_DESCRIPTOR</span>
<span class="cp">#undef __entity_check_INTERFACE</span>
<span class="cp">#undef __entity_check_STRING</span>
<span class="cp">#undef __entity_check_ENDPOINT</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">ffs_do_descs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">count</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
				     <span class="n">ffs_entity_callback</span> <span class="n">entity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Record &quot;descriptor&quot; entity */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">entity</span><span class="p">(</span><span class="n">FFS_DESCRIPTOR</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entity DESCRIPTOR(%02lx); ret = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">num</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">_len</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_do_desc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="o">++</span><span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ffs_data_do_entity</span><span class="p">(</span><span class="k">enum</span> <span class="n">ffs_entity_type</span> <span class="n">type</span><span class="p">,</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">valuep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FFS_DESCRIPTOR</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_INTERFACE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Interfaces are indexed from zero so if we</span>
<span class="cm">		 * encountered interface &quot;n&quot; then there are at least</span>
<span class="cm">		 * &quot;n+1&quot; interfaces.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">valuep</span> <span class="o">&gt;=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">interfaces_count</span><span class="p">)</span>
			<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">interfaces_count</span> <span class="o">=</span> <span class="o">*</span><span class="n">valuep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_STRING</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Strings are indexed from 1 (0 is magic ;) reserved</span>
<span class="cm">		 * for languages list or some such)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">valuep</span> <span class="o">&gt;</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">strings_count</span><span class="p">)</span>
			<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">strings_count</span> <span class="o">=</span> <span class="o">*</span><span class="n">valuep</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_ENDPOINT</span>:
		<span class="cm">/* Endpoints are indexed from 1 as well. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">valuep</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">)</span>
			<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">valuep</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ffs_data_got_descs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">fs_count</span><span class="p">,</span> <span class="n">hs_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_len</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FUNCTIONFS_DESCRIPTORS_MAGIC</span> <span class="o">||</span>
		     <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">fs_count</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span>  <span class="mi">8</span><span class="p">);</span>
	<span class="n">hs_count</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fs_count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hs_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">einval</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">len</span>  <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">fs_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fs_len</span> <span class="o">=</span> <span class="n">ffs_do_descs</span><span class="p">(</span><span class="n">fs_count</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				      <span class="n">__ffs_data_do_entity</span><span class="p">,</span> <span class="n">ffs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fs_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">fs_len</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">+=</span> <span class="n">fs_len</span><span class="p">;</span>
		<span class="n">len</span>  <span class="o">-=</span> <span class="n">fs_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fs_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">hs_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_do_descs</span><span class="p">(</span><span class="n">hs_count</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				   <span class="n">__ffs_data_do_entity</span><span class="p">,</span> <span class="n">ffs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">einval</span><span class="p">;</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_fs_descs_length</span> <span class="o">=</span> <span class="n">fs_len</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_descs_length</span>    <span class="o">=</span> <span class="n">fs_len</span> <span class="o">+</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_descs</span>           <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">fs_descs_count</span>      <span class="o">=</span> <span class="n">fs_count</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">hs_descs_count</span>      <span class="o">=</span> <span class="n">hs_count</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">einval:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ffs_data_got_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">str_count</span><span class="p">,</span> <span class="n">needed_count</span><span class="p">,</span> <span class="n">lang_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_strings</span> <span class="o">**</span><span class="n">stringtabs</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_string</span> <span class="o">*</span><span class="n">strings</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FUNCTIONFS_STRINGS_MAGIC</span> <span class="o">||</span>
		     <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">str_count</span>  <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">lang_count</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>

	<span class="cm">/* if one is zero the other must be zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">str_count</span> <span class="o">!=</span> <span class="o">!</span><span class="n">lang_count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Do we have at least as many strings as descriptors need? */</span>
	<span class="n">needed_count</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">strings_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">str_count</span> <span class="o">&lt;</span> <span class="n">needed_count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t need any strings just return and free all</span>
<span class="cm">	 * memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">needed_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">_data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate everything in one chunk so there&#39;s less maintenance. */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_gadget_strings</span> <span class="o">*</span><span class="n">stringtabs</span><span class="p">[</span><span class="n">lang_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">usb_gadget_strings</span> <span class="n">stringtab</span><span class="p">[</span><span class="n">lang_count</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">usb_string</span> <span class="n">strings</span><span class="p">[</span><span class="n">lang_count</span><span class="o">*</span><span class="p">(</span><span class="n">needed_count</span><span class="o">+</span><span class="mi">1</span><span class="p">)];</span>
		<span class="p">}</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">d</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">_data</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">stringtabs</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">stringtabs</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">stringtab</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">lang_count</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">stringtabs</span><span class="o">++</span> <span class="o">=</span> <span class="n">t</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">);</span>
		<span class="o">*</span><span class="n">stringtabs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">stringtabs</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">stringtabs</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">stringtab</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">strings</span><span class="p">;</span>
		<span class="n">strings</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For each language */</span>
	<span class="n">data</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span> <span class="cm">/* lang_count &gt; 0 so we can use do-while */</span>
		<span class="kt">unsigned</span> <span class="n">needed</span> <span class="o">=</span> <span class="n">needed_count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error_free</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">language</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">strings</span>  <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="o">++</span><span class="n">t</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* For each string */</span>
		<span class="k">do</span> <span class="p">{</span> <span class="cm">/* str_count &gt; 0 so we can use do-while */</span>
			<span class="kt">size_t</span> <span class="n">length</span> <span class="o">=</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="n">len</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">error_free</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * User may provide more strings then we need,</span>
<span class="cm">			 * if that&#39;s the case we simply ignore the</span>
<span class="cm">			 * rest</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">needed</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * s-&gt;id will be set while adding</span>
<span class="cm">				 * function to configuration so for</span>
<span class="cm">				 * now just leave garbage here.</span>
<span class="cm">				 */</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
				<span class="o">--</span><span class="n">needed</span><span class="p">;</span>
				<span class="o">++</span><span class="n">s</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">data</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">str_count</span><span class="p">);</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* terminator */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">++</span><span class="n">s</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">lang_count</span><span class="p">);</span>

	<span class="cm">/* Some garbage left? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_free</span><span class="p">;</span>

	<span class="cm">/* Done! */</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">stringtabs</span> <span class="o">=</span> <span class="n">stringtabs</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_strings</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">stringtabs</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Events handling and management *******************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__ffs_event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">usb_functionfs_event_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">usb_functionfs_event_type</span> <span class="n">rem_type1</span><span class="p">,</span> <span class="n">rem_type2</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">neg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Abort any unhandled setup</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do not need to worry about some cmpxchg() changing value</span>
<span class="cm">	 * of ffs-&gt;setup_state without holding the lock because when</span>
<span class="cm">	 * state is FFS_SETUP_PENDING cmpxchg() in several places in</span>
<span class="cm">	 * the source does nothing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">==</span> <span class="n">FFS_SETUP_PENDING</span><span class="p">)</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">setup_state</span> <span class="o">=</span> <span class="n">FFS_SETUP_CANCELED</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FUNCTIONFS_RESUME</span>:
		<span class="n">rem_type2</span> <span class="o">=</span> <span class="n">FUNCTIONFS_SUSPEND</span><span class="p">;</span>
		<span class="cm">/* FALL THROUGH */</span>
	<span class="k">case</span> <span class="n">FUNCTIONFS_SUSPEND</span>:
	<span class="k">case</span> <span class="n">FUNCTIONFS_SETUP</span>:
		<span class="n">rem_type1</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="cm">/* Discard all similar events */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FUNCTIONFS_BIND</span>:
	<span class="k">case</span> <span class="n">FUNCTIONFS_UNBIND</span>:
	<span class="k">case</span> <span class="n">FUNCTIONFS_DISABLE</span>:
	<span class="k">case</span> <span class="n">FUNCTIONFS_ENABLE</span>:
		<span class="cm">/* Discard everything other then power management. */</span>
		<span class="n">rem_type1</span> <span class="o">=</span> <span class="n">FUNCTIONFS_SUSPEND</span><span class="p">;</span>
		<span class="n">rem_type2</span> <span class="o">=</span> <span class="n">FUNCTIONFS_RESUME</span><span class="p">;</span>
		<span class="n">neg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">ev</span>  <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">types</span><span class="p">,</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span><span class="p">;</span> <span class="o">--</span><span class="n">n</span><span class="p">,</span> <span class="o">++</span><span class="n">ev</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ev</span> <span class="o">==</span> <span class="n">rem_type1</span> <span class="o">||</span> <span class="o">*</span><span class="n">ev</span> <span class="o">==</span> <span class="n">rem_type2</span><span class="p">)</span> <span class="o">==</span> <span class="n">neg</span><span class="p">)</span>
				<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;purging event %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">ev</span><span class="p">);</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">out</span> <span class="o">-</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">types</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;adding event %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">usb_functionfs_event_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__ffs_event_add</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Bind/unbind USB function hooks *******************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ffs_func_bind_do_descs</span><span class="p">(</span><span class="k">enum</span> <span class="n">ffs_entity_type</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">valuep</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="o">*</span><span class="n">ffs_ep</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If hs_descriptors is not NULL then we are reading hs</span>
<span class="cm">	 * descriptors now</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">isHS</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">hs_descriptors</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">FFS_DESCRIPTOR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isHS</span><span class="p">)</span>
		<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">hs_descriptors</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">valuep</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">descriptors</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">valuep</span><span class="p">]</span>    <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ffs_ep</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ffs_ep</span><span class="o">-&gt;</span><span class="n">descs</span><span class="p">[</span><span class="n">isHS</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;two %sspeed descriptors for EP %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">isHS</span> <span class="o">?</span> <span class="s">&quot;high&quot;</span> <span class="o">:</span> <span class="s">&quot;full&quot;</span><span class="p">,</span>
			  <span class="n">ds</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ffs_ep</span><span class="o">-&gt;</span><span class="n">descs</span><span class="p">[</span><span class="n">isHS</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="p">;</span>

	<span class="n">ffs_dump_mem</span><span class="p">(</span><span class="s">&quot;: Original  ep desc&quot;</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ffs_ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ds</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">=</span> <span class="n">ffs_ep</span><span class="o">-&gt;</span><span class="n">descs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">)</span>
			<span class="n">ds</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">ffs_ep</span><span class="o">-&gt;</span><span class="n">descs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

		<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;autoconfig</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_ep_autoconfig</span><span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="n">ds</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">req</span> <span class="o">=</span> <span class="n">usb_ep_alloc_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">ffs_ep</span><span class="o">-&gt;</span><span class="n">ep</span>  <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
		<span class="n">ffs_ep</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
		<span class="n">func</span><span class="o">-&gt;</span><span class="n">eps_revmap</span><span class="p">[</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span>
				 <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ffs_dump_mem</span><span class="p">(</span><span class="s">&quot;: Rewritten ep desc&quot;</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ffs_func_bind_do_nums</span><span class="p">(</span><span class="k">enum</span> <span class="n">ffs_entity_type</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">valuep</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">newValue</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">FFS_DESCRIPTOR</span>:
		<span class="cm">/* Handled in previous pass by __ffs_func_bind_do_descs() */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_INTERFACE</span>:
		<span class="n">idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">valuep</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">interfaces_nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">usb_interface_id</span><span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
			<span class="n">func</span><span class="o">-&gt;</span><span class="n">interfaces_nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">newValue</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">interfaces_nums</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_STRING</span>:
		<span class="cm">/* String&#39; IDs are allocated when fsf_data is bound to cdev */</span>
		<span class="n">newValue</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">stringtabs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">strings</span><span class="p">[</span><span class="o">*</span><span class="n">valuep</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FFS_ENDPOINT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * USB_DT_ENDPOINT are handled in</span>
<span class="cm">		 * __ffs_func_bind_do_descs().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">==</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">valuep</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">ep</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">**</span><span class="n">descs</span><span class="p">;</span>
			<span class="n">descs</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">descs</span><span class="p">;</span>
			<span class="n">newValue</span> <span class="o">=</span> <span class="n">descs</span><span class="p">[</span><span class="n">descs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;%02x -&gt; %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">valuep</span><span class="p">,</span> <span class="n">newValue</span><span class="p">);</span>
	<span class="o">*</span><span class="n">valuep</span> <span class="o">=</span> <span class="n">newValue</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_func_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">ffs_func_from_usb</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">int</span> <span class="n">full</span> <span class="o">=</span> <span class="o">!!</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">fs_descs_count</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">gadget_is_dualspeed</span><span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">hs_descs_count</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Make it a single chunk, less management later on */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ffs_ep</span> <span class="n">eps</span><span class="p">[</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">usb_descriptor_header</span>
			<span class="o">*</span><span class="n">fs_descs</span><span class="p">[</span><span class="n">full</span> <span class="o">?</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">fs_descs_count</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">usb_descriptor_header</span>
			<span class="o">*</span><span class="n">hs_descs</span><span class="p">[</span><span class="n">high</span> <span class="o">?</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">hs_descs_count</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
		<span class="kt">short</span> <span class="n">inums</span><span class="p">[</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">interfaces_count</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">raw_descs</span><span class="p">[</span><span class="n">high</span> <span class="o">?</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_descs_length</span>
				    <span class="o">:</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_fs_descs_length</span><span class="p">];</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Only high speed but not supported by gadget? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">full</span> <span class="o">|</span> <span class="n">high</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="cm">/* Allocate */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Zero */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">,</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">raw_descs</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">inums</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">inums</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">eps_count</span><span class="p">;</span> <span class="n">ret</span><span class="p">;</span> <span class="o">--</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Save pointers */</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">eps</span>             <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">;</span>
	<span class="n">func</span><span class="o">-&gt;</span><span class="n">interfaces_nums</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">inums</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Go through all the endpoint descriptors and allocate</span>
<span class="cm">	 * endpoints first, so that later we can rewrite the endpoint</span>
<span class="cm">	 * numbers without worrying that it may be described later on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">full</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">descriptors</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">fs_descs</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_do_descs</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">fs_descs_count</span><span class="p">,</span>
				   <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">,</span>
				   <span class="k">sizeof</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">,</span>
				   <span class="n">__ffs_func_bind_do_descs</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">high</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">func</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">hs_descriptors</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">hs_descs</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_do_descs</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">hs_descs_count</span><span class="p">,</span>
				   <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span> <span class="o">+</span> <span class="n">ret</span><span class="p">,</span>
				   <span class="p">(</span><span class="k">sizeof</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">)</span> <span class="o">-</span> <span class="n">ret</span><span class="p">,</span>
				   <span class="n">__ffs_func_bind_do_descs</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now handle interface numbers allocation and interface and</span>
<span class="cm">	 * endpoint numbers rewriting.  We can do that in one go</span>
<span class="cm">	 * now.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_do_descs</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">fs_descs_count</span> <span class="o">+</span>
			   <span class="p">(</span><span class="n">high</span> <span class="o">?</span> <span class="n">ffs</span><span class="o">-&gt;</span><span class="n">hs_descs_count</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
			   <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw_descs</span><span class="p">,</span>
			   <span class="n">__ffs_func_bind_do_nums</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* And we&#39;re done */</span>
	<span class="n">ffs_event_add</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">FUNCTIONFS_BIND</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="cm">/* XXX Do we need to release all claimed endpoints here? */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Other USB function hooks *************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_func_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">ffs_func_from_usb</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">==</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ffs_func_eps_disable</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ffs_event_add</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">FUNCTIONFS_UNBIND</span><span class="p">);</span>

	<span class="n">ffs_func_free</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_func_set_alt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="n">interface</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">ffs_func_from_usb</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">intf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alt</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intf</span> <span class="o">=</span> <span class="n">ffs_func_revmap_intf</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">interface</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">intf</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">intf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">)</span>
		<span class="n">ffs_func_eps_disable</span><span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FFS_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alt</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ffs_event_add</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">FUNCTIONFS_DISABLE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_func_eps_enable</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">ffs_event_add</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">FUNCTIONFS_ENABLE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_func_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ffs_func_set_alt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_func_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">creq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">ffs_func_from_usb</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ffs_data</span> <span class="o">*</span><span class="n">ffs</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;creq-&gt;bRequestType = %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creq</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">);</span>
	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;creq-&gt;bRequest     = %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creq</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">);</span>
	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;creq-&gt;wValue       = %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">creq</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">));</span>
	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;creq-&gt;wIndex       = %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">creq</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">));</span>
	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;creq-&gt;wLength      = %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">creq</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Most requests directed to interface go through here</span>
<span class="cm">	 * (notable exceptions are set/get interface) so we need to</span>
<span class="cm">	 * handle them.  All other either handled by composite or</span>
<span class="cm">	 * passed to usb_configuration-&gt;setup() (if one is set).  No</span>
<span class="cm">	 * matter, we will handle requests directed to endpoint here</span>
<span class="cm">	 * as well (as it&#39;s straightforward) but what to do with any</span>
<span class="cm">	 * other request?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FFS_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">creq</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_RECIP_INTERFACE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_func_revmap_intf</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">creq</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_RECIP_ENDPOINT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ffs_func_revmap_ep</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">creq</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span> <span class="o">=</span> <span class="o">*</span><span class="n">creq</span><span class="p">;</span>
	<span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">setup</span><span class="p">.</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="n">__ffs_event_add</span><span class="p">(</span><span class="n">ffs</span><span class="p">,</span> <span class="n">FUNCTIONFS_SETUP</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">.</span><span class="n">waitq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_func_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>
	<span class="n">ffs_event_add</span><span class="p">(</span><span class="n">ffs_func_from_usb</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">,</span> <span class="n">FUNCTIONFS_SUSPEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ffs_func_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ENTER</span><span class="p">();</span>
	<span class="n">ffs_event_add</span><span class="p">(</span><span class="n">ffs_func_from_usb</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="p">,</span> <span class="n">FUNCTIONFS_RESUME</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Endpoint and interface numbers reverse mapping ***************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_func_revmap_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">u8</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">num</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">eps_revmap</span><span class="p">[</span><span class="n">num</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">num</span> <span class="o">?</span> <span class="n">num</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_func_revmap_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ffs_function</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">u8</span> <span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="o">*</span><span class="n">nums</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">interfaces_nums</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">ffs</span><span class="o">-&gt;</span><span class="n">interfaces_count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">count</span><span class="p">;</span> <span class="o">--</span><span class="n">count</span><span class="p">,</span> <span class="o">++</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nums</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">nums</span> <span class="o">==</span> <span class="n">intf</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">nums</span> <span class="o">-</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">interfaces_nums</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Misc helper functions ****************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ffs_mutex_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nonblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nonblock</span>
		<span class="o">?</span> <span class="n">likely</span><span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="n">mutex</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EAGAIN</span>
		<span class="o">:</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ffs_prepare_buffer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">__user</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_vdebug</span><span class="p">(</span><span class="s">&quot;Buffer from user space:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ffs_dump_mem</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
