<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › mv_udc_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mv_udc_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2011 Marvell International Ltd. All rights reserved.</span>
<span class="cm"> * Author: Chao Xie &lt;chao.xie@marvell.com&gt;</span>
<span class="cm"> *	   Neil Zhang &lt;zhangwm@marvell.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &lt;linux/usb/otg.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/platform_data/mv_usb.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &quot;mv_udc.h&quot;</span>

<span class="cp">#define DRIVER_DESC		&quot;Marvell PXA USB Device Controller driver&quot;</span>
<span class="cp">#define DRIVER_VERSION		&quot;8 Nov 2010&quot;</span>

<span class="cp">#define ep_dir(ep)	(((ep)-&gt;ep_num == 0) ? \</span>
<span class="cp">				((ep)-&gt;udc-&gt;ep0_dir) : ((ep)-&gt;direction))</span>

<span class="cm">/* timeout value -- usec */</span>
<span class="cp">#define RESET_TIMEOUT		10000</span>
<span class="cp">#define FLUSH_TIMEOUT		10000</span>
<span class="cp">#define EPSTATUS_TIMEOUT	10000</span>
<span class="cp">#define PRIME_TIMEOUT		10000</span>
<span class="cp">#define READSAFE_TIMEOUT	1000</span>
<span class="cp">#define DTD_TIMEOUT		1000</span>

<span class="cp">#define LOOPS_USEC_SHIFT	4</span>
<span class="cp">#define LOOPS_USEC		(1 &lt;&lt; LOOPS_USEC_SHIFT)</span>
<span class="cp">#define LOOPS(timeout)		((timeout) &gt;&gt; LOOPS_USEC_SHIFT)</span>

<span class="k">static</span> <span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">release_done</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;mv_udc&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_desc</span><span class="p">[]</span> <span class="o">=</span> <span class="n">DRIVER_DESC</span><span class="p">;</span>

<span class="cm">/* controller device global variable */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mv_udc</span>	<span class="o">*</span><span class="n">the_controller</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mv_usb_otgsc</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">nuke</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">stop_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>

<span class="cm">/* for endpoint 0 operations */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="n">mv_ep0_desc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bLength</span> <span class="o">=</span>		<span class="n">USB_DT_ENDPOINT_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span>	<span class="n">USB_DT_ENDPOINT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>	<span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmAttributes</span> <span class="o">=</span>		<span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span>	<span class="n">EP0_MAX_PKT_SIZE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">epctrlx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ep0 in and out */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span> <span class="o">=</span> <span class="n">udc</span><span class="p">;</span>

		<span class="cm">/* ep0 dQH */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* configure ep0 endpoint capabilities in dQH */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span><span class="o">-&gt;</span><span class="n">max_packet_length</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">EP0_MAX_PKT_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">EP_QUEUE_HEAD_MAX_PKT_LEN_POS</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EP_QUEUE_HEAD_IOS</span><span class="p">;</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span><span class="o">-&gt;</span><span class="n">next_dtd_ptr</span> <span class="o">=</span> <span class="n">EP_QUEUE_HEAD_NEXT_TERMINATE</span><span class="p">;</span>

		<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* TX */</span>
			<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_ENABLE</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">USB_ENDPOINT_XFER_CONTROL</span>
					<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_TX_EP_TYPE_SHIFT</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* RX */</span>
			<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_ENABLE</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">USB_ENDPOINT_XFER_CONTROL</span>
					<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_RX_EP_TYPE_SHIFT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* protocol ep0 stall, will automatically be cleared on new transaction */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">epctrlx</span><span class="p">;</span>

	<span class="cm">/* set TX and RX to stall */</span>
	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_EP_STALL</span> <span class="o">|</span> <span class="n">EPCTRL_TX_EP_STALL</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* update ep0 state */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_ep_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">curr_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_dtd</span>	<span class="o">*</span><span class="n">curr_dtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dqh</span>	<span class="o">*</span><span class="n">curr_dqh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">td_complete</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">remaining_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">errors</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit_pos</span><span class="p">;</span>

	<span class="n">curr_dqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">direction</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">curr_dtd</span> <span class="o">=</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">td_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">actual</span> <span class="o">=</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">dtd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_dtd</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span> <span class="o">&amp;</span> <span class="n">DTD_STATUS_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, dTD not completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">errors</span> <span class="o">=</span> <span class="n">curr_dtd</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span> <span class="o">&amp;</span> <span class="n">DTD_ERROR_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">errors</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">remaining_length</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">curr_dtd</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span>	<span class="o">&amp;</span> <span class="n">DTD_PACKET_SIZE</span><span class="p">)</span>
					<span class="o">&gt;&gt;</span> <span class="n">DTD_LENGTH_BIT_POS</span><span class="p">;</span>
			<span class="n">actual</span> <span class="o">-=</span> <span class="n">remaining_length</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">remaining_length</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;TX dTD remains data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;complete_tr error: ep=%d %s: error = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">direction</span> <span class="o">?</span> <span class="s">&quot;SEND&quot;</span> <span class="o">:</span> <span class="s">&quot;RECV&quot;</span><span class="p">,</span>
				<span class="n">errors</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">DTD_STATUS_HALTED</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Clear the errors and Halt condition */</span>
				<span class="n">curr_dqh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">errors</span><span class="p">;</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">DTD_STATUS_DATA_BUFF_ERR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">DTD_STATUS_TRANSACTION_ERR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">curr_dtd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mv_dtd</span> <span class="o">*</span><span class="p">)</span><span class="n">curr_dtd</span><span class="o">-&gt;</span><span class="n">next_dtd_virt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_OUT</span><span class="p">)</span>
		<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">curr_dqh</span><span class="o">-&gt;</span><span class="n">curr_dtd_ptr</span> <span class="o">==</span> <span class="n">curr_dtd</span><span class="o">-&gt;</span><span class="n">td_dma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_dtd</span><span class="o">-&gt;</span><span class="n">dtd_next</span> <span class="o">==</span> <span class="n">EP_QUEUE_HEAD_NEXT_TERMINATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bit_pos</span><span class="p">)</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="n">actual</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * done() - retire a request; caller blocked irqs</span>
<span class="cm"> * @status : request status to be set, only works when</span>
<span class="cm"> * request is still in progress.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">stopped</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dtd</span> <span class="o">*</span><span class="n">curr_td</span><span class="p">,</span> <span class="o">*</span><span class="n">next_td</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="cm">/* Removed the req from fsl_ep-&gt;queue */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* req.status should be set as -EINPROGRESS in ep_queue() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Free dtd for the request */</span>
	<span class="n">next_td</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_td</span> <span class="o">=</span> <span class="n">next_td</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">next_td</span> <span class="o">=</span> <span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">next_dtd_virt</span><span class="p">;</span>
		<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dtd_pool</span><span class="p">,</span> <span class="n">curr_td</span><span class="p">,</span> <span class="n">curr_td</span><span class="o">-&gt;</span><span class="n">td_dma</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
			<span class="p">((</span><span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">DMA_TO_DEVICE</span> <span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">));</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
			<span class="p">((</span><span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">DMA_TO_DEVICE</span> <span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">))</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;complete %s req %p stat %d len %u/%u&quot;</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * complete() is from gadget layer,</span>
<span class="cm">	 * eg fsg-&gt;bulk_in_complete()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="n">stopped</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_dtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dqh</span> <span class="o">*</span><span class="n">dqh</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit_pos</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">usbcmd</span><span class="p">,</span> <span class="n">epstatus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="n">direction</span> <span class="o">=</span> <span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">dqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">direction</span><span class="p">]);</span>
	<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(((</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_OUT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">);</span>

	<span class="cm">/* check if the pipe is empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">lastreq</span><span class="p">;</span>
		<span class="n">lastreq</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">lastreq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">dtd_next</span> <span class="o">=</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">td_dma</span> <span class="o">&amp;</span> <span class="n">EP_QUEUE_HEAD_NEXT_POINTER_MASK</span><span class="p">;</span>

		<span class="n">wmb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epprime</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bit_pos</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="n">loops</span> <span class="o">=</span> <span class="n">LOOPS</span><span class="p">(</span><span class="n">READSAFE_TIMEOUT</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* start with setting the semaphores */</span>
			<span class="n">usbcmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
			<span class="n">usbcmd</span> <span class="o">|=</span> <span class="n">USBCMD_ATDTW_TRIPWIRE_SET</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">usbcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

			<span class="cm">/* read the endpoint status */</span>
			<span class="n">epstatus</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bit_pos</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Reread the ATDTW semaphore bit to check if it is</span>
<span class="cm">			 * cleared. When hardware see a hazard, it will clear</span>
<span class="cm">			 * the bit or else we remain set to 1 and we can</span>
<span class="cm">			 * proceed with priming of endpoint if not already</span>
<span class="cm">			 * primed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">USBCMD_ATDTW_TRIPWIRE_SET</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">loops</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Timeout for ATDTW_TRIPWIRE...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">LOOPS_USEC</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Clear the semaphore */</span>
		<span class="n">usbcmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
		<span class="n">usbcmd</span> <span class="o">&amp;=</span> <span class="n">USBCMD_ATDTW_TRIPWIRE_CLEAR</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">usbcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">epstatus</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write dQH next pointer and terminate bit to 0 */</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">next_dtd_ptr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">td_dma</span>
				<span class="o">&amp;</span> <span class="n">EP_QUEUE_HEAD_NEXT_POINTER_MASK</span><span class="p">;</span>

	<span class="cm">/* clear active and halt bit, in case set from a previous error */</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DTD_STATUS_ACTIVE</span> <span class="o">|</span> <span class="n">DTD_STATUS_HALTED</span><span class="p">);</span>

	<span class="cm">/* Ensure that updates to the QH will occure before priming. */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* Prime the Endpoint */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">bit_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epprime</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">mv_dtd</span> <span class="o">*</span><span class="nf">build_dtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">is_last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dtd</span> <span class="o">*</span><span class="n">dtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>

	<span class="cm">/* how big will this transfer be? */</span>
	<span class="o">*</span><span class="n">length</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">EP_MAX_LENGTH_TRANSFER</span><span class="p">);</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Be careful that no _GFP_HIGHMEM is set,</span>
<span class="cm">	 * or we can not use dma_to_virt</span>
<span class="cm">	 */</span>
	<span class="n">dtd</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dtd_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dtd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dtd</span><span class="p">;</span>

	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">td_dma</span> <span class="o">=</span> <span class="o">*</span><span class="n">dma</span><span class="p">;</span>
	<span class="cm">/* initialize buffer page pointers */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xFFF</span><span class="p">;</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr1</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mh">0x2000</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr3</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mh">0x3000</span><span class="p">);</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">buff_ptr4</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mh">0x4000</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">+=</span> <span class="o">*</span><span class="n">length</span><span class="p">;</span>

	<span class="cm">/* zlp is needed if req-&gt;req.zero is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">length</span> <span class="o">%</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">)</span>
		<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">is_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fill in the transfer size; set active bit */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="n">DTD_LENGTH_BIT_POS</span><span class="p">)</span> <span class="o">|</span> <span class="n">DTD_STATUS_ACTIVE</span><span class="p">);</span>

	<span class="cm">/* Enable interrupt for the last dtd of a request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">is_last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">no_interrupt</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">DTD_IOC</span><span class="p">;</span>

	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">size_ioc_sts</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">dtd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* generate dTD linked list for a request */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">req_to_dtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_last</span><span class="p">,</span> <span class="n">is_first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dtd</span> <span class="o">*</span><span class="n">dtd</span><span class="p">,</span> <span class="o">*</span><span class="n">last_dtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">dtd</span> <span class="o">=</span> <span class="n">build_dtd</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is_last</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_first</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">is_first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">last_dtd</span><span class="o">-&gt;</span><span class="n">dtd_next</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
			<span class="n">last_dtd</span><span class="o">-&gt;</span><span class="n">next_dtd_virt</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_dtd</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_last</span><span class="p">);</span>

	<span class="cm">/* set terminate bit to 1 for the last dTD */</span>
	<span class="n">dtd</span><span class="o">-&gt;</span><span class="n">dtd_next</span> <span class="o">=</span> <span class="n">DTD_NEXT_TERMINATE</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">dtd</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dqh</span> <span class="o">*</span><span class="n">dqh</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit_pos</span><span class="p">,</span> <span class="n">epctrlx</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">zlt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ios</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span>
			<span class="o">||</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">direction</span> <span class="o">=</span> <span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable HW zero length termination select</span>
<span class="cm">	 * driver handles zero length packet through req-&gt;req.zero</span>
<span class="cm">	 */</span>
	<span class="n">zlt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_OUT</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">);</span>

	<span class="cm">/* Check if the Endpoint is Primed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epprime</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bit_pos</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bit_pos</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;ep=%d %s: Init ERROR: ENDPTPRIME=0x%x,&quot;</span>
			<span class="s">&quot; ENDPTSTATUS=0x%x, bit_pos=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">,</span> <span class="n">direction</span> <span class="o">?</span> <span class="s">&quot;SEND&quot;</span> <span class="o">:</span> <span class="s">&quot;RECV&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epprime</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epstatus</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">bit_pos</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">en_done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set the max packet length, interrupt on Setup and Mult fields */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
		<span class="n">zlt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
		<span class="n">ios</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="cm">/* Calculate transactions needed for high bandwidth iso */</span>
		<span class="n">mult</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">max</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">));</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">max</span> <span class="o">&amp;</span> <span class="mh">0x7ff</span><span class="p">;</span>	<span class="cm">/* bit 0~10 */</span>
		<span class="cm">/* 3 transactions at most */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mult</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">en_done</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">en_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Get the endpoint queue head address */</span>
	<span class="n">dqh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span><span class="p">;</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">max_packet_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;&lt;</span> <span class="n">EP_QUEUE_HEAD_MAX_PKT_LEN_POS</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">mult</span> <span class="o">&lt;&lt;</span> <span class="n">EP_QUEUE_HEAD_MULT_POS</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">zlt</span> <span class="o">?</span> <span class="n">EP_QUEUE_HEAD_ZLT_SEL</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">ios</span> <span class="o">?</span> <span class="n">EP_QUEUE_HEAD_IOS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">next_dtd_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable the endpoint for Rx or Tx and set the endpoint type */</span>
	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epctrlx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_TX_ALL_MASK</span><span class="p">;</span>
		<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_ENABLE</span> <span class="o">|</span> <span class="n">EPCTRL_TX_DATA_TOGGLE_RST</span>
			<span class="o">|</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_TX_EP_TYPE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">epctrlx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_RX_ALL_MASK</span><span class="p">;</span>
		<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_ENABLE</span> <span class="o">|</span> <span class="n">EPCTRL_RX_DATA_TOGGLE_RST</span>
			<span class="o">|</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_RX_EP_TYPE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Implement Guideline (GL# USB-7) The unused endpoint type must</span>
<span class="cm">	 * be programmed to bulk.</span>
<span class="cm">	 */</span>
	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epctrlx</span> <span class="o">&amp;</span> <span class="n">EPCTRL_RX_ENABLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epctrlx</span> <span class="o">|=</span> <span class="p">(</span><span class="n">USB_ENDPOINT_XFER_BULK</span>
				<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_RX_EP_TYPE_SHIFT</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epctrlx</span> <span class="o">&amp;</span> <span class="n">EPCTRL_TX_ENABLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epctrlx</span> <span class="o">|=</span> <span class="p">(</span><span class="n">USB_ENDPOINT_XFER_BULK</span>
				<span class="o">&lt;&lt;</span> <span class="n">EPCTRL_TX_EP_TYPE_SHIFT</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">en_done:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>  <span class="nf">mv_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dqh</span> <span class="o">*</span><span class="n">dqh</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit_pos</span><span class="p">,</span> <span class="n">epctrlx</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">_ep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="cm">/* Get the endpoint queue head address */</span>
	<span class="n">dqh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">direction</span> <span class="o">=</span> <span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_OUT</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">);</span>

	<span class="cm">/* Reset the max packet length and the interrupt on Setup */</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">max_packet_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable the endpoint for Rx or Tx and reset the endpoint type */</span>
	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="n">epctrlx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span>
			<span class="o">?</span> <span class="p">(</span><span class="n">EPCTRL_TX_ENABLE</span> <span class="o">|</span> <span class="n">EPCTRL_TX_TYPE</span><span class="p">)</span>
			<span class="o">:</span> <span class="p">(</span><span class="n">EPCTRL_RX_ENABLE</span> <span class="o">|</span> <span class="n">EPCTRL_RX_TYPE</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="cm">/* nuke all pending requests (does flush) */</span>
	<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span>
<span class="nf">mv_alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_req</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_ep_fifo_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit_pos</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="n">direction</span> <span class="o">=</span> <span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bit_pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_OUT</span><span class="p">)</span>
		<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">);</span>

	<span class="n">loops</span> <span class="o">=</span> <span class="n">LOOPS</span><span class="p">(</span><span class="n">EPSTATUS_TIMEOUT</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inter_loops</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">loops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;TIMEOUT for ENDPTSTATUS=0x%x, bit_pos=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epstatus</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">bit_pos</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Write 1 to the Flush register */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">bit_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epflush</span><span class="p">);</span>

		<span class="cm">/* Wait until flushing completed */</span>
		<span class="n">inter_loops</span> <span class="o">=</span> <span class="n">LOOPS</span><span class="p">(</span><span class="n">FLUSH_TIMEOUT</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epflush</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * ENDPTFLUSH bit should be cleared to indicate this</span>
<span class="cm">			 * operation is complete</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inter_loops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;TIMEOUT for ENDPTFLUSH=0x%x,&quot;</span>
					<span class="s">&quot;bit_pos=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epflush</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">bit_pos</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">inter_loops</span><span class="o">--</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">LOOPS_USEC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">loops</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bit_pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* queues (submits) an I/O request to an endpoint */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mv_ep_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* catch various bogus parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_req</span> <span class="o">||</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span> <span class="o">||</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, bad params&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, bad ep&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* map virtual address to hardware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">==</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
						<span class="o">?</span> <span class="n">DMA_TO_DEVICE</span>
						<span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
					<span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
						<span class="o">?</span> <span class="n">DMA_TO_DEVICE</span>
						<span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* build dtds and push them to device queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req_to_dtd</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">queue_dtd</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update ep0 state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">DATA_STATE_XMIT</span><span class="p">;</span>

	<span class="cm">/* irq handler advances the queue */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_prime_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_dqh</span> <span class="o">*</span><span class="n">dqh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit_pos</span><span class="p">;</span>

	<span class="cm">/* Write dQH next pointer and terminate bit to 0 */</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">next_dtd_ptr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">td_dma</span>
		<span class="o">&amp;</span> <span class="n">EP_QUEUE_HEAD_NEXT_POINTER_MASK</span><span class="p">;</span>

	<span class="cm">/* clear active and halt bit, in case set from a previous error */</span>
	<span class="n">dqh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DTD_STATUS_ACTIVE</span> <span class="o">|</span> <span class="n">DTD_STATUS_HALTED</span><span class="p">);</span>

	<span class="cm">/* Ensure that updates to the QH will occure before priming. */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(((</span><span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="n">EP_DIR_OUT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">);</span>

	<span class="cm">/* Prime the Endpoint */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">bit_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epprime</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* dequeues (cancels, unlinks) an I/O request from an endpoint */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_ep_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stopped</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">epctrlx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">_req</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">stopped</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">;</span>

	<span class="cm">/* Stop the ep before we deal with the queue */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span>
		<span class="n">epctrlx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_TX_ENABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">epctrlx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_RX_ENABLE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="cm">/* make sure it&#39;s actually queued on this endpoint */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">==</span> <span class="n">_req</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">!=</span> <span class="n">_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The request is in progress, or completed but not dequeued */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
		<span class="n">mv_ep_fifo_flush</span><span class="p">(</span><span class="n">_ep</span><span class="p">);</span>	<span class="cm">/* flush current transfer */</span>

		<span class="cm">/* The request isn&#39;t the last request in this ep queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">next_req</span><span class="p">;</span>

			<span class="n">next_req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mv_req</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

			<span class="cm">/* Point the QH to the first TD of next request */</span>
			<span class="n">mv_prime_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">next_req</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">mv_dqh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>

			<span class="n">qh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">next_dtd_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">size_ioc_int_sts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The request hasn&#39;t been processed, patch up the TD chain */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">prev_req</span><span class="p">;</span>

		<span class="n">prev_req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">dtd_next</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">prev_req</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">dtd_next</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">);</span>

	<span class="cm">/* Enable EP */</span>
<span class="nl">out:</span>
	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span>
		<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_ENABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_ENABLE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">]);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="n">stopped</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_set_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">u8</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">epctrlx</span><span class="p">;</span>

	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stall</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span>
			<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_EP_STALL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_EP_STALL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epctrlx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_TX_EP_STALL</span><span class="p">;</span>
			<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_TX_DATA_TOGGLE_RST</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">epctrlx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPCTRL_RX_EP_STALL</span><span class="p">;</span>
			<span class="n">epctrlx</span> <span class="o">|=</span> <span class="n">EPCTRL_RX_DATA_TOGGLE_RST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">epctrlx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_is_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">u8</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">epctrlx</span><span class="p">;</span>

	<span class="n">epctrlx</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="n">ep_num</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">EP_DIR_OUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">epctrlx</span> <span class="o">&amp;</span> <span class="n">EPCTRL_RX_EP_STALL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">epctrlx</span> <span class="o">&amp;</span> <span class="n">EPCTRL_TX_EP_STALL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_ep_set_halt_wedge</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">halt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wedge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attempt to halt IN ep will fail if any transfer requests</span>
<span class="cm">	 * are still queue</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">halt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="n">EP_DIR_IN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ep_set_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span><span class="p">,</span> <span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span> <span class="n">halt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">halt</span> <span class="o">&amp;&amp;</span> <span class="n">wedge</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">wedge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">halt</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">wedge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_ep_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">halt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mv_ep_set_halt_wedge</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="n">halt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_ep_set_wedge</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mv_ep_set_halt_wedge</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_ep_ops</span> <span class="n">mv_ep_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">mv_ep_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">mv_ep_disable</span><span class="p">,</span>

	<span class="p">.</span><span class="n">alloc_request</span>	<span class="o">=</span> <span class="n">mv_alloc_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_request</span>	<span class="o">=</span> <span class="n">mv_free_request</span><span class="p">,</span>

	<span class="p">.</span><span class="n">queue</span>		<span class="o">=</span> <span class="n">mv_ep_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue</span>	<span class="o">=</span> <span class="n">mv_ep_dequeue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_wedge</span>	<span class="o">=</span> <span class="n">mv_ep_set_wedge</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_halt</span>	<span class="o">=</span> <span class="n">mv_ep_set_halt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_flush</span>	<span class="o">=</span> <span class="n">mv_ep_fifo_flush</span><span class="p">,</span>	<span class="cm">/* flush fifo */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_clock_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">clknum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_clock_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">clknum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Disable interrupts */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">USBINTR_INT_EN</span> <span class="o">|</span> <span class="n">USBINTR_ERR_INT_EN</span> <span class="o">|</span>
		<span class="n">USBINTR_PORT_CHANGE_DETECT_EN</span> <span class="o">|</span> <span class="n">USBINTR_RESET_EN</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Reset the Run the bit in the command register to stop VUSB */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USBCMD_RUN_STOP</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">usbintr</span><span class="p">;</span>

	<span class="n">usbintr</span> <span class="o">=</span> <span class="n">USBINTR_INT_EN</span> <span class="o">|</span> <span class="n">USBINTR_ERR_INT_EN</span>
		<span class="o">|</span> <span class="n">USBINTR_PORT_CHANGE_DETECT_EN</span>
		<span class="o">|</span> <span class="n">USBINTR_RESET_EN</span> <span class="o">|</span> <span class="n">USBINTR_DEVICE_SUSPEND</span><span class="p">;</span>
	<span class="cm">/* Enable interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">usbintr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the Run bit in the command register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">USBCMD_RUN_STOP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udc_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loops</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">portsc</span><span class="p">;</span>

	<span class="cm">/* Stop the controller */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USBCMD_RUN_STOP</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

	<span class="cm">/* Reset the controller to get default values */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">USBCMD_CTRL_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

	<span class="cm">/* wait for reset to complete */</span>
	<span class="n">loops</span> <span class="o">=</span> <span class="n">LOOPS</span><span class="p">(</span><span class="n">RESET_TIMEOUT</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USBCMD_CTRL_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Wait for RESET completed TIMEOUT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">loops</span><span class="o">--</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">LOOPS_USEC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set controller to device mode */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USBMODE_CTRL_MODE_DEVICE</span><span class="p">;</span>

	<span class="cm">/* turn setup lockout off, require setup tripwire in usbcmd */</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USBMODE_SETUP_LOCK_OFF</span> <span class="o">|</span> <span class="n">USBMODE_STREAM_DISABLE</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epsetupstat</span><span class="p">);</span>

	<span class="cm">/* Configure the Endpoint List Address */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh_dma</span> <span class="o">&amp;</span> <span class="n">USB_EP_LIST_ADDRESS_MASK</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">eplistaddr</span><span class="p">);</span>

	<span class="n">portsc</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcsparams</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HCSPARAMS_PPC</span><span class="p">)</span>
		<span class="n">portsc</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">PORTSCX_W1C_BITS</span> <span class="o">|</span> <span class="o">~</span><span class="n">PORTSCX_PORT_POWER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">force_fs</span><span class="p">)</span>
		<span class="n">portsc</span> <span class="o">|=</span> <span class="n">PORTSCX_FORCE_FULL_SPEED_CONNECT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">portsc</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">PORTSCX_FORCE_FULL_SPEED_CONNECT</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">portsc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EPCTRL_TX_EP_STALL</span> <span class="o">|</span> <span class="n">EPCTRL_RX_EP_STALL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epctrlx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_enable_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;enable udc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">udc_clock_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_init</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;init phy error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="n">udc_clock_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mv_udc_enable_internal</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_udc_disable_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;disable udc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_deinit</span><span class="p">)</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_deinit</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">);</span>
		<span class="n">udc_clock_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_udc_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span><span class="p">)</span>
		<span class="n">mv_udc_disable_internal</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">frindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USB_FRINDEX_MASKS</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Tries to wake up the host connected to this gadget */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">portsc</span><span class="p">;</span>

	<span class="cm">/* Remote wakeup feature not enabled by host */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">portsc</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">);</span>
	<span class="cm">/* not suspended? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SUSPEND</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* trigger force resume */</span>
	<span class="n">portsc</span> <span class="o">|=</span> <span class="n">PORTSCX_PORT_FORCE_RESUME</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">portsc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_vbus_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_active</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: softconnect %d, vbus_active %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">mv_udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Clock is disabled, need re-init registers */</span>
			<span class="n">udc_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">ep0_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">udc_start</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* stop all the transfer in queue*/</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
		<span class="n">udc_stop</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">mv_udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_on</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: softconnect %d, vbus_active %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">mv_udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Clock is disabled, need re-init registers */</span>
			<span class="n">udc_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">ep0_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">udc_start</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* stop all the transfer in queue*/</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
		<span class="n">udc_stop</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">mv_udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_udc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">));</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_udc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="cm">/* device controller usb_gadget_ops structure */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_gadget_ops</span> <span class="n">mv_ops</span> <span class="o">=</span> <span class="p">{</span>

	<span class="cm">/* returns the current frame number */</span>
	<span class="p">.</span><span class="n">get_frame</span>	<span class="o">=</span> <span class="n">mv_udc_get_frame</span><span class="p">,</span>

	<span class="cm">/* tries to wake up the host connected to this gadget */</span>
	<span class="p">.</span><span class="n">wakeup</span>		<span class="o">=</span> <span class="n">mv_udc_wakeup</span><span class="p">,</span>

	<span class="cm">/* notify controller that VBUS is powered or not */</span>
	<span class="p">.</span><span class="n">vbus_session</span>	<span class="o">=</span> <span class="n">mv_udc_vbus_session</span><span class="p">,</span>

	<span class="cm">/* D+ pullup, software-controlled connect/disconnect to USB host */</span>
	<span class="p">.</span><span class="n">pullup</span>		<span class="o">=</span> <span class="n">mv_udc_pullup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">mv_udc_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">mv_udc_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eps_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* initialize ep0 */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span> <span class="o">=</span> <span class="n">udc</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ep0&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_ep_ops</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">wedge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">EP0_MAX_PKT_SIZE</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_ep0_desc</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_type</span> <span class="o">=</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">;</span>

	<span class="cm">/* initialize other endpoints */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;ep%din&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">EP_DIR_IN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;ep%dout&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span> <span class="o">=</span> <span class="n">udc</span><span class="p">;</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_ep_ops</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* delete all endpoint requests, called with spinlock held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nuke</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* called with spinlock held */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* endpoint fifo flush */</span>
	<span class="n">mv_ep_fifo_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* stop all USB activities */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">nuke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* report disconnect; the driver is already quiesced */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* hook up the driver ... */</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ATTACHED</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bind to driver %s --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">otg_set_peripheral</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;unable to register peripheral to otg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* pullup is always on */</span>
	<span class="n">mv_udc_pullup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* When boot with cable attached, there will be no vbus irq occurred */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mv_udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc_stop</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="cm">/* stop all usb activities */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">mv_udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* unbind gadget driver */</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_set_ptc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">portsc</span><span class="p">;</span>

	<span class="n">portsc</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">portsc</span> <span class="o">|=</span> <span class="n">mode</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">portsc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prime_status_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;switch to test mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">test_mode</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">test_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mv_set_ptc</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">test_mode</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">test_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">udc_prime_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">direction</span><span class="p">,</span> <span class="n">u16</span> <span class="n">status</span><span class="p">,</span> <span class="n">bool</span> <span class="n">empty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_OUT_STATUS</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">;</span>

	<span class="cm">/* fill in the reqest structure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">test_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">prime_status_complete</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">test_mode</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">test_mode</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">test_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dtd_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">==</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
				<span class="n">ep_dir</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">?</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* prime the data phase */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req_to_dtd</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">queue_dtd</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">else</span><span class="p">{</span>	<span class="cm">/* no mem */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;response error on GET_STATUS request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_udc_testmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">TEST_FORCE_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">test_mode</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
			<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;This test mode(%d) is not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ch9setaddress</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">;</span>

	<span class="cm">/* update usb state */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
		<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ch9getstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ep_num</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_MASK</span><span class="p">))</span>
		<span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_SELF_POWERED</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span>
			<span class="o">==</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get interface status */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span>
			<span class="o">==</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>

		<span class="n">ep_num</span> <span class="o">=</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_DIR_MASK</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">EP_DIR_IN</span> <span class="o">:</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ep_is_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">USB_ENDPOINT_HALT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">udc_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">DATA_STATE_XMIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ch9clearfeature</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ep_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">direction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_TYPE_MASK</span> <span class="o">|</span> <span class="n">USB_RECIP_MASK</span><span class="p">))</span>
		<span class="o">==</span> <span class="p">((</span><span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span>:
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_TYPE_MASK</span> <span class="o">|</span> <span class="n">USB_RECIP_MASK</span><span class="p">))</span>
		<span class="o">==</span> <span class="p">((</span><span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_ENDPOINT_HALT</span>:
			<span class="n">ep_num</span> <span class="o">=</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
			<span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_DIR_MASK</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">EP_DIR_IN</span> <span class="o">:</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="o">||</span> <span class="n">ep_num</span> <span class="o">&gt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_num</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">direction</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wedge</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ep_set_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
		<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ch9setfeature</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ep_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">direction</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_TYPE_MASK</span> <span class="o">|</span> <span class="n">USB_RECIP_MASK</span><span class="p">))</span>
		<span class="o">==</span> <span class="p">((</span><span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span>:
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_DEVICE_TEST_MODE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
				<span class="o">||</span>  <span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
				<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">!=</span> <span class="n">USB_STATE_CONFIGURED</span>
				<span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">!=</span> <span class="n">USB_STATE_ADDRESS</span>
				<span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">!=</span> <span class="n">USB_STATE_DEFAULT</span><span class="p">)</span>
				<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

			<span class="n">mv_udc_testmode</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_TYPE_MASK</span> <span class="o">|</span> <span class="n">USB_RECIP_MASK</span><span class="p">))</span>
		<span class="o">==</span> <span class="p">((</span><span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_ENDPOINT_HALT</span>:
			<span class="n">ep_num</span> <span class="o">=</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
			<span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_DIR_MASK</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">EP_DIR_IN</span> <span class="o">:</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="o">||</span> <span class="n">ep_num</span> <span class="o">&gt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ep_set_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
		<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_setup_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ep_num</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">delegate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">nuke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_num</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">EP_DIR_OUT</span><span class="p">],</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SETUP %02x.%02x v%04x i%04x l%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">,</span>
			<span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">,</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">,</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">);</span>
	<span class="cm">/* We process some stardard setup requests here */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_TYPE_STANDARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_REQ_GET_STATUS</span>:
			<span class="n">ch9getstatus</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">setup</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_REQ_SET_ADDRESS</span>:
			<span class="n">ch9setaddress</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">setup</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_REQ_CLEAR_FEATURE</span>:
			<span class="n">ch9clearfeature</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">setup</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_REQ_SET_FEATURE</span>:
			<span class="n">ch9setfeature</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">setup</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">delegate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">delegate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* delegate USB standard requests to the gadget driver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegate</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* USB requests handled by gadget */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* DATA phase from gadget, STATUS phase from udc */</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
					<span class="o">?</span>  <span class="n">EP_DIR_IN</span> <span class="o">:</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
					<span class="o">?</span>  <span class="n">DATA_STATE_XMIT</span> <span class="o">:</span> <span class="n">DATA_STATE_RECV</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* no DATA phase, IN STATUS phase from gadget */</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">EP_DIR_IN</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_OUT_STATUS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* complete DATA or STATUS phase of ep0 prime status phase if needed */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_req_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">mv_ep</span> <span class="o">*</span><span class="n">ep0</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">new_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">==</span> <span class="n">USB_STATE_ADDRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set the new address */</span>
		<span class="n">new_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">new_addr</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_ADDRESS_BIT_SHIFT</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">deviceaddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">done</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DATA_STATE_XMIT</span>:
		<span class="cm">/* receive status phase */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_OUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
			<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DATA_STATE_RECV</span>:
		<span class="cm">/* send status phase */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc_prime_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_DIR_IN</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
			<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WAIT_FOR_OUT_STATUS</span>:
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WAIT_FOR_SETUP</span>:
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unexpect ep0 packets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ep0_stall</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_setup_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ep_num</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_dqh</span> <span class="o">*</span><span class="n">dqh</span><span class="p">;</span>

	<span class="n">dqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">[</span><span class="n">ep_num</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">EP_DIR_OUT</span><span class="p">];</span>

	<span class="cm">/* Clear bit in ENDPTSETUPSTAT */</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep_num</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epsetupstat</span><span class="p">);</span>

	<span class="cm">/* while a hazard exists when setup package arrives */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Set Setup Tripwire */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="n">USBCMD_SETUP_TRIPWIRE_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>

		<span class="cm">/* Copy the setup packet to local buffer */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">dqh</span><span class="o">-&gt;</span><span class="n">setup_buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">USBCMD_SETUP_TRIPWIRE_SET</span><span class="p">));</span>

	<span class="cm">/* Clear Setup Tripwire */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USBCMD_SETUP_TRIPWIRE_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbcmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_process_tr_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bit_pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ep_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_ep</span>	<span class="o">*</span><span class="n">curr_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_req</span> <span class="o">*</span><span class="n">curr_req</span><span class="p">,</span> <span class="o">*</span><span class="n">temp_req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use separate loops for ENDPTSETUPSTAT and ENDPTCOMPLETE</span>
<span class="cm">	 * because the setup packets are to be read ASAP</span>
<span class="cm">	 */</span>

	<span class="cm">/* Process all Setup packet received interrupts */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epsetupstat</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">get_setup_data</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">));</span>
				<span class="n">handle_setup_packet</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">local_setup_buff</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t clear the endpoint setup status register here.</span>
<span class="cm">	 * It is cleared as a setup packet is read out of the buffer</span>
<span class="cm">	 */</span>

	<span class="cm">/* Process non-setup transaction complete interrupts */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epcomplete</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epcomplete</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">bit_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_num</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">direction</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bit_pos</span> <span class="o">&amp;</span> <span class="n">tmp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">curr_ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">curr_ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* process the req queue until an uncomplete request */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">curr_req</span><span class="p">,</span> <span class="n">temp_req</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">curr_ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">process_ep_req</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">curr_req</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* write back status to req */</span>
			<span class="n">curr_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

			<span class="cm">/* ep0 request completion */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ep0_req_complete</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">curr_ep</span><span class="p">,</span> <span class="n">curr_req</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">done</span><span class="p">(</span><span class="n">curr_ep</span><span class="p">,</span> <span class="n">curr_req</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irq_process_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loops</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* default to 0 on reset */</span>

	<span class="cm">/* The address bits are past bit 25-31. Set the address */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">deviceaddr</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">USB_DEVICE_ADDRESS_MASK</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">deviceaddr</span><span class="p">);</span>

	<span class="cm">/* Clear all the setup token semaphores */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epsetupstat</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epsetupstat</span><span class="p">);</span>

	<span class="cm">/* Clear all the endpoint complete status bits */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epcomplete</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epcomplete</span><span class="p">);</span>

	<span class="cm">/* wait until all endptprime bits cleared */</span>
	<span class="n">loops</span> <span class="o">=</span> <span class="n">LOOPS</span><span class="p">(</span><span class="n">PRIME_TIMEOUT</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epprime</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Timeout for ENDPTPRIME = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epprime</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">loops</span><span class="o">--</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">LOOPS_USEC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Write 1s to the Flush register */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">epflush</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;usb bus reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_DEFAULT</span><span class="p">;</span>
		<span class="cm">/* reset all the queues, stop all USB activities */</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB reset portsc 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * re-initialize</span>
<span class="cm">		 * controller reset</span>
<span class="cm">		 */</span>
		<span class="n">udc_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="cm">/* reset all the queues, stop all USB activities */</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

		<span class="cm">/* reset ep0 dQH and endptctrl */</span>
		<span class="n">ep0_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="cm">/* enable interrupt and set controller to run state */</span>
		<span class="n">udc_start</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_ATTACHED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* report resume to the driver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_process_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_process_port_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">portsc</span><span class="p">;</span>

	<span class="n">portsc</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">portsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_RESET</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Get the speed */</span>
		<span class="n">u32</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SPEED_MASK</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PORTSCX_PORT_SPEED_HIGH</span>:
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PORTSCX_PORT_SPEED_FULL</span>:
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PORTSCX_PORT_SPEED_LOW</span>:
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_LOW</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORTSCX_PORT_SUSPEND</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">==</span> <span class="n">USB_STATE_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_bus_resume</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_process_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Increment the error count */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">errors</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">mv_udc_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">intr</span><span class="p">;</span>

	<span class="cm">/* Disable ISR when stopped bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbsts</span><span class="p">);</span>
	<span class="n">intr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbintr</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">&amp;=</span> <span class="n">intr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear all the interrupts occurred */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbsts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USBSTS_ERR</span><span class="p">)</span>
		<span class="n">irq_process_error</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USBSTS_RESET</span><span class="p">)</span>
		<span class="n">irq_process_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USBSTS_PORT_CHANGE</span><span class="p">)</span>
		<span class="n">irq_process_port_change</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USBSTS_INT</span><span class="p">)</span>
		<span class="n">irq_process_tr_complete</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USBSTS_SUSPEND</span><span class="p">)</span>
		<span class="n">irq_process_suspend</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">mv_udc_vbus_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* polling VBUS and init phy may cause too much time*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_udc_vbus_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vbus</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_udc</span><span class="p">,</span> <span class="n">vbus_work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vbus</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">();</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vbus is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vbus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vbus</span> <span class="o">==</span> <span class="n">VBUS_HIGH</span><span class="p">)</span>
		<span class="n">mv_udc_vbus_session</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vbus</span> <span class="o">==</span> <span class="n">VBUS_LOW</span><span class="p">)</span>
		<span class="n">mv_udc_vbus_session</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* release device structure */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gadget_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">mv_udc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">clk_i</span><span class="p">;</span>

	<span class="n">usb_del_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">);</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have transceiver inited,</span>
<span class="cm">	 * then vbus irq will not be requested in udc driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span>
		<span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* free memory allocated in probe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dtd_pool</span><span class="p">)</span>
		<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dtd_pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh_size</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh_dma</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">mv_udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">clk_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">clk_i</span> <span class="o">&lt;=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">clknum</span><span class="p">;</span> <span class="n">clk_i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">[</span><span class="n">clk_i</span><span class="p">]);</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* free dev, wait for the release() finished */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="n">the_controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">mv_udc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_usb_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">clk_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;missing platform_data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">udc</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">clknum</span><span class="p">;</span>
	<span class="n">udc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to allocate memory for udc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">the_controller</span> <span class="o">=</span> <span class="n">udc</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">release_done</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_USB_OTG_UTILS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MV_USB_MODE_OTG</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">usb_get_transceiver</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clknum</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">clknum</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">clk_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">clk_i</span> <span class="o">&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">clknum</span><span class="p">;</span> <span class="n">clk_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">[</span><span class="n">clk_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">clkname</span><span class="p">[</span><span class="n">clk_i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">[</span><span class="n">clk_i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">[</span><span class="n">clk_i</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">err_put_clk</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="s">&quot;capregs&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no I/O memory resource defined</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_put_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mv_cap_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">ioremap</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to map I/O memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_put_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="s">&quot;phyregs&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no phy I/O memory resource defined</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_iounmap_capreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_regs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to map phy I/O memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_iounmap_capreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we will acces controller register, so enable the clk */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mv_udc_enable_internal</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_iounmap_phyreg</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">mv_op_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span>
		<span class="o">+</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">caplength_hciversion</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="n">CAPLENGTH_MASK</span><span class="p">));</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">dccparams</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DCCPARAMS_DEN_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * some platform will use usb to download image, it may not disconnect</span>
<span class="cm">	 * usb gadget before loading kernel. So first stop udc here.</span>
<span class="cm">	 */</span>
	<span class="n">udc_stop</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbsts</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_dqh</span><span class="p">)</span> <span class="o">*</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">DQH_ALIGNMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DQH_ALIGNMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;allocate dQH memory failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_disable_clock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* create dTD dma_pool resource */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dtd_pool</span> <span class="o">=</span> <span class="n">dma_pool_create</span><span class="p">(</span><span class="s">&quot;mv_dtd&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_dtd</span><span class="p">),</span>
			<span class="n">DTD_ALIGNMENT</span><span class="p">,</span>
			<span class="n">DMA_BOUNDARY</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dtd_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">max_eps</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_ep</span><span class="p">)</span> <span class="o">*</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;allocate ep memory failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_destroy_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize ep0 status request structure */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_req</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;allocate status_req memory failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_eps</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* allocate a small amount of memory to get valid address */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">resume_state</span> <span class="o">=</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_state</span> <span class="o">=</span> <span class="n">USB_STATE_POWERED</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">=</span> <span class="n">EP_DIR_OUT</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">remote_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no IRQ resource defined</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_status_req</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">mv_udc_irq</span><span class="p">,</span>
		<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">udc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Request irq %d for UDC failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_status_req</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize gadget structure */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_ops</span><span class="p">;</span>	<span class="cm">/* usb_gadget_ops */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ep</span><span class="p">;</span>	<span class="cm">/* gadget ep0 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>	<span class="cm">/* ep_list */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>	<span class="cm">/* speed */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">max_speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>	<span class="cm">/* support dual speed */</span>

	<span class="cm">/* the &quot;gadget&quot; abstracts/virtualizes the controller */</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gadget&quot;</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">gadget_release</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">driver_name</span><span class="p">;</span>		<span class="cm">/* gadget name */</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_irq</span><span class="p">;</span>

	<span class="n">eps_init</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="cm">/* VBUS detect: we can disable/enable clock on demand.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">mv_udc_vbus_irq</span><span class="p">,</span> <span class="n">IRQF_ONESHOT</span><span class="p">,</span> <span class="s">&quot;vbus&quot;</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Can not request irq for VBUS, &quot;</span>
				<span class="s">&quot;disable clock gating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;mv_udc_queue&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">qwork</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot create workqueue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_unregister</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_work</span><span class="p">,</span> <span class="n">mv_udc_vbus_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When clock gating is supported, we can disable clk and phy.</span>
<span class="cm">	 * If not, it means that VBUS detection is not supported, we</span>
<span class="cm">	 * have to enable vbus active all the time to let controller work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span><span class="p">)</span>
		<span class="n">mv_udc_disable_internal</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unregister</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;successful probe UDC device %s clock gating.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span> <span class="o">?</span> <span class="s">&quot;with&quot;</span> <span class="o">:</span> <span class="s">&quot;without&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_unregister:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span>
		<span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_free_status_req:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">status_req</span><span class="p">);</span>
<span class="nl">err_free_eps:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">);</span>
<span class="nl">err_destroy_dma:</span>
	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dtd_pool</span><span class="p">);</span>
<span class="nl">err_free_dma:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh_size</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_dqh_dma</span><span class="p">);</span>
<span class="nl">err_disable_clock:</span>
	<span class="n">mv_udc_disable_internal</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="nl">err_iounmap_phyreg:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">);</span>
<span class="nl">err_iounmap_capreg:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="p">);</span>
<span class="nl">err_put_clk:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">clk_i</span><span class="o">--</span><span class="p">;</span> <span class="n">clk_i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">clk_i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">[</span><span class="n">clk_i</span><span class="p">]);</span>
	<span class="n">the_controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>

	<span class="cm">/* if OTG is enabled, the following will be done in OTG driver*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">()</span> <span class="o">==</span> <span class="n">VBUS_HIGH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB cable is connected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * only cable is unplugged, udc can suspend.</span>
<span class="cm">	 * So do not care about clock_gating == 1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_stop</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* stop all usb activities */</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">mv_udc_disable_internal</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_udc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* if OTG is enabled, the following will be done in OTG driver*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clock_gating</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">mv_udc_enable_internal</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">softconnect</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udc_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">ep0_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="n">udc_start</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">mv_udc_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">mv_udc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">mv_udc_resume</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_udc_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* reset controller mode to IDLE */</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">usbmode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">udc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">mv_udc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">mv_udc_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">mv_udc_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;mv-udc&quot;</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
		<span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_udc_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">udc_driver</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:mv-udc&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Chao Xie &lt;chao.xie@marvell.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRIVER_VERSION</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
