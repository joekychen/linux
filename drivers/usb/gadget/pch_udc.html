<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › pch_udc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pch_udc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2011 LAPIS Semiconductor Co., Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> */</span>
<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>

<span class="cm">/* GPIO port for VBUS detecting */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vbus_gpio_port</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* GPIO port number (-1:Not used) */</span>

<span class="cp">#define PCH_VBUS_PERIOD		3000	</span><span class="cm">/* VBUS polling period (msec) */</span><span class="cp"></span>
<span class="cp">#define PCH_VBUS_INTERVAL	10	</span><span class="cm">/* VBUS polling interval (msec) */</span><span class="cp"></span>

<span class="cm">/* Address offset of Registers */</span>
<span class="cp">#define UDC_EP_REG_SHIFT	0x20	</span><span class="cm">/* Offset to next EP */</span><span class="cp"></span>

<span class="cp">#define UDC_EPCTL_ADDR		0x00	</span><span class="cm">/* Endpoint control */</span><span class="cp"></span>
<span class="cp">#define UDC_EPSTS_ADDR		0x04	</span><span class="cm">/* Endpoint status */</span><span class="cp"></span>
<span class="cp">#define UDC_BUFIN_FRAMENUM_ADDR	0x08	</span><span class="cm">/* buffer size in / frame number out */</span><span class="cp"></span>
<span class="cp">#define UDC_BUFOUT_MAXPKT_ADDR	0x0C	</span><span class="cm">/* buffer size out / maxpkt in */</span><span class="cp"></span>
<span class="cp">#define UDC_SUBPTR_ADDR		0x10	</span><span class="cm">/* setup buffer pointer */</span><span class="cp"></span>
<span class="cp">#define UDC_DESPTR_ADDR		0x14	</span><span class="cm">/* Data descriptor pointer */</span><span class="cp"></span>
<span class="cp">#define UDC_CONFIRM_ADDR	0x18	</span><span class="cm">/* Write/Read confirmation */</span><span class="cp"></span>

<span class="cp">#define UDC_DEVCFG_ADDR		0x400	</span><span class="cm">/* Device configuration */</span><span class="cp"></span>
<span class="cp">#define UDC_DEVCTL_ADDR		0x404	</span><span class="cm">/* Device control */</span><span class="cp"></span>
<span class="cp">#define UDC_DEVSTS_ADDR		0x408	</span><span class="cm">/* Device status */</span><span class="cp"></span>
<span class="cp">#define UDC_DEVIRQSTS_ADDR	0x40C	</span><span class="cm">/* Device irq status */</span><span class="cp"></span>
<span class="cp">#define UDC_DEVIRQMSK_ADDR	0x410	</span><span class="cm">/* Device irq mask */</span><span class="cp"></span>
<span class="cp">#define UDC_EPIRQSTS_ADDR	0x414	</span><span class="cm">/* Endpoint irq status */</span><span class="cp"></span>
<span class="cp">#define UDC_EPIRQMSK_ADDR	0x418	</span><span class="cm">/* Endpoint irq mask */</span><span class="cp"></span>
<span class="cp">#define UDC_DEVLPM_ADDR		0x41C	</span><span class="cm">/* LPM control / status */</span><span class="cp"></span>
<span class="cp">#define UDC_CSR_BUSY_ADDR	0x4f0	</span><span class="cm">/* UDC_CSR_BUSY Status register */</span><span class="cp"></span>
<span class="cp">#define UDC_SRST_ADDR		0x4fc	</span><span class="cm">/* SOFT RESET register */</span><span class="cp"></span>
<span class="cp">#define UDC_CSR_ADDR		0x500	</span><span class="cm">/* USB_DEVICE endpoint register */</span><span class="cp"></span>

<span class="cm">/* Endpoint control register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_EPCTL_MRXFLUSH		(1 &lt;&lt; 12)</span>
<span class="cp">#define UDC_EPCTL_RRDY			(1 &lt;&lt; 9)</span>
<span class="cp">#define UDC_EPCTL_CNAK			(1 &lt;&lt; 8)</span>
<span class="cp">#define UDC_EPCTL_SNAK			(1 &lt;&lt; 7)</span>
<span class="cp">#define UDC_EPCTL_NAK			(1 &lt;&lt; 6)</span>
<span class="cp">#define UDC_EPCTL_P			(1 &lt;&lt; 3)</span>
<span class="cp">#define UDC_EPCTL_F			(1 &lt;&lt; 1)</span>
<span class="cp">#define UDC_EPCTL_S			(1 &lt;&lt; 0)</span>
<span class="cp">#define UDC_EPCTL_ET_SHIFT		4</span>
<span class="cm">/* Mask patern */</span>
<span class="cp">#define UDC_EPCTL_ET_MASK		0x00000030</span>
<span class="cm">/* Value for ET field */</span>
<span class="cp">#define UDC_EPCTL_ET_CONTROL		0</span>
<span class="cp">#define UDC_EPCTL_ET_ISO		1</span>
<span class="cp">#define UDC_EPCTL_ET_BULK		2</span>
<span class="cp">#define UDC_EPCTL_ET_INTERRUPT		3</span>

<span class="cm">/* Endpoint status register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_EPSTS_XFERDONE		(1 &lt;&lt; 27)</span>
<span class="cp">#define UDC_EPSTS_RSS			(1 &lt;&lt; 26)</span>
<span class="cp">#define UDC_EPSTS_RCS			(1 &lt;&lt; 25)</span>
<span class="cp">#define UDC_EPSTS_TXEMPTY		(1 &lt;&lt; 24)</span>
<span class="cp">#define UDC_EPSTS_TDC			(1 &lt;&lt; 10)</span>
<span class="cp">#define UDC_EPSTS_HE			(1 &lt;&lt; 9)</span>
<span class="cp">#define UDC_EPSTS_MRXFIFO_EMP		(1 &lt;&lt; 8)</span>
<span class="cp">#define UDC_EPSTS_BNA			(1 &lt;&lt; 7)</span>
<span class="cp">#define UDC_EPSTS_IN			(1 &lt;&lt; 6)</span>
<span class="cp">#define UDC_EPSTS_OUT_SHIFT		4</span>
<span class="cm">/* Mask patern */</span>
<span class="cp">#define UDC_EPSTS_OUT_MASK		0x00000030</span>
<span class="cp">#define UDC_EPSTS_ALL_CLR_MASK		0x1F0006F0</span>
<span class="cm">/* Value for OUT field */</span>
<span class="cp">#define UDC_EPSTS_OUT_SETUP		2</span>
<span class="cp">#define UDC_EPSTS_OUT_DATA		1</span>

<span class="cm">/* Device configuration register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_DEVCFG_CSR_PRG		(1 &lt;&lt; 17)</span>
<span class="cp">#define UDC_DEVCFG_SP			(1 &lt;&lt; 3)</span>
<span class="cm">/* SPD Valee */</span>
<span class="cp">#define UDC_DEVCFG_SPD_HS		0x0</span>
<span class="cp">#define UDC_DEVCFG_SPD_FS		0x1</span>
<span class="cp">#define UDC_DEVCFG_SPD_LS		0x2</span>

<span class="cm">/* Device control register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_DEVCTL_THLEN_SHIFT		24</span>
<span class="cp">#define UDC_DEVCTL_BRLEN_SHIFT		16</span>
<span class="cp">#define UDC_DEVCTL_CSR_DONE		(1 &lt;&lt; 13)</span>
<span class="cp">#define UDC_DEVCTL_SD			(1 &lt;&lt; 10)</span>
<span class="cp">#define UDC_DEVCTL_MODE			(1 &lt;&lt; 9)</span>
<span class="cp">#define UDC_DEVCTL_BREN			(1 &lt;&lt; 8)</span>
<span class="cp">#define UDC_DEVCTL_THE			(1 &lt;&lt; 7)</span>
<span class="cp">#define UDC_DEVCTL_DU			(1 &lt;&lt; 4)</span>
<span class="cp">#define UDC_DEVCTL_TDE			(1 &lt;&lt; 3)</span>
<span class="cp">#define UDC_DEVCTL_RDE			(1 &lt;&lt; 2)</span>
<span class="cp">#define UDC_DEVCTL_RES			(1 &lt;&lt; 0)</span>

<span class="cm">/* Device status register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_DEVSTS_TS_SHIFT		18</span>
<span class="cp">#define UDC_DEVSTS_ENUM_SPEED_SHIFT	13</span>
<span class="cp">#define UDC_DEVSTS_ALT_SHIFT		8</span>
<span class="cp">#define UDC_DEVSTS_INTF_SHIFT		4</span>
<span class="cp">#define UDC_DEVSTS_CFG_SHIFT		0</span>
<span class="cm">/* Mask patern */</span>
<span class="cp">#define UDC_DEVSTS_TS_MASK		0xfffc0000</span>
<span class="cp">#define UDC_DEVSTS_ENUM_SPEED_MASK	0x00006000</span>
<span class="cp">#define UDC_DEVSTS_ALT_MASK		0x00000f00</span>
<span class="cp">#define UDC_DEVSTS_INTF_MASK		0x000000f0</span>
<span class="cp">#define UDC_DEVSTS_CFG_MASK		0x0000000f</span>
<span class="cm">/* value for maximum speed for SPEED field */</span>
<span class="cp">#define UDC_DEVSTS_ENUM_SPEED_FULL	1</span>
<span class="cp">#define UDC_DEVSTS_ENUM_SPEED_HIGH	0</span>
<span class="cp">#define UDC_DEVSTS_ENUM_SPEED_LOW	2</span>
<span class="cp">#define UDC_DEVSTS_ENUM_SPEED_FULLX	3</span>

<span class="cm">/* Device irq register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_DEVINT_RWKP			(1 &lt;&lt; 7)</span>
<span class="cp">#define UDC_DEVINT_ENUM			(1 &lt;&lt; 6)</span>
<span class="cp">#define UDC_DEVINT_SOF			(1 &lt;&lt; 5)</span>
<span class="cp">#define UDC_DEVINT_US			(1 &lt;&lt; 4)</span>
<span class="cp">#define UDC_DEVINT_UR			(1 &lt;&lt; 3)</span>
<span class="cp">#define UDC_DEVINT_ES			(1 &lt;&lt; 2)</span>
<span class="cp">#define UDC_DEVINT_SI			(1 &lt;&lt; 1)</span>
<span class="cp">#define UDC_DEVINT_SC			(1 &lt;&lt; 0)</span>
<span class="cm">/* Mask patern */</span>
<span class="cp">#define UDC_DEVINT_MSK			0x7f</span>

<span class="cm">/* Endpoint irq register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_EPINT_IN_SHIFT		0</span>
<span class="cp">#define UDC_EPINT_OUT_SHIFT		16</span>
<span class="cp">#define UDC_EPINT_IN_EP0		(1 &lt;&lt; 0)</span>
<span class="cp">#define UDC_EPINT_OUT_EP0		(1 &lt;&lt; 16)</span>
<span class="cm">/* Mask patern */</span>
<span class="cp">#define UDC_EPINT_MSK_DISABLE_ALL	0xffffffff</span>

<span class="cm">/* UDC_CSR_BUSY Status register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_CSR_BUSY			(1 &lt;&lt; 0)</span>

<span class="cm">/* SOFT RESET register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_PSRST			(1 &lt;&lt; 1)</span>
<span class="cp">#define UDC_SRST			(1 &lt;&lt; 0)</span>

<span class="cm">/* USB_DEVICE endpoint register */</span>
<span class="cm">/* Bit position */</span>
<span class="cp">#define UDC_CSR_NE_NUM_SHIFT		0</span>
<span class="cp">#define UDC_CSR_NE_DIR_SHIFT		4</span>
<span class="cp">#define UDC_CSR_NE_TYPE_SHIFT		5</span>
<span class="cp">#define UDC_CSR_NE_CFG_SHIFT		7</span>
<span class="cp">#define UDC_CSR_NE_INTF_SHIFT		11</span>
<span class="cp">#define UDC_CSR_NE_ALT_SHIFT		15</span>
<span class="cp">#define UDC_CSR_NE_MAX_PKT_SHIFT	19</span>
<span class="cm">/* Mask patern */</span>
<span class="cp">#define UDC_CSR_NE_NUM_MASK		0x0000000f</span>
<span class="cp">#define UDC_CSR_NE_DIR_MASK		0x00000010</span>
<span class="cp">#define UDC_CSR_NE_TYPE_MASK		0x00000060</span>
<span class="cp">#define UDC_CSR_NE_CFG_MASK		0x00000780</span>
<span class="cp">#define UDC_CSR_NE_INTF_MASK		0x00007800</span>
<span class="cp">#define UDC_CSR_NE_ALT_MASK		0x00078000</span>
<span class="cp">#define UDC_CSR_NE_MAX_PKT_MASK		0x3ff80000</span>

<span class="cp">#define PCH_UDC_CSR(ep)	(UDC_CSR_ADDR + ep*4)</span>
<span class="cp">#define PCH_UDC_EPINT(in, num)\</span>
<span class="cp">		(1 &lt;&lt; (num + (in ? UDC_EPINT_IN_SHIFT : UDC_EPINT_OUT_SHIFT)))</span>

<span class="cm">/* Index of endpoint */</span>
<span class="cp">#define UDC_EP0IN_IDX		0</span>
<span class="cp">#define UDC_EP0OUT_IDX		1</span>
<span class="cp">#define UDC_EPIN_IDX(ep)	(ep * 2)</span>
<span class="cp">#define UDC_EPOUT_IDX(ep)	(ep * 2 + 1)</span>
<span class="cp">#define PCH_UDC_EP0		0</span>
<span class="cp">#define PCH_UDC_EP1		1</span>
<span class="cp">#define PCH_UDC_EP2		2</span>
<span class="cp">#define PCH_UDC_EP3		3</span>

<span class="cm">/* Number of endpoint */</span>
<span class="cp">#define PCH_UDC_EP_NUM		32	</span><span class="cm">/* Total number of EPs (16 IN,16 OUT) */</span><span class="cp"></span>
<span class="cp">#define PCH_UDC_USED_EP_NUM	4	</span><span class="cm">/* EP number of EP&#39;s really used */</span><span class="cp"></span>
<span class="cm">/* Length Value */</span>
<span class="cp">#define PCH_UDC_BRLEN		0x0F	</span><span class="cm">/* Burst length */</span><span class="cp"></span>
<span class="cp">#define PCH_UDC_THLEN		0x1F	</span><span class="cm">/* Threshold length */</span><span class="cp"></span>
<span class="cm">/* Value of EP Buffer Size */</span>
<span class="cp">#define UDC_EP0IN_BUFF_SIZE	16</span>
<span class="cp">#define UDC_EPIN_BUFF_SIZE	256</span>
<span class="cp">#define UDC_EP0OUT_BUFF_SIZE	16</span>
<span class="cp">#define UDC_EPOUT_BUFF_SIZE	256</span>
<span class="cm">/* Value of EP maximum packet size */</span>
<span class="cp">#define UDC_EP0IN_MAX_PKT_SIZE	64</span>
<span class="cp">#define UDC_EP0OUT_MAX_PKT_SIZE	64</span>
<span class="cp">#define UDC_BULK_MAX_PKT_SIZE	512</span>

<span class="cm">/* DMA */</span>
<span class="cp">#define DMA_DIR_RX		1	</span><span class="cm">/* DMA for data receive */</span><span class="cp"></span>
<span class="cp">#define DMA_DIR_TX		2	</span><span class="cm">/* DMA for data transmit */</span><span class="cp"></span>
<span class="cp">#define DMA_ADDR_INVALID	(~(dma_addr_t)0)</span>
<span class="cp">#define UDC_DMA_MAXPACKET	65536	</span><span class="cm">/* maximum packet size for DMA */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct pch_udc_data_dma_desc - Structure to hold DMA descriptor information</span>
<span class="cm"> *				  for data</span>
<span class="cm"> * @status:		Status quadlet</span>
<span class="cm"> * @reserved:		Reserved</span>
<span class="cm"> * @dataptr:		Buffer descriptor</span>
<span class="cm"> * @next:		Next descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dataptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pch_udc_stp_dma_desc - Structure to hold DMA descriptor information</span>
<span class="cm"> *				 for control data</span>
<span class="cm"> * @status:	Status</span>
<span class="cm"> * @reserved:	Reserved</span>
<span class="cm"> * @data12:	First setup word</span>
<span class="cm"> * @data34:	Second setup word</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pch_udc_stp_dma_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">request</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* DMA status definitions */</span>
<span class="cm">/* Buffer status */</span>
<span class="cp">#define PCH_UDC_BUFF_STS	0xC0000000</span>
<span class="cp">#define PCH_UDC_BS_HST_RDY	0x00000000</span>
<span class="cp">#define PCH_UDC_BS_DMA_BSY	0x40000000</span>
<span class="cp">#define PCH_UDC_BS_DMA_DONE	0x80000000</span>
<span class="cp">#define PCH_UDC_BS_HST_BSY	0xC0000000</span>
<span class="cm">/*  Rx/Tx Status */</span>
<span class="cp">#define PCH_UDC_RXTX_STS	0x30000000</span>
<span class="cp">#define PCH_UDC_RTS_SUCC	0x00000000</span>
<span class="cp">#define PCH_UDC_RTS_DESERR	0x10000000</span>
<span class="cp">#define PCH_UDC_RTS_BUFERR	0x30000000</span>
<span class="cm">/* Last Descriptor Indication */</span>
<span class="cp">#define PCH_UDC_DMA_LAST	0x08000000</span>
<span class="cm">/* Number of Rx/Tx Bytes Mask */</span>
<span class="cp">#define PCH_UDC_RXTX_BYTES	0x0000ffff</span>

<span class="cm">/**</span>
<span class="cm"> * struct pch_udc_cfg_data - Structure to hold current configuration</span>
<span class="cm"> *			     and interface information</span>
<span class="cm"> * @cur_cfg:	current configuration in use</span>
<span class="cm"> * @cur_intf:	current interface in use</span>
<span class="cm"> * @cur_alt:	current alt interface in use</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pch_udc_cfg_data</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">cur_cfg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cur_intf</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cur_alt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pch_udc_ep - Structure holding a PCH USB device Endpoint information</span>
<span class="cm"> * @ep:			embedded ep request</span>
<span class="cm"> * @td_stp_phys:	for setup request</span>
<span class="cm"> * @td_data_phys:	for data request</span>
<span class="cm"> * @td_stp:		for setup request</span>
<span class="cm"> * @td_data:		for data request</span>
<span class="cm"> * @dev:		reference to device struct</span>
<span class="cm"> * @offset_addr:	offset address of ep register</span>
<span class="cm"> * @desc:		for this ep</span>
<span class="cm"> * @queue:		queue for requests</span>
<span class="cm"> * @num:		endpoint number</span>
<span class="cm"> * @in:			endpoint is IN</span>
<span class="cm"> * @halted:		endpoint halted?</span>
<span class="cm"> * @epsts:		Endpoint status</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>			<span class="n">ep</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">td_stp_phys</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">td_data_phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_stp_dma_desc</span>	<span class="o">*</span><span class="n">td_stp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span>	<span class="o">*</span><span class="n">td_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">offset_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">num</span><span class="o">:</span><span class="mi">5</span><span class="p">,</span>
					<span class="nl">in:</span><span class="mi">1</span><span class="p">,</span>
					<span class="nl">halted:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">epsts</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pch_vbus_gpio_data - Structure holding GPIO informaton</span>
<span class="cm"> *					for detecting VBUS</span>
<span class="cm"> * @port:		gpio port number</span>
<span class="cm"> * @intr:		gpio interrupt number</span>
<span class="cm"> * @irq_work_fall	Structure for WorkQueue</span>
<span class="cm"> * @irq_work_rise	Structure for WorkQueue</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pch_vbus_gpio_data</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">intr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">irq_work_fall</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">irq_work_rise</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pch_udc_dev - Structure holding complete information</span>
<span class="cm"> *			of the PCH USB device</span>
<span class="cm"> * @gadget:		gadget driver data</span>
<span class="cm"> * @driver:		reference to gadget driver bound</span>
<span class="cm"> * @pdev:		reference to the PCI device</span>
<span class="cm"> * @ep:			array of endpoints</span>
<span class="cm"> * @lock:		protects all state</span>
<span class="cm"> * @active:		enabled the PCI device</span>
<span class="cm"> * @stall:		stall requested</span>
<span class="cm"> * @prot_stall:		protcol stall requested</span>
<span class="cm"> * @irq_registered:	irq registered with system</span>
<span class="cm"> * @mem_region:		device memory mapped</span>
<span class="cm"> * @registered:		driver regsitered with system</span>
<span class="cm"> * @suspended:		driver in suspended state</span>
<span class="cm"> * @connected:		gadget driver associated</span>
<span class="cm"> * @vbus_session:	required vbus_session state</span>
<span class="cm"> * @set_cfg_not_acked:	pending acknowledgement 4 setup</span>
<span class="cm"> * @waiting_zlp_ack:	pending acknowledgement 4 ZLP</span>
<span class="cm"> * @data_requests:	DMA pool for data requests</span>
<span class="cm"> * @stp_requests:	DMA pool for setup requests</span>
<span class="cm"> * @dma_addr:		DMA pool for received</span>
<span class="cm"> * @ep0out_buf:		Buffer for DMA</span>
<span class="cm"> * @setup_data:		Received setup data</span>
<span class="cm"> * @phys_addr:		of device memory</span>
<span class="cm"> * @base_addr:		for mapped device memory</span>
<span class="cm"> * @irq:		IRQ line for the device</span>
<span class="cm"> * @cfg_data:		current cfg, intf, and alt in use</span>
<span class="cm"> * @vbus_gpio:		GPIO informaton for detecting VBUS</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>		<span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>			<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>		<span class="n">ep</span><span class="p">[</span><span class="n">PCH_UDC_EP_NUM</span><span class="p">];</span>
	<span class="n">spinlock_t</span>			<span class="n">lock</span><span class="p">;</span> <span class="cm">/* protects all state */</span>
	<span class="kt">unsigned</span>	<span class="n">active</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">stall:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">prot_stall:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">irq_registered:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">mem_region:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">registered:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">suspended:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">connected:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">vbus_session:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">set_cfg_not_acked:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">waiting_zlp_ack:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_pool</span>		<span class="o">*</span><span class="n">data_requests</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_pool</span>		<span class="o">*</span><span class="n">stp_requests</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">ep0out_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>		<span class="n">setup_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">phys_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_cfg_data</span>		<span class="n">cfg_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_vbus_gpio_data</span>	<span class="n">vbus_gpio</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PCH_UDC_PCI_BAR			1</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_EG20T_UDC	0x8808</span>
<span class="cp">#define PCI_VENDOR_ID_ROHM		0x10DB</span>
<span class="cp">#define PCI_DEVICE_ID_ML7213_IOH_UDC	0x801D</span>
<span class="cp">#define PCI_DEVICE_ID_ML7831_IOH_UDC	0x8808</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span>	<span class="n">ep0_string</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ep0in&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">udc_stall_spinlock</span><span class="p">);</span>	<span class="cm">/* stall spin lock */</span>
<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">pch_udc</span><span class="p">;</span>		<span class="cm">/* pointer to device object */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">speed_fs</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">speed_fs</span><span class="p">,</span> <span class="n">speed_fs</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">speed_fs</span><span class="p">,</span> <span class="s">&quot;true for Full speed operation&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct pch_udc_request - Structure holding a PCH USB device request packet</span>
<span class="cm"> * @req:		embedded ep request</span>
<span class="cm"> * @td_data_phys:	phys. address</span>
<span class="cm"> * @td_data:		first dma desc. of chain</span>
<span class="cm"> * @td_data_last:	last dma desc. of chain</span>
<span class="cm"> * @queue:		associated queue</span>
<span class="cm"> * @dma_going:		DMA in progress for request</span>
<span class="cm"> * @dma_mapped:		DMA memory mapped for request</span>
<span class="cm"> * @dma_done:		DMA completed for request</span>
<span class="cm"> * @chain_len:		chain length</span>
<span class="cm"> * @buf:		Buffer memory for align adjustment</span>
<span class="cm"> * @dma:		DMA memory for align adjustment</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>		<span class="n">req</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">td_data_phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span>	<span class="o">*</span><span class="n">td_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span>	<span class="o">*</span><span class="n">td_data_last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">dma_going</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
					<span class="nl">dma_mapped:</span><span class="mi">1</span><span class="p">,</span>
					<span class="nl">dma_done:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">chain_len</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">dma</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">pch_udc_readl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_writel</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_bit_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_bit_clr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">bitmask</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">pch_udc_ep_readl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">offset_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_writel</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">offset_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_bit_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_bit_clr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">bitmask</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_csr_busy() - Wait till idle.</span>
<span class="cm"> * @dev:	Reference to pch_udc_dev structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_csr_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

	<span class="cm">/* Wait till idle */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_CSR_BUSY_ADDR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDC_CSR_BUSY</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">count</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: wait error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_write_csr() - Write the command and status registers.</span>
<span class="cm"> * @dev:	Reference to pch_udc_dev structure</span>
<span class="cm"> * @val:	value to be written to CSR register</span>
<span class="cm"> * @addr:	address of CSR register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_write_csr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">PCH_UDC_CSR</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="n">pch_udc_csr_busy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>		<span class="cm">/* Wait till idle */</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">pch_udc_csr_busy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>		<span class="cm">/* Wait till idle */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_read_csr() - Read the command and status registers.</span>
<span class="cm"> * @dev:	Reference to pch_udc_dev structure</span>
<span class="cm"> * @addr:	address of CSR register</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:	content of CSR register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">pch_udc_read_csr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">PCH_UDC_CSR</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="n">pch_udc_csr_busy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>		<span class="cm">/* Wait till idle */</span>
	<span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>	<span class="cm">/* Dummy read */</span>
	<span class="n">pch_udc_csr_busy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>		<span class="cm">/* Wait till idle */</span>
	<span class="k">return</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_rmt_wakeup() - Initiate for remote wakeup</span>
<span class="cm"> * @dev:	Reference to pch_udc_dev structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_rmt_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RES</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_get_frame() - Get the current frame from device status register</span>
<span class="cm"> * @dev:	Reference to pch_udc_dev structure</span>
<span class="cm"> * Retern	current frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pch_udc_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVSTS_ADDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">frame</span> <span class="o">&amp;</span> <span class="n">UDC_DEVSTS_TS_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDC_DEVSTS_TS_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_clear_selfpowered() - Clear the self power control</span>
<span class="cm"> * @dev:	Reference to pch_udc_regs structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_clear_selfpowered</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCFG_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCFG_SP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_set_selfpowered() - Set the self power control</span>
<span class="cm"> * @dev:	Reference to pch_udc_regs structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_set_selfpowered</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCFG_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCFG_SP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_set_disconnect() - Set the disconnect status.</span>
<span class="cm"> * @dev:	Reference to pch_udc_regs structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_set_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_SD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_clear_disconnect() - Clear the disconnect status.</span>
<span class="cm"> * @dev:	Reference to pch_udc_regs structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_clear_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear the disconnect */</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RES</span><span class="p">);</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_SD</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Resume USB signalling */</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_reconnect() - This API initializes usb device controller,</span>
<span class="cm"> *						and clear the disconnect status.</span>
<span class="cm"> * @dev:		Reference to pch_udc_regs structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pch_udc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_reconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* enable device interrupts */</span>
	<span class="cm">/* pch_udc_enable_interrupts() */</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVIRQMSK_ADDR</span><span class="p">,</span>
			<span class="n">UDC_DEVINT_UR</span> <span class="o">|</span> <span class="n">UDC_DEVINT_ENUM</span><span class="p">);</span>

	<span class="cm">/* Clear the disconnect */</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RES</span><span class="p">);</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_SD</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Resume USB signalling */</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_vbus_session() - set or clearr the disconnect status.</span>
<span class="cm"> * @dev:	Reference to pch_udc_regs structure</span>
<span class="cm"> * @is_active:	Parameter specifying the action</span>
<span class="cm"> *		  0:   indicating VBUS power is ending</span>
<span class="cm"> *		  !0:  indicating VBUS power is starting</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_vbus_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">is_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_reconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_session</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pch_udc_set_disconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_session</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_stall() - Set the stall of endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_F</span><span class="p">);</span>
		<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_S</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_S</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_clear_stall() - Clear the stall of endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_clear_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear the stall */</span>
	<span class="n">pch_udc_ep_bit_clr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_S</span><span class="p">);</span>
	<span class="cm">/* Clear NAK by writing CNAK */</span>
	<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_CNAK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_trfr_type() - Set the transfer type of endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * @type:	Type of endpoint</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_trfr_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="n">u8</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="p">((</span><span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_EPCTL_ET_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">UDC_EPCTL_ET_MASK</span><span class="p">),</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_bufsz() - Set the maximum packet size for the endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * @buf_size:	The buffer word size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_bufsz</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
						 <span class="n">u32</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ep_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_BUFIN_FRAMENUM_ADDR</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">buf_size</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">UDC_BUFIN_FRAMENUM_ADDR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_BUFOUT_MAXPKT_ADDR</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf_size</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">UDC_BUFOUT_MAXPKT_ADDR</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_maxpkt() - Set the Max packet size for the endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * @pkt_size:	The packet byte size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_maxpkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pkt_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_BUFOUT_MAXPKT_ADDR</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">pkt_size</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">UDC_BUFOUT_MAXPKT_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_subptr() - Set the Setup buffer pointer for the endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * @addr:	Address of the register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_subptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">UDC_SUBPTR_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_ddptr() - Set the Data descriptor pointer for the endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * @addr:	Address of the register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">UDC_DESPTR_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_pd() - Set the poll demand bit for the endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_P</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_rrdy() - Set the receive ready bit for the endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_rrdy</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_RRDY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_clear_rrdy() - Clear the receive ready bit for the endpoint</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_clear_rrdy</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_bit_clr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_RRDY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_set_dma() - Set the &#39;TDE&#39; or RDE bit of device control</span>
<span class="cm"> *			register depending on the direction specified</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @dir:	whether Tx or Rx</span>
<span class="cm"> *		  DMA_DIR_RX: Receive</span>
<span class="cm"> *		  DMA_DIR_TX: Transmit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_set_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_DIR_RX</span><span class="p">)</span>
		<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RDE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_DIR_TX</span><span class="p">)</span>
		<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_TDE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_clear_dma() - Clear the &#39;TDE&#39; or RDE bit of device control</span>
<span class="cm"> *				 register depending on the direction specified</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @dir:	Whether Tx or Rx</span>
<span class="cm"> *		  DMA_DIR_RX: Receive</span>
<span class="cm"> *		  DMA_DIR_TX: Transmit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_clear_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_DIR_RX</span><span class="p">)</span>
		<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_RDE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_DIR_TX</span><span class="p">)</span>
		<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_TDE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_set_csr_done() - Set the device control register</span>
<span class="cm"> *				CSR done field (bit 13)</span>
<span class="cm"> * @dev:	reference to structure of type pch_udc_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_set_csr_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCTL_CSR_DONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_disable_interrupts() - Disables the specified interrupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @mask:	Mask to disable interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVIRQMSK_ADDR</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_enable_interrupts() - Enable the specified interrupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @mask:	Mask to enable interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVIRQMSK_ADDR</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_disable_ep_interrupts() - Disable endpoint interrupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @mask:	Mask to disable interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_disable_ep_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPIRQMSK_ADDR</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_enable_ep_interrupts() - Enable endpoint interrupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @mask:	Mask to enable interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					      <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_bit_clr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPIRQMSK_ADDR</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_read_device_interrupts() - Read the device interrupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * Retern	The device interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">pch_udc_read_device_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVIRQSTS_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_write_device_interrupts() - Write device interrupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @val:	The value to be written to interrupt register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_write_device_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						     <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">UDC_DEVIRQSTS_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_read_ep_interrupts() - Read the endpoint interrupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * Retern	The endpoint interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">pch_udc_read_ep_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPIRQSTS_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_write_ep_interrupts() - Clear endpoint interupts</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * @val:	The value to be written to interrupt register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_write_ep_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">UDC_EPIRQSTS_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_read_device_status() - Read the device status</span>
<span class="cm"> * @dev:	Reference to structure of type pch_udc_regs</span>
<span class="cm"> * Retern	The device status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">pch_udc_read_device_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVSTS_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_read_ep_control() - Read the endpoint control</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * Retern	The endpoint control register value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">pch_udc_read_ep_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_clear_ep_control() - Clear the endpoint control register</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * Retern	The endpoint control register value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_clear_ep_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_read_ep_status() - Read the endpoint status</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * Retern	The endpoint status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">pch_udc_read_ep_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPSTS_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_clear_ep_status() - Clear the endpoint status</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * @stat:	Endpoint status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_clear_ep_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">UDC_EPSTS_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_set_nak() - Set the bit 7 (SNAK field)</span>
<span class="cm"> *				of the endpoint control register</span>
<span class="cm"> * @ep:		Reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_set_nak</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_SNAK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_clear_nak() - Set the bit 8 (CNAK field)</span>
<span class="cm"> *				of the endpoint control register</span>
<span class="cm"> * @ep:		reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loopcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pch_udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDC_EPCTL_NAK</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loopcnt</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pch_udc_read_ep_status</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_MRXFIFO_EMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">--</span><span class="n">loopcnt</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loopcnt</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: RxFIFO not Empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">loopcnt</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">pch_udc_read_ep_control</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDC_EPCTL_NAK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">loopcnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_CNAK</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loopcnt</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Clear NAK not set for ep%d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_fifo_flush() - Flush the endpoint fifo</span>
<span class="cm"> * @ep:	reference to structure of type pch_udc_ep_regs</span>
<span class="cm"> * @dir:	direction of endpoint</span>
<span class="cm"> *		  0:  endpoint is OUT</span>
<span class="cm"> *		  !0: endpoint is IN</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_fifo_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* IN ep */</span>
		<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">,</span> <span class="n">UDC_EPCTL_F</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_enable() - This api enables endpoint</span>
<span class="cm"> * @regs:	Reference to structure pch_udc_ep_regs</span>
<span class="cm"> * @desc:	endpoint descriptor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pch_udc_cfg_data</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buff_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pch_udc_ep_set_trfr_type</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
		<span class="n">buff_size</span> <span class="o">=</span> <span class="n">UDC_EPIN_BUFF_SIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buff_size</span> <span class="o">=</span> <span class="n">UDC_EPOUT_BUFF_SIZE</span><span class="p">;</span>
	<span class="n">pch_udc_ep_set_bufsz</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">buff_size</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_maxpkt</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
	<span class="n">pch_udc_ep_set_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">pch_udc_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
	<span class="cm">/* Configure the endpoint */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_NUM_SHIFT</span> <span class="o">|</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_DIR_SHIFT</span> <span class="o">|</span>
	      <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
		<span class="n">UDC_CSR_NE_TYPE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
	      <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cur_cfg</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_CFG_SHIFT</span><span class="p">)</span> <span class="o">|</span>
	      <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cur_intf</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_INTF_SHIFT</span><span class="p">)</span> <span class="o">|</span>
	      <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">cur_alt</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_ALT_SHIFT</span><span class="p">)</span> <span class="o">|</span>
	      <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_MAX_PKT_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
		<span class="n">pch_udc_write_csr</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">UDC_EPIN_IDX</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">pch_udc_write_csr</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">UDC_EPOUT_IDX</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_ep_disable() - This api disables endpoint</span>
<span class="cm"> * @regs:	Reference to structure pch_udc_ep_regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* flush the fifo */</span>
		<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_F</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">);</span>
		<span class="cm">/* set NAK */</span>
		<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_SNAK</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">);</span>
		<span class="n">pch_udc_ep_bit_set</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPSTS_ADDR</span><span class="p">,</span> <span class="n">UDC_EPSTS_IN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* set NAK */</span>
		<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPCTL_SNAK</span><span class="p">,</span> <span class="n">UDC_EPCTL_ADDR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* reset desc pointer */</span>
	<span class="n">pch_udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UDC_DESPTR_ADDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_wait_ep_stall() - Wait EP stall.</span>
<span class="cm"> * @dev:	Reference to pch_udc_dev structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_wait_ep_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

	<span class="cm">/* Wait till idle */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">pch_udc_read_ep_control</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDC_EPCTL_S</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">count</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: wait error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_init() - This API initializes usb device controller</span>
<span class="cm"> * @dev:	Rreference to pch_udc_regs structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Invalid address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Soft Reset and Reset PHY */</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_SRST</span><span class="p">,</span> <span class="n">UDC_SRST_ADDR</span><span class="p">);</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_SRST</span> <span class="o">|</span> <span class="n">UDC_PSRST</span><span class="p">,</span> <span class="n">UDC_SRST_ADDR</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_SRST</span><span class="p">,</span> <span class="n">UDC_SRST_ADDR</span><span class="p">);</span>
	<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">UDC_SRST_ADDR</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* mask and clear all device interrupts */</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVIRQMSK_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVINT_MSK</span><span class="p">);</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVIRQSTS_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVINT_MSK</span><span class="p">);</span>

	<span class="cm">/* mask and clear all ep interrupts */</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPIRQMSK_ADDR</span><span class="p">,</span> <span class="n">UDC_EPINT_MSK_DISABLE_ALL</span><span class="p">);</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPIRQSTS_ADDR</span><span class="p">,</span> <span class="n">UDC_EPINT_MSK_DISABLE_ALL</span><span class="p">);</span>

	<span class="cm">/* enable dynamic CSR programmingi, self powered and device speed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speed_fs</span><span class="p">)</span>
		<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCFG_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCFG_CSR_PRG</span> <span class="o">|</span>
				<span class="n">UDC_DEVCFG_SP</span> <span class="o">|</span> <span class="n">UDC_DEVCFG_SPD_FS</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* defaul high speed */</span>
		<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCFG_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVCFG_CSR_PRG</span> <span class="o">|</span>
				<span class="n">UDC_DEVCFG_SP</span> <span class="o">|</span> <span class="n">UDC_DEVCFG_SPD_HS</span><span class="p">);</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCTL_ADDR</span><span class="p">,</span>
			<span class="p">(</span><span class="n">PCH_UDC_THLEN</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_DEVCTL_THLEN_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">PCH_UDC_BRLEN</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_DEVCTL_BRLEN_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">UDC_DEVCTL_MODE</span> <span class="o">|</span> <span class="n">UDC_DEVCTL_BREN</span> <span class="o">|</span>
			<span class="n">UDC_DEVCTL_THE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_exit() - This API exit usb device controller</span>
<span class="cm"> * @dev:	Reference to pch_udc_regs structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mask all device interrupts */</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVIRQMSK_ADDR</span><span class="p">,</span> <span class="n">UDC_DEVINT_MSK</span><span class="p">);</span>
	<span class="cm">/* mask all ep interrupts */</span>
	<span class="n">pch_udc_bit_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPIRQMSK_ADDR</span><span class="p">,</span> <span class="n">UDC_EPINT_MSK_DISABLE_ALL</span><span class="p">);</span>
	<span class="cm">/* put device in disconnected state */</span>
	<span class="n">pch_udc_set_disconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_get_frame() - This API is invoked to get the current frame number</span>
<span class="cm"> * @gadget:	Reference to the gadget driver</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	-EINVAL:	If the gadget passed is NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_dev</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pch_udc_get_frame</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_wakeup() - This API is invoked to initiate a remote wakeup</span>
<span class="cm"> * @gadget:	Reference to the gadget driver</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	-EINVAL:	If the gadget passed is NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_dev</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pch_udc_rmt_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_selfpowered() - This API is invoked to specify whether the device</span>
<span class="cm"> *				is self powered or not</span>
<span class="cm"> * @gadget:	Reference to the gadget driver</span>
<span class="cm"> * @value:	Specifies self powered or not</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	-EINVAL:	If the gadget passed is NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_selfpowered</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_dev</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span>
		<span class="n">pch_udc_set_selfpowered</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pch_udc_clear_selfpowered</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_pullup() - This API is invoked to make the device</span>
<span class="cm"> *				visible/invisible to the host</span>
<span class="cm"> * @gadget:	Reference to the gadget driver</span>
<span class="cm"> * @is_on:	Specifies whether the pull up is made active or inactive</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	-EINVAL:	If the gadget passed is NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_dev</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_reconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pch_udc_set_disconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_vbus_session() - This API is used by a driver for an external</span>
<span class="cm"> *				transceiver (or GPIO) that</span>
<span class="cm"> *				detects a VBUS power session starting/ending</span>
<span class="cm"> * @gadget:	Reference to the gadget driver</span>
<span class="cm"> * @is_active:	specifies whether the session is starting or ending</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	-EINVAL:	If the gadget passed is NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_vbus_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_dev</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
	<span class="n">pch_udc_vbus_session</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">is_active</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_vbus_draw() - This API is used by gadget drivers during</span>
<span class="cm"> *				SET_CONFIGURATION calls to</span>
<span class="cm"> *				specify how much power the device can consume</span>
<span class="cm"> * @gadget:	Reference to the gadget driver</span>
<span class="cm"> * @mA:		specifies the current limit in 2mA unit</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	-EINVAL:	If the gadget passed is NULL</span>
<span class="cm"> *	-EOPNOTSUPP:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_vbus_draw</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mA</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pch_udc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">));</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pch_udc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_gadget_ops</span> <span class="n">pch_udc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_frame</span> <span class="o">=</span> <span class="n">pch_udc_pcd_get_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="n">pch_udc_pcd_wakeup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_selfpowered</span> <span class="o">=</span> <span class="n">pch_udc_pcd_selfpowered</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pullup</span> <span class="o">=</span> <span class="n">pch_udc_pcd_pullup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vbus_session</span> <span class="o">=</span> <span class="n">pch_udc_pcd_vbus_session</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vbus_draw</span> <span class="o">=</span> <span class="n">pch_udc_pcd_vbus_draw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">pch_udc_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">pch_udc_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pch_vbus_gpio_get_value() - This API gets value of GPIO port as VBUS status.</span>
<span class="cm"> * @dev:	Reference to the driver structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1: VBUS is high</span>
<span class="cm"> *	0: VBUS is low</span>
<span class="cm"> *     -1: It is not enable to detect VBUS using GPIO</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_vbus_gpio_get_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vbus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
		<span class="n">vbus</span> <span class="o">=</span> <span class="n">gpio_get_value</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vbus</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vbus</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_vbus_gpio_work_fall() - This API keeps watch on VBUS becoming Low.</span>
<span class="cm"> *                             If VBUS is Low, disconnect is processed</span>
<span class="cm"> * @irq_work:	Structure for WorkQueue</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_vbus_gpio_work_fall</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">irq_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_vbus_gpio_data</span> <span class="o">*</span><span class="n">vbus_gpio</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">irq_work</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pch_vbus_gpio_data</span><span class="p">,</span> <span class="n">irq_work_fall</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">vbus_gpio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_dev</span><span class="p">,</span> <span class="n">vbus_gpio</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">vbus_saved</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vbus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">PCH_VBUS_PERIOD</span> <span class="o">/</span> <span class="n">PCH_VBUS_INTERVAL</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vbus</span> <span class="o">=</span> <span class="n">pch_vbus_gpio_get_value</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">vbus_saved</span> <span class="o">==</span> <span class="n">vbus</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vbus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VBUS fell&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span>
				<span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span><span class="p">)</span>
				<span class="n">pch_udc_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pch_udc_reconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vbus_saved</span> <span class="o">=</span> <span class="n">vbus</span><span class="p">;</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">PCH_VBUS_INTERVAL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_vbus_gpio_work_rise() - This API checks VBUS is High.</span>
<span class="cm"> *                             If VBUS is High, connect is processed</span>
<span class="cm"> * @irq_work:	Structure for WorkQueue</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_vbus_gpio_work_rise</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">irq_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_vbus_gpio_data</span> <span class="o">*</span><span class="n">vbus_gpio</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">irq_work</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pch_vbus_gpio_data</span><span class="p">,</span> <span class="n">irq_work_rise</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">vbus_gpio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_dev</span><span class="p">,</span> <span class="n">vbus_gpio</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">vbus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mdelay</span><span class="p">(</span><span class="n">PCH_VBUS_INTERVAL</span><span class="p">);</span>
	<span class="n">vbus</span> <span class="o">=</span> <span class="n">pch_vbus_gpio_get_value</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vbus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VBUS rose&quot;</span><span class="p">);</span>
		<span class="n">pch_udc_reconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_vbus_gpio_irq() - IRQ handler for GPIO intrerrupt for changing VBUS</span>
<span class="cm"> * @irq:	Interrupt request number</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0: Success</span>
<span class="cm"> *	-EINVAL: GPIO port is invalid or can&#39;t be initialized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pch_vbus_gpio_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pch_vbus_gpio_get_value</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">irq_work_rise</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">irq_work_fall</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_vbus_gpio_init() - This API initializes GPIO port detecting VBUS.</span>
<span class="cm"> * @dev:	Reference to the driver structure</span>
<span class="cm"> * @vbus_gpio	Number of GPIO port to detect gpio</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0: Success</span>
<span class="cm"> *	-EINVAL: GPIO port is invalid or can&#39;t be initialized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_vbus_gpio_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vbus_gpio_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vbus_gpio_port</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">vbus_gpio_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: gpio port %d is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">vbus_gpio_port</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">vbus_gpio_port</span><span class="p">,</span> <span class="s">&quot;pch_vbus&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t request gpio port %d, err: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">vbus_gpio_port</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">vbus_gpio_port</span><span class="p">;</span>
	<span class="n">gpio_direction_input</span><span class="p">(</span><span class="n">vbus_gpio_port</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">irq_work_fall</span><span class="p">,</span> <span class="n">pch_vbus_gpio_work_fall</span><span class="p">);</span>

	<span class="n">irq_num</span> <span class="o">=</span> <span class="n">gpio_to_irq</span><span class="p">(</span><span class="n">vbus_gpio_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_set_irq_type</span><span class="p">(</span><span class="n">irq_num</span><span class="p">,</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq_num</span><span class="p">,</span> <span class="n">pch_vbus_gpio_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="s">&quot;vbus_detect&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span> <span class="o">=</span> <span class="n">irq_num</span><span class="p">;</span>
			<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">irq_work_rise</span><span class="p">,</span>
				<span class="n">pch_vbus_gpio_work_rise</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t request irq %d, err: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">irq_num</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_vbus_gpio_free() - This API frees resources of GPIO port</span>
<span class="cm"> * @dev:	Reference to the driver structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_vbus_gpio_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * complete_req() - This API is invoked from the driver when processing</span>
<span class="cm"> *			of a request is complete</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> * @req:	Reference to the request structure</span>
<span class="cm"> * @status:	Indicates the success/failure of completion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">complete_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
								 <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">halted</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span><span class="p">;</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* set new status if pending */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_mapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">==</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span>
						 <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
						 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span>
						 <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
						 <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
						 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
						 <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
		<span class="n">pch_udc_ep_clear_rrdy</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="n">halted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * empty_req_queue() - This API empties the request queue of an endpoint</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">empty_req_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">complete_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>	<span class="cm">/* Remove from list */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_free_dma_chain() - This function frees the DMA chain created</span>
<span class="cm"> *				for the request</span>
<span class="cm"> * @dev		Reference to the driver structure</span>
<span class="cm"> * @req		Reference to the request to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0: Success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_free_dma_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span><span class="p">;</span>

	<span class="n">dma_addr_t</span> <span class="n">addr2</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* do not free first desc., will be done by free for request */</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">addr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">addr2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_create_dma_chain() - This function creates or reinitializes</span>
<span class="cm"> *				a DMA chain</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> * @req:	Reference to the request</span>
<span class="cm"> * @buf_len:	The buffer length</span>
<span class="cm"> * @gfp_flags:	Flags to be used while mapping the data buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		success,</span>
<span class="cm"> *	-ENOMEM:	pci_pool_alloc invocation fails</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_create_dma_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf_len</span><span class="p">,</span>
				    <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pch_udc_free_dma_chain</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">==</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">)</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>

	<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PCH_UDC_BS_HST_BSY</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="p">;</span> <span class="n">bytes</span> <span class="o">-=</span> <span class="n">buf_len</span><span class="p">,</span> <span class="o">++</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PCH_UDC_BS_HST_BSY</span> <span class="o">|</span> <span class="n">min</span><span class="p">(</span><span class="n">buf_len</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="n">buf_len</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">buf_len</span><span class="p">;</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">;</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">pch_udc_free_dma_chain</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * prepare_dma() - This function creates and initializes the DMA chain</span>
<span class="cm"> *			for the request</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> * @req:	Reference to the request</span>
<span class="cm"> * @gfp:	Flag to be used while mapping the data buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	Other 0:	linux error number on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Allocate and create a DMA chain */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pch_udc_create_dma_chain</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: could not create DMA chain:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span>
				<span class="o">~</span><span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">|</span> <span class="n">PCH_UDC_BS_HST_RDY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * process_zlp() - This function process zero length packets</span>
<span class="cm"> *			from the gadget driver</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> * @req:	Reference to the request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_zlp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* IN zlp&#39;s are handled by hardware */</span>
	<span class="n">complete_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* if set_config or set_intf is waiting for ack by zlp</span>
<span class="cm">	 * then set CSR_DONE</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_cfg_not_acked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_set_csr_done</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_cfg_not_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* setup command is ACK&#39;ed now by zlp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting_zlp_ack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">]));</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting_zlp_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_start_rxrequest() - This function starts the receive requirement.</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> * @req:	Reference to the request structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_start_rxrequest</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span> <span class="o">*</span><span class="n">td_data</span><span class="p">;</span>

	<span class="n">pch_udc_clear_dma</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
	<span class="n">td_data</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="p">;</span>
	<span class="cm">/* Set the status bits for all descriptors */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">|</span>
				    <span class="n">PCH_UDC_BS_HST_RDY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">)</span> <span class="o">==</span>  <span class="n">PCH_UDC_DMA_LAST</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">td_data</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Write the descriptor pointer */</span>
	<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_going</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPINT_OUT_EP0</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
	<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_rrdy</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_ep_enable() - This API enables the endpoint. It is called</span>
<span class="cm"> *				from gadget driver</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> * @desc:	Reference to the USB endpoint descriptor structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	-EINVAL:</span>
<span class="cm"> *	-ESHUTDOWN:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">iflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span> <span class="o">||</span> <span class="p">(</span><span class="n">usbep</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="n">ep0_string</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pch_udc_ep_enable</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_ep_disable() - This API disables endpoint and is called</span>
<span class="cm"> *				from gadget driver</span>
<span class="cm"> * @usbep	Reference to the USB endpoint structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:		Success</span>
<span class="cm"> *	-EINVAL:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">iflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">usbep</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="n">ep0_string</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">empty_req_queue</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pch_udc_ep_disable</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">pch_udc_disable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_alloc_request() - This function allocates request structure.</span>
<span class="cm"> *				It is called by gadget driver</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> * @gfp:	Flag to be used while allocating memory</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	NULL:			Failure</span>
<span class="cm"> *	Allocated address:	Success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="nf">pch_udc_alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">,</span>
						  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span>		<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span>	<span class="o">*</span><span class="n">dma_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
	<span class="cm">/* ep0 in requests are allocated from data pool here */</span>
	<span class="n">dma_desc</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dma_desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* prevent from using desc. - set HOST BUSY */</span>
	<span class="n">dma_desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">PCH_UDC_BS_HST_BSY</span><span class="p">;</span>
	<span class="n">dma_desc</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">=</span> <span class="n">__constant_cpu_to_le32</span><span class="p">(</span><span class="n">DMA_ADDR_INVALID</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span> <span class="o">=</span> <span class="n">dma_desc</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span> <span class="o">=</span> <span class="n">dma_desc</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_free_request() - This function frees request structure.</span>
<span class="cm"> *				It is called by gadget driver</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> * @usbreq:	Reference to the USB request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">usbreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span> <span class="o">||</span> <span class="o">!</span><span class="n">usbreq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %s req=0x%p queue not empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">usbep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">chain_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pch_udc_free_dma_chain</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="p">,</span>
			      <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_queue() - This function queues a request packet. It is called</span>
<span class="cm"> *			by gadget driver</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> * @usbreq:	Reference to the USB request</span>
<span class="cm"> * @gfp:	Flag to be used while mapping the data buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:			Success</span>
<span class="cm"> *	linux error number:	Failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">usbreq</span><span class="p">,</span>
								 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">iflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span> <span class="o">||</span> <span class="o">!</span><span class="n">usbreq</span> <span class="o">||</span> <span class="o">!</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">||</span> <span class="o">!</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="cm">/* map the buffer for dma */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">==</span> <span class="n">DMA_ADDR_INVALID</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
				<span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							     <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
							     <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
							     <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							     <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
							     <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
							     <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">probe_end</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							  <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
							  <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
							  <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							  <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
							  <span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
							  <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">prepare_dma</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">probe_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no pending transfer, so start this req */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbreq</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">process_zlp</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">probe_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pch_udc_start_rxrequest</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			* For IN trfr the descriptors will be programmed and</span>
<span class="cm">			* P bit will be set when</span>
<span class="cm">			* we get an IN token</span>
<span class="cm">			*/</span>
			<span class="n">pch_udc_wait_ep_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Now add this request to the ep&#39;s pending requests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

<span class="nl">probe_end:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_dequeue() - This function de-queues a request packet.</span>
<span class="cm"> *				It is called by gadget driver</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> * @usbreq:	Reference to the USB request</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:			Success</span>
<span class="cm"> *	linux error number:	Failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">usbreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span> <span class="o">||</span> <span class="o">!</span><span class="n">usbreq</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* make sure it&#39;s still queued on this endpoint */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">==</span> <span class="n">usbreq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_set_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
				<span class="n">complete_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_set_halt() - This function Sets or clear the endpoint halt</span>
<span class="cm"> *			    feature</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> * @halt:	Specifies whether to set or clear the feature</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:			Success</span>
<span class="cm"> *	linux error number:	Failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">halt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_stall_spinlock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">halt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">==</span> <span class="n">PCH_UDC_EP0</span><span class="p">)</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						     <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span>
								   <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_clear_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_stall_spinlock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_set_wedge() - This function Sets or clear the endpoint</span>
<span class="cm"> *				halt feature</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> * @halt:	Specifies whether to set or clear the feature</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0:			Success</span>
<span class="cm"> *	linux error number:	Failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_set_wedge</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_stall_spinlock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">==</span> <span class="n">PCH_UDC_EP0</span><span class="p">)</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">prot_stall</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_stall_spinlock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_fifo_flush() - This function Flush the FIFO of specified endpoint</span>
<span class="cm"> * @usbep:	Reference to the USB endpoint structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_pcd_fifo_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usbep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>  <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usbep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usbep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">desc</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
		<span class="n">pch_udc_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ep_ops</span> <span class="n">pch_udc_ep_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">pch_udc_pcd_ep_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">pch_udc_pcd_ep_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_request</span>	<span class="o">=</span> <span class="n">pch_udc_alloc_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_request</span>	<span class="o">=</span> <span class="n">pch_udc_free_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queue</span>		<span class="o">=</span> <span class="n">pch_udc_pcd_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue</span>	<span class="o">=</span> <span class="n">pch_udc_pcd_dequeue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_halt</span>	<span class="o">=</span> <span class="n">pch_udc_pcd_set_halt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wedge</span>	<span class="o">=</span> <span class="n">pch_udc_pcd_set_wedge</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_status</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_flush</span>	<span class="o">=</span> <span class="n">pch_udc_pcd_fifo_flush</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_init_setup_buff() - This function initializes the SETUP buffer</span>
<span class="cm"> * @td_stp:	Reference to the SETP buffer structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_init_setup_buff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_stp_dma_desc</span> <span class="o">*</span><span class="n">td_stp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">u32</span>	<span class="n">pky_marker</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td_stp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">td_stp</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="o">++</span><span class="n">pky_marker</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td_stp</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">td_stp</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">);</span>
	<span class="n">td_stp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PCH_UDC_BS_HST_RDY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_start_next_txrequest() - This function starts</span>
<span class="cm"> *					the next transmission requirement</span>
<span class="cm"> * @ep:	Reference to the endpoint structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_start_next_txrequest</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span> <span class="o">*</span><span class="n">td_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pch_udc_read_ep_control</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDC_EPCTL_P</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* next request */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_going</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pch_udc_wait_ep_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_going</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">td_data</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">|</span>
				   <span class="n">PCH_UDC_BS_HST_RDY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">td_data</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">);</span>
	<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_TX</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_pd</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_complete_transfer() - This function completes a transfer</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_complete_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">PCH_UDC_BS_DMA_DONE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_RXTX_STS</span><span class="p">)</span> <span class="o">!=</span>
	     <span class="n">PCH_UDC_RTS_SUCC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid RXTX status (0x%08x) &quot;</span>
			<span class="s">&quot;epstatus=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_RXTX_STS</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PCH_UDC_BS_HST_BSY</span> <span class="o">|</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PCH_UDC_BS_HST_BSY</span> <span class="o">|</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">;</span>
	<span class="n">complete_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_going</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pch_udc_wait_ep_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pch_udc_disable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					      <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_complete_receiver() - This function completes a receiver</span>
<span class="cm"> * @ep:		Reference to the endpoint structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_complete_receiver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* next request */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">pch_udc_clear_dma</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">PCH_UDC_BS_DMA_DONE</span><span class="p">)</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_RXTX_STS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PCH_UDC_RTS_SUCC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid RXTX status=0x%08x &quot;</span>
				<span class="s">&quot;epstatus=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_RXTX_STS</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCH_UDC_BS_DMA_DONE</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_RXTX_BYTES</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">td</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not complete RX descriptor&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* on 64k packets the RXBYTES field is zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">UDC_DMA_MAXPACKET</span><span class="p">))</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">UDC_DMA_MAXPACKET</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">;</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">PCH_UDC_BS_HST_BSY</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_going</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">complete_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* If there is a new/failed requests try that now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">pch_udc_start_rxrequest</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_data_in() - This function process endpoint interrupts</span>
<span class="cm"> *				for IN endpoints</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> * @ep_num:	Endpoint that generated the interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_data_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ep_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">epsts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EPIN_IDX</span><span class="p">(</span><span class="n">ep_num</span><span class="p">)];</span>
	<span class="n">epsts</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UDC_EPSTS_IN</span> <span class="o">|</span> <span class="n">UDC_EPSTS_BNA</span>  <span class="o">|</span> <span class="n">UDC_EPSTS_HE</span> <span class="o">|</span>
		       <span class="n">UDC_EPSTS_TDC</span> <span class="o">|</span> <span class="n">UDC_EPSTS_RCS</span> <span class="o">|</span> <span class="n">UDC_EPSTS_TXEMPTY</span> <span class="o">|</span>
		       <span class="n">UDC_EPSTS_RSS</span> <span class="o">|</span> <span class="n">UDC_EPSTS_XFERDONE</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_BNA</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_HE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_RSS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_RCS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">prot_stall</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_clear_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_TDC</span><span class="p">)</span>
		<span class="n">pch_udc_complete_transfer</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="cm">/* On IN interrupt, provide data if we have any */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_IN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_RSS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_TDC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_TXEMPTY</span><span class="p">))</span>
		<span class="n">pch_udc_start_next_txrequest</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_data_out() - Handles interrupts from OUT endpoint</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> * @ep_num:	Endpoint that generated the interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_data_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ep_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">epsts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span>		<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EPOUT_IDX</span><span class="p">(</span><span class="n">ep_num</span><span class="p">)];</span>
	<span class="n">epsts</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_BNA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* next request */</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span>
				 <span class="n">queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">td_data_last</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="n">PCH_UDC_BS_DMA_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dma_going</span><span class="p">)</span>
				<span class="n">pch_udc_start_rxrequest</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_HE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_RSS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_RCS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">prot_stall</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_clear_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_OUT_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDC_EPSTS_OUT_SHIFT</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">UDC_EPSTS_OUT_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">prot_stall</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pch_udc_complete_receiver</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_control_in() - Handle Control IN endpoint interrupts</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_control_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">epsts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep_out</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">];</span>
	<span class="n">ep_out</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">];</span>
	<span class="n">epsts</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UDC_EPSTS_IN</span> <span class="o">|</span> <span class="n">UDC_EPSTS_BNA</span> <span class="o">|</span> <span class="n">UDC_EPSTS_HE</span> <span class="o">|</span>
		       <span class="n">UDC_EPSTS_TDC</span> <span class="o">|</span> <span class="n">UDC_EPSTS_RCS</span> <span class="o">|</span> <span class="n">UDC_EPSTS_TXEMPTY</span> <span class="o">|</span>
		       <span class="n">UDC_EPSTS_XFERDONE</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_BNA</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_HE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_TDC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pch_udc_complete_transfer</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_clear_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
		<span class="n">ep_out</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">ep_out</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span>
					<span class="o">~</span><span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">PCH_UDC_BS_HST_RDY</span><span class="p">;</span>
		<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep_out</span><span class="p">);</span>
		<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
		<span class="n">pch_udc_ep_set_rrdy</span><span class="p">(</span><span class="n">ep_out</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* On IN interrupt, provide data if we have any */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_IN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_TDC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">epsts</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_TXEMPTY</span><span class="p">))</span>
		<span class="n">pch_udc_start_next_txrequest</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_control_out() - Routine that handle Control</span>
<span class="cm"> *					OUT endpoint interrupts</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_control_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">setup_supported</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">];</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If setup data */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_OUT_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDC_EPSTS_OUT_SHIFT</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">UDC_EPSTS_OUT_SETUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_stp</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">;</span>
		<span class="n">pch_udc_init_setup_buff</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_stp</span><span class="p">);</span>
		<span class="n">pch_udc_clear_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
		<span class="n">pch_udc_ep_fifo_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">]),</span>
				      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">in</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">))</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">ep</span><span class="p">;</span>
		<span class="k">else</span> <span class="cm">/* OUT */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* If Mass storage Reset */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">==</span> <span class="mh">0x21</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">))</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">prot_stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* call gadget with setup data received */</span>
		<span class="n">setup_supported</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span>
						<span class="o">~</span><span class="n">PCH_UDC_BUFF_STS</span><span class="p">)</span> <span class="o">|</span>
						<span class="n">PCH_UDC_BS_HST_RDY</span><span class="p">;</span>
			<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* ep0 in returns data on IN phase */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setup_supported</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">setup_supported</span> <span class="o">&lt;</span>
					    <span class="n">UDC_EP0IN_MAX_PKT_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">]));</span>
			<span class="cm">/* Gadget would have queued a request when</span>
<span class="cm">			 * we called the setup */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
				<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">setup_supported</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if unsupported request, then stall */</span>
			<span class="n">pch_udc_ep_set_stall</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">]));</span>
			<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting_zlp_ack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((((</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">UDC_EPSTS_OUT_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDC_EPSTS_OUT_SHIFT</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">UDC_EPSTS_OUT_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_clear_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
		<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span> <span class="o">=</span> <span class="n">stat</span><span class="p">;</span>
			<span class="n">pch_udc_svc_data_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCH_UDC_EP0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pch_udc_ep_set_rrdy</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pch_udc_postsvc_epinters() - This function enables end point interrupts</span>
<span class="cm"> *				and clears NAK status</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> * @ep_num:	End point number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_postsvc_epinters</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ep_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EPIN_IDX</span><span class="p">(</span><span class="n">ep_num</span><span class="p">)];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pch_udc_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">PCH_UDC_EPINT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
		<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_read_all_epstatus() - This function read all endpoint status</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> * @ep_intr:	Status of endpoint interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_read_all_epstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ep_intr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCH_UDC_USED_EP_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* IN */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EPIN_IDX</span><span class="p">(</span><span class="n">i</span><span class="p">)];</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span> <span class="o">=</span> <span class="n">pch_udc_read_ep_status</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_clear_ep_status</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* OUT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x10000</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EPOUT_IDX</span><span class="p">(</span><span class="n">i</span><span class="p">)];</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span> <span class="o">=</span> <span class="n">pch_udc_read_ep_status</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">pch_udc_clear_ep_status</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">epsts</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_activate_control_ep() - This function enables the control endpoints</span>
<span class="cm"> *					for traffic after a reset</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_activate_control_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/* Setup the IN endpoint */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">];</span>
	<span class="n">pch_udc_clear_ep_control</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">pch_udc_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_bufsz</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EP0IN_BUFF_SIZE</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_maxpkt</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EP0IN_MAX_PKT_SIZE</span><span class="p">);</span>
	<span class="cm">/* Initialize the IN EP Descriptor */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data</span>      <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_stp</span>       <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_stp_phys</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Setup the OUT endpoint */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">];</span>
	<span class="n">pch_udc_clear_ep_control</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">pch_udc_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_bufsz</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EP0OUT_BUFF_SIZE</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_maxpkt</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EP0OUT_MAX_PKT_SIZE</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">UDC_EP0OUT_MAX_PKT_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_MAX_PKT_SHIFT</span><span class="p">;</span>
	<span class="n">pch_udc_write_csr</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">UDC_EP0OUT_IDX</span><span class="p">);</span>

	<span class="cm">/* Initialize the SETUP buffer */</span>
	<span class="n">pch_udc_init_setup_buff</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_stp</span><span class="p">);</span>
	<span class="cm">/* Write the pointer address of dma descriptor */</span>
	<span class="n">pch_udc_ep_set_subptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_stp_phys</span><span class="p">);</span>
	<span class="cm">/* Write the pointer address of Setup descriptor */</span>
	<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">);</span>

	<span class="cm">/* Initialize the dma descriptor */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">status</span>  <span class="o">=</span> <span class="n">PCH_UDC_DMA_LAST</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data</span><span class="o">-&gt;</span><span class="n">next</span>    <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">td_data_phys</span><span class="p">;</span>

	<span class="n">pch_udc_ep_clear_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_ur_interrupt() - This function handles a USB reset interrupt</span>
<span class="cm"> * @dev:	Reference to driver structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_ur_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_ep</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pch_udc_clear_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_TX</span><span class="p">);</span>
	<span class="n">pch_udc_clear_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
	<span class="cm">/* Mask all endpoint interrupts */</span>
	<span class="n">pch_udc_disable_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPINT_MSK_DISABLE_ALL</span><span class="p">);</span>
	<span class="cm">/* clear all endpoint interrupts */</span>
	<span class="n">pch_udc_write_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPINT_MSK_DISABLE_ALL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCH_UDC_EP_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pch_udc_clear_ep_status</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDC_EPSTS_ALL_CLR_MASK</span><span class="p">);</span>
		<span class="n">pch_udc_clear_ep_control</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_ep_set_ddptr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">pch_udc_write_csr</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">prot_stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting_zlp_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_cfg_not_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* disable ep to empty req queue. Skip the control EP&#39;s */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">PCH_UDC_USED_EP_NUM</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pch_udc_ep_set_nak</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">pch_udc_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">);</span>
		<span class="cm">/* Complete request queue */</span>
		<span class="n">empty_req_queue</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_enum_interrupt() - This function handles a USB speed enumeration</span>
<span class="cm"> *				done interrupt</span>
<span class="cm"> * @dev:	Reference to driver structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_enum_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dev_stat</span><span class="p">,</span> <span class="n">dev_speed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>

	<span class="n">dev_stat</span> <span class="o">=</span> <span class="n">pch_udc_read_device_status</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_stat</span> <span class="o">&amp;</span> <span class="n">UDC_DEVSTS_ENUM_SPEED_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
						 <span class="n">UDC_DEVSTS_ENUM_SPEED_SHIFT</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev_speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UDC_DEVSTS_ENUM_SPEED_HIGH</span>:
		<span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span>  <span class="n">UDC_DEVSTS_ENUM_SPEED_FULL</span>:
		<span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span>  <span class="n">UDC_DEVSTS_ENUM_SPEED_LOW</span>:
		<span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_LOW</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">pch_udc_activate_control_ep</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPINT_IN_EP0</span> <span class="o">|</span> <span class="n">UDC_EPINT_OUT_EP0</span><span class="p">);</span>
	<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_TX</span><span class="p">);</span>
	<span class="n">pch_udc_set_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_DIR_RX</span><span class="p">);</span>
	<span class="n">pch_udc_ep_set_rrdy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">]));</span>

	<span class="cm">/* enable device interrupts */</span>
	<span class="n">pch_udc_enable_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVINT_UR</span> <span class="o">|</span> <span class="n">UDC_DEVINT_US</span> <span class="o">|</span>
					<span class="n">UDC_DEVINT_ES</span> <span class="o">|</span> <span class="n">UDC_DEVINT_ENUM</span> <span class="o">|</span>
					<span class="n">UDC_DEVINT_SI</span> <span class="o">|</span> <span class="n">UDC_DEVINT_SC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_intf_interrupt() - This function handles a set interface</span>
<span class="cm"> *				  interrupt</span>
<span class="cm"> * @dev:	Reference to driver structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_intf_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">dev_stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dev_stat</span> <span class="o">=</span> <span class="n">pch_udc_read_device_status</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_intf</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_stat</span> <span class="o">&amp;</span> <span class="n">UDC_DEVSTS_INTF_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
							 <span class="n">UDC_DEVSTS_INTF_SHIFT</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_alt</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_stat</span> <span class="o">&amp;</span> <span class="n">UDC_DEVSTS_ALT_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
							 <span class="n">UDC_DEVSTS_ALT_SHIFT</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_cfg_not_acked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Construct the usb request for gadget driver and inform it */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="k">sizeof</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_SET_INTERFACE</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_alt</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_intf</span><span class="p">);</span>
	<span class="cm">/* programm the Endpoint Cfg registers */</span>
	<span class="cm">/* Only one end point cfg register */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">pch_udc_read_csr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EP0OUT_IDX</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UDC_CSR_NE_INTF_MASK</span><span class="p">)</span> <span class="o">|</span>
	      <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_intf</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_INTF_SHIFT</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UDC_CSR_NE_ALT_MASK</span><span class="p">)</span> <span class="o">|</span>
	      <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_alt</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_ALT_SHIFT</span><span class="p">);</span>
	<span class="n">pch_udc_write_csr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">UDC_EP0OUT_IDX</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCH_UDC_USED_EP_NUM</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* clear stall bits */</span>
		<span class="n">pch_udc_ep_clear_stall</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_svc_cfg_interrupt() - This function handles a set configuration</span>
<span class="cm"> *				interrupt</span>
<span class="cm"> * @dev:	Reference to driver structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_svc_cfg_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">dev_stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_stat</span> <span class="o">=</span> <span class="n">pch_udc_read_device_status</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_cfg_not_acked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_cfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_stat</span> <span class="o">&amp;</span> <span class="n">UDC_DEVSTS_CFG_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				<span class="n">UDC_DEVSTS_CFG_SHIFT</span><span class="p">;</span>
	<span class="cm">/* make usb request for gadget driver */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="k">sizeof</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_SET_CONFIGURATION</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_cfg</span><span class="p">);</span>
	<span class="cm">/* program the NE registers */</span>
	<span class="cm">/* Only one end point cfg register */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">pch_udc_read_csr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EP0OUT_IDX</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UDC_CSR_NE_CFG_MASK</span><span class="p">)</span> <span class="o">|</span>
	      <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_data</span><span class="p">.</span><span class="n">cur_cfg</span> <span class="o">&lt;&lt;</span> <span class="n">UDC_CSR_NE_CFG_SHIFT</span><span class="p">);</span>
	<span class="n">pch_udc_write_csr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">UDC_EP0OUT_IDX</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCH_UDC_USED_EP_NUM</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* clear stall bits */</span>
		<span class="n">pch_udc_ep_clear_stall</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* call gadget zero with setup data received */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">setup_data</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_dev_isr() - This function services device interrupts</span>
<span class="cm"> *			by invoking appropriate routines.</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> * @dev_intr:	The Device interrupt status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_dev_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dev_intr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vbus</span><span class="p">;</span>

	<span class="cm">/* USB Reset Interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_UR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_svc_ur_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB_RESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Enumeration Done Interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_ENUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_svc_enum_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB_ENUM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Set Interface Interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_SI</span><span class="p">)</span>
		<span class="n">pch_udc_svc_intf_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* Set Config Interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_SC</span><span class="p">)</span>
		<span class="n">pch_udc_svc_cfg_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* USB Suspend interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_US</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span>
			<span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">vbus</span> <span class="o">=</span> <span class="n">pch_vbus_gpio_get_value</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_session</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vbus</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">pch_udc_reconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_session</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vbus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span><span class="p">)</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">irq_work_fall</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB_SUSPEND</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Clear the SOF interrupt, if enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_SOF</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SOF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* ES interrupt, IDLE &gt; 3ms on the USB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_ES</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* RWKP interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">&amp;</span> <span class="n">UDC_DEVINT_RWKP</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RWKP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_isr() - This function handles interrupts from the PCH USB Device</span>
<span class="cm"> * @irq:	Interrupt request number</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pch_udc_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="p">)</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dev_intr</span><span class="p">,</span> <span class="n">ep_intr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_intr</span> <span class="o">=</span> <span class="n">pch_udc_read_device_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ep_intr</span> <span class="o">=</span> <span class="n">pch_udc_read_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* For a hot plug, this find that the controller is hung up. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">==</span> <span class="n">ep_intr</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span> <span class="o">==</span> <span class="n">pch_udc_readl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVCFG_ADDR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;UDC: Hung up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* The controller is reset */</span>
			<span class="n">pch_udc_writel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_SRST</span><span class="p">,</span> <span class="n">UDC_SRST_ADDR</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span><span class="p">)</span>
		<span class="cm">/* Clear device interrupts */</span>
		<span class="n">pch_udc_write_device_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_intr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span><span class="p">)</span>
		<span class="cm">/* Clear ep interrupts */</span>
		<span class="n">pch_udc_write_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep_intr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_intr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_intr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_intr</span><span class="p">)</span>
		<span class="n">pch_udc_dev_isr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_intr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pch_udc_read_all_epstatus</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep_intr</span><span class="p">);</span>
		<span class="cm">/* Process Control In interrupts, if present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span> <span class="o">&amp;</span> <span class="n">UDC_EPINT_IN_EP0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pch_udc_svc_control_in</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">pch_udc_postsvc_epinters</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Process Control Out interrupts, if present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span> <span class="o">&amp;</span> <span class="n">UDC_EPINT_OUT_EP0</span><span class="p">)</span>
			<span class="n">pch_udc_svc_control_out</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* Process data in end point interrupts */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCH_UDC_USED_EP_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pch_udc_svc_data_in</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">pch_udc_postsvc_epinters</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Process data out end point interrupts */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">UDC_EPINT_OUT_SHIFT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">UDC_EPINT_OUT_SHIFT</span> <span class="o">+</span>
						 <span class="n">PCH_UDC_USED_EP_NUM</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep_intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="n">i</span><span class="p">))</span>
				<span class="n">pch_udc_svc_data_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span>
							 <span class="n">UDC_EPINT_OUT_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_setup_ep0() - This function enables control endpoint for traffic</span>
<span class="cm"> * @dev:	Reference to the device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_setup_ep0</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* enable ep0 interrupts */</span>
	<span class="n">pch_udc_enable_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPINT_IN_EP0</span> <span class="o">|</span>
						<span class="n">UDC_EPINT_OUT_EP0</span><span class="p">);</span>
	<span class="cm">/* enable device interrupts */</span>
	<span class="n">pch_udc_enable_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVINT_UR</span> <span class="o">|</span> <span class="n">UDC_DEVINT_US</span> <span class="o">|</span>
				       <span class="n">UDC_DEVINT_ES</span> <span class="o">|</span> <span class="n">UDC_DEVINT_ENUM</span> <span class="o">|</span>
				       <span class="n">UDC_DEVINT_SI</span> <span class="o">|</span> <span class="n">UDC_DEVINT_SC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gadget_release() - Free the gadget driver private data</span>
<span class="cm"> * @pdev	reference to struct pci_dev</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gadget_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_reinit() - This API initializes the endpoint structures</span>
<span class="cm"> * @dev:	Reference to the driver structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_pcd_reinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">ep_string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">ep0_string</span><span class="p">,</span> <span class="s">&quot;ep0out&quot;</span><span class="p">,</span> <span class="s">&quot;ep1in&quot;</span><span class="p">,</span> <span class="s">&quot;ep1out&quot;</span><span class="p">,</span> <span class="s">&quot;ep2in&quot;</span><span class="p">,</span> <span class="s">&quot;ep2out&quot;</span><span class="p">,</span>
		<span class="s">&quot;ep3in&quot;</span><span class="p">,</span> <span class="s">&quot;ep3out&quot;</span><span class="p">,</span> <span class="s">&quot;ep4in&quot;</span><span class="p">,</span> <span class="s">&quot;ep4out&quot;</span><span class="p">,</span> <span class="s">&quot;ep5in&quot;</span><span class="p">,</span> <span class="s">&quot;ep5out&quot;</span><span class="p">,</span>
		<span class="s">&quot;ep6in&quot;</span><span class="p">,</span> <span class="s">&quot;ep6out&quot;</span><span class="p">,</span> <span class="s">&quot;ep7in&quot;</span><span class="p">,</span> <span class="s">&quot;ep7out&quot;</span><span class="p">,</span> <span class="s">&quot;ep8in&quot;</span><span class="p">,</span> <span class="s">&quot;ep8out&quot;</span><span class="p">,</span>
		<span class="s">&quot;ep9in&quot;</span><span class="p">,</span> <span class="s">&quot;ep9out&quot;</span><span class="p">,</span> <span class="s">&quot;ep10in&quot;</span><span class="p">,</span> <span class="s">&quot;ep10out&quot;</span><span class="p">,</span> <span class="s">&quot;ep11in&quot;</span><span class="p">,</span> <span class="s">&quot;ep11out&quot;</span><span class="p">,</span>
		<span class="s">&quot;ep12in&quot;</span><span class="p">,</span> <span class="s">&quot;ep12out&quot;</span><span class="p">,</span> <span class="s">&quot;ep13in&quot;</span><span class="p">,</span> <span class="s">&quot;ep13out&quot;</span><span class="p">,</span> <span class="s">&quot;ep14in&quot;</span><span class="p">,</span> <span class="s">&quot;ep14out&quot;</span><span class="p">,</span>
		<span class="s">&quot;ep15in&quot;</span><span class="p">,</span> <span class="s">&quot;ep15out&quot;</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>

	<span class="cm">/* Initialize the endpoints structures */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCH_UDC_EP_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pch_udc_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">=</span> <span class="o">~</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ep_string</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pch_udc_ep_ops</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">)</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">offset_addr</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">*</span> <span class="n">UDC_EP_REG_SHIFT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">offset_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">UDC_EPINT_OUT_SHIFT</span> <span class="o">+</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="o">*</span>
					  <span class="n">UDC_EP_REG_SHIFT</span><span class="p">;</span>
		<span class="cm">/* need to set ep-&gt;ep.maxpacket and set Default Configuration?*/</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">UDC_BULK_MAX_PKT_SIZE</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">UDC_EP0IN_MAX_PKT_SIZE</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">UDC_EP0OUT_MAX_PKT_SIZE</span><span class="p">;</span>

	<span class="cm">/* remove ep0 in and out from the list.  They have own pointer */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pch_udc_pcd_init() - This API initializes the driver structure</span>
<span class="cm"> * @dev:	Reference to the driver structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	0: Success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_pcd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pch_udc_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pch_udc_pcd_reinit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pch_vbus_gpio_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vbus_gpio_port</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_dma_pools() - create dma pools during initialization</span>
<span class="cm"> * @pdev:	reference to struct pci_dev</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_dma_pools</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_stp_dma_desc</span>	<span class="o">*</span><span class="n">td_stp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span>	<span class="o">*</span><span class="n">td_data</span><span class="p">;</span>

	<span class="cm">/* DMA setup */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span> <span class="o">=</span> <span class="n">pci_pool_create</span><span class="p">(</span><span class="s">&quot;data_requests&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_data_dma_desc</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: can&#39;t get request data pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* dma desc for setup data */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stp_requests</span> <span class="o">=</span> <span class="n">pci_pool_create</span><span class="p">(</span><span class="s">&quot;setup requests&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pch_udc_stp_dma_desc</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stp_requests</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: can&#39;t get setup request pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* setup */</span>
	<span class="n">td_stp</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stp_requests</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_stp_phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td_stp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: can&#39;t allocate setup dma descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_stp</span> <span class="o">=</span> <span class="n">td_stp</span><span class="p">;</span>

	<span class="cm">/* data: 0 packets !? */</span>
	<span class="n">td_data</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_data_phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: can&#39;t allocate data dma descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_data</span> <span class="o">=</span> <span class="n">td_data</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">td_stp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">td_stp_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">td_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0IN_IDX</span><span class="p">].</span><span class="n">td_data_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0out_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">UDC_EP0OUT_BUFF_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0out_buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0out_buf</span><span class="p">,</span>
				       <span class="n">UDC_EP0OUT_BUFF_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
				       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pch_udc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">max_speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">bind</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: invalid driver parameter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: already bound</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="cm">/* Invoke the bind routine of the gadget driver */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: binding to %s returning %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* get ready for ep0 traffic */</span>
	<span class="n">pch_udc_setup_ep0</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* clear SD */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pch_vbus_gpio_get_value</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">.</span><span class="n">intr</span><span class="p">)</span>
		<span class="n">pch_udc_clear_disconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pch_udc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="p">(</span><span class="n">driver</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: invalid driver parameter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pch_udc_disable_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVINT_MSK</span><span class="p">);</span>

	<span class="cm">/* Assures that there are no pending requests with this driver */</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set SD */</span>
	<span class="n">pch_udc_set_disconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pch_udc_disable_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVINT_MSK</span><span class="p">);</span>
	<span class="n">pch_udc_disable_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPINT_MSK_DISABLE_ALL</span><span class="p">);</span>

	<span class="cm">/* disable the pullup so the host will think we&#39;re gone */</span>
	<span class="n">pch_udc_set_disconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pch_udc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">usb_del_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>

	<span class="cm">/* gadget driver must not be registered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: gadget driver still bound!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="cm">/* dma pool cleanup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">)</span>
		<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data_requests</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stp_requests</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cleanup DMA desc&#39;s for ep0in */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_stp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stp_requests</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_stp</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_stp_phys</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stp_requests</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_data</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">UDC_EP0OUT_IDX</span><span class="p">].</span><span class="n">td_data_phys</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stp_requests</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
				 <span class="n">UDC_EP0OUT_BUFF_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0out_buf</span><span class="p">);</span>

	<span class="n">pch_vbus_gpio_free</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pch_udc_exit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_registered</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_region</span><span class="p">)</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span>
				   <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCH_UDC_PCI_BAR</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pch_udc_disable_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_DEVINT_MSK</span><span class="p">);</span>
	<span class="n">pch_udc_disable_ep_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDC_EPINT_MSK_DISABLE_ALL</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: could not save PCI config state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: pci_enable_device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define pch_udc_suspend	NULL</span>
<span class="cp">#define pch_udc_resume	NULL</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pch_udc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">resource</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pch_udc_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* one udc only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pch_udc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: already probed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* init */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: no memory for device structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* pci setup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: pci_enable_device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* PCI resource allocation */</span>
	<span class="n">resource</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">KBUILD_MODNAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: pci device used already</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">resource</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_region</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: device memory cannot be mapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: irq not set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pch_udc</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="cm">/* initialize the hardware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pch_udc_pcd_init</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pch_udc_isr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
			<span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: request_irq(%d) fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_try_set_mwi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* device struct setup */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pch_udc_ops</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">init_dma_pools</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>

	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gadget&quot;</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">gadget_release</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">max_speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Put the device in disconnected state till a driver is bound */</span>
	<span class="n">pch_udc_set_disconnect</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">finished:</span>
	<span class="n">pch_udc_remove</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">pch_udc_pcidev_id</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_EG20T_UDC</span><span class="p">),</span>
		<span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCI_CLASS_SERIAL_USB</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xfe</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ROHM</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ML7213_IOH_UDC</span><span class="p">),</span>
		<span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCI_CLASS_SERIAL_USB</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xfe</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ROHM</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ML7831_IOH_UDC</span><span class="p">),</span>
		<span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCI_CLASS_SERIAL_USB</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xfe</span><span class="p">,</span>
		<span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pch_udc_pcidev_id</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pch_udc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>	<span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">pch_udc_pcidev_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">pch_udc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span>	<span class="n">pch_udc_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">pch_udc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">pch_udc_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">pch_udc_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_pci_driver</span><span class="p">(</span><span class="n">pch_udc_driver</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel EG20T USB Device Controller&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;LAPIS Semiconductor, &lt;tomoya-linux@dsn.lapis-semi.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
