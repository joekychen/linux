<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › file_storage.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>file_storage.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * file_storage.c -- File-backed USB Storage Gadget, for USB development</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003-2008 Alan Stern</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. The names of the above-listed copyright holders may not be used</span>
<span class="cm"> *    to endorse or promote products derived from this software without</span>
<span class="cm"> *    specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * ALTERNATIVELY, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) as published by the Free Software</span>
<span class="cm"> * Foundation, either version 2 of that License or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span>
<span class="cm"> * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span>
<span class="cm"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<span class="cm"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span>
<span class="cm"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<span class="cm"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
<span class="cm"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<span class="cm"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="cm"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="cm"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * The File-backed Storage Gadget acts as a USB Mass Storage device,</span>
<span class="cm"> * appearing to the host as a disk drive or as a CD-ROM drive.  In addition</span>
<span class="cm"> * to providing an example of a genuinely useful gadget driver for a USB</span>
<span class="cm"> * device, it also illustrates a technique of double-buffering for increased</span>
<span class="cm"> * throughput.  Last but not least, it gives an easy way to probe the</span>
<span class="cm"> * behavior of the Mass Storage drivers in a USB host.</span>
<span class="cm"> *</span>
<span class="cm"> * Backing storage is provided by a regular file or a block device, specified</span>
<span class="cm"> * by the &quot;file&quot; module parameter.  Access can be limited to read-only by</span>
<span class="cm"> * setting the optional &quot;ro&quot; module parameter.  (For CD-ROM emulation,</span>
<span class="cm"> * access is always read-only.)  The gadget will indicate that it has</span>
<span class="cm"> * removable media if the optional &quot;removable&quot; module parameter is set.</span>
<span class="cm"> *</span>
<span class="cm"> * The gadget supports the Control-Bulk (CB), Control-Bulk-Interrupt (CBI),</span>
<span class="cm"> * and Bulk-Only (also known as Bulk-Bulk-Bulk or BBB) transports, selected</span>
<span class="cm"> * by the optional &quot;transport&quot; module parameter.  It also supports the</span>
<span class="cm"> * following protocols: RBC (0x01), ATAPI or SFF-8020i (0x02), QIC-157 (0c03),</span>
<span class="cm"> * UFI (0x04), SFF-8070i (0x05), and transparent SCSI (0x06), selected by</span>
<span class="cm"> * the optional &quot;protocol&quot; module parameter.  In addition, the default</span>
<span class="cm"> * Vendor ID, Product ID, release number and serial number can be overridden.</span>
<span class="cm"> *</span>
<span class="cm"> * There is support for multiple logical units (LUNs), each of which has</span>
<span class="cm"> * its own backing file.  The number of LUNs can be set using the optional</span>
<span class="cm"> * &quot;luns&quot; module parameter (anywhere from 1 to 8), and the corresponding</span>
<span class="cm"> * files are specified using comma-separated lists for &quot;file&quot; and &quot;ro&quot;.</span>
<span class="cm"> * The default number of LUNs is taken from the number of &quot;file&quot; elements;</span>
<span class="cm"> * it is 1 if &quot;file&quot; is not given.  If &quot;removable&quot; is not set then a backing</span>
<span class="cm"> * file must be specified for each LUN.  If it is set, then an unspecified</span>
<span class="cm"> * or empty backing filename means the LUN&#39;s medium is not loaded.  Ideally</span>
<span class="cm"> * each LUN would be settable independently as a disk drive or a CD-ROM</span>
<span class="cm"> * drive, but currently all LUNs have to be the same type.  The CD-ROM</span>
<span class="cm"> * emulation includes a single data track and no audio tracks; hence there</span>
<span class="cm"> * need be only one backing file per LUN.</span>
<span class="cm"> *</span>
<span class="cm"> * Requirements are modest; only a bulk-in and a bulk-out endpoint are</span>
<span class="cm"> * needed (an interrupt-out endpoint is also needed for CBI).  The memory</span>
<span class="cm"> * requirement amounts to two 16K buffers, size configurable by a parameter.</span>
<span class="cm"> * Support is included for both full-speed and high-speed operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the driver is slightly non-portable in that it assumes a</span>
<span class="cm"> * single memory/DMA buffer will be useable for bulk-in, bulk-out, and</span>
<span class="cm"> * interrupt-in endpoints.  With most device controllers this isn&#39;t an</span>
<span class="cm"> * issue, but there may be some with hardware restrictions that prevent</span>
<span class="cm"> * a buffer from being used by more than one endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Module options:</span>
<span class="cm"> *</span>
<span class="cm"> *	file=filename[,filename...]</span>
<span class="cm"> *				Required if &quot;removable&quot; is not set, names of</span>
<span class="cm"> *					the files or block devices used for</span>
<span class="cm"> *					backing storage</span>
<span class="cm"> *	serial=HHHH...		Required serial number (string of hex chars)</span>
<span class="cm"> *	ro=b[,b...]		Default false, booleans for read-only access</span>
<span class="cm"> *	removable		Default false, boolean for removable media</span>
<span class="cm"> *	luns=N			Default N = number of filenames, number of</span>
<span class="cm"> *					LUNs to support</span>
<span class="cm"> *	nofua=b[,b...]		Default false, booleans for ignore FUA flag</span>
<span class="cm"> *					in SCSI WRITE(10,12) commands</span>
<span class="cm"> *	stall			Default determined according to the type of</span>
<span class="cm"> *					USB device controller (usually true),</span>
<span class="cm"> *					boolean to permit the driver to halt</span>
<span class="cm"> *					bulk endpoints</span>
<span class="cm"> *	cdrom			Default false, boolean for whether to emulate</span>
<span class="cm"> *					a CD-ROM drive</span>
<span class="cm"> *	transport=XXX		Default BBB, transport name (CB, CBI, or BBB)</span>
<span class="cm"> *	protocol=YYY		Default SCSI, protocol name (RBC, 8020 or</span>
<span class="cm"> *					ATAPI, QIC, UFI, 8070, or SCSI;</span>
<span class="cm"> *					also 1 - 6)</span>
<span class="cm"> *	vendor=0xVVVV		Default 0x0525 (NetChip), USB Vendor ID</span>
<span class="cm"> *	product=0xPPPP		Default 0xa4a5 (FSG), USB Product ID</span>
<span class="cm"> *	release=0xRRRR		Override the USB release number (bcdDevice)</span>
<span class="cm"> *	buflen=N		Default N=16384, buffer size used (will be</span>
<span class="cm"> *					rounded down to a multiple of</span>
<span class="cm"> *					PAGE_CACHE_SIZE)</span>
<span class="cm"> *</span>
<span class="cm"> * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the &quot;file&quot;, &quot;serial&quot;, &quot;ro&quot;,</span>
<span class="cm"> * &quot;removable&quot;, &quot;luns&quot;, &quot;nofua&quot;, &quot;stall&quot;, and &quot;cdrom&quot; options are available;</span>
<span class="cm"> * default values are used for everything else.</span>
<span class="cm"> *</span>
<span class="cm"> * The pathnames of the backing files and the ro settings are available in</span>
<span class="cm"> * the attribute files &quot;file&quot;, &quot;nofua&quot;, and &quot;ro&quot; in the lun&lt;n&gt; subdirectory of</span>
<span class="cm"> * the gadget&#39;s sysfs directory.  If the &quot;removable&quot; option is set, writing to</span>
<span class="cm"> * these files will simulate ejecting/loading the medium (writing an empty</span>
<span class="cm"> * line means eject) and adjusting a write-enable tab.  Changes to the ro</span>
<span class="cm"> * setting are not allowed when the medium is loaded or if CD-ROM emulation</span>
<span class="cm"> * is being used.</span>
<span class="cm"> *</span>
<span class="cm"> * This gadget driver is heavily based on &quot;Gadget Zero&quot; by David Brownell.</span>
<span class="cm"> * The driver&#39;s SCSI command interface was based on the &quot;Information</span>
<span class="cm"> * technology - Small Computer System Interface - 2&quot; document from</span>
<span class="cm"> * X3T9.2 Project 375D, Revision 10L, 7-SEP-93, available at</span>
<span class="cm"> * &lt;http://www.t10.org/ftp/t10/drafts/s2/s2-r10l.pdf&gt;.  The single exception</span>
<span class="cm"> * is opcode 0x23 (READ FORMAT CAPACITIES), which was based on the</span>
<span class="cm"> * &quot;Universal Serial Bus Mass Storage Class UFI Command Specification&quot;</span>
<span class="cm"> * document, Revision 1.0, December 14, 1998, available at</span>
<span class="cm"> * &lt;http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf&gt;.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> *				Driver Design</span>
<span class="cm"> *</span>
<span class="cm"> * The FSG driver is fairly straightforward.  There is a main kernel</span>
<span class="cm"> * thread that handles most of the work.  Interrupt routines field</span>
<span class="cm"> * callbacks from the controller driver: bulk- and interrupt-request</span>
<span class="cm"> * completion notifications, endpoint-0 events, and disconnect events.</span>
<span class="cm"> * Completion events are passed to the main thread by wakeup calls.  Many</span>
<span class="cm"> * ep0 requests are handled at interrupt time, but SetInterface,</span>
<span class="cm"> * SetConfiguration, and device reset requests are forwarded to the</span>
<span class="cm"> * thread in the form of &quot;exceptions&quot; using SIGUSR1 signals (since they</span>
<span class="cm"> * should interrupt any ongoing file I/O operations).</span>
<span class="cm"> *</span>
<span class="cm"> * The thread&#39;s main routine implements the standard command/data/status</span>
<span class="cm"> * parts of a SCSI interaction.  It and its subroutines are full of tests</span>
<span class="cm"> * for pending signals/exceptions -- all this polling is necessary since</span>
<span class="cm"> * the kernel has no setjmp/longjmp equivalents.  (Maybe this is an</span>
<span class="cm"> * indication that the driver really wants to be running in userspace.)</span>
<span class="cm"> * An important point is that so long as the thread is alive it keeps an</span>
<span class="cm"> * open reference to the backing file.  This will prevent unmounting</span>
<span class="cm"> * the backing file&#39;s underlying filesystem and could cause problems</span>
<span class="cm"> * during system shutdown, for example.  To prevent such problems, the</span>
<span class="cm"> * thread catches INT, TERM, and KILL signals and converts them into</span>
<span class="cm"> * an EXIT exception.</span>
<span class="cm"> *</span>
<span class="cm"> * In normal operation the main thread is started during the gadget&#39;s</span>
<span class="cm"> * fsg_bind() callback and stopped during fsg_unbind().  But it can also</span>
<span class="cm"> * exit when it receives a signal, and there&#39;s no point leaving the</span>
<span class="cm"> * gadget running when the thread is dead.  So just before the thread</span>
<span class="cm"> * exits, it deregisters the gadget driver.  This makes things a little</span>
<span class="cm"> * tricky: The driver is deregistered at two places, and the exiting</span>
<span class="cm"> * thread can indirectly call fsg_unbind() which in turn can tell the</span>
<span class="cm"> * thread to exit.  The first problem is resolved through the use of the</span>
<span class="cm"> * REGISTERED atomic bitflag; the driver will only be deregistered once.</span>
<span class="cm"> * The second problem is resolved by having fsg_unbind() check</span>
<span class="cm"> * fsg-&gt;state; it won&#39;t try to stop the thread if the state is already</span>
<span class="cm"> * FSG_STATE_TERMINATED.</span>
<span class="cm"> *</span>
<span class="cm"> * To provide maximum throughput, the driver uses a circular pipeline of</span>
<span class="cm"> * buffer heads (struct fsg_buffhd).  In principle the pipeline can be</span>
<span class="cm"> * arbitrarily long; in practice the benefits don&#39;t justify having more</span>
<span class="cm"> * than 2 stages (i.e., double buffering).  But it helps to think of the</span>
<span class="cm"> * pipeline as being a long one.  Each buffer head contains a bulk-in and</span>
<span class="cm"> * a bulk-out request pointer (since the buffer can be used for both</span>
<span class="cm"> * output and input -- directions always are given from the host&#39;s</span>
<span class="cm"> * point of view) as well as a pointer to the buffer and various state</span>
<span class="cm"> * variables.</span>
<span class="cm"> *</span>
<span class="cm"> * Use of the pipeline follows a simple protocol.  There is a variable</span>
<span class="cm"> * (fsg-&gt;next_buffhd_to_fill) that points to the next buffer head to use.</span>
<span class="cm"> * At any time that buffer head may still be in use from an earlier</span>
<span class="cm"> * request, so each buffer head has a state variable indicating whether</span>
<span class="cm"> * it is EMPTY, FULL, or BUSY.  Typical use involves waiting for the</span>
<span class="cm"> * buffer head to be EMPTY, filling the buffer either by file I/O or by</span>
<span class="cm"> * USB I/O (during which the buffer head is BUSY), and marking the buffer</span>
<span class="cm"> * head FULL when the I/O is complete.  Then the buffer will be emptied</span>
<span class="cm"> * (again possibly by USB I/O, during which it is marked BUSY) and</span>
<span class="cm"> * finally marked EMPTY again (possibly by a completion routine).</span>
<span class="cm"> *</span>
<span class="cm"> * A module parameter tells the driver to avoid stalling the bulk</span>
<span class="cm"> * endpoints wherever the transport specification allows.  This is</span>
<span class="cm"> * necessary for some UDCs like the SuperH, which cannot reliably clear a</span>
<span class="cm"> * halt on a bulk endpoint.  However, under certain circumstances the</span>
<span class="cm"> * Bulk-only specification requires a stall.  In such cases the driver</span>
<span class="cm"> * will halt the endpoint and set a flag indicating that it should clear</span>
<span class="cm"> * the halt in software during the next device reset.  Hopefully this</span>
<span class="cm"> * will permit everything to work correctly.  Furthermore, although the</span>
<span class="cm"> * specification allows the bulk-out endpoint to halt when the host sends</span>
<span class="cm"> * too much data, implementing this would cause an unavoidable race.</span>
<span class="cm"> * The driver will always use the &quot;no-stall&quot; approach for OUT transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * One subtle point concerns sending status-stage responses for ep0</span>
<span class="cm"> * requests.  Some of these requests, such as device reset, can involve</span>
<span class="cm"> * interrupting an ongoing file I/O operation, which might take an</span>
<span class="cm"> * arbitrarily long time.  During that delay the host might give up on</span>
<span class="cm"> * the original ep0 request and issue a new one.  When that happens the</span>
<span class="cm"> * driver should not notify the host about completion of the original</span>
<span class="cm"> * request, as the host will no longer be waiting for it.  So the driver</span>
<span class="cm"> * assigns to each ep0 request a unique tag, and it keeps track of the</span>
<span class="cm"> * tag value of the request associated with a long-running exception</span>
<span class="cm"> * (device-reset, interface-change, or configuration-change).  When the</span>
<span class="cm"> * exception handler is finished, the status-stage response is submitted</span>
<span class="cm"> * only if the current ep0 request tag is equal to the exception request</span>
<span class="cm"> * tag.  Thus only the most recently received ep0 request will get a</span>
<span class="cm"> * status-stage response.</span>
<span class="cm"> *</span>
<span class="cm"> * Warning: This driver source file is too long.  It ought to be split up</span>
<span class="cm"> * into a header file plus about 3 separate .c files, to handle the details</span>
<span class="cm"> * of the Gadget, USB Mass Storage, and SCSI protocols.</span>
<span class="cm"> */</span>


<span class="cm">/* #define VERBOSE_DEBUG */</span>
<span class="cm">/* #define DUMP_MSGS */</span>


<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/limits.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>

<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>

<span class="cp">#include &quot;gadget_chips.h&quot;</span>



<span class="cm">/*</span>
<span class="cm"> * Kbuild is not very cooperative with respect to linking separately</span>
<span class="cm"> * compiled library objects into one module.  So for now we won&#39;t use</span>
<span class="cm"> * separate compilation ... ensuring init/exit sections work to shrink</span>
<span class="cm"> * the runtime footprint, and giving us at least some parts of what</span>
<span class="cm"> * a &quot;gcc --combine ... part1.c part2.c part3.c ... &quot; build would.</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;usbstring.c&quot;</span>
<span class="cp">#include &quot;config.c&quot;</span>
<span class="cp">#include &quot;epautoconf.c&quot;</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define DRIVER_DESC		&quot;File-backed Storage Gadget&quot;</span>
<span class="cp">#define DRIVER_NAME		&quot;g_file_storage&quot;</span>
<span class="cp">#define DRIVER_VERSION		&quot;1 September 2010&quot;</span>

<span class="k">static</span>       <span class="kt">char</span> <span class="n">fsg_string_manufacturer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">fsg_string_product</span><span class="p">[]</span> <span class="o">=</span> <span class="n">DRIVER_DESC</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">fsg_string_config</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Self-powered&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">fsg_string_interface</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Mass Storage&quot;</span><span class="p">;</span>


<span class="cp">#include &quot;storage_common.c&quot;</span>


<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Alan Stern&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This driver assumes self-powered hardware and has no way for users to</span>
<span class="cm"> * trigger remote wakeup.  It uses autoconfiguration to select endpoints</span>
<span class="cm"> * and endpoint addresses.</span>
<span class="cm"> */</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>


<span class="cm">/* Encapsulate the module parameter settings */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">serial</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">ro</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>
	<span class="n">bool</span>		<span class="n">nofua</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">num_filenames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">num_ros</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">num_nofuas</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">nluns</span><span class="p">;</span>

	<span class="n">bool</span>		<span class="n">removable</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">can_stall</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">cdrom</span><span class="p">;</span>

	<span class="kt">char</span>		<span class="o">*</span><span class="n">transport_parm</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">protocol_parm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">vendor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">product</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">release</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">buflen</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">transport_type</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">transport_name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">protocol_type</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">protocol_name</span><span class="p">;</span>

<span class="p">}</span> <span class="n">mod_data</span> <span class="o">=</span> <span class="p">{</span>					<span class="c1">// Default values</span>
	<span class="p">.</span><span class="n">transport_parm</span>		<span class="o">=</span> <span class="s">&quot;BBB&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">protocol_parm</span>		<span class="o">=</span> <span class="s">&quot;SCSI&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removable</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_stall</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cdrom</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vendor</span>			<span class="o">=</span> <span class="n">FSG_VENDOR_ID</span><span class="p">,</span>
	<span class="p">.</span><span class="n">product</span>		<span class="o">=</span> <span class="n">FSG_PRODUCT_ID</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span>	<span class="c1">// Use controller chip type</span>
	<span class="p">.</span><span class="n">buflen</span>			<span class="o">=</span> <span class="mi">16384</span><span class="p">,</span>
	<span class="p">};</span>


<span class="n">module_param_array_named</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod_data</span><span class="p">.</span><span class="n">num_filenames</span><span class="p">,</span>
		<span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">&quot;names of backing files or devices&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="s">&quot;USB serial number&quot;</span><span class="p">);</span>

<span class="n">module_param_array_named</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">ro</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod_data</span><span class="p">.</span><span class="n">num_ros</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="s">&quot;true to force read-only&quot;</span><span class="p">);</span>

<span class="n">module_param_array_named</span><span class="p">(</span><span class="n">nofua</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">nofua</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod_data</span><span class="p">.</span><span class="n">num_nofuas</span><span class="p">,</span>
		<span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nofua</span><span class="p">,</span> <span class="s">&quot;true to ignore SCSI WRITE(10,12) FUA bit&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">luns</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">nluns</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">luns</span><span class="p">,</span> <span class="s">&quot;number of LUNs&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">removable</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">removable</span><span class="p">,</span> <span class="s">&quot;true to simulate removable media&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">stall</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">can_stall</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">stall</span><span class="p">,</span> <span class="s">&quot;false to prevent bulk stalls&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">cdrom</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cdrom</span><span class="p">,</span> <span class="s">&quot;true to emulate cdrom instead of disk&quot;</span><span class="p">);</span>

<span class="cm">/* In the non-TEST version, only the module parameters listed above</span>
<span class="cm"> * are available. */</span>
<span class="cp">#ifdef CONFIG_USB_FILE_STORAGE_TEST</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">transport_parm</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="s">&quot;type of transport (BBB, CBI, or CB)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="s">&quot;type of protocol (RBC, 8020, QIC, UFI, &quot;</span>
		<span class="s">&quot;8070, or SCSI)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="s">&quot;USB Vendor ID&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">product</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="s">&quot;USB Product ID&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">release</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">release</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">release</span><span class="p">,</span> <span class="s">&quot;USB release number&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">buflen</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;I/O buffer size&quot;</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_FILE_STORAGE_TEST */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * These definitions will permit the compiler to avoid generating code for</span>
<span class="cm"> * parts of the driver that aren&#39;t used in the non-TEST version.  Even gcc</span>
<span class="cm"> * can recognize when a test of a constant expression yields a dead code</span>
<span class="cm"> * path.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_USB_FILE_STORAGE_TEST</span>

<span class="cp">#define transport_is_bbb()	(mod_data.transport_type == USB_PR_BULK)</span>
<span class="cp">#define transport_is_cbi()	(mod_data.transport_type == USB_PR_CBI)</span>
<span class="cp">#define protocol_is_scsi()	(mod_data.protocol_type == USB_SC_SCSI)</span>

<span class="cp">#else</span>

<span class="cp">#define transport_is_bbb()	1</span>
<span class="cp">#define transport_is_cbi()	0</span>
<span class="cp">#define protocol_is_scsi()	1</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_FILE_STORAGE_TEST */</span><span class="cp"></span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>


<span class="k">struct</span> <span class="n">fsg_dev</span> <span class="p">{</span>
	<span class="cm">/* lock protects: state, all the req_busy&#39;s, and cbbuf_cmnd */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>	<span class="o">*</span><span class="n">gadget</span><span class="p">;</span>

	<span class="cm">/* filesem protects: backing files in use */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">filesem</span><span class="p">;</span>

	<span class="cm">/* reference counting: wait until all LUNs are released */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">ref</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">ep0</span><span class="p">;</span>		<span class="c1">// Handy copy of gadget-&gt;ep0</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">ep0req</span><span class="p">;</span>	<span class="c1">// For control responses</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ep0_req_tag</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">ep0req_name</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">intreq</span><span class="p">;</span>	<span class="c1">// For interrupt responses</span>
	<span class="kt">int</span>			<span class="n">intreq_busy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">intr_buffhd</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bulk_out_maxpacket</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fsg_state</span>		<span class="n">state</span><span class="p">;</span>		<span class="c1">// For exception handling</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">exception_req_tag</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">config</span><span class="p">,</span> <span class="n">new_config</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">running</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bulk_in_enabled</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bulk_out_enabled</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">intr_in_enabled</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">phase_error</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">short_packet_received</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bad_lun_okay</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">atomic_bitflags</span><span class="p">;</span>
<span class="cp">#define REGISTERED		0</span>
<span class="cp">#define IGNORE_BULK_OUT		1</span>
<span class="cp">#define SUSPENDED		2</span>

	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">bulk_in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">bulk_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">intr_in</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">next_buffhd_to_drain</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">thread_wakeup_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">thread_notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">thread_task</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">cmnd_size</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">cmnd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">data_direction</span>	<span class="n">data_dir</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">data_size</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">data_size_from_cmnd</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">tag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">lun</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">residue</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">usb_amount_left</span><span class="p">;</span>

	<span class="cm">/* The CB protocol offers no way for a host to know when a command</span>
<span class="cm">	 * has completed.  As a result the next command may arrive early,</span>
<span class="cm">	 * and we will still have to handle it.  For that reason we need</span>
<span class="cm">	 * a buffer to store new commands when using CB (or CBI, which</span>
<span class="cm">	 * does not oblige a host to wait for command completion either). */</span>
	<span class="kt">int</span>			<span class="n">cbbuf_cmnd_size</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">cbbuf_cmnd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nluns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">luns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>
	<span class="cm">/* Must be the last entry */</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="n">buffhds</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fsg_routine_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exception_in_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;</span> <span class="n">FSG_STATE_IDLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Make bulk-out requests be divisible by the maxpacket size */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_bulk_out_req_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rem</span><span class="p">;</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">length</span> <span class="o">%</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_maxpacket</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">+=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_maxpacket</span> <span class="o">-</span> <span class="n">rem</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fsg_dev</span>			<span class="o">*</span><span class="n">the_fsg</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_gadget_driver</span>		<span class="n">fsg_driver</span><span class="p">;</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bulk-in&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bulk-out&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s set halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">usb_ep_set_halt</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * DESCRIPTORS ... most are static, but strings and (full) configuration</span>
<span class="cm"> * descriptors are built on demand.  Also the (static) config and interface</span>
<span class="cm"> * descriptors are adjusted during fsg_bind().</span>
<span class="cm"> */</span>

<span class="cm">/* There is only one configuration. */</span>
<span class="cp">#define	CONFIG_VALUE		1</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_descriptor</span>
<span class="n">device_desc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bLength</span> <span class="o">=</span>		<span class="k">sizeof</span> <span class="n">device_desc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span>	<span class="n">USB_DT_DEVICE</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bcdUSB</span> <span class="o">=</span>		<span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0200</span><span class="p">),</span>
	<span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">=</span>		<span class="n">USB_CLASS_PER_INTERFACE</span><span class="p">,</span>

	<span class="cm">/* The next three values can be overridden by module parameters */</span>
	<span class="p">.</span><span class="n">idVendor</span> <span class="o">=</span>		<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">FSG_VENDOR_ID</span><span class="p">),</span>
	<span class="p">.</span><span class="n">idProduct</span> <span class="o">=</span>		<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">FSG_PRODUCT_ID</span><span class="p">),</span>
	<span class="p">.</span><span class="n">bcdDevice</span> <span class="o">=</span>		<span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">),</span>

	<span class="p">.</span><span class="n">iManufacturer</span> <span class="o">=</span>	<span class="n">FSG_STRING_MANUFACTURER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iProduct</span> <span class="o">=</span>		<span class="n">FSG_STRING_PRODUCT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iSerialNumber</span> <span class="o">=</span>	<span class="n">FSG_STRING_SERIAL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bNumConfigurations</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_config_descriptor</span>
<span class="n">config_desc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bLength</span> <span class="o">=</span>		<span class="k">sizeof</span> <span class="n">config_desc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span>	<span class="n">USB_DT_CONFIG</span><span class="p">,</span>

	<span class="cm">/* wTotalLength computed by usb_gadget_config_buf() */</span>
	<span class="p">.</span><span class="n">bNumInterfaces</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bConfigurationValue</span> <span class="o">=</span>	<span class="n">CONFIG_VALUE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iConfiguration</span> <span class="o">=</span>	<span class="n">FSG_STRING_CONFIG</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmAttributes</span> <span class="o">=</span>		<span class="n">USB_CONFIG_ATT_ONE</span> <span class="o">|</span> <span class="n">USB_CONFIG_ATT_SELFPOWER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bMaxPower</span> <span class="o">=</span>		<span class="n">CONFIG_USB_GADGET_VBUS_DRAW</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_qualifier_descriptor</span>
<span class="n">dev_qualifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bLength</span> <span class="o">=</span>		<span class="k">sizeof</span> <span class="n">dev_qualifier</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span>	<span class="n">USB_DT_DEVICE_QUALIFIER</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bcdUSB</span> <span class="o">=</span>		<span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0200</span><span class="p">),</span>
	<span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">=</span>		<span class="n">USB_CLASS_PER_INTERFACE</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bNumConfigurations</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">populate_bos</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_bos_desc</span><span class="p">,</span> <span class="n">USB_DT_BOS_SIZE</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">USB_DT_BOS_SIZE</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_ext_cap_desc</span><span class="p">,</span> <span class="n">USB_DT_USB_EXT_CAP_SIZE</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">USB_DT_USB_EXT_CAP_SIZE</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_ss_cap_desc</span><span class="p">,</span> <span class="n">USB_DT_USB_SS_CAP_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">USB_DT_BOS_SIZE</span> <span class="o">+</span> <span class="n">USB_DT_USB_SS_CAP_SIZE</span>
		<span class="o">+</span> <span class="n">USB_DT_USB_EXT_CAP_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Config descriptors must agree with the code that sets configurations</span>
<span class="cm"> * and with code managing interfaces and their altsettings.  They must</span>
<span class="cm"> * also handle different speeds and other-speed requests.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">populate_config_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span>			<span class="n">speed</span> <span class="o">=</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
	<span class="kt">int</span>					<span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_descriptor_header</span>	<span class="o">**</span><span class="n">function</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_dualspeed</span><span class="p">(</span><span class="n">gadget</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">USB_DT_OTHER_SPEED_CONFIG</span><span class="p">)</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">USB_SPEED_FULL</span> <span class="o">+</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="o">-</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">function</span> <span class="o">=</span> <span class="n">gadget_is_dualspeed</span><span class="p">(</span><span class="n">gadget</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span>
		<span class="o">?</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="p">)</span><span class="n">fsg_hs_function</span>
		<span class="o">:</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="p">)</span><span class="n">fsg_fs_function</span><span class="p">;</span>

	<span class="cm">/* for now, don&#39;t advertise srp-only devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget_is_otg</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span>
		<span class="n">function</span><span class="o">++</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">usb_gadget_config_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config_desc</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">EP0_BUFSIZE</span><span class="p">,</span> <span class="n">function</span><span class="p">);</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">usb_config_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* These routines may be called in process context or in_irq */</span>

<span class="cm">/* Caller must hold fsg-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Tell the main thread that something has happened */</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_wakeup_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">raise_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fsg_state</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Do nothing if a higher-priority exception is already in progress.</span>
<span class="cm">	 * If a lower-or-equal priority exception is in progress, preempt it</span>
<span class="cm">	 * and notify the main thread by sending it a signal. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">new_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">exception_req_tag</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">)</span>
			<span class="n">send_sig_info</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">SEND_SIG_FORCED</span><span class="p">,</span>
					<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* The disconnect callback and ep0 routines.  These always run in_irq,</span>
<span class="cm"> * except that ep0_queue() is called in the main thread to acknowledge</span>
<span class="cm"> * completion of various requests: set config, set interface, and</span>
<span class="cm"> * Bulk-only device reset. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsg_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">get_gadget_data</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;disconnect or port reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_DISCONNECT</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep0_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_queue</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* We can&#39;t do much more than wait for a reset */</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;error in submission: %s --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dump_msg</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req_name</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s --&gt; %d, %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>		<span class="c1">// Request was cancelled</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">)</span>
		<span class="p">((</span><span class="n">fsg_routine_t</span><span class="p">)</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">))(</span><span class="n">fsg</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Bulk and interrupt endpoint completion handlers.</span>
<span class="cm"> * These always run in_irq. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bulk_in_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s --&gt; %d, %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>		<span class="c1">// Request was cancelled</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Hold the lock while we update the request and buffer states */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
	<span class="n">wakeup_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bulk_out_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">dump_msg</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;bulk-out&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s --&gt; %d, %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>		<span class="c1">// Request was cancelled</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Hold the lock while we update the request and buffer states */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>
	<span class="n">wakeup_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_USB_FILE_STORAGE_TEST</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">intr_in_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s --&gt; %d, %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>		<span class="c1">// Request was cancelled</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Hold the lock while we update the request and buffer states */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
	<span class="n">wakeup_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">intr_in_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_FILE_STORAGE_TEST */</span><span class="cp"></span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Ep0 class-specific handlers.  These always run in_irq. */</span>

<span class="cp">#ifdef CONFIG_USB_FILE_STORAGE_TEST</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">received_cbi_adsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">u8</span>		<span class="n">cbi_reset_cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">SEND_DIAGNOSTIC</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">};</span>

	<span class="cm">/* Error in command transfer? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">||</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&gt;</span> <span class="n">MAX_COMMAND_SIZE</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Not all controllers allow a protocol stall after</span>
<span class="cm">		 * receiving control-out data, but we&#39;ll try anyway. */</span>
		<span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>			<span class="c1">// Wait for reset</span>
	<span class="p">}</span>

	<span class="cm">/* Is it the special reset command? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&gt;=</span> <span class="k">sizeof</span> <span class="n">cbi_reset_cmnd</span> <span class="o">&amp;&amp;</span>
			<span class="n">memcmp</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">cbi_reset_cmnd</span><span class="p">,</span>
				<span class="k">sizeof</span> <span class="n">cbi_reset_cmnd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Raise an exception to stop the current operation</span>
<span class="cm">		 * and reinitialize our state. */</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;cbi reset request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_RESET</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;CB[I] accept device-specific command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Save the command for later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd_size</span><span class="p">)</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;CB[I] overwriting previous command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd_size</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd_size</span><span class="p">);</span>

	<span class="n">wakeup_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">received_cbi_adsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_FILE_STORAGE_TEST */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">class_setup_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">w_index</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">);</span>
	<span class="n">u16</span>                     <span class="n">w_value</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">);</span>
	<span class="n">u16</span>			<span class="n">w_length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Handle Bulk-only class-specific requests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_bbb</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">US_BULK_RESET_REQUEST</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_OUT</span> <span class="o">|</span>
					<span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w_value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Raise an exception to stop the current operation</span>
<span class="cm">			 * and reinitialize our state. */</span>
			<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;bulk reset request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_RESET</span><span class="p">);</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">DELAYED_STATUS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">US_BULK_GET_MAX_LUN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span>
					<span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w_value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w_length</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get max LUN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Handle CBI class-specific requests */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">USB_CBI_ADSC_REQUEST</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_OUT</span> <span class="o">|</span>
					<span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_length</span> <span class="o">&gt;</span> <span class="n">MAX_COMMAND_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">w_length</span><span class="p">;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">received_cbi_adsc</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span>
			<span class="s">&quot;unknown class-specific control req &quot;</span>
			<span class="s">&quot;%02x.%02x v%04x i%04x l%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">),</span> <span class="n">w_index</span><span class="p">,</span> <span class="n">w_length</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Ep0 standard request handlers.  These always run in_irq. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">standard_setup_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">w_index</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">);</span>
	<span class="n">u16</span>			<span class="n">w_value</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">);</span>

	<span class="cm">/* Usually this just stores reply data in the pre-allocated ep0 buffer,</span>
<span class="cm">	 * but config change events will also reconfigure hardware. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">USB_REQ_GET_DESCRIPTOR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span>
				<span class="n">USB_RECIP_DEVICE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">w_value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">USB_DT_DEVICE</span>:
			<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get device descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">device_desc</span><span class="p">.</span><span class="n">bMaxPacketSize0</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">;</span>
			<span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">device_desc</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_desc</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_DT_DEVICE_QUALIFIER</span>:
			<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get device qualifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget_is_dualspeed</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">)</span> <span class="o">||</span>
					<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Assume ep0 uses the same maxpacket value for both</span>
<span class="cm">			 * speeds</span>
<span class="cm">			 */</span>
			<span class="n">dev_qualifier</span><span class="p">.</span><span class="n">bMaxPacketSize0</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">;</span>
			<span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">dev_qualifier</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_qualifier</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_DT_OTHER_SPEED_CONFIG</span>:
			<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get other-speed config descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget_is_dualspeed</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">)</span> <span class="o">||</span>
					<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">get_config</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_DT_CONFIG</span>:
			<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get configuration descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">get_config:</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">populate_config_buf</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
					<span class="n">w_value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
					<span class="n">w_value</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_DT_STRING</span>:
			<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get string descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/* wIndex == language code */</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">usb_gadget_get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg_stringtab</span><span class="p">,</span>
					<span class="n">w_value</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_DT_BOS</span>:
			<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get bos descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_superspeed</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">))</span>
				<span class="n">value</span> <span class="o">=</span> <span class="n">populate_bos</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* One config, two speeds */</span>
	<span class="k">case</span> <span class="n">USB_REQ_SET_CONFIGURATION</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span>
				<span class="n">USB_RECIP_DEVICE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;set configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w_value</span> <span class="o">==</span> <span class="n">CONFIG_VALUE</span> <span class="o">||</span> <span class="n">w_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">new_config</span> <span class="o">=</span> <span class="n">w_value</span><span class="p">;</span>

			<span class="cm">/* Raise an exception to wipe out previous transaction</span>
<span class="cm">			 * state (queued bufs, etc) and set the new config. */</span>
			<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_CONFIG_CHANGE</span><span class="p">);</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">DELAYED_STATUS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_REQ_GET_CONFIGURATION</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span>
				<span class="n">USB_RECIP_DEVICE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_REQ_SET_INTERFACE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_OUT</span><span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span>
				<span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">&amp;&amp;</span> <span class="n">w_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Raise an exception to wipe out previous transaction</span>
<span class="cm">			 * state (queued bufs, etc) and install the new</span>
<span class="cm">			 * interface altsetting. */</span>
			<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_INTERFACE_CHANGE</span><span class="p">);</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">DELAYED_STATUS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_REQ_GET_INTERFACE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span>
				<span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span>
			<span class="s">&quot;unknown control req %02x.%02x v%04x i%04x l%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">,</span>
			<span class="n">w_value</span><span class="p">,</span> <span class="n">w_index</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">get_gadget_data</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">w_length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">);</span>

	<span class="o">++</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span><span class="p">;</span>		<span class="c1">// Record arrival of a new request</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dump_msg</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;ep0-setup&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">ctrl</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctrl</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_TYPE_CLASS</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">class_setup_req</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">standard_setup_req</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="cm">/* Respond with data/status or defer until later? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="n">DELAYED_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">w_length</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="n">w_length</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span> <span class="o">?</span>
				<span class="s">&quot;ep0-in&quot;</span> <span class="o">:</span> <span class="s">&quot;ep0-out&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ep0_queue</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Device either stalls (rc &lt; 0) or reports success */</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* All the following routines run in process context */</span>


<span class="cm">/* Use this for bulk or interrupt transfers, not ep0 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pbusy</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">fsg_buffer_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">)</span>
		<span class="n">dump_msg</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;bulk-in&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">)</span>
		<span class="n">dump_msg</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;intr-in&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pbusy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_BUSY</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_queue</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pbusy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>

		<span class="cm">/* We can&#39;t do much more than wait for a reset */</span>

		<span class="cm">/* Note: currently the net2280 driver fails zero-length</span>
<span class="cm">		 * submissions if DMA is enabled. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span> <span class="o">&amp;&amp;</span>
						<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;error in submission: %s --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sleep_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait until a signal arrives or we are woken up */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_wakeup_needed</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_wakeup_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount_left</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">file_offset</span><span class="p">,</span> <span class="n">file_offset_tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">amount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">nread</span><span class="p">;</span>

	<span class="cm">/* Get the starting Logical Block Address and check that it&#39;s</span>
<span class="cm">	 * not too big */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_6</span><span class="p">)</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be24</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

		<span class="cm">/* We allow DPO (Disable Page Out = don&#39;t save data in the</span>
<span class="cm">		 * cache) and FUA (Force Unit Access = don&#39;t read from the</span>
<span class="cm">		 * cache), but we don&#39;t implement them. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x18</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">file_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">lba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>

	<span class="cm">/* Carry out the file reads */</span>
	<span class="n">amount_left</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">amount_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="c1">// No default reply</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>

		<span class="cm">/* Figure out how much we need to read:</span>
<span class="cm">		 * Try to read the remaining amount.</span>
<span class="cm">		 * But don&#39;t read more than the buffer size.</span>
<span class="cm">		 * And don&#39;t try to read past the end of the file.</span>
<span class="cm">		 */</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">amount_left</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span><span class="p">);</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">amount</span><span class="p">,</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span><span class="p">);</span>

		<span class="cm">/* Wait for the next buffer to become available */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we were asked to read past the end of file,</span>
<span class="cm">		 * end with an empty buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span>
					<span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Perform the read */</span>
		<span class="n">file_offset_tmp</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>
		<span class="n">nread</span> <span class="o">=</span> <span class="n">vfs_read</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
				<span class="n">amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_offset_tmp</span><span class="p">);</span>
		<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;file read %u @ %llu -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">file_offset</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nread</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;error in file read: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nread</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;partial file read: %d/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nread</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">nread</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">file_offset</span>  <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">amount_left</span>  <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span>

		<span class="cm">/* Except at the end of the transfer, nread will be</span>
<span class="cm">		 * equal to the buffer size, which is divisible by the</span>
<span class="cm">		 * bulk-in maxpacket size.</span>
<span class="cm">		 */</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>

		<span class="cm">/* If an error occurred, report it and its position */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_UNRECOVERED_READ_ERROR</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">amount_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>		<span class="c1">// No more left to read</span>

		<span class="cm">/* Send this buffer and go read some more */</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="c1">// No default reply</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">get_some_more</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount_left_to_req</span><span class="p">,</span> <span class="n">amount_left_to_write</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">usb_offset</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">file_offset_tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">amount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">nwritten</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_WRITE_PROTECTED</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">O_SYNC</span><span class="p">;</span>	<span class="c1">// Default is not to wait</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

	<span class="cm">/* Get the starting Logical Block Address and check that it&#39;s</span>
<span class="cm">	 * not too big */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_6</span><span class="p">)</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be24</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

		<span class="cm">/* We allow DPO (Disable Page Out = don&#39;t save data in the</span>
<span class="cm">		 * cache) and FUA (Force Unit Access = write directly to the</span>
<span class="cm">		 * medium).  We don&#39;t implement DPO; we implement FUA by</span>
<span class="cm">		 * performing synchronous output. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x18</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FUA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">nofua</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_DSYNC</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Carry out the file writes */</span>
	<span class="n">get_some_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">file_offset</span> <span class="o">=</span> <span class="n">usb_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">lba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
	<span class="n">amount_left_to_req</span> <span class="o">=</span> <span class="n">amount_left_to_write</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">amount_left_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Queue a request for more data from the host */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_EMPTY</span> <span class="o">&amp;&amp;</span> <span class="n">get_some_more</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Figure out how much we want to get:</span>
<span class="cm">			 * Try to get the remaining amount,</span>
<span class="cm">			 * but not more than the buffer size.</span>
<span class="cm">			 */</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">amount_left_to_req</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span><span class="p">);</span>

			<span class="cm">/* Beyond the end of the backing file? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_offset</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">get_some_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span>
					<span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="n">usb_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Get the next buffer */</span>
			<span class="n">usb_offset</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="n">amount_left_to_req</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">amount_left_to_req</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">get_some_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Except at the end of the transfer, amount will be</span>
<span class="cm">			 * equal to the buffer size, which is divisible by</span>
<span class="cm">			 * the bulk-out maxpacket size.</span>
<span class="cm">			 */</span>
			<span class="n">set_bulk_out_req_length</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Write the received data to the backing file */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_EMPTY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">get_some_more</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>			<span class="c1">// We stopped early</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>

			<span class="cm">/* Did something go wrong with the transfer? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_COMMUNICATION_FAILURE</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">amount</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">LERROR</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span>
	<span class="s">&quot;write %u @ %llu beyond end %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	<span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">file_offset</span><span class="p">,</span>
	<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span><span class="p">);</span>
				<span class="n">amount</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Don&#39;t accept excess data.  The spec doesn&#39;t say</span>
<span class="cm">			 * what to do in this case.  We&#39;ll ignore the error.</span>
<span class="cm">			 */</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">);</span>

			<span class="cm">/* Don&#39;t write a partial block */</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">empty_write</span><span class="p">;</span>

			<span class="cm">/* Perform the write */</span>
			<span class="n">file_offset_tmp</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>
			<span class="n">nwritten</span> <span class="o">=</span> <span class="n">vfs_write</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
					<span class="n">amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_offset_tmp</span><span class="p">);</span>
			<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;file write %u @ %llu -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">file_offset</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nwritten</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>		<span class="c1">// Interrupted!</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;error in file write: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nwritten</span><span class="p">);</span>
				<span class="n">nwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;partial file write: %d/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nwritten</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
				<span class="n">nwritten</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">nwritten</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">file_offset</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>
			<span class="n">amount_left_to_write</span> <span class="o">-=</span> <span class="n">nwritten</span><span class="p">;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">-=</span> <span class="n">nwritten</span><span class="p">;</span>

			<span class="cm">/* If an error occurred, report it and its position */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_WRITE_ERROR</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

 <span class="nl">empty_write:</span>
			<span class="cm">/* Did the host decide to stop early? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">short_packet_received</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for something to happen */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="c1">// No default reply</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_synchronize_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* We ignore the requested LBA and write out all file&#39;s</span>
<span class="cm">	 * dirty data buffers. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_lun_fsync_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_WRITE_ERROR</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">invalidate_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">curlun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;invalidate_mapping_pages -&gt; %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lba</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">verification_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">file_offset</span><span class="p">,</span> <span class="n">file_offset_tmp</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount_left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">amount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">nread</span><span class="p">;</span>

	<span class="cm">/* Get the starting Logical Block Address and check that it&#39;s</span>
<span class="cm">	 * not too big */</span>
	<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We allow DPO (Disable Page Out = don&#39;t save data in the</span>
<span class="cm">	 * cache) but we don&#39;t implement it. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x10</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">verification_length</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">verification_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="c1">// No default reply</span>

	<span class="cm">/* Prepare to carry out the file verify */</span>
	<span class="n">amount_left</span> <span class="o">=</span> <span class="n">verification_length</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
	<span class="n">file_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">lba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>

	<span class="cm">/* Write out all the dirty buffers before invalidating them */</span>
	<span class="n">fsg_lun_fsync_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="n">invalidate_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="cm">/* Just try to read the requested blocks */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">amount_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Figure out how much we need to read:</span>
<span class="cm">		 * Try to read the remaining amount, but not more than</span>
<span class="cm">		 * the buffer size.</span>
<span class="cm">		 * And don&#39;t try to read past the end of the file.</span>
<span class="cm">		 */</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">amount_left</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span><span class="p">);</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">amount</span><span class="p">,</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span>
					<span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Perform the read */</span>
		<span class="n">file_offset_tmp</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>
		<span class="n">nread</span> <span class="o">=</span> <span class="n">vfs_read</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
				<span class="n">amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_offset_tmp</span><span class="p">);</span>
		<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;file read %u @ %llu -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">file_offset</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nread</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;error in file verify: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nread</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;partial file verify: %d/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nread</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">nread</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_UNRECOVERED_READ_ERROR</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">file_offset</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">amount_left</span> <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">char</span> <span class="n">vendor_id</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Linux   &quot;</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">product_disk_id</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;File-Stor Gadget&quot;</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">product_cdrom_id</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;File-CD Gadget  &quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// Unsupported LUNs are okay</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x7f</span><span class="p">;</span>		<span class="c1">// Unsupported, no device-type</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>		<span class="c1">// Additional length</span>
		<span class="k">return</span> <span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span> <span class="o">?</span> <span class="n">TYPE_ROM</span> <span class="o">:</span> <span class="n">TYPE_DISK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>		<span class="c1">// ANSI SCSI level 2</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>		<span class="c1">// SCSI-2 INQUIRY data format</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>		<span class="c1">// Additional length</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>No special options</p></td><td class="code"><div class="highlight"><pre>	<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;%-8s%-16s%04x&quot;</span><span class="p">,</span> <span class="n">vendor_id</span><span class="p">,</span>
			<span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span> <span class="o">?</span> <span class="n">product_cdrom_id</span> <span class="o">:</span>
				<span class="n">product_disk_id</span><span class="p">),</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">release</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">36</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_request_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">sd</span><span class="p">,</span> <span class="n">sdinfo</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">valid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From the SCSI-2 spec., section 7.9 (Unit attention condition):</span>
<span class="cm">	 *</span>
<span class="cm">	 * If a REQUEST SENSE command is received from an initiator</span>
<span class="cm">	 * with a pending unit attention condition (before the target</span>
<span class="cm">	 * generates the contingent allegiance condition), then the</span>
<span class="cm">	 * target shall either:</span>
<span class="cm">	 *   a) report any pending sense data and preserve the unit</span>
<span class="cm">	 *	attention condition on the logical unit, or,</span>
<span class="cm">	 *   b) report the unit attention condition, may discard any</span>
<span class="cm">	 *	pending sense data, and clear the unit attention</span>
<span class="cm">	 *	condition on the logical unit for that initiator.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FSG normally uses option a); enable this code to use option b).</span>
<span class="cm">	 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (curlun &amp;&amp; curlun-&gt;unit_attention_data != SS_NO_SENSE) {</span>
<span class="c">		curlun-&gt;sense_data = curlun-&gt;unit_attention_data;</span>
<span class="c">		curlun-&gt;unit_attention_data = SS_NO_SENSE;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// Unsupported LUNs are okay</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_LOGICAL_UNIT_NOT_SUPPORTED</span><span class="p">;</span>
		<span class="n">sdinfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span><span class="p">;</span>
		<span class="n">sdinfo</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span><span class="p">;</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">|</span> <span class="mh">0x70</span><span class="p">;</span>			<span class="c1">// Valid, current error</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">SK</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">sdinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>	<span class="cm">/* Sense information */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">18</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>			<span class="c1">// Additional sense length</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">ASC</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">ASCQ</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">18</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="kt">int</span>		<span class="n">pmi</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Check the PMI and LBA fields */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmi</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">pmi</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lba</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
						<span class="cm">/* Max logical block */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>	<span class="cm">/* Block length */</span>
	<span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">msf</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x02</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Mask away MSF */</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>		<span class="cm">/* 2048 bytes of user data, rest is EC */</span>
	<span class="n">store_cdrom_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">msf</span><span class="p">,</span> <span class="n">lba</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_toc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">msf</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">start_track</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x02</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>		<span class="cm">/* Mask away MSF */</span>
			<span class="n">start_track</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>		<span class="cm">/* TOC data length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* First track number */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* Last track number */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x16</span><span class="p">;</span>			<span class="cm">/* Data track, copying allowed */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>			<span class="cm">/* Only track is number 1 */</span>
	<span class="n">store_cdrom_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">msf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x16</span><span class="p">;</span>			<span class="cm">/* Lead-out track is data */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xAA</span><span class="p">;</span>			<span class="cm">/* Lead-out track number */</span>
	<span class="n">store_cdrom_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">msf</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_mode_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">mscmnd</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf0</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">pc</span><span class="p">,</span> <span class="n">page_code</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">changeable_values</span><span class="p">,</span> <span class="n">all_pages</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">valid_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">len</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x08</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// Mask away DBD</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pc</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">page_code</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_SAVING_PARAMETERS_NOT_SUPPORTED</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">changeable_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">all_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">page_code</span> <span class="o">==</span> <span class="mh">0x3f</span><span class="p">);</span>

	<span class="cm">/* Write the mode parameter header.  Fixed values are: default</span>
<span class="cm">	 * medium type, no cache control (DPOFUA), and no block descriptors.</span>
<span class="cm">	 * The only variable value is the WriteProtect bit.  We will fill in</span>
<span class="cm">	 * the mode data length later. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mscmnd</span> <span class="o">==</span> <span class="n">MODE_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="c1">// WP, DPOFUA</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="c1">// MODE_SENSE_10</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="c1">// WP, DPOFUA</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">65535</span><span class="p">;</span>		<span class="c1">// Should really be mod_data.buflen</span>
	<span class="p">}</span>

	<span class="cm">/* No block descriptors */</span>

	<span class="cm">/* The mode pages, in numerical order.  The only page we support</span>
<span class="cm">	 * is the Caching page. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_code</span> <span class="o">==</span> <span class="mh">0x08</span> <span class="o">||</span> <span class="n">all_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">valid_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>		<span class="c1">// Page code</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>		<span class="c1">// Page length</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>	<span class="c1">// None of the fields are changeable</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">changeable_values</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span>	<span class="c1">// Write cache enable,</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Read cache not disabled
No cache retention priorities</p></td><td class="code"><div class="highlight"><pre>			<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
					<span class="cm">/* Don&#39;t disable prefetch */</span>
					<span class="cm">/* Minimum prefetch = 0 */</span>
			<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
					<span class="cm">/* Maximum prefetch */</span>
			<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
					<span class="cm">/* Maximum prefetch ceiling */</span>
		<span class="p">}</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that a valid page was requested and the mode data length</span>
<span class="cm">	 * isn&#39;t too long. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">-</span> <span class="n">buf0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_page</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  Store the mode data length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mscmnd</span> <span class="o">==</span> <span class="n">MODE_SENSE</span><span class="p">)</span>
		<span class="n">buf0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buf0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_start_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">loej</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>int immed = fsg->cmnd[1] &amp; 0x01;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">loej</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_USB_FILE_STORAGE_TEST</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>		<span class="c1">// Mask away Immed</span>
			<span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x03</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Mask LoEj, Start</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Are we allowed to unload the media? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;unload attempt prevented</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_MEDIUM_REMOVAL_PREVENTED</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loej</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// Simulate an unload/eject</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
			<span class="n">fsg_lun_close</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* Our emulation doesn&#39;t support mounting; the medium is</span>
<span class="cm">		 * available for use as soon as it is loaded. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_lun_is_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_MEDIUM_NOT_PRESENT</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_prevent_allow</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">prevent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prevent</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// Mask away Prevent</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">prevent</span><span class="p">)</span>
		<span class="n">fsg_lun_fsync_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span> <span class="o">=</span> <span class="n">prevent</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_format_capacities</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>		<span class="c1">// Only the Current/Maximum Capacity Descriptor</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
						<span class="cm">/* Number of blocks */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>	<span class="cm">/* Block length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>				<span class="cm">/* Current capacity */</span>
	<span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_mode_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t support MODE SELECT */</span>
	<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">halt_bulk_in_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;delayed bulk-in endpoint halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;usb_ep_set_halt -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for a short time and then try again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wedge_bulk_in_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;bulk-in set wedge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_set_wedge</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;delayed bulk-in endpoint wedge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;usb_ep_set_wedge -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for a short time and then try again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_set_wedge</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">throw_away_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span> <span class="o">||</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Throw away the data in a filled buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="cm">/* A short packet or an error ends everything */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span> <span class="o">||</span>
					<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_ABORT_BULK_OUT</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Try to submit another request if we need one */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_EMPTY</span> <span class="o">&amp;&amp;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span><span class="p">);</span>

			<span class="cm">/* Except at the end of the transfer, amount will be</span>
<span class="cm">			 * equal to the buffer size, which is divisible by</span>
<span class="cm">			 * the bulk-out maxpacket size.</span>
<span class="cm">			 */</span>
			<span class="n">set_bulk_out_req_length</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Otherwise wait for something to happen */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">finish_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DATA_DIR_NONE</span>:
		<span class="k">break</span><span class="p">;</span>			<span class="c1">// Nothing to send</span>

	<span class="cm">/* If we don&#39;t know whether the host wants to read or write,</span>
<span class="cm">	 * this must be CB or CBI with an unknown command.  We mustn&#39;t</span>
<span class="cm">	 * try to send or receive any data.  So stall both bulk pipes</span>
<span class="cm">	 * if we can and wait for a reset. */</span>
	<span class="k">case</span> <span class="n">DATA_DIR_UNKNOWN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">can_stall</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">halt_bulk_in_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* All but the last buffer of data must have already been sent */</span>
	<span class="k">case</span> <span class="n">DATA_DIR_TO_HOST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>		<span class="c1">// Nothing to send</span>

		<span class="cm">/* If there&#39;s no residue, simply send the last buffer */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* There is a residue.  For CB and CBI, simply mark the end</span>
<span class="cm">		 * of the data with a short packet.  However, if we are</span>
<span class="cm">		 * allowed to stall, there was no data at all (residue ==</span>
<span class="cm">		 * data_size), and the command failed (invalid LUN or</span>
<span class="cm">		 * sense data is set), then halt the bulk-in endpoint</span>
<span class="cm">		 * instead. */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport_is_bbb</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">can_stall</span> <span class="o">&amp;&amp;</span>
					<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">&amp;&amp;</span>
	<span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span> <span class="o">||</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">!=</span> <span class="n">SS_NO_SENSE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">halt_bulk_in_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
				<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * For Bulk-only, mark the end of the data with a short</span>
<span class="cm">		 * packet.  If we are allowed to stall, halt the bulk-in</span>
<span class="cm">		 * endpoint.  (Note: This violates the Bulk-Only Transport</span>
<span class="cm">		 * specification, which requires us to pad the data if we</span>
<span class="cm">		 * don&#39;t halt the endpoint.  Presumably nobody will mind.)</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">can_stall</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">halt_bulk_in_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* We have processed all we want from the data the host has sent.</span>
<span class="cm">	 * There may still be outstanding bulk-out requests. */</span>
	<span class="k">case</span> <span class="n">DATA_DIR_FROM_HOST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>		<span class="c1">// Nothing to receive</span>

		<span class="cm">/* Did the host stop sending unexpectedly early? */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">short_packet_received</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_ABORT_BULK_OUT</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We haven&#39;t processed all the incoming data.  Even though</span>
<span class="cm">		 * we may be allowed to stall, doing so would cause a race.</span>
<span class="cm">		 * The controller may already have ACK&#39;ed all the remaining</span>
<span class="cm">		 * bulk-out packets, in which case the host wouldn&#39;t see a</span>
<span class="cm">		 * STALL.  Not realizing the endpoint was halted, it wouldn&#39;t</span>
<span class="cm">		 * clear the halt -- leading to problems later on. */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		else if (mod_data.can_stall) {</span>
<span class="c">			fsg_set_halt(fsg, fsg-&gt;bulk_out);</span>
<span class="c">			raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);</span>
<span class="c">			rc = -EINTR;</span>
<span class="c">		}</span>
<span class="cp">#endif</span>

		<span class="cm">/* We can&#39;t stall.  Read in the excess data and throw it</span>
<span class="cm">		 * all away. */</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">throw_away_data</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">status</span> <span class="o">=</span> <span class="n">US_BULK_STAT_OK</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">sd</span><span class="p">,</span> <span class="n">sdinfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for the next buffer to become available */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span><span class="p">;</span>
		<span class="n">sdinfo</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span><span class="p">)</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_LOGICAL_UNIT_NOT_SUPPORTED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">phase_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;sending phase-error status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">US_BULK_STAT_PHASE</span><span class="p">;</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sd</span> <span class="o">!=</span> <span class="n">SS_NO_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;sending command-failure status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">US_BULK_STAT_FAIL</span><span class="p">;</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;&quot;</span>
				<span class="s">&quot;  info x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">SK</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">ASC</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">ASCQ</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">sdinfo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_bbb</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bulk_cs_wrap</span>	<span class="o">*</span><span class="n">csw</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

		<span class="cm">/* Store and send the Bulk-only CSW */</span>
		<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">US_BULK_CS_SIGN</span><span class="p">);</span>
		<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Tag</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
		<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Residue</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span><span class="p">);</span>
		<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">US_BULK_CS_WRAP_LEN</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span> <span class="o">==</span> <span class="n">USB_PR_CB</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Control-Bulk transport has no status phase! */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="c1">// USB_PR_CBI</span>
		<span class="k">struct</span> <span class="n">interrupt_data</span>	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

		<span class="cm">/* Store and send the Interrupt data.  UFI sends the ASC</span>
<span class="cm">		 * and ASCQ bytes.  Everything else sends a Type (which</span>
<span class="cm">		 * is always 0) and the status Value. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">==</span> <span class="n">USB_SC_UFI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bType</span> <span class="o">=</span> <span class="n">ASC</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bValue</span> <span class="o">=</span> <span class="n">ASCQ</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bValue</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">CBI_INTERRUPT_DATA_LEN</span><span class="p">;</span>

		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_buffhd</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>		<span class="c1">// Point to the right buffhd</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Check whether the command is properly formed and whether its data size</span>
<span class="cm"> * and direction agree with the values we already have. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmnd_size</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">data_direction</span> <span class="n">data_dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">needs_medium</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">lun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span>	<span class="n">dirletter</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">};</span>
	<span class="kt">char</span>			<span class="n">hdlen</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>

	<span class="cm">/* Adjust the expected cmnd_size for protocol encapsulation padding.</span>
<span class="cm">	 * Transparent SCSI doesn&#39;t pad. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protocol_is_scsi</span><span class="p">())</span>
		<span class="p">;</span>

	<span class="cm">/* There&#39;s some disagreement as to whether RBC pads commands or not.</span>
<span class="cm">	 * We&#39;ll play it safe and accept either form. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">==</span> <span class="n">USB_SC_RBC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
			<span class="n">cmnd_size</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

	<span class="cm">/* All the other protocols pad to 12 bytes */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cmnd_size</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

	<span class="n">hdlen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">!=</span> <span class="n">DATA_DIR_UNKNOWN</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">hdlen</span><span class="p">,</span> <span class="s">&quot;, H%c=%u&quot;</span><span class="p">,</span> <span class="n">dirletter</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span><span class="p">],</span>
				<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
	<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;SCSI command: %s;  Dc=%d, D%c=%u;  Hc=%d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">name</span><span class="p">,</span> <span class="n">cmnd_size</span><span class="p">,</span> <span class="n">dirletter</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">data_dir</span><span class="p">],</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">,</span> <span class="n">hdlen</span><span class="p">);</span>

	<span class="cm">/* We can&#39;t reply at all until we know the correct data direction</span>
<span class="cm">	 * and size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">==</span> <span class="n">DATA_DIR_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// CB or CBI</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">data_dir</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>					<span class="c1">// Bulk-only</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Host data size &lt; Device data size is a phase error.</span>
<span class="cm">			 * Carry out the command, but only transfer as much</span>
<span class="cm">			 * as we are allowed. */</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>

	<span class="cm">/* Conflicting data directions is a phase error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">!=</span> <span class="n">data_dir</span> <span class="o">&amp;&amp;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Verify the length of the command itself */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmnd_size</span> <span class="o">!=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Special case workaround: There are plenty of buggy SCSI</span>
<span class="cm">		 * implementations. Many have issues with cbw-&gt;Length</span>
<span class="cm">		 * field passing a wrong command size. For those cases we</span>
<span class="cm">		 * always try to work around the problem by using the length</span>
<span class="cm">		 * sent by the host side provided it is at least as large</span>
<span class="cm">		 * as the correct command length.</span>
<span class="cm">		 * Examples of such cases would be MS-Windows, which issues</span>
<span class="cm">		 * REQUEST SENSE with cbw-&gt;Length == 12 where it should</span>
<span class="cm">		 * be 6, and xbox360 issuing INQUIRY, TEST UNIT READY and</span>
<span class="cm">		 * REQUEST SENSE with cbw-&gt;Length == 10 where it should</span>
<span class="cm">		 * be 6 as well.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmnd_size</span> <span class="o">&lt;=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s is buggy! Expected length %d &quot;</span>
					<span class="s">&quot;but we got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
					<span class="n">cmnd_size</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">);</span>
			<span class="n">cmnd_size</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check that the LUN values are consistent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_bbb</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">lun</span><span class="p">)</span>
			<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;using LUN %d from CBW, &quot;</span>
					<span class="s">&quot;not LUN %d from CDB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check the LUN */</span>
	<span class="n">curlun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* INQUIRY and REQUEST SENSE commands are explicitly allowed</span>
<span class="cm">		 * to use unsupported LUNs; all others may not. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INQUIRY</span> <span class="o">&amp;&amp;</span>
				<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;unsupported LUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If a unit attention condition exists, only INQUIRY and</span>
<span class="cm">	 * REQUEST SENSE commands are allowed; anything else must fail. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span> <span class="o">&amp;&amp;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span> <span class="o">!=</span> <span class="n">SS_NO_SENSE</span> <span class="o">&amp;&amp;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INQUIRY</span> <span class="o">&amp;&amp;</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that only command bytes listed in the mask are non-zero */</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x1f</span><span class="p">;</span>			<span class="c1">// Mask away the LUN</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmnd_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="p">)</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If the medium isn&#39;t mounted and the command needs to access</span>
<span class="cm">	 * it, return an error. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fsg_lun_is_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">needs_medium</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_MEDIUM_NOT_PRESENT</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* wrapper of check_command for data size in blocks handling */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_command_size_in_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmnd_size</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">data_direction</span> <span class="n">data_dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">needs_medium</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">)</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">&lt;&lt;=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">cmnd_size</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span>
			<span class="n">mask</span><span class="p">,</span> <span class="n">needs_medium</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_scsi_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">reply</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span>		<span class="n">unknown</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">dump_cdb</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>

	<span class="cm">/* Wait for the next buffer to become available for data or status */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">short_packet_received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>	<span class="c1">// We&#39;re using the backing file</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">INQUIRY</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;INQUIRY&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_inquiry</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SELECT</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;MODE SELECT(6)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_select</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SELECT_10</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;MODE SELECT(10)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_select</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SENSE</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;MODE SENSE(6)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_sense</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SENSE_10</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;MODE SENSE(10)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_sense</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ALLOW_MEDIUM_REMOVAL</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;PREVENT-ALLOW MEDIUM REMOVAL&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_prevent_allow</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_6</span>:
		<span class="n">i</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">256</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
				<span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;READ(6)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_10</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
				<span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;READ(10)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_12</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
				<span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;READ(12)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;READ CAPACITY&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_capacity</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_HEADER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unknown_cmnd</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x1f</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;READ HEADER&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_header</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_TOC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unknown_cmnd</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;READ TOC&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_toc</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_FORMAT_CAPACITIES</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;READ FORMAT CAPACITIES&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_format_capacities</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REQUEST_SENSE</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;REQUEST SENSE&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_request_sense</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">START_STOP</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="s">&quot;START-STOP UNIT&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_start_stop</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SYNCHRONIZE_CACHE</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				<span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;SYNCHRONIZE CACHE&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_synchronize_cache</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TEST_UNIT_READY</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;TEST UNIT READY&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Although optional, this command is used by MS-Windows.  We</span>
<span class="cm">	 * support a minimal version: BytChk must be 0. */</span>
	<span class="k">case</span> <span class="n">VERIFY</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;VERIFY&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_verify</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="n">i</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">256</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
				<span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;WRITE(6)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_write</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
				<span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;WRITE(10)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_write</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WRITE_12</span>:
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
				<span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;WRITE(12)&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_write</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Some mandatory commands that we recognize but don&#39;t implement.</span>
<span class="cm">	 * They don&#39;t mean much in this setting.  It&#39;s left as an exercise</span>
<span class="cm">	 * for anyone interested to implement RESERVE and RELEASE in terms</span>
<span class="cm">	 * of Posix locks. */</span>
	<span class="k">case</span> <span class="n">FORMAT_UNIT</span>:
	<span class="k">case</span> <span class="n">RELEASE</span>:
	<span class="k">case</span> <span class="n">RESERVE</span>:
	<span class="k">case</span> <span class="n">SEND_DIAGNOSTIC</span>:</pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Fall through</p></td><td class="code"><div class="highlight"><pre>	<span class="nl">default:</span>
 <span class="nl">unknown_cmnd:</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">unknown</span><span class="p">,</span> <span class="s">&quot;Unknown x%02x&quot;</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">,</span>
				<span class="n">DATA_DIR_UNKNOWN</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unknown</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">||</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="cm">/* Set up the single reply buffer for finish_reply() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="c1">// Error reply length</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">==</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">reply</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">reply</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">-=</span> <span class="n">reply</span><span class="p">;</span>
	<span class="p">}</span>				<span class="c1">// Otherwise it&#39;s already set</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">received_cbw</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>		<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bulk_cb_wrap</span>	<span class="o">*</span><span class="n">cbw</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Was this a real packet?  Should it be ignored? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Is the CBW valid? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">US_BULK_CB_WRAP_LEN</span> <span class="o">||</span>
			<span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
				<span class="n">US_BULK_CB_SIGN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;invalid CBW: len %u sig 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">));</span>

		<span class="cm">/* The Bulk-only spec says we MUST stall the IN endpoint</span>
<span class="cm">		 * (6.6.1), so it&#39;s unavoidable.  It also says we must</span>
<span class="cm">		 * retain this state until the next reset, but there&#39;s</span>
<span class="cm">		 * no way to tell the controller driver it should ignore</span>
<span class="cm">		 * Clear-Feature(HALT) requests.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We aren&#39;t required to halt the OUT endpoint; instead</span>
<span class="cm">		 * we can simply accept and discard any data received</span>
<span class="cm">		 * until the next reset. */</span>
		<span class="n">wedge_bulk_in_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is the CBW meaningful? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Lun</span> <span class="o">&gt;=</span> <span class="n">FSG_MAX_LUNS</span> <span class="o">||</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">US_BULK_FLAG_IN</span> <span class="o">||</span>
			<span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="n">MAX_COMMAND_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;non-meaningful CBW: lun = %u, flags = 0x%x, &quot;</span>
				<span class="s">&quot;cmdlen %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Lun</span><span class="p">,</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Flags</span><span class="p">,</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>

		<span class="cm">/* We can do anything we want here, so let&#39;s stall the</span>
<span class="cm">		 * bulk pipes if we are allowed to. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">can_stall</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
			<span class="n">halt_bulk_in_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save the command for later */</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span> <span class="o">=</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">CDB</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">US_BULK_FLAG_IN</span><span class="p">)</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_FROM_HOST</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">DataTransferLength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_NONE</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Lun</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Tag</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_next_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_bbb</span><span class="p">())</span> <span class="p">{</span>

		<span class="cm">/* Wait for the next buffer to become available */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Queue a request to read a Bulk-only CBW */</span>
		<span class="n">set_bulk_out_req_length</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">US_BULK_CB_WRAP_LEN</span><span class="p">);</span>
		<span class="n">start_transfer</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

		<span class="cm">/* We will drain the buffer in software, which means we</span>
<span class="cm">		 * can reuse it for the next filling.  No need to advance</span>
<span class="cm">		 * next_buffhd_to_fill. */</span>

		<span class="cm">/* Wait for the CBW to arrive */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">received_cbw</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="c1">// USB_PR_CB or USB_PR_CBI</span>

		<span class="cm">/* Wait for the next command to arrive */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Is the previous status interrupt request still busy?</span>
<span class="cm">		 * The host is allowed to skip reading the status,</span>
<span class="cm">		 * so we must cancel it. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq_busy</span><span class="p">)</span>
			<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="p">);</span>

		<span class="cm">/* Copy the command and mark the buffer empty */</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_UNKNOWN</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd_size</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cbbuf_cmnd_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* Use LUN from the command */</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update current lun */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">)</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">curlun</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enable_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">fsg</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_enable</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;can&#39;t enable %s, result %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">**</span><span class="n">preq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">preq</span> <span class="o">=</span> <span class="n">usb_ep_alloc_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">preq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;can&#39;t allocate request for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset interface setting and re-init endpoint state (toggle etc).</span>
<span class="cm"> * Call with altsetting &lt; 0 to disable the interface.  The only other</span>
<span class="cm"> * available altsetting is 0, which enables the interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_set_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">altsetting</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>	<span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;reset interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">reset:</span>
	<span class="cm">/* Deallocate the requests */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable the endpoints */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_ep_disable</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_ep_disable</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_ep_disable</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">altsetting</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;set interface %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">altsetting</span><span class="p">);</span>

	<span class="cm">/* Enable the endpoints */</span>
	<span class="n">d</span> <span class="o">=</span> <span class="n">fsg_ep_desc</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fsg_fs_bulk_in_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_hs_bulk_in_desc</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fsg_ss_bulk_in_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">enable_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">fsg_ep_desc</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fsg_fs_bulk_out_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_hs_bulk_out_desc</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fsg_ss_bulk_out_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">enable_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_maxpacket</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_cbi</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">fsg_ep_desc</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">fsg_fs_intr_in_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_hs_intr_in_desc</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">fsg_ss_intr_in_desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">enable_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate the requests */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_request</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_request</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">bulk_in_complete</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">bulk_out_complete</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_cbi</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_request</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">intr_in_complete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">unit_attention_data</span> <span class="o">=</span> <span class="n">SS_RESET_OCCURRED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Change our operational configuration.  This code must agree with the code</span>
<span class="cm"> * that returns config descriptors, and with interface altsetting code.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s also responsible for power management interactions.  Some</span>
<span class="cm"> * configurations might not work with our current power sources.</span>
<span class="cm"> * For now we just assume the gadget is always self-powered.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_set_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable the single interface */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;reset config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">do_set_interface</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable the interface */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_config</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="n">new_config</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">do_set_interface</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// Reset on errors</span>
		<span class="k">else</span>
			<span class="n">INFO</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s config #%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">usb_speed_string</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">),</span>
			     <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span>		<span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sig</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fsg_state</span>		<span class="n">old_state</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">new_config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">exception_req_tag</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Clear the existing signals.  Anything but SIGUSR1 is converted</span>
<span class="cm">	 * into a high-priority EXIT exception. */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">dequeue_signal_lock</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGUSR1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">FSG_STATE_EXIT</span><span class="p">)</span>
				<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;Main thread exiting on signal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_EXIT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Cancel all the pending transfers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq_busy</span><span class="p">)</span>
		<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">)</span>
			<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">)</span>
			<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wait until everything is idle */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">num_active</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intreq_busy</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">num_active</span> <span class="o">+=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear out the controller&#39;s fifos */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span><span class="p">)</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span><span class="p">)</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in_enabled</span><span class="p">)</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span><span class="p">);</span>

	<span class="cm">/* Reset the I/O buffer states and pointers, the SCSI</span>
<span class="cm">	 * state, and the exception.  Then invoke the handler. */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">exception_req_tag</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">exception_req_tag</span><span class="p">;</span>
	<span class="n">new_config</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">new_config</span><span class="p">;</span>
	<span class="n">old_state</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">FSG_STATE_ABORT_BULK_OUT</span><span class="p">)</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_STATUS_PHASE</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span> <span class="o">=</span>
					<span class="n">SS_NO_SENSE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_IDLE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Carry out any extra actions required for the exception */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">old_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_ABORT_BULK_OUT</span>:
		<span class="n">send_status</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FSG_STATE_STATUS_PHASE</span><span class="p">)</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_IDLE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_RESET</span>:
		<span class="cm">/* In case we were forced against our will to halt a</span>
<span class="cm">		 * bulk endpoint, clear the halt now.  (The SuperH UDC</span>
<span class="cm">		 * requires this.) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">))</span>
			<span class="n">usb_ep_clear_halt</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_bbb</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span> <span class="o">==</span> <span class="n">exception_req_tag</span><span class="p">)</span>
				<span class="n">ep0_queue</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>	<span class="c1">// Complete the status stage</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">transport_is_cbi</span><span class="p">())</span>
			<span class="n">send_status</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>	<span class="c1">// Status by interrupt pipe</span>

		<span class="cm">/* Technically this should go here, but it would only be</span>
<span class="cm">		 * a waste of time.  Ditto for the INTERFACE_CHANGE and</span>
<span class="cm">		 * CONFIG_CHANGE cases. */</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>for (i = 0; i &lt; fsg->nluns; ++i)
fsg->luns[i].unit<em>attention</em>data = SS<em>RESET</em>OCCURRED;</p></td><td class="code"><div class="highlight"><pre>		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_INTERFACE_CHANGE</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">do_set_interface</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span> <span class="o">!=</span> <span class="n">exception_req_tag</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>			<span class="c1">// STALL on errors</span>
			<span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">);</span>
		<span class="k">else</span>				<span class="c1">// Complete the status stage</span>
			<span class="n">ep0_queue</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_CONFIG_CHANGE</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">do_set_config</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">new_config</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span> <span class="o">!=</span> <span class="n">exception_req_tag</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>			<span class="c1">// STALL on errors</span>
			<span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">);</span>
		<span class="k">else</span>				<span class="c1">// Complete the status stage</span>
			<span class="n">ep0_queue</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_DISCONNECT</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">fsg_lun_fsync_sub</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">do_set_config</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>		<span class="c1">// Unconfigured state</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_EXIT</span>:
	<span class="k">case</span> <span class="n">FSG_STATE_TERMINATED</span>:
		<span class="n">do_set_config</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>			<span class="c1">// Free resources</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">;</span>	<span class="c1">// Stop the thread</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_main_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fsg_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">fsg_</span><span class="p">;</span>

	<span class="cm">/* Allow the thread to be killed by a signal, but set the signal mask</span>
<span class="cm">	 * to block everything but INT, TERM, KILL, and USR1. */</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">);</span>

	<span class="cm">/* Allow the thread to be frozen */</span>
	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="cm">/* Arrange for userspace references to be interpreted as kernel</span>
<span class="cm">	 * pointers.  That way we can pass a kernel pointer to a routine</span>
<span class="cm">	 * that expects a __user pointer and it will work okay. */</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">get_ds</span><span class="p">());</span>

	<span class="cm">/* The main loop */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">fsg</span><span class="p">)</span> <span class="o">||</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">handle_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sleep_thread</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_next_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_DATA_PHASE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_scsi_command</span><span class="p">(</span><span class="n">fsg</span><span class="p">)</span> <span class="o">||</span> <span class="n">finish_reply</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_STATUS_PHASE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_IDLE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* If we are exiting because of a signal, unregister the</span>
<span class="cm">	 * gadget driver. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">))</span>
		<span class="n">usb_gadget_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg_driver</span><span class="p">);</span>

	<span class="cm">/* Let the unbind and cleanup routines know the thread has exited */</span>
	<span class="n">complete_and_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>


<span class="cm">/* The write permissions and store_xxx pointers are set in fsg_bind() */</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">fsg_show_ro</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">nofua</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">fsg_show_nofua</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">fsg_show_file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsg_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>	<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_dev</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lun_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="o">*</span><span class="n">filesem</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">filesem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_dev</span><span class="p">,</span> <span class="n">filesem</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">fsg_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="cm">/* __init_or_exit */</span> <span class="n">fsg_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">get_gadget_data</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;unbind</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>

	<span class="cm">/* If the thread isn&#39;t already dead, tell it to exit now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">FSG_STATE_EXIT</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">);</span>

		<span class="cm">/* The cleanup routine waits for this completion also */</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unregister the sysfs attribute files and the LUNs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_nofua</span><span class="p">);</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_ro</span><span class="p">);</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_file</span><span class="p">);</span>
			<span class="n">fsg_lun_close</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
			<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Free the data buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">);</span>

	<span class="cm">/* Free the request and buffer for endpoint 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_gadget_data</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">check_parameters</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">prot</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">gcnum</span><span class="p">;</span>

	<span class="cm">/* Store the default values */</span>
	<span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span> <span class="o">=</span> <span class="n">USB_PR_BULK</span><span class="p">;</span>
	<span class="n">mod_data</span><span class="p">.</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Bulk-only&quot;</span><span class="p">;</span>
	<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">=</span> <span class="n">USB_SC_SCSI</span><span class="p">;</span>
	<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;Transparent SCSI&quot;</span><span class="p">;</span>

	<span class="cm">/* Some peripheral controllers are known not to be able to</span>
<span class="cm">	 * halt bulk endpoints correctly.  If one of them is present,</span>
<span class="cm">	 * disable stalls.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_at91</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">))</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">can_stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">release</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Parameter wasn&#39;t set</span>
		<span class="n">gcnum</span> <span class="o">=</span> <span class="n">usb_gadget_controller_number</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gcnum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="mh">0x0300</span> <span class="o">+</span> <span class="n">gcnum</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;controller &#39;%s&#39; not recognized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="mh">0x0399</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">prot</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB_FILE_STORAGE_TEST</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">transport_parm</span><span class="p">,</span> <span class="s">&quot;BBB&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">;</span>		<span class="c1">// Use default setting</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">transport_parm</span><span class="p">,</span> <span class="s">&quot;CB&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span> <span class="o">=</span> <span class="n">USB_PR_CB</span><span class="p">;</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Control-Bulk&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">transport_parm</span><span class="p">,</span> <span class="s">&quot;CBI&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span> <span class="o">=</span> <span class="n">USB_PR_CBI</span><span class="p">;</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Control-Bulk-Interrupt&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;invalid transport: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">transport_parm</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="s">&quot;SCSI&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">prot</span> <span class="o">==</span> <span class="n">USB_SC_SCSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">;</span>		<span class="c1">// Use default setting</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="s">&quot;RBC&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">prot</span> <span class="o">==</span> <span class="n">USB_SC_RBC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">=</span> <span class="n">USB_SC_RBC</span><span class="p">;</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;RBC&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="s">&quot;8020&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="s">&quot;ATAPI&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">prot</span> <span class="o">==</span> <span class="n">USB_SC_8020</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">=</span> <span class="n">USB_SC_8020</span><span class="p">;</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;8020i (ATAPI)&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="s">&quot;QIC&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">prot</span> <span class="o">==</span> <span class="n">USB_SC_QIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">=</span> <span class="n">USB_SC_QIC</span><span class="p">;</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;QIC-157&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="s">&quot;UFI&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">prot</span> <span class="o">==</span> <span class="n">USB_SC_UFI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">=</span> <span class="n">USB_SC_UFI</span><span class="p">;</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;UFI&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">,</span> <span class="s">&quot;8070&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">prot</span> <span class="o">==</span> <span class="n">USB_SC_8070</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span> <span class="o">=</span> <span class="n">USB_SC_8070</span><span class="p">;</span>
		<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;8070i&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;invalid protocol: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_parm</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span> <span class="o">&amp;=</span> <span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;invalid buflen</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETOOSMALL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_FILE_STORAGE_TEST */</span><span class="cp"></span>

	<span class="cm">/* Serial string handling.</span>
<span class="cm">	 * On a real device, the serial string would be loaded</span>
<span class="cm">	 * from permanent storage. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Sanity check :</span>
<span class="cm">		 * The CB[I] specification limits the serial string to</span>
<span class="cm">		 * 12 uppercase hexadecimal characters.</span>
<span class="cm">		 * BBB need at least 12 uppercase hexadecimal characters,</span>
<span class="cm">		 * with a maximum of 126. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">serial</span><span class="p">;</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span> <span class="o">++</span><span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ch</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">ch</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">*</span><span class="n">ch</span> <span class="o">&lt;</span> <span class="sc">&#39;A&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">ch</span> <span class="o">&gt;</span> <span class="sc">&#39;F&#39;</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* not uppercase hex */</span>
				<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span>
					<span class="s">&quot;Invalid serial string character: %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="o">*</span><span class="n">ch</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">no_serial</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">126</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span> <span class="o">==</span> <span class="n">USB_PR_BULK</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span> <span class="o">!=</span> <span class="n">USB_PR_BULK</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;Invalid serial string length!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_serial</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fsg_strings</span><span class="p">[</span><span class="n">FSG_STRING_SERIAL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">s</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">serial</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;No serial-number string provided!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
 <span class="nl">no_serial:</span>
		<span class="n">device_desc</span><span class="p">.</span><span class="n">iSerialNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">fsg_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">the_fsg</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">pathbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">gadget</span><span class="p">;</span>
	<span class="n">set_gadget_data</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="n">fsg</span><span class="p">);</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span> <span class="o">=</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">fsg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">check_parameters</span><span class="p">(</span><span class="n">fsg</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Enable the store_xxx attributes</span>
		<span class="n">dev_attr_file</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span><span class="p">;</span>
		<span class="n">dev_attr_file</span><span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">fsg_store_file</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_attr_ro</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span><span class="p">;</span>
			<span class="n">dev_attr_ro</span><span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">fsg_store_ro</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Only for removable media? */</span>
	<span class="n">dev_attr_nofua</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span><span class="p">;</span>
	<span class="n">dev_attr_nofua</span><span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">fsg_store_nofua</span><span class="p">;</span>

	<span class="cm">/* Find out how many LUNs there should be */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">nluns</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">num_filenames</span><span class="p">,</span> <span class="mi">1u</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">FSG_MAX_LUNS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;invalid number of LUNs: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create the LUNs, open their backing files, and register the</span>
<span class="cm">	 * LUN devices in sysfs. */</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_lun</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">cdrom</span> <span class="o">=</span> <span class="o">!!</span><span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span> <span class="o">||</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">ro</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">initially_ro</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">nofua</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">nofua</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">lun_release</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">;</span>
		<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="s">&quot;%s-lun%d&quot;</span><span class="p">,</span>
			     <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INFO</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;failed to register LUN%d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_ro</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_nofua</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">file</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">mod_data</span><span class="p">.</span><span class="n">file</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_lun_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">file</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;no file given for LUN%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Find all the endpoints we will use */</span>
	<span class="n">usb_ep_autoconfig_reset</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_ep_autoconfig</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_fs_bulk_in_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">autoconf_fail</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">fsg</span><span class="p">;</span>		<span class="c1">// claim the endpoint</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_ep_autoconfig</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_fs_bulk_out_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">autoconf_fail</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">fsg</span><span class="p">;</span>		<span class="c1">// claim the endpoint</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport_is_cbi</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_ep_autoconfig</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_fs_intr_in_desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">autoconf_fail</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">fsg</span><span class="p">;</span>		<span class="c1">// claim the endpoint</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">intr_in</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fix up the descriptors */</span>
	<span class="n">device_desc</span><span class="p">.</span><span class="n">idVendor</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">vendor</span><span class="p">);</span>
	<span class="n">device_desc</span><span class="p">.</span><span class="n">idProduct</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">product</span><span class="p">);</span>
	<span class="n">device_desc</span><span class="p">.</span><span class="n">bcdDevice</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">release</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">transport_is_cbi</span><span class="p">()</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);</span>	<span class="c1">// Number of endpoints</span>
	<span class="n">fsg_intf_desc</span><span class="p">.</span><span class="n">bNumEndpoints</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">fsg_intf_desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span><span class="p">;</span>
	<span class="n">fsg_intf_desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span><span class="p">;</span>
	<span class="n">fsg_fs_function</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">FSG_FS_FUNCTION_PRE_EP_ENTRIES</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_dualspeed</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fsg_hs_function</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">FSG_HS_FUNCTION_PRE_EP_ENTRIES</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Assume endpoint addresses are the same for both speeds */</span>
		<span class="n">fsg_hs_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">fsg_hs_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">fsg_hs_intr_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_intr_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_superspeed</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span>		<span class="n">max_burst</span><span class="p">;</span>

		<span class="n">fsg_ss_function</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">FSG_SS_FUNCTION_PRE_EP_ENTRIES</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Calculate bMaxBurst, we know packet size is 1024 */</span>
		<span class="n">max_burst</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>

		<span class="cm">/* Assume endpoint addresses are the same for both speeds */</span>
		<span class="n">fsg_ss_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">fsg_ss_bulk_in_comp_desc</span><span class="p">.</span><span class="n">bMaxBurst</span> <span class="o">=</span> <span class="n">max_burst</span><span class="p">;</span>

		<span class="n">fsg_ss_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">fsg_ss_bulk_out_comp_desc</span><span class="p">.</span><span class="n">bMaxBurst</span> <span class="o">=</span> <span class="n">max_burst</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_otg</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span>
		<span class="n">fsg_otg_desc</span><span class="p">.</span><span class="n">bmAttributes</span> <span class="o">|=</span> <span class="n">USB_OTG_HNP</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Allocate the request and buffer for endpoint 0 */</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0req</span> <span class="o">=</span> <span class="n">req</span> <span class="o">=</span> <span class="n">usb_ep_alloc_request</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">EP0_BUFSIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">ep0_complete</span><span class="p">;</span>

	<span class="cm">/* Allocate the data buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* Allocate for the bulk-in endpoint.  We assume that</span>
<span class="cm">		 * the buffer will also work with the bulk-out (and</span>
<span class="cm">		 * interrupt-in) endpoint. */</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">fsg_num_buffers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* This should reflect the actual gadget power source */</span>
	<span class="n">usb_gadget_set_selfpowered</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">fsg_string_manufacturer</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">fsg_string_manufacturer</span><span class="p">,</span>
			<span class="s">&quot;%s %s with %s&quot;</span><span class="p">,</span>
			<span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sysname</span><span class="p">,</span> <span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">,</span>
			<span class="n">gadget</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">fsg_main_thread</span><span class="p">,</span> <span class="n">fsg</span><span class="p">,</span>
			<span class="s">&quot;file-storage-gadget&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INFO</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">DRIVER_DESC</span> <span class="s">&quot;, version: &quot;</span> <span class="n">DRIVER_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">INFO</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;NOTE: This driver is deprecated.  &quot;</span>
			<span class="s">&quot;Consider using g_mass_storage instead.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">INFO</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;Number of LUNs=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">);</span>

	<span class="n">pathbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PATH_MAX</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg_lun_is_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pathbuf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span>
					   <span class="n">pathbuf</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
					<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">LINFO</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;ro=%d, nofua=%d, file: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">nofua</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span> <span class="o">?</span> <span class="n">p</span> <span class="o">:</span> <span class="s">&quot;(error)&quot;</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pathbuf</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;transport=%s (x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">transport_name</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">transport_type</span><span class="p">);</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;protocol=%s (x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_name</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">protocol_type</span><span class="p">);</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;VendorID=x%04x, ProductID=x%04x, Release=x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">product</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">release</span><span class="p">);</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;removable=%d, stall=%d, cdrom=%d, buflen=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">removable</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">can_stall</span><span class="p">,</span>
			<span class="n">mod_data</span><span class="p">.</span><span class="n">cdrom</span><span class="p">,</span> <span class="n">mod_data</span><span class="p">.</span><span class="n">buflen</span><span class="p">);</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;I/O thread pid: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">));</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>

	<span class="cm">/* Tell the thread to start working */</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">autoconf_fail:</span>
	<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;unable to autoconfigure all endpoints</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">;</span>	<span class="c1">// The thread is dead</span>
	<span class="n">fsg_unbind</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fsg_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">get_gadget_data</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fsg_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">get_gadget_data</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_gadget_driver</span>		<span class="n">fsg_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">max_speed</span>	<span class="o">=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">function</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fsg_string_product</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind</span>		<span class="o">=</span> <span class="n">fsg_unbind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span>	<span class="o">=</span> <span class="n">fsg_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">fsg_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">fsg_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">fsg_resume</span><span class="p">,</span>

	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>.release = ...
.suspend = ...
.resume = ...</p></td><td class="code"><div class="highlight"><pre>	<span class="p">},</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fsg_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span><span class="p">;</span>

	<span class="n">fsg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">fsg</span> <span class="o">+</span>
		      <span class="n">fsg_num_buffers</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="o">*</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">);</span>

	<span class="n">the_fsg</span> <span class="o">=</span> <span class="n">fsg</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fsg_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>	<span class="o">*</span><span class="n">fsg</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_num_buffers_validate</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_alloc</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">fsg</span> <span class="o">=</span> <span class="n">the_fsg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_gadget_probe_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg_driver</span><span class="p">,</span> <span class="n">fsg_bind</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">fsg_release</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">fsg_init</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">fsg_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>	<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">the_fsg</span><span class="p">;</span>

	<span class="cm">/* Unregister the driver iff the thread hasn&#39;t already done so */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">))</span>
		<span class="n">usb_gadget_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg_driver</span><span class="p">);</span>

	<span class="cm">/* Wait for the thread to finish up */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">fsg_release</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">fsg_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
