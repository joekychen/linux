<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › fsl_usb2_udc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fsl_usb2_udc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2004,2012 Freescale Semiconductor, Inc</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Freescale USB device/endpoint management registers</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __FSL_USB2_UDC_H</span>
<span class="cp">#define __FSL_USB2_UDC_H</span>

<span class="cm">/* ### define USB registers here</span>
<span class="cm"> */</span>
<span class="cp">#define USB_MAX_CTRL_PAYLOAD		64</span>
<span class="cp">#define USB_DR_SYS_OFFSET		0x400</span>

 <span class="cm">/* USB DR device mode registers (Little Endian) */</span>
<span class="k">struct</span> <span class="n">usb_dr_device</span> <span class="p">{</span>
	<span class="cm">/* Capability register */</span>
	<span class="n">u8</span> <span class="n">res1</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">caplength</span><span class="p">;</span>		<span class="cm">/* Capability Register Length */</span>
	<span class="n">u16</span> <span class="n">hciversion</span><span class="p">;</span>		<span class="cm">/* Host Controller Interface Version */</span>
	<span class="n">u32</span> <span class="n">hcsparams</span><span class="p">;</span>		<span class="cm">/* Host Controller Structural Parameters */</span>
	<span class="n">u32</span> <span class="n">hccparams</span><span class="p">;</span>		<span class="cm">/* Host Controller Capability Parameters */</span>
	<span class="n">u8</span> <span class="n">res2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">dciversion</span><span class="p">;</span>		<span class="cm">/* Device Controller Interface Version */</span>
	<span class="n">u32</span> <span class="n">dccparams</span><span class="p">;</span>		<span class="cm">/* Device Controller Capability Parameters */</span>
	<span class="n">u8</span> <span class="n">res3</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
	<span class="cm">/* Operation register */</span>
	<span class="n">u32</span> <span class="n">usbcmd</span><span class="p">;</span>		<span class="cm">/* USB Command Register */</span>
	<span class="n">u32</span> <span class="n">usbsts</span><span class="p">;</span>		<span class="cm">/* USB Status Register */</span>
	<span class="n">u32</span> <span class="n">usbintr</span><span class="p">;</span>		<span class="cm">/* USB Interrupt Enable Register */</span>
	<span class="n">u32</span> <span class="n">frindex</span><span class="p">;</span>		<span class="cm">/* Frame Index Register */</span>
	<span class="n">u8</span> <span class="n">res4</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">deviceaddr</span><span class="p">;</span>		<span class="cm">/* Device Address */</span>
	<span class="n">u32</span> <span class="n">endpointlistaddr</span><span class="p">;</span>	<span class="cm">/* Endpoint List Address Register */</span>
	<span class="n">u8</span> <span class="n">res5</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">burstsize</span><span class="p">;</span>		<span class="cm">/* Master Interface Data Burst Size Register */</span>
	<span class="n">u32</span> <span class="n">txttfilltuning</span><span class="p">;</span>	<span class="cm">/* Transmit FIFO Tuning Controls Register */</span>
	<span class="n">u8</span> <span class="n">res6</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">configflag</span><span class="p">;</span>		<span class="cm">/* Configure Flag Register */</span>
	<span class="n">u32</span> <span class="n">portsc1</span><span class="p">;</span>		<span class="cm">/* Port 1 Status and Control Register */</span>
	<span class="n">u8</span> <span class="n">res7</span><span class="p">[</span><span class="mi">28</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">otgsc</span><span class="p">;</span>		<span class="cm">/* On-The-Go Status and Control */</span>
	<span class="n">u32</span> <span class="n">usbmode</span><span class="p">;</span>		<span class="cm">/* USB Mode Register */</span>
	<span class="n">u32</span> <span class="n">endptsetupstat</span><span class="p">;</span>	<span class="cm">/* Endpoint Setup Status Register */</span>
	<span class="n">u32</span> <span class="n">endpointprime</span><span class="p">;</span>	<span class="cm">/* Endpoint Initialization Register */</span>
	<span class="n">u32</span> <span class="n">endptflush</span><span class="p">;</span>		<span class="cm">/* Endpoint Flush Register */</span>
	<span class="n">u32</span> <span class="n">endptstatus</span><span class="p">;</span>	<span class="cm">/* Endpoint Status Register */</span>
	<span class="n">u32</span> <span class="n">endptcomplete</span><span class="p">;</span>	<span class="cm">/* Endpoint Complete Register */</span>
	<span class="n">u32</span> <span class="n">endptctrl</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>	<span class="cm">/* Endpoint Control Registers */</span>
<span class="p">};</span>

 <span class="cm">/* USB DR host mode registers (Little Endian) */</span>
<span class="k">struct</span> <span class="n">usb_dr_host</span> <span class="p">{</span>
	<span class="cm">/* Capability register */</span>
	<span class="n">u8</span> <span class="n">res1</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">caplength</span><span class="p">;</span>		<span class="cm">/* Capability Register Length */</span>
	<span class="n">u16</span> <span class="n">hciversion</span><span class="p">;</span>		<span class="cm">/* Host Controller Interface Version */</span>
	<span class="n">u32</span> <span class="n">hcsparams</span><span class="p">;</span>		<span class="cm">/* Host Controller Structural Parameters */</span>
	<span class="n">u32</span> <span class="n">hccparams</span><span class="p">;</span>		<span class="cm">/* Host Controller Capability Parameters */</span>
	<span class="n">u8</span> <span class="n">res2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">dciversion</span><span class="p">;</span>		<span class="cm">/* Device Controller Interface Version */</span>
	<span class="n">u32</span> <span class="n">dccparams</span><span class="p">;</span>		<span class="cm">/* Device Controller Capability Parameters */</span>
	<span class="n">u8</span> <span class="n">res3</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
	<span class="cm">/* Operation register */</span>
	<span class="n">u32</span> <span class="n">usbcmd</span><span class="p">;</span>		<span class="cm">/* USB Command Register */</span>
	<span class="n">u32</span> <span class="n">usbsts</span><span class="p">;</span>		<span class="cm">/* USB Status Register */</span>
	<span class="n">u32</span> <span class="n">usbintr</span><span class="p">;</span>		<span class="cm">/* USB Interrupt Enable Register */</span>
	<span class="n">u32</span> <span class="n">frindex</span><span class="p">;</span>		<span class="cm">/* Frame Index Register */</span>
	<span class="n">u8</span> <span class="n">res4</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">periodiclistbase</span><span class="p">;</span>	<span class="cm">/* Periodic Frame List Base Address Register */</span>
	<span class="n">u32</span> <span class="n">asynclistaddr</span><span class="p">;</span>	<span class="cm">/* Current Asynchronous List Address Register */</span>
	<span class="n">u8</span> <span class="n">res5</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">burstsize</span><span class="p">;</span>		<span class="cm">/* Master Interface Data Burst Size Register */</span>
	<span class="n">u32</span> <span class="n">txttfilltuning</span><span class="p">;</span>	<span class="cm">/* Transmit FIFO Tuning Controls Register */</span>
	<span class="n">u8</span> <span class="n">res6</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">configflag</span><span class="p">;</span>		<span class="cm">/* Configure Flag Register */</span>
	<span class="n">u32</span> <span class="n">portsc1</span><span class="p">;</span>		<span class="cm">/* Port 1 Status and Control Register */</span>
	<span class="n">u8</span> <span class="n">res7</span><span class="p">[</span><span class="mi">28</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">otgsc</span><span class="p">;</span>		<span class="cm">/* On-The-Go Status and Control */</span>
	<span class="n">u32</span> <span class="n">usbmode</span><span class="p">;</span>		<span class="cm">/* USB Mode Register */</span>
	<span class="n">u32</span> <span class="n">endptsetupstat</span><span class="p">;</span>	<span class="cm">/* Endpoint Setup Status Register */</span>
	<span class="n">u32</span> <span class="n">endpointprime</span><span class="p">;</span>	<span class="cm">/* Endpoint Initialization Register */</span>
	<span class="n">u32</span> <span class="n">endptflush</span><span class="p">;</span>		<span class="cm">/* Endpoint Flush Register */</span>
	<span class="n">u32</span> <span class="n">endptstatus</span><span class="p">;</span>	<span class="cm">/* Endpoint Status Register */</span>
	<span class="n">u32</span> <span class="n">endptcomplete</span><span class="p">;</span>	<span class="cm">/* Endpoint Complete Register */</span>
	<span class="n">u32</span> <span class="n">endptctrl</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>	<span class="cm">/* Endpoint Control Registers */</span>
<span class="p">};</span>

 <span class="cm">/* non-EHCI USB system interface registers (Big Endian) */</span>
<span class="k">struct</span> <span class="n">usb_sys_interface</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">snoop1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">snoop2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">age_cnt_thresh</span><span class="p">;</span>	<span class="cm">/* Age Count Threshold Register */</span>
	<span class="n">u32</span> <span class="n">pri_ctrl</span><span class="p">;</span>		<span class="cm">/* Priority Control Register */</span>
	<span class="n">u32</span> <span class="n">si_ctrl</span><span class="p">;</span>		<span class="cm">/* System Interface Control Register */</span>
	<span class="n">u8</span> <span class="n">res</span><span class="p">[</span><span class="mi">236</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">control</span><span class="p">;</span>		<span class="cm">/* General Purpose Control Register */</span>
<span class="p">};</span>

<span class="cm">/* ep0 transfer state */</span>
<span class="cp">#define WAIT_FOR_SETUP          0</span>
<span class="cp">#define DATA_STATE_XMIT         1</span>
<span class="cp">#define DATA_STATE_NEED_ZLP     2</span>
<span class="cp">#define WAIT_FOR_OUT_STATUS     3</span>
<span class="cp">#define DATA_STATE_RECV         4</span>

<span class="cm">/* Device Controller Capability Parameter register */</span>
<span class="cp">#define DCCPARAMS_DC				0x00000080</span>
<span class="cp">#define DCCPARAMS_DEN_MASK			0x0000001f</span>

<span class="cm">/* Frame Index Register Bit Masks */</span>
<span class="cp">#define	USB_FRINDEX_MASKS			0x3fff</span>
<span class="cm">/* USB CMD  Register Bit Masks */</span>
<span class="cp">#define  USB_CMD_RUN_STOP                     0x00000001</span>
<span class="cp">#define  USB_CMD_CTRL_RESET                   0x00000002</span>
<span class="cp">#define  USB_CMD_PERIODIC_SCHEDULE_EN         0x00000010</span>
<span class="cp">#define  USB_CMD_ASYNC_SCHEDULE_EN            0x00000020</span>
<span class="cp">#define  USB_CMD_INT_AA_DOORBELL              0x00000040</span>
<span class="cp">#define  USB_CMD_ASP                          0x00000300</span>
<span class="cp">#define  USB_CMD_ASYNC_SCH_PARK_EN            0x00000800</span>
<span class="cp">#define  USB_CMD_SUTW                         0x00002000</span>
<span class="cp">#define  USB_CMD_ATDTW                        0x00004000</span>
<span class="cp">#define  USB_CMD_ITC                          0x00FF0000</span>

<span class="cm">/* bit 15,3,2 are frame list size */</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_1024              0x00000000</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_512               0x00000004</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_256               0x00000008</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_128               0x0000000C</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_64                0x00008000</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_32                0x00008004</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_16                0x00008008</span>
<span class="cp">#define  USB_CMD_FRAME_SIZE_8                 0x0000800C</span>

<span class="cm">/* bit 9-8 are async schedule park mode count */</span>
<span class="cp">#define  USB_CMD_ASP_00                       0x00000000</span>
<span class="cp">#define  USB_CMD_ASP_01                       0x00000100</span>
<span class="cp">#define  USB_CMD_ASP_10                       0x00000200</span>
<span class="cp">#define  USB_CMD_ASP_11                       0x00000300</span>
<span class="cp">#define  USB_CMD_ASP_BIT_POS                  8</span>

<span class="cm">/* bit 23-16 are interrupt threshold control */</span>
<span class="cp">#define  USB_CMD_ITC_NO_THRESHOLD             0x00000000</span>
<span class="cp">#define  USB_CMD_ITC_1_MICRO_FRM              0x00010000</span>
<span class="cp">#define  USB_CMD_ITC_2_MICRO_FRM              0x00020000</span>
<span class="cp">#define  USB_CMD_ITC_4_MICRO_FRM              0x00040000</span>
<span class="cp">#define  USB_CMD_ITC_8_MICRO_FRM              0x00080000</span>
<span class="cp">#define  USB_CMD_ITC_16_MICRO_FRM             0x00100000</span>
<span class="cp">#define  USB_CMD_ITC_32_MICRO_FRM             0x00200000</span>
<span class="cp">#define  USB_CMD_ITC_64_MICRO_FRM             0x00400000</span>
<span class="cp">#define  USB_CMD_ITC_BIT_POS                  16</span>

<span class="cm">/* USB STS Register Bit Masks */</span>
<span class="cp">#define  USB_STS_INT                          0x00000001</span>
<span class="cp">#define  USB_STS_ERR                          0x00000002</span>
<span class="cp">#define  USB_STS_PORT_CHANGE                  0x00000004</span>
<span class="cp">#define  USB_STS_FRM_LST_ROLL                 0x00000008</span>
<span class="cp">#define  USB_STS_SYS_ERR                      0x00000010</span>
<span class="cp">#define  USB_STS_IAA                          0x00000020</span>
<span class="cp">#define  USB_STS_RESET                        0x00000040</span>
<span class="cp">#define  USB_STS_SOF                          0x00000080</span>
<span class="cp">#define  USB_STS_SUSPEND                      0x00000100</span>
<span class="cp">#define  USB_STS_HC_HALTED                    0x00001000</span>
<span class="cp">#define  USB_STS_RCL                          0x00002000</span>
<span class="cp">#define  USB_STS_PERIODIC_SCHEDULE            0x00004000</span>
<span class="cp">#define  USB_STS_ASYNC_SCHEDULE               0x00008000</span>

<span class="cm">/* USB INTR Register Bit Masks */</span>
<span class="cp">#define  USB_INTR_INT_EN                      0x00000001</span>
<span class="cp">#define  USB_INTR_ERR_INT_EN                  0x00000002</span>
<span class="cp">#define  USB_INTR_PTC_DETECT_EN               0x00000004</span>
<span class="cp">#define  USB_INTR_FRM_LST_ROLL_EN             0x00000008</span>
<span class="cp">#define  USB_INTR_SYS_ERR_EN                  0x00000010</span>
<span class="cp">#define  USB_INTR_ASYN_ADV_EN                 0x00000020</span>
<span class="cp">#define  USB_INTR_RESET_EN                    0x00000040</span>
<span class="cp">#define  USB_INTR_SOF_EN                      0x00000080</span>
<span class="cp">#define  USB_INTR_DEVICE_SUSPEND              0x00000100</span>

<span class="cm">/* Device Address bit masks */</span>
<span class="cp">#define  USB_DEVICE_ADDRESS_MASK              0xFE000000</span>
<span class="cp">#define  USB_DEVICE_ADDRESS_BIT_POS           25</span>

<span class="cm">/* endpoint list address bit masks */</span>
<span class="cp">#define USB_EP_LIST_ADDRESS_MASK              0xfffff800</span>

<span class="cm">/* PORTSCX  Register Bit Masks */</span>
<span class="cp">#define  PORTSCX_CURRENT_CONNECT_STATUS       0x00000001</span>
<span class="cp">#define  PORTSCX_CONNECT_STATUS_CHANGE        0x00000002</span>
<span class="cp">#define  PORTSCX_PORT_ENABLE                  0x00000004</span>
<span class="cp">#define  PORTSCX_PORT_EN_DIS_CHANGE           0x00000008</span>
<span class="cp">#define  PORTSCX_OVER_CURRENT_ACT             0x00000010</span>
<span class="cp">#define  PORTSCX_OVER_CURRENT_CHG             0x00000020</span>
<span class="cp">#define  PORTSCX_PORT_FORCE_RESUME            0x00000040</span>
<span class="cp">#define  PORTSCX_PORT_SUSPEND                 0x00000080</span>
<span class="cp">#define  PORTSCX_PORT_RESET                   0x00000100</span>
<span class="cp">#define  PORTSCX_LINE_STATUS_BITS             0x00000C00</span>
<span class="cp">#define  PORTSCX_PORT_POWER                   0x00001000</span>
<span class="cp">#define  PORTSCX_PORT_INDICTOR_CTRL           0x0000C000</span>
<span class="cp">#define  PORTSCX_PORT_TEST_CTRL               0x000F0000</span>
<span class="cp">#define  PORTSCX_WAKE_ON_CONNECT_EN           0x00100000</span>
<span class="cp">#define  PORTSCX_WAKE_ON_CONNECT_DIS          0x00200000</span>
<span class="cp">#define  PORTSCX_WAKE_ON_OVER_CURRENT         0x00400000</span>
<span class="cp">#define  PORTSCX_PHY_LOW_POWER_SPD            0x00800000</span>
<span class="cp">#define  PORTSCX_PORT_FORCE_FULL_SPEED        0x01000000</span>
<span class="cp">#define  PORTSCX_PORT_SPEED_MASK              0x0C000000</span>
<span class="cp">#define  PORTSCX_PORT_WIDTH                   0x10000000</span>
<span class="cp">#define  PORTSCX_PHY_TYPE_SEL                 0xC0000000</span>

<span class="cm">/* bit 11-10 are line status */</span>
<span class="cp">#define  PORTSCX_LINE_STATUS_SE0              0x00000000</span>
<span class="cp">#define  PORTSCX_LINE_STATUS_JSTATE           0x00000400</span>
<span class="cp">#define  PORTSCX_LINE_STATUS_KSTATE           0x00000800</span>
<span class="cp">#define  PORTSCX_LINE_STATUS_UNDEF            0x00000C00</span>
<span class="cp">#define  PORTSCX_LINE_STATUS_BIT_POS          10</span>

<span class="cm">/* bit 15-14 are port indicator control */</span>
<span class="cp">#define  PORTSCX_PIC_OFF                      0x00000000</span>
<span class="cp">#define  PORTSCX_PIC_AMBER                    0x00004000</span>
<span class="cp">#define  PORTSCX_PIC_GREEN                    0x00008000</span>
<span class="cp">#define  PORTSCX_PIC_UNDEF                    0x0000C000</span>
<span class="cp">#define  PORTSCX_PIC_BIT_POS                  14</span>

<span class="cm">/* bit 19-16 are port test control */</span>
<span class="cp">#define  PORTSCX_PTC_DISABLE                  0x00000000</span>
<span class="cp">#define  PORTSCX_PTC_JSTATE                   0x00010000</span>
<span class="cp">#define  PORTSCX_PTC_KSTATE                   0x00020000</span>
<span class="cp">#define  PORTSCX_PTC_SEQNAK                   0x00030000</span>
<span class="cp">#define  PORTSCX_PTC_PACKET                   0x00040000</span>
<span class="cp">#define  PORTSCX_PTC_FORCE_EN                 0x00050000</span>
<span class="cp">#define  PORTSCX_PTC_BIT_POS                  16</span>

<span class="cm">/* bit 27-26 are port speed */</span>
<span class="cp">#define  PORTSCX_PORT_SPEED_FULL              0x00000000</span>
<span class="cp">#define  PORTSCX_PORT_SPEED_LOW               0x04000000</span>
<span class="cp">#define  PORTSCX_PORT_SPEED_HIGH              0x08000000</span>
<span class="cp">#define  PORTSCX_PORT_SPEED_UNDEF             0x0C000000</span>
<span class="cp">#define  PORTSCX_SPEED_BIT_POS                26</span>

<span class="cm">/* bit 28 is parallel transceiver width for UTMI interface */</span>
<span class="cp">#define  PORTSCX_PTW                          0x10000000</span>
<span class="cp">#define  PORTSCX_PTW_8BIT                     0x00000000</span>
<span class="cp">#define  PORTSCX_PTW_16BIT                    0x10000000</span>

<span class="cm">/* bit 31-30 are port transceiver select */</span>
<span class="cp">#define  PORTSCX_PTS_UTMI                     0x00000000</span>
<span class="cp">#define  PORTSCX_PTS_ULPI                     0x80000000</span>
<span class="cp">#define  PORTSCX_PTS_FSLS                     0xC0000000</span>
<span class="cp">#define  PORTSCX_PTS_BIT_POS                  30</span>

<span class="cm">/* otgsc Register Bit Masks */</span>
<span class="cp">#define  OTGSC_CTRL_VUSB_DISCHARGE            0x00000001</span>
<span class="cp">#define  OTGSC_CTRL_VUSB_CHARGE               0x00000002</span>
<span class="cp">#define  OTGSC_CTRL_OTG_TERM                  0x00000008</span>
<span class="cp">#define  OTGSC_CTRL_DATA_PULSING              0x00000010</span>
<span class="cp">#define  OTGSC_STS_USB_ID                     0x00000100</span>
<span class="cp">#define  OTGSC_STS_A_VBUS_VALID               0x00000200</span>
<span class="cp">#define  OTGSC_STS_A_SESSION_VALID            0x00000400</span>
<span class="cp">#define  OTGSC_STS_B_SESSION_VALID            0x00000800</span>
<span class="cp">#define  OTGSC_STS_B_SESSION_END              0x00001000</span>
<span class="cp">#define  OTGSC_STS_1MS_TOGGLE                 0x00002000</span>
<span class="cp">#define  OTGSC_STS_DATA_PULSING               0x00004000</span>
<span class="cp">#define  OTGSC_INTSTS_USB_ID                  0x00010000</span>
<span class="cp">#define  OTGSC_INTSTS_A_VBUS_VALID            0x00020000</span>
<span class="cp">#define  OTGSC_INTSTS_A_SESSION_VALID         0x00040000</span>
<span class="cp">#define  OTGSC_INTSTS_B_SESSION_VALID         0x00080000</span>
<span class="cp">#define  OTGSC_INTSTS_B_SESSION_END           0x00100000</span>
<span class="cp">#define  OTGSC_INTSTS_1MS                     0x00200000</span>
<span class="cp">#define  OTGSC_INTSTS_DATA_PULSING            0x00400000</span>
<span class="cp">#define  OTGSC_INTR_USB_ID                    0x01000000</span>
<span class="cp">#define  OTGSC_INTR_A_VBUS_VALID              0x02000000</span>
<span class="cp">#define  OTGSC_INTR_A_SESSION_VALID           0x04000000</span>
<span class="cp">#define  OTGSC_INTR_B_SESSION_VALID           0x08000000</span>
<span class="cp">#define  OTGSC_INTR_B_SESSION_END             0x10000000</span>
<span class="cp">#define  OTGSC_INTR_1MS_TIMER                 0x20000000</span>
<span class="cp">#define  OTGSC_INTR_DATA_PULSING              0x40000000</span>

<span class="cm">/* USB MODE Register Bit Masks */</span>
<span class="cp">#define  USB_MODE_CTRL_MODE_IDLE              0x00000000</span>
<span class="cp">#define  USB_MODE_CTRL_MODE_DEVICE            0x00000002</span>
<span class="cp">#define  USB_MODE_CTRL_MODE_HOST              0x00000003</span>
<span class="cp">#define  USB_MODE_CTRL_MODE_MASK              0x00000003</span>
<span class="cp">#define  USB_MODE_CTRL_MODE_RSV               0x00000001</span>
<span class="cp">#define  USB_MODE_ES                          0x00000004 </span><span class="cm">/* Endian Select */</span><span class="cp"></span>
<span class="cp">#define  USB_MODE_SETUP_LOCK_OFF              0x00000008</span>
<span class="cp">#define  USB_MODE_STREAM_DISABLE              0x00000010</span>
<span class="cm">/* Endpoint Flush Register */</span>
<span class="cp">#define EPFLUSH_TX_OFFSET		      0x00010000</span>
<span class="cp">#define EPFLUSH_RX_OFFSET		      0x00000000</span>

<span class="cm">/* Endpoint Setup Status bit masks */</span>
<span class="cp">#define  EP_SETUP_STATUS_MASK                 0x0000003F</span>
<span class="cp">#define  EP_SETUP_STATUS_EP0		      0x00000001</span>

<span class="cm">/* ENDPOINTCTRLx  Register Bit Masks */</span>
<span class="cp">#define  EPCTRL_TX_ENABLE                     0x00800000</span>
<span class="cp">#define  EPCTRL_TX_DATA_TOGGLE_RST            0x00400000	</span><span class="cm">/* Not EP0 */</span><span class="cp"></span>
<span class="cp">#define  EPCTRL_TX_DATA_TOGGLE_INH            0x00200000	</span><span class="cm">/* Not EP0 */</span><span class="cp"></span>
<span class="cp">#define  EPCTRL_TX_TYPE                       0x000C0000</span>
<span class="cp">#define  EPCTRL_TX_DATA_SOURCE                0x00020000	</span><span class="cm">/* Not EP0 */</span><span class="cp"></span>
<span class="cp">#define  EPCTRL_TX_EP_STALL                   0x00010000</span>
<span class="cp">#define  EPCTRL_RX_ENABLE                     0x00000080</span>
<span class="cp">#define  EPCTRL_RX_DATA_TOGGLE_RST            0x00000040	</span><span class="cm">/* Not EP0 */</span><span class="cp"></span>
<span class="cp">#define  EPCTRL_RX_DATA_TOGGLE_INH            0x00000020	</span><span class="cm">/* Not EP0 */</span><span class="cp"></span>
<span class="cp">#define  EPCTRL_RX_TYPE                       0x0000000C</span>
<span class="cp">#define  EPCTRL_RX_DATA_SINK                  0x00000002	</span><span class="cm">/* Not EP0 */</span><span class="cp"></span>
<span class="cp">#define  EPCTRL_RX_EP_STALL                   0x00000001</span>

<span class="cm">/* bit 19-18 and 3-2 are endpoint type */</span>
<span class="cp">#define  EPCTRL_EP_TYPE_CONTROL               0</span>
<span class="cp">#define  EPCTRL_EP_TYPE_ISO                   1</span>
<span class="cp">#define  EPCTRL_EP_TYPE_BULK                  2</span>
<span class="cp">#define  EPCTRL_EP_TYPE_INTERRUPT             3</span>
<span class="cp">#define  EPCTRL_TX_EP_TYPE_SHIFT              18</span>
<span class="cp">#define  EPCTRL_RX_EP_TYPE_SHIFT              2</span>

<span class="cm">/* SNOOPn Register Bit Masks */</span>
<span class="cp">#define  SNOOP_ADDRESS_MASK                   0xFFFFF000</span>
<span class="cp">#define  SNOOP_SIZE_ZERO                      0x00	</span><span class="cm">/* snooping disable */</span><span class="cp"></span>
<span class="cp">#define  SNOOP_SIZE_4KB                       0x0B	</span><span class="cm">/* 4KB snoop size */</span><span class="cp"></span>
<span class="cp">#define  SNOOP_SIZE_8KB                       0x0C</span>
<span class="cp">#define  SNOOP_SIZE_16KB                      0x0D</span>
<span class="cp">#define  SNOOP_SIZE_32KB                      0x0E</span>
<span class="cp">#define  SNOOP_SIZE_64KB                      0x0F</span>
<span class="cp">#define  SNOOP_SIZE_128KB                     0x10</span>
<span class="cp">#define  SNOOP_SIZE_256KB                     0x11</span>
<span class="cp">#define  SNOOP_SIZE_512KB                     0x12</span>
<span class="cp">#define  SNOOP_SIZE_1MB                       0x13</span>
<span class="cp">#define  SNOOP_SIZE_2MB                       0x14</span>
<span class="cp">#define  SNOOP_SIZE_4MB                       0x15</span>
<span class="cp">#define  SNOOP_SIZE_8MB                       0x16</span>
<span class="cp">#define  SNOOP_SIZE_16MB                      0x17</span>
<span class="cp">#define  SNOOP_SIZE_32MB                      0x18</span>
<span class="cp">#define  SNOOP_SIZE_64MB                      0x19</span>
<span class="cp">#define  SNOOP_SIZE_128MB                     0x1A</span>
<span class="cp">#define  SNOOP_SIZE_256MB                     0x1B</span>
<span class="cp">#define  SNOOP_SIZE_512MB                     0x1C</span>
<span class="cp">#define  SNOOP_SIZE_1GB                       0x1D</span>
<span class="cp">#define  SNOOP_SIZE_2GB                       0x1E	</span><span class="cm">/* 2GB snoop size */</span><span class="cp"></span>

<span class="cm">/* pri_ctrl Register Bit Masks */</span>
<span class="cp">#define  PRI_CTRL_PRI_LVL1                    0x0000000C</span>
<span class="cp">#define  PRI_CTRL_PRI_LVL0                    0x00000003</span>

<span class="cm">/* si_ctrl Register Bit Masks */</span>
<span class="cp">#define  SI_CTRL_ERR_DISABLE                  0x00000010</span>
<span class="cp">#define  SI_CTRL_IDRC_DISABLE                 0x00000008</span>
<span class="cp">#define  SI_CTRL_RD_SAFE_EN                   0x00000004</span>
<span class="cp">#define  SI_CTRL_RD_PREFETCH_DISABLE          0x00000002</span>
<span class="cp">#define  SI_CTRL_RD_PREFEFETCH_VAL            0x00000001</span>

<span class="cm">/* control Register Bit Masks */</span>
<span class="cp">#define  USB_CTRL_IOENB                       0x00000004</span>
<span class="cp">#define  USB_CTRL_ULPI_INT0EN                 0x00000001</span>
<span class="cp">#define USB_CTRL_UTMI_PHY_EN		      0x00000200</span>
<span class="cp">#define USB_CTRL_USB_EN			      0x00000004</span>
<span class="cp">#define USB_CTRL_ULPI_PHY_CLK_SEL	      0x00000400</span>

<span class="cm">/* Endpoint Queue Head data struct</span>
<span class="cm"> * Rem: all the variables of qh are LittleEndian Mode</span>
<span class="cm"> * and NEXT_POINTER_MASK should operate on a LittleEndian, Phy Addr</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_pkt_length</span><span class="p">;</span>	<span class="cm">/* Mult(31-30) , Zlt(29) , Max Pkt len</span>
<span class="cm">				   and IOS(15) */</span>
	<span class="n">u32</span> <span class="n">curr_dtd_ptr</span><span class="p">;</span>	<span class="cm">/* Current dTD Pointer(31-5) */</span>
	<span class="n">u32</span> <span class="n">next_dtd_ptr</span><span class="p">;</span>	<span class="cm">/* Next dTD Pointer(31-5), T(0) */</span>
	<span class="n">u32</span> <span class="n">size_ioc_int_sts</span><span class="p">;</span>	<span class="cm">/* Total bytes (30-16), IOC (15),</span>
<span class="cm">				   MultO(11-10), STS (7-0)  */</span>
	<span class="n">u32</span> <span class="n">buff_ptr0</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 0 (31-12) */</span>
	<span class="n">u32</span> <span class="n">buff_ptr1</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 1 (31-12) */</span>
	<span class="n">u32</span> <span class="n">buff_ptr2</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 2 (31-12) */</span>
	<span class="n">u32</span> <span class="n">buff_ptr3</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 3 (31-12) */</span>
	<span class="n">u32</span> <span class="n">buff_ptr4</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 4 (31-12) */</span>
	<span class="n">u32</span> <span class="n">res1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">setup_buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* Setup data 8 bytes */</span>
	<span class="n">u32</span> <span class="n">res2</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Endpoint Queue Head Bit Masks */</span>
<span class="cp">#define  EP_QUEUE_HEAD_MULT_POS               30</span>
<span class="cp">#define  EP_QUEUE_HEAD_ZLT_SEL                0x20000000</span>
<span class="cp">#define  EP_QUEUE_HEAD_MAX_PKT_LEN_POS        16</span>
<span class="cp">#define  EP_QUEUE_HEAD_MAX_PKT_LEN(ep_info)   (((ep_info)&gt;&gt;16)&amp;0x07ff)</span>
<span class="cp">#define  EP_QUEUE_HEAD_IOS                    0x00008000</span>
<span class="cp">#define  EP_QUEUE_HEAD_NEXT_TERMINATE         0x00000001</span>
<span class="cp">#define  EP_QUEUE_HEAD_IOC                    0x00008000</span>
<span class="cp">#define  EP_QUEUE_HEAD_MULTO                  0x00000C00</span>
<span class="cp">#define  EP_QUEUE_HEAD_STATUS_HALT	      0x00000040</span>
<span class="cp">#define  EP_QUEUE_HEAD_STATUS_ACTIVE          0x00000080</span>
<span class="cp">#define  EP_QUEUE_CURRENT_OFFSET_MASK         0x00000FFF</span>
<span class="cp">#define  EP_QUEUE_HEAD_NEXT_POINTER_MASK      0xFFFFFFE0</span>
<span class="cp">#define  EP_QUEUE_FRINDEX_MASK                0x000007FF</span>
<span class="cp">#define  EP_MAX_LENGTH_TRANSFER               0x4000</span>

<span class="cm">/* Endpoint Transfer Descriptor data struct */</span>
<span class="cm">/* Rem: all the variables of td are LittleEndian Mode */</span>
<span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">next_td_ptr</span><span class="p">;</span>	<span class="cm">/* Next TD pointer(31-5), T(0) set</span>
<span class="cm">				   indicate invalid */</span>
	<span class="n">u32</span> <span class="n">size_ioc_sts</span><span class="p">;</span>	<span class="cm">/* Total bytes (30-16), IOC (15),</span>
<span class="cm">				   MultO(11-10), STS (7-0)  */</span>
	<span class="n">u32</span> <span class="n">buff_ptr0</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 0 */</span>
	<span class="n">u32</span> <span class="n">buff_ptr1</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 1 */</span>
	<span class="n">u32</span> <span class="n">buff_ptr2</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 2 */</span>
	<span class="n">u32</span> <span class="n">buff_ptr3</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 3 */</span>
	<span class="n">u32</span> <span class="n">buff_ptr4</span><span class="p">;</span>		<span class="cm">/* Buffer pointer Page 4 */</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>
	<span class="cm">/* 32 bytes */</span>
	<span class="n">dma_addr_t</span> <span class="n">td_dma</span><span class="p">;</span>	<span class="cm">/* dma address for this td */</span>
	<span class="cm">/* virtual address of next td specified in next_td_ptr */</span>
	<span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="n">next_td_virt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Endpoint Transfer Descriptor bit Masks */</span>
<span class="cp">#define  DTD_NEXT_TERMINATE                   0x00000001</span>
<span class="cp">#define  DTD_IOC                              0x00008000</span>
<span class="cp">#define  DTD_STATUS_ACTIVE                    0x00000080</span>
<span class="cp">#define  DTD_STATUS_HALTED                    0x00000040</span>
<span class="cp">#define  DTD_STATUS_DATA_BUFF_ERR             0x00000020</span>
<span class="cp">#define  DTD_STATUS_TRANSACTION_ERR           0x00000008</span>
<span class="cp">#define  DTD_RESERVED_FIELDS                  0x80007300</span>
<span class="cp">#define  DTD_ADDR_MASK                        0xFFFFFFE0</span>
<span class="cp">#define  DTD_PACKET_SIZE                      0x7FFF0000</span>
<span class="cp">#define  DTD_LENGTH_BIT_POS                   16</span>
<span class="cp">#define  DTD_ERROR_MASK                       (DTD_STATUS_HALTED | \</span>
<span class="cp">                                               DTD_STATUS_DATA_BUFF_ERR | \</span>
<span class="cp">                                               DTD_STATUS_TRANSACTION_ERR)</span>
<span class="cm">/* Alignment requirements; must be a power of two */</span>
<span class="cp">#define DTD_ALIGNMENT				0x20</span>
<span class="cp">#define QH_ALIGNMENT				2048</span>

<span class="cm">/* Controller dma boundary */</span>
<span class="cp">#define UDC_DMA_BOUNDARY			0x1000</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* ### driver private data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
	<span class="cm">/* ep_queue() func will add</span>
<span class="cm">	   a request-&gt;queue into a udc_ep-&gt;queue &#39;d tail */</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mapped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ep_td_struct</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>	<span class="cm">/* For dTD List</span>
<span class="cm">						   cpu endian Virtual addr */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dtd_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define REQ_UNCOMPLETE			1</span>

<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ep</span> <span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">stopped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EP_DIR_IN	1</span>
<span class="cp">#define EP_DIR_OUT	0</span>

<span class="k">struct</span> <span class="n">fsl_udc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span> <span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_usb2_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">done</span><span class="p">;</span>	<span class="cm">/* to make sure release() is done */</span>
	<span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">eps</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">local_setup_buff</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">transceiver</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">softconnect</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vbus_active</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">stopped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">remote_wakeup</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">already_stopped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">big_endian_desc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="o">*</span><span class="n">ep_qh</span><span class="p">;</span>	<span class="cm">/* Endpoints Queue-Head */</span>
	<span class="k">struct</span> <span class="n">fsl_req</span> <span class="o">*</span><span class="n">status_req</span><span class="p">;</span>	<span class="cm">/* ep0 status request */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span> <span class="o">*</span><span class="n">td_pool</span><span class="p">;</span>	<span class="cm">/* dma pool for DTD */</span>
	<span class="k">enum</span> <span class="n">fsl_usb2_phy_modes</span> <span class="n">phy_mode</span><span class="p">;</span>

	<span class="kt">size_t</span> <span class="n">ep_qh_size</span><span class="p">;</span>		<span class="cm">/* size after alignment adjustment*/</span>
	<span class="n">dma_addr_t</span> <span class="n">ep_qh_dma</span><span class="p">;</span>		<span class="cm">/* dma address of QH */</span>

	<span class="n">u32</span> <span class="n">max_pipes</span><span class="p">;</span>          <span class="cm">/* Device max pipes */</span>
	<span class="n">u32</span> <span class="n">bus_reset</span><span class="p">;</span>		<span class="cm">/* Device is bus resetting */</span>
	<span class="n">u32</span> <span class="n">resume_state</span><span class="p">;</span>	<span class="cm">/* USB state to resume */</span>
	<span class="n">u32</span> <span class="n">usb_state</span><span class="p">;</span>		<span class="cm">/* USB current state */</span>
	<span class="n">u32</span> <span class="n">ep0_state</span><span class="p">;</span>		<span class="cm">/* Endpoint zero state */</span>
	<span class="n">u32</span> <span class="n">ep0_dir</span><span class="p">;</span>		<span class="cm">/* Endpoint zero direction: can be</span>
<span class="cm">				   USB_DIR_IN or USB_DIR_OUT */</span>
	<span class="n">u8</span> <span class="n">device_address</span><span class="p">;</span>	<span class="cm">/* Device USB address */</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DBG(fmt, args...) 	printk(KERN_DEBUG &quot;[%s]  &quot; fmt &quot;\n&quot;, \</span>
<span class="cp">				__func__, ## args)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(fmt, args...)	do{}while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static void dump_msg(const char *label, const u8 * buf, unsigned int length)</span>
<span class="c">{</span>
<span class="c">	unsigned int start, num, i;</span>
<span class="c">	char line[52], *p;</span>

<span class="c">	if (length &gt;= 512)</span>
<span class="c">		return;</span>
<span class="c">	DBG(&quot;%s, length %u:\n&quot;, label, length);</span>
<span class="c">	start = 0;</span>
<span class="c">	while (length &gt; 0) {</span>
<span class="c">		num = min(length, 16u);</span>
<span class="c">		p = line;</span>
<span class="c">		for (i = 0; i &lt; num; ++i) {</span>
<span class="c">			if (i == 8)</span>
<span class="c">				*p++ = &#39; &#39;;</span>
<span class="c">			sprintf(p, &quot; %02x&quot;, buf[i]);</span>
<span class="c">			p += 3;</span>
<span class="c">		}</span>
<span class="c">		*p = 0;</span>
<span class="c">		printk(KERN_DEBUG &quot;%6x: %s\n&quot;, start, line);</span>
<span class="c">		buf += num;</span>
<span class="c">		start += num;</span>
<span class="c">		length -= num;</span>
<span class="c">	}</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef VERBOSE</span>
<span class="cp">#define VDBG		DBG</span>
<span class="cp">#else</span>
<span class="cp">#define VDBG(stuff...)	do{}while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#define ERR(stuff...)		pr_err(&quot;udc: &quot; stuff)</span>
<span class="cp">#define WARNING(stuff...)		pr_warning(&quot;udc: &quot; stuff)</span>
<span class="cp">#define INFO(stuff...)		pr_info(&quot;udc: &quot; stuff)</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* ### Add board specific defines here</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * ### pipe direction macro from device view</span>
<span class="cm"> */</span>
<span class="cp">#define USB_RECV	0	</span><span class="cm">/* OUT EP */</span><span class="cp"></span>
<span class="cp">#define USB_SEND	1	</span><span class="cm">/* IN EP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ### internal used help routines.</span>
<span class="cm"> */</span>
<span class="cp">#define ep_index(EP)		((EP)-&gt;ep.desc-&gt;bEndpointAddress&amp;0xF)</span>
<span class="cp">#define ep_maxpacket(EP)	((EP)-&gt;ep.maxpacket)</span>
<span class="cp">#define ep_is_in(EP)	( (ep_index(EP) == 0) ? (EP-&gt;udc-&gt;ep0_dir == \</span>
<span class="cp">			USB_DIR_IN) : ((EP)-&gt;ep.desc-&gt;bEndpointAddress \</span>
<span class="cp">			&amp; USB_DIR_IN)==USB_DIR_IN)</span>
<span class="cp">#define get_ep_by_pipe(udc, pipe)	((pipe == 1)? &amp;udc-&gt;eps[0]: \</span>
<span class="cp">					&amp;udc-&gt;eps[pipe])</span>
<span class="cp">#define get_pipe_by_windex(windex)	((windex &amp; USB_ENDPOINT_NUMBER_MASK) \</span>
<span class="cp">					* 2 + ((windex &amp; USB_DIR_IN) ? 1 : 0))</span>
<span class="cp">#define get_pipe_by_ep(EP)	(ep_index(EP) * 2 + ep_is_in(EP))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ep_queue_head</span> <span class="o">*</span><span class="nf">get_qh_by_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we only have one ep0 structure but two queue heads */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_index</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_qh</span><span class="p">[(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0_dir</span> <span class="o">==</span>
				<span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">platform_device</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ARCH_MXC</span>
<span class="kt">int</span> <span class="n">fsl_udc_clk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fsl_udc_clk_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fsl_udc_clk_release</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fsl_udc_clk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fsl_udc_clk_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fsl_udc_clk_release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
