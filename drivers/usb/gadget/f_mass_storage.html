<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › f_mass_storage.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>f_mass_storage.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * f_mass_storage.c -- Mass Storage USB Composite Function</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003-2008 Alan Stern</span>
<span class="cm"> * Copyright (C) 2009 Samsung Electronics</span>
<span class="cm"> *                    Author: Michal Nazarewicz &lt;mina86@mina86.com&gt;</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. The names of the above-listed copyright holders may not be used</span>
<span class="cm"> *    to endorse or promote products derived from this software without</span>
<span class="cm"> *    specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * ALTERNATIVELY, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) as published by the Free Software</span>
<span class="cm"> * Foundation, either version 2 of that License or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span>
<span class="cm"> * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span>
<span class="cm"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<span class="cm"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span>
<span class="cm"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<span class="cm"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
<span class="cm"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<span class="cm"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="cm"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="cm"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The Mass Storage Function acts as a USB Mass Storage device,</span>
<span class="cm"> * appearing to the host as a disk drive or as a CD-ROM drive.  In</span>
<span class="cm"> * addition to providing an example of a genuinely useful composite</span>
<span class="cm"> * function for a USB device, it also illustrates a technique of</span>
<span class="cm"> * double-buffering for increased throughput.</span>
<span class="cm"> *</span>
<span class="cm"> * Function supports multiple logical units (LUNs).  Backing storage</span>
<span class="cm"> * for each LUN is provided by a regular file or a block device.</span>
<span class="cm"> * Access for each LUN can be limited to read-only.  Moreover, the</span>
<span class="cm"> * function can indicate that LUN is removable and/or CD-ROM.  (The</span>
<span class="cm"> * later implies read-only access.)</span>
<span class="cm"> *</span>
<span class="cm"> * MSF is configured by specifying a fsg_config structure.  It has the</span>
<span class="cm"> * following fields:</span>
<span class="cm"> *</span>
<span class="cm"> *	nluns		Number of LUNs function have (anywhere from 1</span>
<span class="cm"> *				to FSG_MAX_LUNS which is 8).</span>
<span class="cm"> *	luns		An array of LUN configuration values.  This</span>
<span class="cm"> *				should be filled for each LUN that</span>
<span class="cm"> *				function will include (ie. for &quot;nluns&quot;</span>
<span class="cm"> *				LUNs).  Each element of the array has</span>
<span class="cm"> *				the following fields:</span>
<span class="cm"> *	-&gt;filename	The path to the backing file for the LUN.</span>
<span class="cm"> *				Required if LUN is not marked as</span>
<span class="cm"> *				removable.</span>
<span class="cm"> *	-&gt;ro		Flag specifying access to the LUN shall be</span>
<span class="cm"> *				read-only.  This is implied if CD-ROM</span>
<span class="cm"> *				emulation is enabled as well as when</span>
<span class="cm"> *				it was impossible to open &quot;filename&quot;</span>
<span class="cm"> *				in R/W mode.</span>
<span class="cm"> *	-&gt;removable	Flag specifying that LUN shall be indicated as</span>
<span class="cm"> *				being removable.</span>
<span class="cm"> *	-&gt;cdrom		Flag specifying that LUN shall be reported as</span>
<span class="cm"> *				being a CD-ROM.</span>
<span class="cm"> *	-&gt;nofua		Flag specifying that FUA flag in SCSI WRITE(10,12)</span>
<span class="cm"> *				commands for this LUN shall be ignored.</span>
<span class="cm"> *</span>
<span class="cm"> *	lun_name_format	A printf-like format for names of the LUN</span>
<span class="cm"> *				devices.  This determines how the</span>
<span class="cm"> *				directory in sysfs will be named.</span>
<span class="cm"> *				Unless you are using several MSFs in</span>
<span class="cm"> *				a single gadget (as opposed to single</span>
<span class="cm"> *				MSF in many configurations) you may</span>
<span class="cm"> *				leave it as NULL (in which case</span>
<span class="cm"> *				&quot;lun%d&quot; will be used).  In the format</span>
<span class="cm"> *				you can use &quot;%d&quot; to index LUNs for</span>
<span class="cm"> *				MSF&#39;s with more than one LUN.  (Beware</span>
<span class="cm"> *				that there is only one integer given</span>
<span class="cm"> *				as an argument for the format and</span>
<span class="cm"> *				specifying invalid format may cause</span>
<span class="cm"> *				unspecified behaviour.)</span>
<span class="cm"> *	thread_name	Name of the kernel thread process used by the</span>
<span class="cm"> *				MSF.  You can safely set it to NULL</span>
<span class="cm"> *				(in which case default &quot;file-storage&quot;</span>
<span class="cm"> *				will be used).</span>
<span class="cm"> *</span>
<span class="cm"> *	vendor_name</span>
<span class="cm"> *	product_name</span>
<span class="cm"> *	release		Information used as a reply to INQUIRY</span>
<span class="cm"> *				request.  To use default set to NULL,</span>
<span class="cm"> *				NULL, 0xffff respectively.  The first</span>
<span class="cm"> *				field should be 8 and the second 16</span>
<span class="cm"> *				characters or less.</span>
<span class="cm"> *</span>
<span class="cm"> *	can_stall	Set to permit function to halt bulk endpoints.</span>
<span class="cm"> *				Disabled on some USB devices known not</span>
<span class="cm"> *				to work correctly.  You should set it</span>
<span class="cm"> *				to true.</span>
<span class="cm"> *</span>
<span class="cm"> * If &quot;removable&quot; is not set for a LUN then a backing file must be</span>
<span class="cm"> * specified.  If it is set, then NULL filename means the LUN&#39;s medium</span>
<span class="cm"> * is not loaded (an empty string as &quot;filename&quot; in the fsg_config</span>
<span class="cm"> * structure causes error).  The CD-ROM emulation includes a single</span>
<span class="cm"> * data track and no audio tracks; hence there need be only one</span>
<span class="cm"> * backing file per LUN.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * MSF includes support for module parameters.  If gadget using it</span>
<span class="cm"> * decides to use it, the following module parameters will be</span>
<span class="cm"> * available:</span>
<span class="cm"> *</span>
<span class="cm"> *	file=filename[,filename...]</span>
<span class="cm"> *			Names of the files or block devices used for</span>
<span class="cm"> *				backing storage.</span>
<span class="cm"> *	ro=b[,b...]	Default false, boolean for read-only access.</span>
<span class="cm"> *	removable=b[,b...]</span>
<span class="cm"> *			Default true, boolean for removable media.</span>
<span class="cm"> *	cdrom=b[,b...]	Default false, boolean for whether to emulate</span>
<span class="cm"> *				a CD-ROM drive.</span>
<span class="cm"> *	nofua=b[,b...]	Default false, booleans for ignore FUA flag</span>
<span class="cm"> *				in SCSI WRITE(10,12) commands</span>
<span class="cm"> *	luns=N		Default N = number of filenames, number of</span>
<span class="cm"> *				LUNs to support.</span>
<span class="cm"> *	stall		Default determined according to the type of</span>
<span class="cm"> *				USB device controller (usually true),</span>
<span class="cm"> *				boolean to permit the driver to halt</span>
<span class="cm"> *				bulk endpoints.</span>
<span class="cm"> *</span>
<span class="cm"> * The module parameters may be prefixed with some string.  You need</span>
<span class="cm"> * to consult gadget&#39;s documentation or source to verify whether it is</span>
<span class="cm"> * using those module parameters and if it does what are the prefixes</span>
<span class="cm"> * (look for FSG_MODULE_PARAMETERS() macro usage, what&#39;s inside it is</span>
<span class="cm"> * the prefix).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Requirements are modest; only a bulk-in and a bulk-out endpoint are</span>
<span class="cm"> * needed.  The memory requirement amounts to two 16K buffers, size</span>
<span class="cm"> * configurable by a parameter.  Support is included for both</span>
<span class="cm"> * full-speed and high-speed operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the driver is slightly non-portable in that it assumes a</span>
<span class="cm"> * single memory/DMA buffer will be useable for bulk-in, bulk-out, and</span>
<span class="cm"> * interrupt-in endpoints.  With most device controllers this isn&#39;t an</span>
<span class="cm"> * issue, but there may be some with hardware restrictions that prevent</span>
<span class="cm"> * a buffer from being used by more than one endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The pathnames of the backing files and the ro settings are</span>
<span class="cm"> * available in the attribute files &quot;file&quot; and &quot;ro&quot; in the lun&lt;n&gt; (or</span>
<span class="cm"> * to be more precise in a directory which name comes from</span>
<span class="cm"> * &quot;lun_name_format&quot; option!) subdirectory of the gadget&#39;s sysfs</span>
<span class="cm"> * directory.  If the &quot;removable&quot; option is set, writing to these</span>
<span class="cm"> * files will simulate ejecting/loading the medium (writing an empty</span>
<span class="cm"> * line means eject) and adjusting a write-enable tab.  Changes to the</span>
<span class="cm"> * ro setting are not allowed when the medium is loaded or if CD-ROM</span>
<span class="cm"> * emulation is being used.</span>
<span class="cm"> *</span>
<span class="cm"> * When a LUN receive an &quot;eject&quot; SCSI request (Start/Stop Unit),</span>
<span class="cm"> * if the LUN is removable, the backing file is released to simulate</span>
<span class="cm"> * ejection.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This function is heavily based on &quot;File-backed Storage Gadget&quot; by</span>
<span class="cm"> * Alan Stern which in turn is heavily based on &quot;Gadget Zero&quot; by David</span>
<span class="cm"> * Brownell.  The driver&#39;s SCSI command interface was based on the</span>
<span class="cm"> * &quot;Information technology - Small Computer System Interface - 2&quot;</span>
<span class="cm"> * document from X3T9.2 Project 375D, Revision 10L, 7-SEP-93,</span>
<span class="cm"> * available at &lt;http://www.t10.org/ftp/t10/drafts/s2/s2-r10l.pdf&gt;.</span>
<span class="cm"> * The single exception is opcode 0x23 (READ FORMAT CAPACITIES), which</span>
<span class="cm"> * was based on the &quot;Universal Serial Bus Mass Storage Class UFI</span>
<span class="cm"> * Command Specification&quot; document, Revision 1.0, December 14, 1998,</span>
<span class="cm"> * available at</span>
<span class="cm"> * &lt;http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf&gt;.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *				Driver Design</span>
<span class="cm"> *</span>
<span class="cm"> * The MSF is fairly straightforward.  There is a main kernel</span>
<span class="cm"> * thread that handles most of the work.  Interrupt routines field</span>
<span class="cm"> * callbacks from the controller driver: bulk- and interrupt-request</span>
<span class="cm"> * completion notifications, endpoint-0 events, and disconnect events.</span>
<span class="cm"> * Completion events are passed to the main thread by wakeup calls.  Many</span>
<span class="cm"> * ep0 requests are handled at interrupt time, but SetInterface,</span>
<span class="cm"> * SetConfiguration, and device reset requests are forwarded to the</span>
<span class="cm"> * thread in the form of &quot;exceptions&quot; using SIGUSR1 signals (since they</span>
<span class="cm"> * should interrupt any ongoing file I/O operations).</span>
<span class="cm"> *</span>
<span class="cm"> * The thread&#39;s main routine implements the standard command/data/status</span>
<span class="cm"> * parts of a SCSI interaction.  It and its subroutines are full of tests</span>
<span class="cm"> * for pending signals/exceptions -- all this polling is necessary since</span>
<span class="cm"> * the kernel has no setjmp/longjmp equivalents.  (Maybe this is an</span>
<span class="cm"> * indication that the driver really wants to be running in userspace.)</span>
<span class="cm"> * An important point is that so long as the thread is alive it keeps an</span>
<span class="cm"> * open reference to the backing file.  This will prevent unmounting</span>
<span class="cm"> * the backing file&#39;s underlying filesystem and could cause problems</span>
<span class="cm"> * during system shutdown, for example.  To prevent such problems, the</span>
<span class="cm"> * thread catches INT, TERM, and KILL signals and converts them into</span>
<span class="cm"> * an EXIT exception.</span>
<span class="cm"> *</span>
<span class="cm"> * In normal operation the main thread is started during the gadget&#39;s</span>
<span class="cm"> * fsg_bind() callback and stopped during fsg_unbind().  But it can</span>
<span class="cm"> * also exit when it receives a signal, and there&#39;s no point leaving</span>
<span class="cm"> * the gadget running when the thread is dead.  At of this moment, MSF</span>
<span class="cm"> * provides no way to deregister the gadget when thread dies -- maybe</span>
<span class="cm"> * a callback functions is needed.</span>
<span class="cm"> *</span>
<span class="cm"> * To provide maximum throughput, the driver uses a circular pipeline of</span>
<span class="cm"> * buffer heads (struct fsg_buffhd).  In principle the pipeline can be</span>
<span class="cm"> * arbitrarily long; in practice the benefits don&#39;t justify having more</span>
<span class="cm"> * than 2 stages (i.e., double buffering).  But it helps to think of the</span>
<span class="cm"> * pipeline as being a long one.  Each buffer head contains a bulk-in and</span>
<span class="cm"> * a bulk-out request pointer (since the buffer can be used for both</span>
<span class="cm"> * output and input -- directions always are given from the host&#39;s</span>
<span class="cm"> * point of view) as well as a pointer to the buffer and various state</span>
<span class="cm"> * variables.</span>
<span class="cm"> *</span>
<span class="cm"> * Use of the pipeline follows a simple protocol.  There is a variable</span>
<span class="cm"> * (fsg-&gt;next_buffhd_to_fill) that points to the next buffer head to use.</span>
<span class="cm"> * At any time that buffer head may still be in use from an earlier</span>
<span class="cm"> * request, so each buffer head has a state variable indicating whether</span>
<span class="cm"> * it is EMPTY, FULL, or BUSY.  Typical use involves waiting for the</span>
<span class="cm"> * buffer head to be EMPTY, filling the buffer either by file I/O or by</span>
<span class="cm"> * USB I/O (during which the buffer head is BUSY), and marking the buffer</span>
<span class="cm"> * head FULL when the I/O is complete.  Then the buffer will be emptied</span>
<span class="cm"> * (again possibly by USB I/O, during which it is marked BUSY) and</span>
<span class="cm"> * finally marked EMPTY again (possibly by a completion routine).</span>
<span class="cm"> *</span>
<span class="cm"> * A module parameter tells the driver to avoid stalling the bulk</span>
<span class="cm"> * endpoints wherever the transport specification allows.  This is</span>
<span class="cm"> * necessary for some UDCs like the SuperH, which cannot reliably clear a</span>
<span class="cm"> * halt on a bulk endpoint.  However, under certain circumstances the</span>
<span class="cm"> * Bulk-only specification requires a stall.  In such cases the driver</span>
<span class="cm"> * will halt the endpoint and set a flag indicating that it should clear</span>
<span class="cm"> * the halt in software during the next device reset.  Hopefully this</span>
<span class="cm"> * will permit everything to work correctly.  Furthermore, although the</span>
<span class="cm"> * specification allows the bulk-out endpoint to halt when the host sends</span>
<span class="cm"> * too much data, implementing this would cause an unavoidable race.</span>
<span class="cm"> * The driver will always use the &quot;no-stall&quot; approach for OUT transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * One subtle point concerns sending status-stage responses for ep0</span>
<span class="cm"> * requests.  Some of these requests, such as device reset, can involve</span>
<span class="cm"> * interrupting an ongoing file I/O operation, which might take an</span>
<span class="cm"> * arbitrarily long time.  During that delay the host might give up on</span>
<span class="cm"> * the original ep0 request and issue a new one.  When that happens the</span>
<span class="cm"> * driver should not notify the host about completion of the original</span>
<span class="cm"> * request, as the host will no longer be waiting for it.  So the driver</span>
<span class="cm"> * assigns to each ep0 request a unique tag, and it keeps track of the</span>
<span class="cm"> * tag value of the request associated with a long-running exception</span>
<span class="cm"> * (device-reset, interface-change, or configuration-change).  When the</span>
<span class="cm"> * exception handler is finished, the status-stage response is submitted</span>
<span class="cm"> * only if the current ep0 request tag is equal to the exception request</span>
<span class="cm"> * tag.  Thus only the most recently received ep0 request will get a</span>
<span class="cm"> * status-stage response.</span>
<span class="cm"> *</span>
<span class="cm"> * Warning: This driver source file is too long.  It ought to be split up</span>
<span class="cm"> * into a header file plus about 3 separate .c files, to handle the details</span>
<span class="cm"> * of the Gadget, USB Mass Storage, and SCSI protocols.</span>
<span class="cm"> */</span>


<span class="cm">/* #define VERBOSE_DEBUG */</span>
<span class="cm">/* #define DUMP_MSGS */</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/limits.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>

<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &lt;linux/usb/composite.h&gt;</span>

<span class="cp">#include &quot;gadget_chips.h&quot;</span>


<span class="cm">/*------------------------------------------------------------------------*/</span>

<span class="cp">#define FSG_DRIVER_DESC		&quot;Mass Storage Function&quot;</span>
<span class="cp">#define FSG_DRIVER_VERSION	&quot;2009/09/11&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">fsg_string_interface</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Mass Storage&quot;</span><span class="p">;</span>

<span class="cp">#define FSG_NO_DEVICE_STRINGS    1</span>
<span class="cp">#define FSG_NO_OTG               1</span>
<span class="cp">#define FSG_NO_INTR_EP           1</span>

<span class="cp">#include &quot;storage_common.c&quot;</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">struct</span> <span class="n">fsg_dev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fsg_common</span><span class="p">;</span>

<span class="cm">/* FSF callback functions */</span>
<span class="k">struct</span> <span class="n">fsg_operations</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Callback function to call when thread exits.  If no</span>
<span class="cm">	 * callback is set or it returns value lower then zero MSF</span>
<span class="cm">	 * will force eject all LUNs it operates on (including those</span>
<span class="cm">	 * marked as non-removable or with prevent_medium_removal flag</span>
<span class="cm">	 * set).</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">thread_exits</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Called prior to ejection.  Negative return means error,</span>
<span class="cm">	 * zero means to continue with ejection, positive means not to</span>
<span class="cm">	 * eject.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_eject</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Called after ejection.  Negative return means error, zero</span>
<span class="cm">	 * or positive is just a success.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">post_eject</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Data shared by all the FSG instances. */</span>
<span class="k">struct</span> <span class="n">fsg_common</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>	<span class="o">*</span><span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="o">*</span><span class="n">new_fsg</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">fsg_wait</span><span class="p">;</span>

	<span class="cm">/* filesem protects: backing files in use */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">filesem</span><span class="p">;</span>

	<span class="cm">/* lock protects: state, all the req_busy&#39;s */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">ep0</span><span class="p">;</span>		<span class="cm">/* Copy of gadget-&gt;ep0 */</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">ep0req</span><span class="p">;</span>	<span class="cm">/* Copy of cdev-&gt;req */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ep0_req_tag</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">next_buffhd_to_drain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">buffhds</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">cmnd_size</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">cmnd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nluns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">luns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bulk_out_maxpacket</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fsg_state</span>		<span class="n">state</span><span class="p">;</span>		<span class="cm">/* For exception handling */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">exception_req_tag</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">data_direction</span>	<span class="n">data_dir</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">data_size</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">data_size_from_cmnd</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">tag</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">residue</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">usb_amount_left</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">can_stall</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">free_storage_on_release</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">phase_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">short_packet_received</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bad_lun_okay</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">running</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">thread_wakeup_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">thread_notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">thread_task</span><span class="p">;</span>

	<span class="cm">/* Callback functions. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fsg_operations</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="cm">/* Gadget&#39;s private data. */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Vendor (8 chars), product (16 chars), release (4</span>
<span class="cm">	 * hexadecimal digits) and NUL byte</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">inquiry_string</span><span class="p">[</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">ref</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fsg_config</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">nluns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun_config</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">ro</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">removable</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">cdrom</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">nofua</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">luns</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>

	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">lun_name_format</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">thread_name</span><span class="p">;</span>

	<span class="cm">/* Callback functions. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fsg_operations</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="cm">/* Gadget&#39;s private data. */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vendor_name</span><span class="p">;</span>		<span class="cm">/*  8 characters or less */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">product_name</span><span class="p">;</span>		<span class="cm">/* 16 characters or less */</span>
	<span class="n">u16</span> <span class="n">release</span><span class="p">;</span>

	<span class="kt">char</span>			<span class="n">can_stall</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fsg_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_function</span>	<span class="n">function</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>	<span class="o">*</span><span class="n">gadget</span><span class="p">;</span>	<span class="cm">/* Copy of cdev-&gt;gadget */</span>
	<span class="k">struct</span> <span class="n">fsg_common</span>	<span class="o">*</span><span class="n">common</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">interface_number</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bulk_in_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bulk_out_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">atomic_bitflags</span><span class="p">;</span>
<span class="cp">#define IGNORE_BULK_OUT		0</span>

	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">bulk_in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">bulk_out</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__fsg_is_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ERROR</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;common-&gt;fsg is NULL in %s at %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define fsg_is_set(common) likely(__fsg_is_set(common, __func__, __LINE__))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="nf">fsg_from_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_dev</span><span class="p">,</span> <span class="n">function</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fsg_routine_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exception_in_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;</span> <span class="n">FSG_STATE_IDLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make bulk-out requests be divisible by the maxpacket size */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_bulk_out_req_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rem</span><span class="p">;</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">length</span> <span class="o">%</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">bulk_out_maxpacket</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">+=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">bulk_out_maxpacket</span> <span class="o">-</span> <span class="n">rem</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bulk-in&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bulk-out&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;%s set halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">usb_ep_set_halt</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* These routines may be called in process context or in_irq */</span>

<span class="cm">/* Caller must hold fsg-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Tell the main thread that something has happened */</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_wakeup_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">raise_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fsg_state</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do nothing if a higher-priority exception is already in progress.</span>
<span class="cm">	 * If a lower-or-equal priority exception is in progress, preempt it</span>
<span class="cm">	 * and notify the main thread by sending it a signal.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">new_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">exception_req_tag</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span><span class="p">;</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">)</span>
			<span class="n">send_sig_info</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">SEND_SIG_FORCED</span><span class="p">,</span>
				      <span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep0_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_queue</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">common</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We can&#39;t do much more than wait for a reset */</span>
		<span class="n">WARNING</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;error in submission: %s --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Completion handlers. These always run in_irq. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bulk_in_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_common</span>	<span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;%s --&gt; %d, %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		    <span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>		<span class="cm">/* Request was cancelled */</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Hold the lock while we update the request and buffer states */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
	<span class="n">wakeup_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bulk_out_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_common</span>	<span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">dump_msg</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;bulk-out&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;%s --&gt; %d, %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		    <span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>		<span class="cm">/* Request was cancelled */</span>
		<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Hold the lock while we update the request and buffer states */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>
	<span class="n">wakeup_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">fsg_from_func</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0req</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">w_index</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">);</span>
	<span class="n">u16</span>			<span class="n">w_value</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">);</span>
	<span class="n">u16</span>			<span class="n">w_length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_is_set</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="o">++</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span><span class="p">;</span>	<span class="cm">/* Record arrival of a new request */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dump_msg</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;ep0-setup&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">ctrl</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctrl</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">US_BULK_RESET_REQUEST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w_index</span> <span class="o">!=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">interface_number</span> <span class="o">||</span> <span class="n">w_value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
				<span class="n">w_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Raise an exception to stop the current operation</span>
<span class="cm">		 * and reinitialize our state.</span>
<span class="cm">		 */</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;bulk reset request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_STATE_RESET</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DELAYED_STATUS</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">US_BULK_GET_MAX_LUN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w_index</span> <span class="o">!=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">interface_number</span> <span class="o">||</span> <span class="n">w_value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
				<span class="n">w_length</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;get max LUN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Respond with data/status */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span> <span class="n">w_length</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ep0_queue</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span>
	     <span class="s">&quot;unknown class-specific control req %02x.%02x v%04x i%04x l%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">,</span>
	     <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">),</span> <span class="n">w_index</span><span class="p">,</span> <span class="n">w_length</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* All the following routines run in process context */</span>

<span class="cm">/* Use this for bulk or interrupt transfers, not ep0 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pbusy</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">fsg_buffer_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">)</span>
		<span class="n">dump_msg</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;bulk-in&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pbusy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_BUSY</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_queue</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pbusy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>

		<span class="cm">/* We can&#39;t do much more than wait for a reset */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note: currently the net2280 driver fails zero-length</span>
<span class="cm">		 * submissions if DMA is enabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;error in submission: %s --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">start_in_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_is_set</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">start_transfer</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span>
		       <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">start_out_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_is_set</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">start_transfer</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span>
		       <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sleep_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait until a signal arrives or we are woken up */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_wakeup_needed</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_wakeup_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount_left</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">file_offset</span><span class="p">,</span> <span class="n">file_offset_tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">amount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">nread</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the starting Logical Block Address and check that it&#39;s</span>
<span class="cm">	 * not too big.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_6</span><span class="p">)</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be24</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We allow DPO (Disable Page Out = don&#39;t save data in the</span>
<span class="cm">		 * cache) and FUA (Force Unit Access = don&#39;t read from the</span>
<span class="cm">		 * cache), but we don&#39;t implement them.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x18</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">file_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">lba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>

	<span class="cm">/* Carry out the file reads */</span>
	<span class="n">amount_left</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">amount_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="cm">/* No default reply */</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Figure out how much we need to read:</span>
<span class="cm">		 * Try to read the remaining amount.</span>
<span class="cm">		 * But don&#39;t read more than the buffer size.</span>
<span class="cm">		 * And don&#39;t try to read past the end of the file.</span>
<span class="cm">		 */</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">amount_left</span><span class="p">,</span> <span class="n">FSG_BUFLEN</span><span class="p">);</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">amount</span><span class="p">,</span>
			     <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span><span class="p">);</span>

		<span class="cm">/* Wait for the next buffer to become available */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we were asked to read past the end of file,</span>
<span class="cm">		 * end with an empty buffer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span>
					<span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span>
					<span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Perform the read */</span>
		<span class="n">file_offset_tmp</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>
		<span class="n">nread</span> <span class="o">=</span> <span class="n">vfs_read</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
				 <span class="n">amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_offset_tmp</span><span class="p">);</span>
		<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;file read %u @ %llu -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">file_offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;error in file read: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;partial file read: %d/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">nread</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">file_offset</span>  <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">amount_left</span>  <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Except at the end of the transfer, nread will be</span>
<span class="cm">		 * equal to the buffer size, which is divisible by the</span>
<span class="cm">		 * bulk-in maxpacket size.</span>
<span class="cm">		 */</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>

		<span class="cm">/* If an error occurred, report it and its position */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_UNRECOVERED_READ_ERROR</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span>
					<span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">amount_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>		<span class="cm">/* No more left to read */</span>

		<span class="cm">/* Send this buffer and go read some more */</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_in_transfer</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
			<span class="cm">/* Don&#39;t know what to do if common-&gt;fsg is NULL */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="cm">/* No default reply */</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">get_some_more</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount_left_to_req</span><span class="p">,</span> <span class="n">amount_left_to_write</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">usb_offset</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">file_offset_tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">amount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">nwritten</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_WRITE_PROTECTED</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">O_SYNC</span><span class="p">;</span>	<span class="cm">/* Default is not to wait */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the starting Logical Block Address and check that it&#39;s</span>
<span class="cm">	 * not too big</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_6</span><span class="p">)</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be24</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We allow DPO (Disable Page Out = don&#39;t save data in the</span>
<span class="cm">		 * cache) and FUA (Force Unit Access = write directly to the</span>
<span class="cm">		 * medium).  We don&#39;t implement DPO; we implement FUA by</span>
<span class="cm">		 * performing synchronous output.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x18</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">nofua</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* FUA */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_SYNC</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Carry out the file writes */</span>
	<span class="n">get_some_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">file_offset</span> <span class="o">=</span> <span class="n">usb_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">lba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
	<span class="n">amount_left_to_req</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">;</span>
	<span class="n">amount_left_to_write</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">amount_left_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Queue a request for more data from the host */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_EMPTY</span> <span class="o">&amp;&amp;</span> <span class="n">get_some_more</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Figure out how much we want to get:</span>
<span class="cm">			 * Try to get the remaining amount,</span>
<span class="cm">			 * but not more than the buffer size.</span>
<span class="cm">			 */</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">amount_left_to_req</span><span class="p">,</span> <span class="n">FSG_BUFLEN</span><span class="p">);</span>

			<span class="cm">/* Beyond the end of the backing file? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_offset</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">get_some_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span>
					<span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span>
					<span class="n">usb_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Get the next buffer */</span>
			<span class="n">usb_offset</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="n">amount_left_to_req</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">amount_left_to_req</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">get_some_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Except at the end of the transfer, amount will be</span>
<span class="cm">			 * equal to the buffer size, which is divisible by</span>
<span class="cm">			 * the bulk-out maxpacket size.</span>
<span class="cm">			 */</span>
			<span class="n">set_bulk_out_req_length</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_out_transfer</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
				<span class="cm">/* Dunno what to do if common-&gt;fsg is NULL */</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Write the received data to the backing file */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_EMPTY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">get_some_more</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>			<span class="cm">/* We stopped early */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>

			<span class="cm">/* Did something go wrong with the transfer? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_COMMUNICATION_FAILURE</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span>
					<span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">amount</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">LERROR</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span>
				       <span class="s">&quot;write %u @ %llu beyond end %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">file_offset</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span><span class="p">);</span>
				<span class="n">amount</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Don&#39;t accept excess data.  The spec doesn&#39;t say</span>
<span class="cm">			 * what to do in this case.  We&#39;ll ignore the error.</span>
<span class="cm">			 */</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">);</span>

			<span class="cm">/* Don&#39;t write a partial block */</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">empty_write</span><span class="p">;</span>

			<span class="cm">/* Perform the write */</span>
			<span class="n">file_offset_tmp</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>
			<span class="n">nwritten</span> <span class="o">=</span> <span class="n">vfs_write</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">,</span>
					     <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
					     <span class="n">amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_offset_tmp</span><span class="p">);</span>
			<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;file write %u @ %llu -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">file_offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nwritten</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>		<span class="cm">/* Interrupted! */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;error in file write: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nwritten</span><span class="p">);</span>
				<span class="n">nwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;partial file write: %d/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nwritten</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
				<span class="n">nwritten</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">nwritten</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">file_offset</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>
			<span class="n">amount_left_to_write</span> <span class="o">-=</span> <span class="n">nwritten</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">-=</span> <span class="n">nwritten</span><span class="p">;</span>

			<span class="cm">/* If an error occurred, report it and its position */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_WRITE_ERROR</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span>
					<span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

 <span class="nl">empty_write:</span>
			<span class="cm">/* Did the host decide to stop early? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">common</span><span class="o">-&gt;</span><span class="n">short_packet_received</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for something to happen */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="cm">/* No default reply */</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_synchronize_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* We ignore the requested LBA and write out all file&#39;s</span>
<span class="cm">	 * dirty data buffers. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_lun_fsync_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_WRITE_ERROR</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">invalidate_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">curlun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;invalidate_mapping_pages -&gt; %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lba</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">verification_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">file_offset</span><span class="p">,</span> <span class="n">file_offset_tmp</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount_left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">amount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">nread</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the starting Logical Block Address and check that it&#39;s</span>
<span class="cm">	 * not too big.</span>
<span class="cm">	 */</span>
	<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We allow DPO (Disable Page Out = don&#39;t save data in the</span>
<span class="cm">	 * cache) but we don&#39;t implement it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">verification_length</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">verification_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="cm">/* No default reply */</span>

	<span class="cm">/* Prepare to carry out the file verify */</span>
	<span class="n">amount_left</span> <span class="o">=</span> <span class="n">verification_length</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
	<span class="n">file_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">lba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>

	<span class="cm">/* Write out all the dirty buffers before invalidating them */</span>
	<span class="n">fsg_lun_fsync_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="n">invalidate_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="cm">/* Just try to read the requested blocks */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">amount_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Figure out how much we need to read:</span>
<span class="cm">		 * Try to read the remaining amount, but not more than</span>
<span class="cm">		 * the buffer size.</span>
<span class="cm">		 * And don&#39;t try to read past the end of the file.</span>
<span class="cm">		 */</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">amount_left</span><span class="p">,</span> <span class="n">FSG_BUFLEN</span><span class="p">);</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">amount</span><span class="p">,</span>
			     <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">-</span> <span class="n">file_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span>
					<span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span>
				<span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Perform the read */</span>
		<span class="n">file_offset_tmp</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>
		<span class="n">nread</span> <span class="o">=</span> <span class="n">vfs_read</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
				<span class="n">amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_offset_tmp</span><span class="p">);</span>
		<span class="n">VLDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;file read %u @ %llu -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">file_offset</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nread</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;error in file verify: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;partial file verify: %d/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nread</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">nread</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_UNRECOVERED_READ_ERROR</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span>
				<span class="n">file_offset</span> <span class="o">&gt;&gt;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">file_offset</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
		<span class="n">amount_left</span> <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Unsupported LUNs are okay */</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x7f</span><span class="p">;</span>		<span class="cm">/* Unsupported, no device-type */</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>		<span class="cm">/* Additional length */</span>
		<span class="k">return</span> <span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">cdrom</span> <span class="o">?</span> <span class="n">TYPE_ROM</span> <span class="o">:</span> <span class="n">TYPE_DISK</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>		<span class="cm">/* ANSI SCSI level 2 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>		<span class="cm">/* SCSI-2 INQUIRY data format */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>		<span class="cm">/* Additional length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* No special options */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">inquiry_string</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">inquiry_string</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">36</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_request_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">sd</span><span class="p">,</span> <span class="n">sdinfo</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">valid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From the SCSI-2 spec., section 7.9 (Unit attention condition):</span>
<span class="cm">	 *</span>
<span class="cm">	 * If a REQUEST SENSE command is received from an initiator</span>
<span class="cm">	 * with a pending unit attention condition (before the target</span>
<span class="cm">	 * generates the contingent allegiance condition), then the</span>
<span class="cm">	 * target shall either:</span>
<span class="cm">	 *   a) report any pending sense data and preserve the unit</span>
<span class="cm">	 *	attention condition on the logical unit, or,</span>
<span class="cm">	 *   b) report the unit attention condition, may discard any</span>
<span class="cm">	 *	pending sense data, and clear the unit attention</span>
<span class="cm">	 *	condition on the logical unit for that initiator.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FSG normally uses option a); enable this code to use option b).</span>
<span class="cm">	 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (curlun &amp;&amp; curlun-&gt;unit_attention_data != SS_NO_SENSE) {</span>
<span class="c">		curlun-&gt;sense_data = curlun-&gt;unit_attention_data;</span>
<span class="c">		curlun-&gt;unit_attention_data = SS_NO_SENSE;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Unsupported LUNs are okay */</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_LOGICAL_UNIT_NOT_SUPPORTED</span><span class="p">;</span>
		<span class="n">sdinfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span><span class="p">;</span>
		<span class="n">sdinfo</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span><span class="p">;</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">|</span> <span class="mh">0x70</span><span class="p">;</span>			<span class="cm">/* Valid, current error */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">SK</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">sdinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>	<span class="cm">/* Sense information */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">18</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>			<span class="cm">/* Additional sense length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">ASC</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">ASCQ</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">18</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="kt">int</span>		<span class="n">pmi</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Check the PMI and LBA fields */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmi</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">pmi</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lba</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
						<span class="cm">/* Max logical block */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="cm">/* Block length */</span>
	<span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">msf</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lba</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x02</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Mask away MSF */</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>		<span class="cm">/* 2048 bytes of user data, rest is EC */</span>
	<span class="n">store_cdrom_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">msf</span><span class="p">,</span> <span class="n">lba</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_toc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">msf</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">start_track</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x02</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>	<span class="cm">/* Mask away MSF */</span>
			<span class="n">start_track</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>		<span class="cm">/* TOC data length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* First track number */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* Last track number */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x16</span><span class="p">;</span>			<span class="cm">/* Data track, copying allowed */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>			<span class="cm">/* Only track is number 1 */</span>
	<span class="n">store_cdrom_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">msf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x16</span><span class="p">;</span>			<span class="cm">/* Lead-out track is data */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xAA</span><span class="p">;</span>			<span class="cm">/* Lead-out track number */</span>
	<span class="n">store_cdrom_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">msf</span><span class="p">,</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_mode_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">mscmnd</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf0</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">pc</span><span class="p">,</span> <span class="n">page_code</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">changeable_values</span><span class="p">,</span> <span class="n">all_pages</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">valid_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">len</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x08</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Mask away DBD */</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pc</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">page_code</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_SAVING_PARAMETERS_NOT_SUPPORTED</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">changeable_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">all_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">page_code</span> <span class="o">==</span> <span class="mh">0x3f</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write the mode parameter header.  Fixed values are: default</span>
<span class="cm">	 * medium type, no cache control (DPOFUA), and no block descriptors.</span>
<span class="cm">	 * The only variable value is the WriteProtect bit.  We will fill in</span>
<span class="cm">	 * the mode data length later.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mscmnd</span> <span class="o">==</span> <span class="n">MODE_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="cm">/* WP, DPOFUA */</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="cm">/* MODE_SENSE_10 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="cm">/* WP, DPOFUA */</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">65535</span><span class="p">;</span>		<span class="cm">/* Should really be FSG_BUFLEN */</span>
	<span class="p">}</span>

	<span class="cm">/* No block descriptors */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The mode pages, in numerical order.  The only page we support</span>
<span class="cm">	 * is the Caching page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_code</span> <span class="o">==</span> <span class="mh">0x08</span> <span class="o">||</span> <span class="n">all_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">valid_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>		<span class="cm">/* Page code */</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>		<span class="cm">/* Page length */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>	<span class="cm">/* None of the fields are changeable */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">changeable_values</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span>	<span class="cm">/* Write cache enable, */</span>
					<span class="cm">/* Read cache not disabled */</span>
					<span class="cm">/* No cache retention priorities */</span>
			<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
					<span class="cm">/* Don&#39;t disable prefetch */</span>
					<span class="cm">/* Minimum prefetch = 0 */</span>
			<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
					<span class="cm">/* Maximum prefetch */</span>
			<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
					<span class="cm">/* Maximum prefetch ceiling */</span>
		<span class="p">}</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that a valid page was requested and the mode data length</span>
<span class="cm">	 * isn&#39;t too long.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">-</span> <span class="n">buf0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_page</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  Store the mode data length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mscmnd</span> <span class="o">==</span> <span class="n">MODE_SENSE</span><span class="p">)</span>
		<span class="n">buf0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buf0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_start_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">loej</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="cm">/* Mask away Immed */</span>
		   <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x03</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Mask LoEj, Start */</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">loej</span>  <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our emulation doesn&#39;t support mounting; the medium is</span>
<span class="cm">	 * available for use as soon as it is loaded.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_lun_is_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_MEDIUM_NOT_PRESENT</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Are we allowed to unload the media? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LDBG</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;unload attempt prevented</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_MEDIUM_REMOVAL_PREVENTED</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loej</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Simulate an unload/eject */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pre_eject</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pre_eject</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">curlun</span><span class="p">,</span>
					       <span class="n">curlun</span> <span class="o">-</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
	<span class="n">fsg_lun_close</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">post_eject</span>
		<span class="o">?</span> <span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">post_eject</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">curlun</span><span class="p">,</span>
						 <span class="n">curlun</span> <span class="o">-</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">))</span>
		<span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_prevent_allow</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">prevent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prevent</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Mask away Prevent */</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">prevent</span><span class="p">)</span>
		<span class="n">fsg_lun_fsync_sub</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
	<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span> <span class="o">=</span> <span class="n">prevent</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_read_format_capacities</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* Only the Current/Maximum Capacity Descriptor */</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">num_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
						<span class="cm">/* Number of blocks */</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="cm">/* Block length */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>				<span class="cm">/* Current capacity */</span>
	<span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_mode_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>	<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t support MODE SELECT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="p">)</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">halt_bulk_in_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;delayed bulk-in endpoint halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;usb_ep_set_halt -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for a short time and then try again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wedge_bulk_in_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;bulk-in set wedge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_set_wedge</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;delayed bulk-in endpoint wedge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;usb_ep_set_wedge -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait for a short time and then try again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_set_wedge</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">throw_away_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">amount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span><span class="p">;</span>
	     <span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span> <span class="o">||</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Throw away the data in a filled buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="cm">/* A short packet or an error ends everything */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">bulk_out_intended_length</span> <span class="o">||</span>
			    <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">raise_exception</span><span class="p">(</span><span class="n">common</span><span class="p">,</span>
						<span class="n">FSG_STATE_ABORT_BULK_OUT</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Try to submit another request if we need one */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BUF_STATE_EMPTY</span>
		 <span class="o">&amp;&amp;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span><span class="p">,</span> <span class="n">FSG_BUFLEN</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Except at the end of the transfer, amount will be</span>
<span class="cm">			 * equal to the buffer size, which is divisible by</span>
<span class="cm">			 * the bulk-out maxpacket size.</span>
<span class="cm">			 */</span>
			<span class="n">set_bulk_out_req_length</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_out_transfer</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
				<span class="cm">/* Dunno what to do if common-&gt;fsg is NULL */</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Otherwise wait for something to happen */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">finish_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DATA_DIR_NONE</span>:
		<span class="k">break</span><span class="p">;</span>			<span class="cm">/* Nothing to send */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t know whether the host wants to read or write,</span>
<span class="cm">	 * this must be CB or CBI with an unknown command.  We mustn&#39;t</span>
<span class="cm">	 * try to send or receive any data.  So stall both bulk pipes</span>
<span class="cm">	 * if we can and wait for a reset.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">DATA_DIR_UNKNOWN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">can_stall</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Nothing */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fsg_is_set</span><span class="p">(</span><span class="n">common</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">halt_bulk_in_endpoint</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t know what to do if common-&gt;fsg is NULL */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* All but the last buffer of data must have already been sent */</span>
	<span class="k">case</span> <span class="n">DATA_DIR_TO_HOST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Nothing to send */</span>

		<span class="cm">/* Don&#39;t know what to do if common-&gt;fsg is NULL */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_is_set</span><span class="p">(</span><span class="n">common</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/* If there&#39;s no residue, simply send the last buffer */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_in_transfer</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For Bulk-only, mark the end of the data with a short</span>
<span class="cm">		 * packet.  If we are allowed to stall, halt the bulk-in</span>
<span class="cm">		 * endpoint.  (Note: This violates the Bulk-Only Transport</span>
<span class="cm">		 * specification, which requires us to pad the data if we</span>
<span class="cm">		 * don&#39;t halt the endpoint.  Presumably nobody will mind.)</span>
<span class="cm">		 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_in_transfer</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">can_stall</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">halt_bulk_in_endpoint</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have processed all we want from the data the host has sent.</span>
<span class="cm">	 * There may still be outstanding bulk-out requests.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">DATA_DIR_FROM_HOST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Nothing to receive */</span>

		<span class="cm">/* Did the host stop sending unexpectedly early? */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">short_packet_received</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raise_exception</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_STATE_ABORT_BULK_OUT</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We haven&#39;t processed all the incoming data.  Even though</span>
<span class="cm">		 * we may be allowed to stall, doing so would cause a race.</span>
<span class="cm">		 * The controller may already have ACK&#39;ed all the remaining</span>
<span class="cm">		 * bulk-out packets, in which case the host wouldn&#39;t see a</span>
<span class="cm">		 * STALL.  Not realizing the endpoint was halted, it wouldn&#39;t</span>
<span class="cm">		 * clear the halt -- leading to problems later on.</span>
<span class="cm">		 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		} else if (common-&gt;can_stall) {</span>
<span class="c">			if (fsg_is_set(common))</span>
<span class="c">				fsg_set_halt(common-&gt;fsg,</span>
<span class="c">					     common-&gt;fsg-&gt;bulk_out);</span>
<span class="c">			raise_exception(common, FSG_STATE_ABORT_BULK_OUT);</span>
<span class="c">			rc = -EINTR;</span>
<span class="cp">#endif</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can&#39;t stall.  Read in the excess data and throw it</span>
<span class="cm">		 * all away.</span>
<span class="cm">		 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">throw_away_data</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bulk_cs_wrap</span>	<span class="o">*</span><span class="n">csw</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">status</span> <span class="o">=</span> <span class="n">US_BULK_STAT_OK</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">sd</span><span class="p">,</span> <span class="n">sdinfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for the next buffer to become available */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span><span class="p">;</span>
		<span class="n">sdinfo</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span><span class="p">)</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_LOGICAL_UNIT_NOT_SUPPORTED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">phase_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;sending phase-error status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">US_BULK_STAT_PHASE</span><span class="p">;</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sd</span> <span class="o">!=</span> <span class="n">SS_NO_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;sending command-failure status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">US_BULK_STAT_FAIL</span><span class="p">;</span>
		<span class="n">VDBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;&quot;</span>
				<span class="s">&quot;  info x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">SK</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">ASC</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">ASCQ</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">sdinfo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Store and send the Bulk-only CSW */</span>
	<span class="n">csw</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">US_BULK_CS_SIGN</span><span class="p">);</span>
	<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Tag</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Residue</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">residue</span><span class="p">);</span>
	<span class="n">csw</span><span class="o">-&gt;</span><span class="n">Status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">US_BULK_CS_WRAP_LEN</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_in_transfer</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
		<span class="cm">/* Don&#39;t know what to do if common-&gt;fsg is NULL */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether the command is properly formed and whether its data size</span>
<span class="cm"> * and direction agree with the values we already have.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmnd_size</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">data_direction</span> <span class="n">data_dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">needs_medium</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">lun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span>	<span class="n">dirletter</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">};</span>
	<span class="kt">char</span>			<span class="n">hdlen</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>

	<span class="n">hdlen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">!=</span> <span class="n">DATA_DIR_UNKNOWN</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">hdlen</span><span class="p">,</span> <span class="s">&quot;, H%c=%u&quot;</span><span class="p">,</span> <span class="n">dirletter</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span><span class="p">],</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
	<span class="n">VDBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;SCSI command: %s;  Dc=%d, D%c=%u;  Hc=%d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">name</span><span class="p">,</span> <span class="n">cmnd_size</span><span class="p">,</span> <span class="n">dirletter</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">data_dir</span><span class="p">],</span>
	     <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">,</span> <span class="n">hdlen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t reply at all until we know the correct data direction</span>
<span class="cm">	 * and size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">&lt;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Host data size &lt; Device data size is a phase error.</span>
<span class="cm">		 * Carry out the command, but only transfer as much as</span>
<span class="cm">		 * we are allowed.</span>
<span class="cm">		 */</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">usb_amount_left</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>

	<span class="cm">/* Conflicting data directions is a phase error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">!=</span> <span class="n">data_dir</span> <span class="o">&amp;&amp;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Verify the length of the command itself */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmnd_size</span> <span class="o">!=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Special case workaround: There are plenty of buggy SCSI</span>
<span class="cm">		 * implementations. Many have issues with cbw-&gt;Length</span>
<span class="cm">		 * field passing a wrong command size. For those cases we</span>
<span class="cm">		 * always try to work around the problem by using the length</span>
<span class="cm">		 * sent by the host side provided it is at least as large</span>
<span class="cm">		 * as the correct command length.</span>
<span class="cm">		 * Examples of such cases would be MS-Windows, which issues</span>
<span class="cm">		 * REQUEST SENSE with cbw-&gt;Length == 12 where it should</span>
<span class="cm">		 * be 6, and xbox360 issuing INQUIRY, TEST UNIT READY and</span>
<span class="cm">		 * REQUEST SENSE with cbw-&gt;Length == 10 where it should</span>
<span class="cm">		 * be 6 as well.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmnd_size</span> <span class="o">&lt;=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;%s is buggy! Expected length %d &quot;</span>
			    <span class="s">&quot;but we got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			    <span class="n">cmnd_size</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">);</span>
			<span class="n">cmnd_size</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check that the LUN values are consistent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">lun</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;using LUN %d from CBW, not LUN %d from CDB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">common</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>

	<span class="cm">/* Check the LUN */</span>
	<span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">bad_lun_okay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * INQUIRY and REQUEST SENSE commands are explicitly allowed</span>
<span class="cm">		 * to use unsupported LUNs; all others may not.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INQUIRY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;unsupported LUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a unit attention condition exists, only INQUIRY and</span>
<span class="cm">	 * REQUEST SENSE commands are allowed; anything else must fail.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span> <span class="o">&amp;&amp;</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span> <span class="o">!=</span> <span class="n">SS_NO_SENSE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INQUIRY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that only command bytes listed in the mask are non-zero */</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x1f</span><span class="p">;</span>			<span class="cm">/* Mask away the LUN */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmnd_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span><span class="p">)</span>
				<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If the medium isn&#39;t mounted and the command needs to access</span>
<span class="cm">	 * it, return an error. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curlun</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fsg_lun_is_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">needs_medium</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_MEDIUM_NOT_PRESENT</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* wrapper of check_command for data size in blocks handling */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_command_size_in_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cmnd_size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">data_direction</span> <span class="n">data_dir</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">needs_medium</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="p">)</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">&lt;&lt;=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">cmnd_size</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span>
			<span class="n">mask</span><span class="p">,</span> <span class="n">needs_medium</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_scsi_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">reply</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span>		<span class="n">unknown</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">dump_cdb</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>

	<span class="cm">/* Wait for the next buffer to become available for data or status */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">phase_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">short_packet_received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>	<span class="cm">/* We&#39;re using the backing file */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">INQUIRY</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;INQUIRY&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_inquiry</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SELECT</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;MODE SELECT(6)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_select</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SELECT_10</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
			<span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;MODE SELECT(10)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_select</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SENSE</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;MODE SENSE(6)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_sense</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SENSE_10</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
			<span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;MODE SENSE(10)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_mode_sense</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ALLOW_MEDIUM_REMOVAL</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;PREVENT-ALLOW MEDIUM REMOVAL&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_prevent_allow</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_6</span>:
		<span class="n">i</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">256</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
				      <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;READ(6)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_10</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
				<span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
				      <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;READ(10)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_12</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
				<span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
				      <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;READ(12)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;READ CAPACITY&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_capacity</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_HEADER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span> <span class="o">||</span> <span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">cdrom</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unknown_cmnd</span><span class="p">;</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
			<span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x1f</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;READ HEADER&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_header</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_TOC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span> <span class="o">||</span> <span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">cdrom</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unknown_cmnd</span><span class="p">;</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
			<span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;READ TOC&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_toc</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_FORMAT_CAPACITIES</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
			<span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;READ FORMAT CAPACITIES&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_read_format_capacities</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REQUEST_SENSE</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;REQUEST SENSE&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_request_sense</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">START_STOP</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="s">&quot;START-STOP UNIT&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_start_stop</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SYNCHRONIZE_CACHE</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				      <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;SYNCHRONIZE CACHE&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_synchronize_cache</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TEST_UNIT_READY</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				<span class="s">&quot;TEST UNIT READY&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Although optional, this command is used by MS-Windows.  We</span>
<span class="cm">	 * support a minimal version: BytChk must be 0.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">VERIFY</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">DATA_DIR_NONE</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;VERIFY&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_verify</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="n">i</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">256</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
				      <span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;WRITE(6)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_write</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
				<span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
				      <span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;WRITE(10)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_write</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WRITE_12</span>:
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span>
				<span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command_size_in_blocks</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
				      <span class="n">DATA_DIR_FROM_HOST</span><span class="p">,</span>
				      <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xf</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="s">&quot;WRITE(12)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="n">do_write</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some mandatory commands that we recognize but don&#39;t implement.</span>
<span class="cm">	 * They don&#39;t mean much in this setting.  It&#39;s left as an exercise</span>
<span class="cm">	 * for anyone interested to implement RESERVE and RELEASE in terms</span>
<span class="cm">	 * of Posix locks.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">FORMAT_UNIT</span>:
	<span class="k">case</span> <span class="n">RELEASE</span>:
	<span class="k">case</span> <span class="n">RESERVE</span>:
	<span class="k">case</span> <span class="n">SEND_DIAGNOSTIC</span>:
		<span class="cm">/* Fall through */</span>

	<span class="nl">default:</span>
<span class="nl">unknown_cmnd:</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">unknown</span><span class="p">,</span> <span class="s">&quot;Unknown x%02x&quot;</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">check_command</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">,</span>
				      <span class="n">DATA_DIR_UNKNOWN</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unknown</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_INVALID_COMMAND</span><span class="p">;</span>
			<span class="n">reply</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">||</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="cm">/* Set up the single reply buffer for finish_reply() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Error reply length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">==</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">reply</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size_from_cmnd</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">reply</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_FULL</span><span class="p">;</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">-=</span> <span class="n">reply</span><span class="p">;</span>
	<span class="p">}</span>				<span class="cm">/* Otherwise it&#39;s already set */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">received_cbw</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bulk_cb_wrap</span>	<span class="o">*</span><span class="n">cbw</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_common</span>	<span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">;</span>

	<span class="cm">/* Was this a real packet?  Should it be ignored? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">||</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Is the CBW valid? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">!=</span> <span class="n">US_BULK_CB_WRAP_LEN</span> <span class="o">||</span>
			<span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
				<span class="n">US_BULK_CB_SIGN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;invalid CBW: len %u sig 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">actual</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * The Bulk-only spec says we MUST stall the IN endpoint</span>
<span class="cm">		 * (6.6.1), so it&#39;s unavoidable.  It also says we must</span>
<span class="cm">		 * retain this state until the next reset, but there&#39;s</span>
<span class="cm">		 * no way to tell the controller driver it should ignore</span>
<span class="cm">		 * Clear-Feature(HALT) requests.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We aren&#39;t required to halt the OUT endpoint; instead</span>
<span class="cm">		 * we can simply accept and discard any data received</span>
<span class="cm">		 * until the next reset.</span>
<span class="cm">		 */</span>
		<span class="n">wedge_bulk_in_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is the CBW meaningful? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Lun</span> <span class="o">&gt;=</span> <span class="n">FSG_MAX_LUNS</span> <span class="o">||</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">US_BULK_FLAG_IN</span> <span class="o">||</span>
			<span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="n">MAX_COMMAND_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;non-meaningful CBW: lun = %u, flags = 0x%x, &quot;</span>
				<span class="s">&quot;cmdlen %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Lun</span><span class="p">,</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Flags</span><span class="p">,</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can do anything we want here, so let&#39;s stall the</span>
<span class="cm">		 * bulk pipes if we are allowed to.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">can_stall</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fsg_set_halt</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
			<span class="n">halt_bulk_in_endpoint</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save the command for later */</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span> <span class="o">=</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">CDB</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">cmnd_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">US_BULK_FLAG_IN</span><span class="p">)</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_TO_HOST</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_FROM_HOST</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cbw</span><span class="o">-&gt;</span><span class="n">DataTransferLength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">DATA_DIR_NONE</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Lun</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&lt;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">)</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">curlun</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">cbw</span><span class="o">-&gt;</span><span class="n">Tag</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_next_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for the next buffer to become available */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Queue a request to read a Bulk-only CBW */</span>
	<span class="n">set_bulk_out_req_length</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">US_BULK_CB_WRAP_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_out_transfer</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
		<span class="cm">/* Don&#39;t know what to do if common-&gt;fsg is NULL */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We will drain the buffer in software, which means we</span>
<span class="cm">	 * can reuse it for the next filling.  No need to advance</span>
<span class="cm">	 * next_buffhd_to_fill.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Wait for the CBW to arrive */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BUF_STATE_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_is_set</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">?</span> <span class="n">received_cbw</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">,</span> <span class="n">bh</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">**</span><span class="n">preq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">preq</span> <span class="o">=</span> <span class="n">usb_ep_alloc_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">preq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ERROR</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;can&#39;t allocate request for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reset interface setting and re-init endpoint state (toggle etc). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_set_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">new_fsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;reset interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">reset:</span>
	<span class="cm">/* Deallocate the requests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsg</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">);</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">usb_ep_free_request</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">);</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Disable the endpoints */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_ep_disable</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_ep_disable</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
			<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg_wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">common</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fsg</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">new_fsg</span><span class="p">;</span>
	<span class="n">fsg</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">;</span>

	<span class="cm">/* Enable the endpoints */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">config_ep_by_speed</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">),</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_enable</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">common</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">config_ep_by_speed</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">),</span>
				<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_ep_enable</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">common</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">bulk_out_maxpacket</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">);</span>

	<span class="cm">/* Allocate the requests */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_request</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_request</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">bulk_in_complete</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">bulk_out_complete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">common</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">unit_attention_data</span> <span class="o">=</span> <span class="n">SS_RESET_OCCURRED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/****************************** ALT CONFIGS ******************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_set_alt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">intf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">fsg_from_func</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">new_fsg</span> <span class="o">=</span> <span class="n">fsg</span><span class="p">;</span>
	<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_STATE_CONFIG_CHANGE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">USB_GADGET_DELAYED_STATUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsg_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">fsg_from_func</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">new_fsg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_STATE_CONFIG_CHANGE</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span>		<span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fsg_state</span>		<span class="n">old_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span>		<span class="o">*</span><span class="n">curlun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">exception_req_tag</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the existing signals.  Anything but SIGUSR1 is converted</span>
<span class="cm">	 * into a high-priority EXIT exception.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span>
			<span class="n">dequeue_signal_lock</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGUSR1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">FSG_STATE_EXIT</span><span class="p">)</span>
				<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;Main thread exiting on signal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">raise_exception</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_STATE_EXIT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Cancel all the pending transfers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span><span class="p">)</span>
				<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">)</span>
				<span class="n">usb_ep_dequeue</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">,</span>
					       <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Wait until everything is idle */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">num_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">num_active</span> <span class="o">+=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">inreq_busy</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">outreq_busy</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Clear out the controller&#39;s fifos */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in_enabled</span><span class="p">)</span>
			<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out_enabled</span><span class="p">)</span>
			<span class="n">usb_ep_fifo_flush</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the I/O buffer states and pointers, the SCSI</span>
<span class="cm">	 * state, and the exception.  Then invoke the handler.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fsg_num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">BUF_STATE_EMPTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_fill</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">next_buffhd_to_drain</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">exception_req_tag</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">exception_req_tag</span><span class="p">;</span>
	<span class="n">old_state</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">FSG_STATE_ABORT_BULK_OUT</span><span class="p">)</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_STATUS_PHASE</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curlun</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">prevent_medium_removal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span> <span class="o">=</span> <span class="n">SS_NO_SENSE</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">sense_data_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">info_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_IDLE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Carry out any extra actions required for the exception */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">old_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FSG_STATE_ABORT_BULK_OUT</span>:
		<span class="n">send_status</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FSG_STATE_STATUS_PHASE</span><span class="p">)</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_IDLE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_RESET</span>:
		<span class="cm">/*</span>
<span class="cm">		 * In case we were forced against our will to halt a</span>
<span class="cm">		 * bulk endpoint, clear the halt now.  (The SuperH UDC</span>
<span class="cm">		 * requires this.)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_is_set</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">IGNORE_BULK_OUT</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">atomic_bitflags</span><span class="p">))</span>
			<span class="n">usb_ep_clear_halt</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0_req_tag</span> <span class="o">==</span> <span class="n">exception_req_tag</span><span class="p">)</span>
			<span class="n">ep0_queue</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>	<span class="cm">/* Complete the status stage */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Technically this should go here, but it would only be</span>
<span class="cm">		 * a waste of time.  Ditto for the INTERFACE_CHANGE and</span>
<span class="cm">		 * CONFIG_CHANGE cases.</span>
<span class="cm">		 */</span>
		<span class="cm">/* for (i = 0; i &lt; common-&gt;nluns; ++i) */</span>
		<span class="cm">/*	common-&gt;luns[i].unit_attention_data = */</span>
		<span class="cm">/*		SS_RESET_OCCURRED;  */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_CONFIG_CHANGE</span>:
		<span class="n">do_set_interface</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">new_fsg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">new_fsg</span><span class="p">)</span>
			<span class="n">usb_composite_setup_continue</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_EXIT</span>:
	<span class="k">case</span> <span class="n">FSG_STATE_TERMINATED</span>:
		<span class="n">do_set_interface</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>		<span class="cm">/* Free resources */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">;</span>	<span class="cm">/* Stop the thread */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSG_STATE_INTERFACE_CHANGE</span>:
	<span class="k">case</span> <span class="n">FSG_STATE_DISCONNECT</span>:
	<span class="k">case</span> <span class="n">FSG_STATE_COMMAND_PHASE</span>:
	<span class="k">case</span> <span class="n">FSG_STATE_DATA_PHASE</span>:
	<span class="k">case</span> <span class="n">FSG_STATE_STATUS_PHASE</span>:
	<span class="k">case</span> <span class="n">FSG_STATE_IDLE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_main_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">common_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_common</span>	<span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">common_</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow the thread to be killed by a signal, but set the signal mask</span>
<span class="cm">	 * to block everything but INT, TERM, KILL, and USR1.</span>
<span class="cm">	 */</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">);</span>

	<span class="cm">/* Allow the thread to be frozen */</span>
	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Arrange for userspace references to be interpreted as kernel</span>
<span class="cm">	 * pointers.  That way we can pass a kernel pointer to a routine</span>
<span class="cm">	 * that expects a __user pointer and it will work okay.</span>
<span class="cm">	 */</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">get_ds</span><span class="p">());</span>

	<span class="cm">/* The main loop */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">||</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">handle_exception</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sleep_thread</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_next_command</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_DATA_PHASE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_scsi_command</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">||</span> <span class="n">finish_reply</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_STATUS_PHASE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exception_in_progress</span><span class="p">(</span><span class="n">common</span><span class="p">))</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_IDLE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">thread_exits</span>
	 <span class="o">||</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">thread_exits</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span>

		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="o">++</span><span class="n">curlun</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsg_lun_is_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">fsg_lun_close</span><span class="p">(</span><span class="n">curlun</span><span class="p">);</span>
			<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">unit_attention_data</span> <span class="o">=</span> <span class="n">SS_MEDIUM_NOT_PRESENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Let fsg_unbind() know the thread has exited */</span>
	<span class="n">complete_and_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*************************** DEVICE ATTRIBUTES ***************************/</span>

<span class="cm">/* Write permission is checked per LUN in store_*() functions. */</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">fsg_show_ro</span><span class="p">,</span> <span class="n">fsg_store_ro</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">nofua</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">fsg_show_nofua</span><span class="p">,</span> <span class="n">fsg_store_nofua</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">fsg_show_file</span><span class="p">,</span> <span class="n">fsg_store_file</span><span class="p">);</span>


<span class="cm">/****************************** FSG COMMON ******************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fsg_common_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsg_lun_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing needs to be done */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fsg_common_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fsg_common_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">fsg_common_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="nf">fsg_common_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">fsg_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">cdev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">curlun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsg_lun_config</span> <span class="o">*</span><span class="n">lcfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nluns</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pathbuf</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_num_buffers_validate</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="cm">/* Find out how many LUNs there should be */</span>
	<span class="n">nluns</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nluns</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">nluns</span> <span class="o">&gt;</span> <span class="n">FSG_MAX_LUNS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid number of LUNs: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nluns</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">common</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">free_storage_on_release</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">common</span><span class="p">);</span>
		<span class="n">common</span><span class="o">-&gt;</span><span class="n">free_storage_on_release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">fsg_num_buffers</span><span class="p">,</span>
				  <span class="k">sizeof</span> <span class="o">*</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">free_storage_on_release</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">common</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">common</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">gadget</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0</span> <span class="o">=</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">ep0req</span> <span class="o">=</span> <span class="n">cdev</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">cdev</span> <span class="o">=</span> <span class="n">cdev</span><span class="p">;</span>

	<span class="cm">/* Maybe allocate device-global string IDs, and patch descriptors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg_strings</span><span class="p">[</span><span class="n">FSG_STRING_INTERFACE</span><span class="p">].</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_string_id</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error_release</span><span class="p">;</span>
		<span class="n">fsg_strings</span><span class="p">[</span><span class="n">FSG_STRING_INTERFACE</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">fsg_intf_desc</span><span class="p">.</span><span class="n">iInterface</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create the LUNs, open their backing files, and register the</span>
<span class="cm">	 * LUN devices in sysfs.</span>
<span class="cm">	 */</span>
	<span class="n">curlun</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">nluns</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">curlun</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_release</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span> <span class="o">=</span> <span class="n">curlun</span><span class="p">;</span>

	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lcfg</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">curlun</span><span class="p">,</span> <span class="o">++</span><span class="n">lcfg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">cdrom</span> <span class="o">=</span> <span class="o">!!</span><span class="n">lcfg</span><span class="o">-&gt;</span><span class="n">cdrom</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">=</span> <span class="n">lcfg</span><span class="o">-&gt;</span><span class="n">cdrom</span> <span class="o">||</span> <span class="n">lcfg</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">initially_ro</span> <span class="o">=</span> <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="n">lcfg</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">fsg_lun_release</span><span class="p">;</span>
		<span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="cm">/* curlun-&gt;dev.driver = &amp;fsg_driver.driver; XXX */</span>
		<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">filesem</span><span class="p">);</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			     <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">lun_name_format</span>
			   <span class="o">?</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">lun_name_format</span>
			   <span class="o">:</span> <span class="s">&quot;lun%d&quot;</span><span class="p">,</span>
			     <span class="n">i</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INFO</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;failed to register LUN%d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_release</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_ro</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_luns</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_luns</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_nofua</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_luns</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lcfg</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">fsg_lun_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="n">lcfg</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error_luns</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;no file given for LUN%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_luns</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span> <span class="o">=</span> <span class="n">nluns</span><span class="p">;</span>

	<span class="cm">/* Data buffers cyclic list */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">fsg_num_buffers</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">buffhds_first_it</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">++</span><span class="n">bh</span><span class="p">;</span>
<span class="nl">buffhds_first_it:</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">FSG_BUFLEN</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_release</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">;</span>

	<span class="cm">/* Prepare inquiryString */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">usb_gadget_controller_number</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mh">0x0300</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">WARNING</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;controller &#39;%s&#39; not recognized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">gadget</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mh">0x0399</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">inquiry_string</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">inquiry_string</span><span class="p">,</span>
		 <span class="s">&quot;%-8s%-16s%04x&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vendor_name</span> <span class="o">?:</span> <span class="s">&quot;Linux&quot;</span><span class="p">,</span>
		 <span class="cm">/* Assume product name dependent on the first LUN */</span>
		 <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">product_name</span> <span class="o">?:</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="o">-&gt;</span><span class="n">cdrom</span>
				     <span class="o">?</span> <span class="s">&quot;File-Stor Gadget&quot;</span>
				     <span class="o">:</span> <span class="s">&quot;File-CD Gadget&quot;</span><span class="p">),</span>
		 <span class="n">i</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some peripheral controllers are known not to be able to</span>
<span class="cm">	 * halt bulk endpoints correctly.  If one of them is present,</span>
<span class="cm">	 * disable stalls.</span>
<span class="cm">	 */</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">can_stall</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">can_stall</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">gadget_is_at91</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">));</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>

	<span class="cm">/* Tell the thread to start working */</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span> <span class="o">=</span>
		<span class="n">kthread_create</span><span class="p">(</span><span class="n">fsg_main_thread</span><span class="p">,</span> <span class="n">common</span><span class="p">,</span>
			       <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">thread_name</span> <span class="o">?:</span> <span class="s">&quot;file-storage&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_release</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg_wait</span><span class="p">);</span>

	<span class="cm">/* Information */</span>
	<span class="n">INFO</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_DRIVER_DESC</span> <span class="s">&quot;, version: &quot;</span> <span class="n">FSG_DRIVER_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">INFO</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;Number of LUNs=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">);</span>

	<span class="n">pathbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PATH_MAX</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nluns</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">,</span> <span class="n">curlun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nluns</span><span class="p">;</span>
	     <span class="o">++</span><span class="n">curlun</span><span class="p">,</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;(no medium)&quot;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsg_lun_is_open</span><span class="p">(</span><span class="n">curlun</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;(error)&quot;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pathbuf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curlun</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span>
					   <span class="n">pathbuf</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
					<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;(error)&quot;</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">LINFO</span><span class="p">(</span><span class="n">curlun</span><span class="p">,</span> <span class="s">&quot;LUN: %s%s%sfile: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">?</span> <span class="s">&quot;removable &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		      <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">?</span> <span class="s">&quot;read only &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		      <span class="n">curlun</span><span class="o">-&gt;</span><span class="n">cdrom</span> <span class="o">?</span> <span class="s">&quot;CD-ROM &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		      <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pathbuf</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="s">&quot;I/O thread pid: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">));</span>

	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">common</span><span class="p">;</span>

<span class="nl">error_luns:</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">error_release:</span>
	<span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">;</span>	<span class="cm">/* The thread is dead */</span>
	<span class="cm">/* Call fsg_common_release() directly, ref might be not initialised. */</span>
	<span class="n">fsg_common_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsg_common_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsg_common</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

	<span class="cm">/* If the thread isn&#39;t already dead, tell it to exit now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FSG_STATE_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raise_exception</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_STATE_EXIT</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">thread_notifier</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsg_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span>

		<span class="cm">/* In error recovery common-&gt;nluns may be zero. */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">lun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_nofua</span><span class="p">);</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_ro</span><span class="p">);</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_file</span><span class="p">);</span>
			<span class="n">fsg_lun_close</span><span class="p">(</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsg_buffhd</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">fsg_num_buffers</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">bh</span><span class="p">,</span> <span class="o">--</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">buffhds</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">free_storage_on_release</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsg_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">fsg_from_func</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsg_common</span>	<span class="o">*</span><span class="n">common</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;unbind</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span> <span class="o">==</span> <span class="n">fsg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">new_fsg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">raise_exception</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">,</span> <span class="n">FSG_STATE_CONFIG_CHANGE</span><span class="p">);</span>
		<span class="cm">/* FIXME: make interruptible or killable somehow? */</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg_wait</span><span class="p">,</span> <span class="n">common</span><span class="o">-&gt;</span><span class="n">fsg</span> <span class="o">!=</span> <span class="n">fsg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fsg_common_put</span><span class="p">(</span><span class="n">common</span><span class="p">);</span>
	<span class="n">usb_free_descriptors</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">descriptors</span><span class="p">);</span>
	<span class="n">usb_free_descriptors</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">hs_descriptors</span><span class="p">);</span>
	<span class="n">usb_free_descriptors</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">ss_descriptors</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span>		<span class="o">*</span><span class="n">fsg</span> <span class="o">=</span> <span class="n">fsg_from_func</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>	<span class="o">*</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">gadget</span> <span class="o">=</span> <span class="n">gadget</span><span class="p">;</span>

	<span class="cm">/* New interface */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">usb_interface_id</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">fsg_intf_desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">interface_number</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Find all the endpoints we will use */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_ep_autoconfig</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_fs_bulk_in_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">autoconf_fail</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">;</span>	<span class="cm">/* claim the endpoint */</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_in</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_ep_autoconfig</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg_fs_bulk_out_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">autoconf_fail</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">;</span>	<span class="cm">/* claim the endpoint */</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">bulk_out</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* Copy descriptors */</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">descriptors</span> <span class="o">=</span> <span class="n">usb_copy_descriptors</span><span class="p">(</span><span class="n">fsg_fs_function</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_dualspeed</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Assume endpoint addresses are the same for both speeds */</span>
		<span class="n">fsg_hs_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">fsg_hs_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">hs_descriptors</span> <span class="o">=</span> <span class="n">usb_copy_descriptors</span><span class="p">(</span><span class="n">fsg_hs_function</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">hs_descriptors</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">usb_free_descriptors</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gadget_is_superspeed</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">max_burst</span><span class="p">;</span>

		<span class="cm">/* Calculate bMaxBurst, we know packet size is 1024 */</span>
		<span class="n">max_burst</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">FSG_BUFLEN</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>

		<span class="n">fsg_ss_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_in_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">fsg_ss_bulk_in_comp_desc</span><span class="p">.</span><span class="n">bMaxBurst</span> <span class="o">=</span> <span class="n">max_burst</span><span class="p">;</span>

		<span class="n">fsg_ss_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span>
			<span class="n">fsg_fs_bulk_out_desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="n">fsg_ss_bulk_out_comp_desc</span><span class="p">.</span><span class="n">bMaxBurst</span> <span class="o">=</span> <span class="n">max_burst</span><span class="p">;</span>

		<span class="n">f</span><span class="o">-&gt;</span><span class="n">ss_descriptors</span> <span class="o">=</span> <span class="n">usb_copy_descriptors</span><span class="p">(</span><span class="n">fsg_ss_function</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ss_descriptors</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">usb_free_descriptors</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">hs_descriptors</span><span class="p">);</span>
			<span class="n">usb_free_descriptors</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">autoconf_fail:</span>
	<span class="n">ERROR</span><span class="p">(</span><span class="n">fsg</span><span class="p">,</span> <span class="s">&quot;unable to autoconfigure all endpoints</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/****************************** ADD FUNCTION ******************************/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_gadget_strings</span> <span class="o">*</span><span class="n">fsg_strings_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">fsg_stringtab</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsg_bind_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_dev</span> <span class="o">*</span><span class="n">fsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">fsg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">fsg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fsg</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">name</span>        <span class="o">=</span> <span class="n">FSG_DRIVER_DESC</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">strings</span>     <span class="o">=</span> <span class="n">fsg_strings_array</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">bind</span>        <span class="o">=</span> <span class="n">fsg_bind</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">unbind</span>      <span class="o">=</span> <span class="n">fsg_unbind</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">setup</span>       <span class="o">=</span> <span class="n">fsg_setup</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">set_alt</span>     <span class="o">=</span> <span class="n">fsg_set_alt</span><span class="p">;</span>
	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">.</span><span class="n">disable</span>     <span class="o">=</span> <span class="n">fsg_disable</span><span class="p">;</span>

	<span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span>               <span class="o">=</span> <span class="n">common</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Our caller holds a reference to common structure so we</span>
<span class="cm">	 * don&#39;t have to be worry about it being freed until we return</span>
<span class="cm">	 * from this function.  So instead of incrementing counter now</span>
<span class="cm">	 * and decrement in error recovery we increment it only when</span>
<span class="cm">	 * call to usb_add_function() was successful.</span>
<span class="cm">	 */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_add_function</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fsg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fsg_common_get</span><span class="p">(</span><span class="n">fsg</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/************************* Module parameters *************************/</span>

<span class="k">struct</span> <span class="n">fsg_module_parameters</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>
	<span class="n">bool</span>		<span class="n">ro</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>
	<span class="n">bool</span>		<span class="n">removable</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>
	<span class="n">bool</span>		<span class="n">cdrom</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>
	<span class="n">bool</span>		<span class="n">nofua</span><span class="p">[</span><span class="n">FSG_MAX_LUNS</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">file_count</span><span class="p">,</span> <span class="n">ro_count</span><span class="p">,</span> <span class="n">removable_count</span><span class="p">,</span> <span class="n">cdrom_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">nofua_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">luns</span><span class="p">;</span>	<span class="cm">/* nluns */</span>
	<span class="n">bool</span>		<span class="n">stall</span><span class="p">;</span>	<span class="cm">/* can_stall */</span>
<span class="p">};</span>

<span class="cp">#define _FSG_MODULE_PARAM_ARRAY(prefix, params, name, type, desc)	\</span>
<span class="cp">	module_param_array_named(prefix ## name, params.name, type,	\</span>
<span class="cp">				 &amp;prefix ## params.name ## _count,	\</span>
<span class="cp">				 S_IRUGO);				\</span>
<span class="cp">	MODULE_PARM_DESC(prefix ## name, desc)</span>

<span class="cp">#define _FSG_MODULE_PARAM(prefix, params, name, type, desc)		\</span>
<span class="cp">	module_param_named(prefix ## name, params.name, type,		\</span>
<span class="cp">			   S_IRUGO);					\</span>
<span class="cp">	MODULE_PARM_DESC(prefix ## name, desc)</span>

<span class="cp">#define FSG_MODULE_PARAMETERS(prefix, params)				\</span>
<span class="cp">	_FSG_MODULE_PARAM_ARRAY(prefix, params, file, charp,		\</span>
<span class="cp">				&quot;names of backing files or devices&quot;);	\</span>
<span class="cp">	_FSG_MODULE_PARAM_ARRAY(prefix, params, ro, bool,		\</span>
<span class="cp">				&quot;true to force read-only&quot;);		\</span>
<span class="cp">	_FSG_MODULE_PARAM_ARRAY(prefix, params, removable, bool,	\</span>
<span class="cp">				&quot;true to simulate removable media&quot;);	\</span>
<span class="cp">	_FSG_MODULE_PARAM_ARRAY(prefix, params, cdrom, bool,		\</span>
<span class="cp">				&quot;true to simulate CD-ROM instead of disk&quot;); \</span>
<span class="cp">	_FSG_MODULE_PARAM_ARRAY(prefix, params, nofua, bool,		\</span>
<span class="cp">				&quot;true to ignore SCSI WRITE(10,12) FUA bit&quot;); \</span>
<span class="cp">	_FSG_MODULE_PARAM(prefix, params, luns, uint,			\</span>
<span class="cp">			  &quot;number of LUNs&quot;);				\</span>
<span class="cp">	_FSG_MODULE_PARAM(prefix, params, stall, bool,			\</span>
<span class="cp">			  &quot;false to prevent bulk stalls&quot;)</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fsg_config_from_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">fsg_module_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_lun_config</span> <span class="o">*</span><span class="n">lun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Configure LUNs */</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">nluns</span> <span class="o">=</span>
		<span class="n">min</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">luns</span> <span class="o">?:</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">file_count</span> <span class="o">?:</span> <span class="mi">1u</span><span class="p">),</span>
		    <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">FSG_MAX_LUNS</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lun</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">nluns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">lun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lun</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">=</span> <span class="o">!!</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">lun</span><span class="o">-&gt;</span><span class="n">cdrom</span> <span class="o">=</span> <span class="o">!!</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cdrom</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">lun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="cm">/* Removable by default */</span>
			<span class="n">params</span><span class="o">-&gt;</span><span class="n">removable_count</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">||</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">lun</span><span class="o">-&gt;</span><span class="n">filename</span> <span class="o">=</span>
			<span class="n">params</span><span class="o">-&gt;</span><span class="n">file_count</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			<span class="o">?</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Let MSF use defaults */</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">lun_name_format</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">thread_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vendor_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">product_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Finalise */</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">can_stall</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">stall</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span>
<span class="n">fsg_common_from_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">fsg_module_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
	<span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span>
<span class="nf">fsg_common_from_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsg_common</span> <span class="o">*</span><span class="n">common</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">fsg_module_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsg_config</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="n">fsg_config_from_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fsg_common_init</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
