<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › pxa27x_udc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pxa27x_udc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Handles the Intel 27x USB Device Controller (UDC)</span>
<span class="cm"> *</span>
<span class="cm"> * Inspired by original driver by Frank Becker, David Brownell, and others.</span>
<span class="cm"> * Copyright (C) 2008 Robert Jarzmik</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;mach/hardware.h&gt;</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &lt;mach/udc.h&gt;</span>

<span class="cp">#include &quot;pxa27x_udc.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This driver handles the USB Device Controller (UDC) in Intel&#39;s PXA 27x</span>
<span class="cm"> * series processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Such controller drivers work with a gadget driver.  The gadget driver</span>
<span class="cm"> * returns descriptors, implements configuration and data protocols used</span>
<span class="cm"> * by the host to interact with this device, and allocates endpoints to</span>
<span class="cm"> * the different protocol interfaces.  The controller driver virtualizes</span>
<span class="cm"> * usb hardware so that the gadget drivers will be more portable.</span>
<span class="cm"> *</span>
<span class="cm"> * This UDC hardware wants to implement a bit too much USB protocol. The</span>
<span class="cm"> * biggest issues are:  that the endpoints have to be set up before the</span>
<span class="cm"> * controller can be enabled (minor, and not uncommon); and each endpoint</span>
<span class="cm"> * can only have one configuration, interface and alternative interface</span>
<span class="cm"> * number (major, and very unusual). Once set up, these cannot be changed</span>
<span class="cm"> * without a controller reset.</span>
<span class="cm"> *</span>
<span class="cm"> * The workaround is to setup all combinations necessary for the gadgets which</span>
<span class="cm"> * will work with this driver. This is done in pxa_udc structure, statically.</span>
<span class="cm"> * See pxa_udc, udc_usb_ep versus pxa_ep, and matching function find_pxa_ep.</span>
<span class="cm"> * (You could modify this if needed.  Some drivers have a &quot;fifo_mode&quot; module</span>
<span class="cm"> * parameter to facilitate such changes.)</span>
<span class="cm"> *</span>
<span class="cm"> * The combinations have been tested with these gadgets :</span>
<span class="cm"> *  - zero gadget</span>
<span class="cm"> *  - file storage gadget</span>
<span class="cm"> *  - ether gadget</span>
<span class="cm"> *</span>
<span class="cm"> * The driver doesn&#39;t use DMA, only IO access and IRQ callbacks. No use is</span>
<span class="cm"> * made of UDC&#39;s double buffering either. USB &quot;On-The-Go&quot; is not implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * All the requests are handled the same way :</span>
<span class="cm"> *  - the drivers tries to handle the request directly to the IO</span>
<span class="cm"> *  - if the IO fifo is not big enough, the remaining is send/received in</span>
<span class="cm"> *    interrupt handling.</span>
<span class="cm"> */</span>

<span class="cp">#define	DRIVER_VERSION	&quot;2008-04-18&quot;</span>
<span class="cp">#define	DRIVER_DESC	&quot;PXA 27x USB Device Controller driver&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;pxa27x_udc&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">the_controller</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">handle_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Debug filesystem</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_USB_GADGET_DEBUG_FS</span>

<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">state_dbg_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* basic device status */</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DRIVER_DESC</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;%s version: %s</span><span class="se">\n</span><span class="s">Gadget driver: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">driver_name</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">,</span>
			 <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;(none)&quot;</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
			 <span class="s">&quot;udccr=0x%0x(%s%s%s%s%s%s%s%s%s%s), &quot;</span>
			 <span class="s">&quot;con=%d,inter=%d,altinter=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_OEN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; oen&quot;</span><span class="o">:</span><span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_AALTHNP</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; aalthnp&quot;</span><span class="o">:</span><span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_AHNP</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; rem&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_BHNP</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; rstir&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_DWRE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; dwre&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_SMAC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; smac&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_EMCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; emce&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_UDR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; udr&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_UDA</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; uda&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_UDE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; ude&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_ACN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDCCR_ACN_S</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_AIN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDCCR_AIN_S</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCR_AAISN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDCCR_AAISN_S</span><span class="p">);</span>
	<span class="cm">/* registers for device and ep0 */</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;udcicr0=0x%08x udcicr1=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR0</span><span class="p">),</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">));</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;udcisr0=0x%08x udcisr1=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR0</span><span class="p">),</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">));</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;udcfnr=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCFNR</span><span class="p">));</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;irqs: reset=%lu, suspend=%lu, resume=%lu, &quot;</span>
			<span class="s">&quot;reconfig=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_reset</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_suspend</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_resume</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_reconfig</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queues_dbg_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">maxpkt</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* dump endpoint queues */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_PXA_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">maxpkt</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>  <span class="s">&quot;%-12s max_pkt=%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">EPNAME</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span> <span class="n">maxpkt</span><span class="p">,</span> <span class="s">&quot;pio&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">(nothing queued)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>  <span class="s">&quot;</span><span class="se">\t</span><span class="s">req %p len %d/%d buf %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eps_dbg_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;udccsr0=0x%03x(%s%s%s%s%s%s%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_SA</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; sa&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_RNE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; rne&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_FST</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; fst&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_SST</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; sst&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_DME</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; dme&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_IPR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; ipr&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_OPC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; opc&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_PXA_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">i</span><span class="o">?</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">)</span> <span class="o">:</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%-12s: &quot;</span>
				<span class="s">&quot;IN %lu(%lu reqs), OUT %lu(%lu reqs), &quot;</span>
				<span class="s">&quot;irqs=%lu, udccr=0x%08x, udccsr=0x%03x, &quot;</span>
				<span class="s">&quot;udcbcr=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">EPNAME</span><span class="p">(</span><span class="n">ep</span><span class="p">),</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">in_bytes</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">in_ops</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">out_bytes</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">out_ops</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs</span><span class="p">,</span>
				<span class="n">tmp</span><span class="p">,</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">),</span>
				<span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCBCR</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eps_dbg_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">eps_dbg_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queues_dbg_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">queues_dbg_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">state_dbg_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">state_dbg_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">state_dbg_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">state_dbg_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">queues_dbg_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">queues_dbg_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">eps_dbg_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">eps_dbg_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_init_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">queues</span><span class="p">,</span> <span class="o">*</span><span class="n">eps</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_root</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;udcstate&quot;</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">udc</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">state_dbg_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_state</span><span class="p">;</span>
	<span class="n">queues</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;queues&quot;</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">udc</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">queues_dbg_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queues</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_queues</span><span class="p">;</span>
	<span class="n">eps</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;epstate&quot;</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">udc</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">eps_dbg_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eps</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_eps</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_queues</span> <span class="o">=</span> <span class="n">queues</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_eps</span> <span class="o">=</span> <span class="n">eps</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">err_eps:</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">eps</span><span class="p">);</span>
<span class="nl">err_queues:</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">queues</span><span class="p">);</span>
<span class="nl">err_state:</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="nl">err_root:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;debugfs is not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_cleanup_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_eps</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_queues</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_state</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_eps</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_queues</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">debugfs_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pxa_init_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pxa_cleanup_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * is_match_usb_pxa - check if usb_ep and pxa_ep match</span>
<span class="cm"> * @udc_usb_ep: usb endpoint</span>
<span class="cm"> * @ep: pxa endpoint</span>
<span class="cm"> * @config: configuration required in pxa_ep</span>
<span class="cm"> * @interface: interface required in pxa_ep</span>
<span class="cm"> * @altsetting: altsetting required in pxa_ep</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if all criteria match between pxa and usb endpoint, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_match_usb_pxa</span><span class="p">(</span><span class="k">struct</span> <span class="n">udc_usb_ep</span> <span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">config</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interface</span><span class="p">,</span> <span class="kt">int</span> <span class="n">altsetting</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">!=</span> <span class="n">config</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">!=</span> <span class="n">interface</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">alternate</span> <span class="o">!=</span> <span class="n">altsetting</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_pxa_ep - find pxa_ep structure matching udc_usb_ep</span>
<span class="cm"> * @udc: pxa udc</span>
<span class="cm"> * @udc_usb_ep: udc_usb_ep structure</span>
<span class="cm"> *</span>
<span class="cm"> * Match udc_usb_ep and all pxa_ep available, to see if one matches.</span>
<span class="cm"> * This is necessary because of the strong pxa hardware restriction requiring</span>
<span class="cm"> * that once pxa endpoints are initialized, their configuration is freezed, and</span>
<span class="cm"> * no change can be made to their address, direction, or in which configuration,</span>
<span class="cm"> * interface or altsetting they are active ... which differs from more usual</span>
<span class="cm"> * models which have endpoints be roughly just addressable fifos, and leave</span>
<span class="cm"> * configuration events up to gadget drivers (like all control messages).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that there is still a blurred point here :</span>
<span class="cm"> *   - we rely on UDCCR register &quot;active interface&quot; and &quot;active altsetting&quot;.</span>
<span class="cm"> *     This is a nonsense in regard of USB spec, where multiple interfaces are</span>
<span class="cm"> *     active at the same time.</span>
<span class="cm"> *   - if we knew for sure that the pxa can handle multiple interface at the</span>
<span class="cm"> *     same time, assuming Intel&#39;s Developer Guide is wrong, this function</span>
<span class="cm"> *     should be reviewed, and a cache of couples (iface, altsetting) should</span>
<span class="cm"> *     be kept in the pxa_udc structure. In this case this function would match</span>
<span class="cm"> *     against the cache of couples instead of the &quot;last altsetting&quot; set up.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the matched pxa_ep structure or NULL if none found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="nf">find_pxa_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">udc_usb_ep</span> <span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iface</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_interface</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alt</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_alternate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_usb_ep</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udc_usb_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_PXA_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_match_usb_pxa</span><span class="p">(</span><span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="n">alt</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_pxa_ep_matches - update pxa_ep cached values in all udc_usb_ep</span>
<span class="cm"> * @udc: pxa udc</span>
<span class="cm"> *</span>
<span class="cm"> * Context: in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Updates all pxa_ep fields in udc_usb_ep structures, if this field was</span>
<span class="cm"> * previously set up (and is not NULL). The update is necessary is a</span>
<span class="cm"> * configuration change or altsetting change was issued by the USB host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_pxa_ep_matches</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span> <span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_USB_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udc_usb_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">)</span>
			<span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span> <span class="o">=</span> <span class="n">find_pxa_ep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc_usb_ep</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pio_irq_enable - Enables irq generation for one endpoint</span>
<span class="cm"> * @ep: udc endpoint</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pio_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">EPIDX</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">udcicr0</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR0</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">udcicr1</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR0</span><span class="p">,</span> <span class="n">udcicr0</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)));</span>
	<span class="k">else</span>
		<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">,</span> <span class="n">udcicr1</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">index</span> <span class="o">-</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pio_irq_disable - Disables irq generation for one endpoint</span>
<span class="cm"> * @ep: udc endpoint</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pio_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">EPIDX</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">udcicr0</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR0</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">udcicr1</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR0</span><span class="p">,</span> <span class="n">udcicr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)));</span>
	<span class="k">else</span>
		<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">,</span> <span class="n">udcicr1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">index</span> <span class="o">-</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * udc_set_mask_UDCCR - set bits in UDCCR</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @mask: bits to set in UDCCR</span>
<span class="cm"> *</span>
<span class="cm"> * Sets bits in UDCCR, leaving DME and FST bits as they were.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">udc_set_mask_UDCCR</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">udccr</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">,</span>
			<span class="p">(</span><span class="n">udccr</span> <span class="o">&amp;</span> <span class="n">UDCCR_MASK_BITS</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">UDCCR_MASK_BITS</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * udc_clear_mask_UDCCR - clears bits in UDCCR</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @mask: bit to clear in UDCCR</span>
<span class="cm"> *</span>
<span class="cm"> * Clears bits in UDCCR, leaving DME and FST bits as they were.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">udc_clear_mask_UDCCR</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">udccr</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">,</span>
			<span class="p">(</span><span class="n">udccr</span> <span class="o">&amp;</span> <span class="n">UDCCR_MASK_BITS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">UDCCR_MASK_BITS</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_write_UDCCSR - set bits in UDCCSR</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @mask: bits to set in UDCCR</span>
<span class="cm"> *</span>
<span class="cm"> * Sets bits in UDCCSR (UDCCSR0 and UDCCSR*).</span>
<span class="cm"> *</span>
<span class="cm"> * A specific case is applied to ep0 : the ACM bit is always set to 1, for</span>
<span class="cm"> * SET_INTERFACE and SET_CONFIGURATION.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ep_write_UDCCSR</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">UDCCSR0_ACM</span><span class="p">;</span>
	<span class="n">udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_count_bytes_remain - get how many bytes in udc endpoint</span>
<span class="cm"> * @ep: udc endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes in OUT fifos. Broken for IN fifos (-EOPNOTSUPP)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_count_bytes_remain</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCBCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_is_empty - checks if ep has byte ready for reading</span>
<span class="cm"> * @ep: udc endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * If endpoint is the control endpoint, checks if there are bytes in the</span>
<span class="cm"> * control endpoint fifo. If endpoint is a data endpoint, checks if bytes</span>
<span class="cm"> * are ready for reading on OUT endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if ep not empty, 1 if ep empty, -EOPNOTSUPP if IN endpoint</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_is_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_RNE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCSR_BNE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_is_full - checks if ep has place to write bytes</span>
<span class="cm"> * @ep: udc endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * If endpoint is not the control endpoint and is an IN endpoint, checks if</span>
<span class="cm"> * there is place to write bytes into the endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if ep not full, 1 if ep full, -EOPNOTSUPP if OUT endpoint</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_is_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_IPR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCSR_BNF</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * epout_has_pkt - checks if OUT endpoint fifo has a packet available</span>
<span class="cm"> * @ep: pxa endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if a complete packet is available, 0 if not, -EOPNOTSUPP for IN ep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">epout_has_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_OPC</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCSR_PC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_ep0state - Set ep0 automata state</span>
<span class="cm"> * @dev: udc device</span>
<span class="cm"> * @state: state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ep0state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">old_stname</span> <span class="o">=</span> <span class="n">EP0_STNAME</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;state=%s-&gt;%s, udccsr0=0x%03x, udcbcr=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">old_stname</span><span class="p">,</span>
		<span class="n">EP0_STNAME</span><span class="p">(</span><span class="n">udc</span><span class="p">),</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">),</span>
		<span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCBCR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep0_idle - Put control endpoint into idle state</span>
<span class="cm"> * @dev: udc device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_ep0state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inc_ep_stats_reqs - Update ep stats counts</span>
<span class="cm"> * @ep: physical endpoint</span>
<span class="cm"> * @req: usb request</span>
<span class="cm"> * @is_in: ep direction (USB_DIR_IN or 0)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_ep_stats_reqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_in</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">in_ops</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">out_ops</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inc_ep_stats_bytes - Update ep stats counts</span>
<span class="cm"> * @ep: physical endpoint</span>
<span class="cm"> * @count: bytes transferred on endpoint</span>
<span class="cm"> * @is_in: ep direction (USB_DIR_IN or 0)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_ep_stats_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_in</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">in_bytes</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">out_bytes</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_setup - Sets up an usb physical endpoint</span>
<span class="cm"> * @ep: pxa27x physical endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Find the physical pxa27x ep, and setup its UDCCR</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">pxa_ep_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">new_udccr</span><span class="p">;</span>

	<span class="n">new_udccr</span> <span class="o">=</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">&lt;&lt;</span> <span class="n">UDCCONR_CN_S</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCONR_CN</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">&lt;&lt;</span> <span class="n">UDCCONR_IN_S</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCONR_IN</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">alternate</span> <span class="o">&lt;&lt;</span> <span class="n">UDCCONR_AISN_S</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCONR_AISN</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">EPADDR</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">UDCCONR_EN_S</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCONR_EN</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">EPXFERTYPE</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">UDCCONR_ET_S</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCONR_ET</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span> <span class="o">?</span> <span class="n">UDCCONR_ED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">&lt;&lt;</span> <span class="n">UDCCONR_MPS_S</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCONR_MPS</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">UDCCONR_EE</span><span class="p">;</span>

	<span class="n">udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">,</span> <span class="n">new_udccr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_eps_setup - Sets up all usb physical endpoints</span>
<span class="cm"> * @dev: udc device</span>
<span class="cm"> *</span>
<span class="cm"> * Setup all pxa physical endpoints, except ep0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">pxa_eps_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: dev=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_PXA_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pxa_ep_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_alloc_request - Allocate usb request</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> * @gfp_flags:</span>
<span class="cm"> *</span>
<span class="cm"> * For the pxa27x, these can just wrap kmalloc/kfree.  gadget drivers</span>
<span class="cm"> * must still pass correctly initialized endpoints, since other controller</span>
<span class="cm"> * drivers may care about how it&#39;s currently set up (dma issues etc).</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span>
<span class="nf">pxa_ep_alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_free_request - Free usb request</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> * @_req: usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Wrapper around kfree to free _req</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_ep_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_add_request - add a request to the endpoint&#39;s queue</span>
<span class="cm"> * @ep: usb endpoint</span>
<span class="cm"> * @req: usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Queues the request in the endpoint&#39;s queue, and enables the interrupts</span>
<span class="cm"> * on the endpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_add_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ep_vdbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;req:%p, lg=%d, udccsr=0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">));</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">pio_irq_enable</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_del_request - removes a request from the endpoint&#39;s queue</span>
<span class="cm"> * @ep: usb endpoint</span>
<span class="cm"> * @req: usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Unqueue the request from the endpoint&#39;s queue. If there are no more requests</span>
<span class="cm"> * on the endpoint, and if it&#39;s not the control endpoint, interrupts are</span>
<span class="cm"> * disabled on the endpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_del_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ep_vdbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;req:%p, lg=%d, udccsr=0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">));</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">pio_irq_disable</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * req_done - Complete an usb request</span>
<span class="cm"> * @ep: pxa physical endpoint</span>
<span class="cm"> * @req: pxa request</span>
<span class="cm"> * @status: usb request status sent to gadget API</span>
<span class="cm"> * @pflags: flags of previous spinlock_irq_save() or NULL if no lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock held if flags not NULL, else ep-&gt;lock released</span>
<span class="cm"> *</span>
<span class="cm"> * Retire a pxa27x usb request. Endpoint must be locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">req_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="n">ep_del_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;complete req %p stat %d len %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pflags</span><span class="p">)</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">pflags</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">usb_ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pflags</span><span class="p">)</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">pflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_end_out_req - Ends endpoint OUT request</span>
<span class="cm"> * @ep: physical endpoint</span>
<span class="cm"> * @req: pxa request</span>
<span class="cm"> * @pflags: flags of previous spinlock_irq_save() or NULL if no lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock held or released (see req_done())</span>
<span class="cm"> *</span>
<span class="cm"> * Ends endpoint OUT request (completes usb request).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_end_out_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inc_ep_stats_reqs</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">!</span><span class="n">USB_DIR_IN</span><span class="p">);</span>
	<span class="n">req_done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep0_end_out_req - Ends control endpoint OUT request (ends data stage)</span>
<span class="cm"> * @ep: physical endpoint</span>
<span class="cm"> * @req: pxa request</span>
<span class="cm"> * @pflags: flags of previous spinlock_irq_save() or NULL if no lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock held or released (see req_done())</span>
<span class="cm"> *</span>
<span class="cm"> * Ends control endpoint OUT request (completes usb request), and puts</span>
<span class="cm"> * control endpoint into idle state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_end_out_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_ep0state</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">OUT_STATUS_STAGE</span><span class="p">);</span>
	<span class="n">ep_end_out_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>
	<span class="n">ep0_idle</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_end_in_req - Ends endpoint IN request</span>
<span class="cm"> * @ep: physical endpoint</span>
<span class="cm"> * @req: pxa request</span>
<span class="cm"> * @pflags: flags of previous spinlock_irq_save() or NULL if no lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock held or released (see req_done())</span>
<span class="cm"> *</span>
<span class="cm"> * Ends endpoint IN request (completes usb request).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_end_in_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inc_ep_stats_reqs</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">);</span>
	<span class="n">req_done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep0_end_in_req - Ends control endpoint IN request (ends data stage)</span>
<span class="cm"> * @ep: physical endpoint</span>
<span class="cm"> * @req: pxa request</span>
<span class="cm"> * @pflags: flags of previous spinlock_irq_save() or NULL if no lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock held or released (see req_done())</span>
<span class="cm"> *</span>
<span class="cm"> * Ends control endpoint IN request (completes usb request), and puts</span>
<span class="cm"> * control endpoint into status state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep0_end_in_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_ep0state</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">IN_STATUS_STAGE</span><span class="p">);</span>
	<span class="n">ep_end_in_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nuke - Dequeue all requests</span>
<span class="cm"> * @ep: pxa endpoint</span>
<span class="cm"> * @status: usb request status</span>
<span class="cm"> *</span>
<span class="cm"> * Context: ep-&gt;lock released</span>
<span class="cm"> *</span>
<span class="cm"> * Dequeues all requests on an endpoint. As a side effect, interrupts will be</span>
<span class="cm"> * disabled on that endpoint (because no more requests).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nuke</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">req_done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_packet - transfer 1 packet from an OUT endpoint into request</span>
<span class="cm"> * @ep: pxa physical endpoint</span>
<span class="cm"> * @req: usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Takes bytes from OUT endpoint and transfers them info the usb request.</span>
<span class="cm"> * If there is less space in request than bytes received in OUT endpoint,</span>
<span class="cm"> * bytes are left in the OUT endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns how many bytes were actually transferred</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_ep</span><span class="p">,</span> <span class="n">bufferspace</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bytes_ep</span> <span class="o">=</span> <span class="n">ep_count_bytes_remain</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">bufferspace</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">);</span>
	<span class="n">prefetchw</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ep_is_empty</span><span class="p">(</span><span class="n">ep</span><span class="p">)))</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes_ep</span><span class="p">,</span> <span class="n">bufferspace</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* zlp */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCDR</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR_PC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_packet - transfer 1 packet from request into an IN endpoint</span>
<span class="cm"> * @ep: pxa physical endpoint</span>
<span class="cm"> * @req: usb request</span>
<span class="cm"> * @max: max bytes that fit into endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Takes bytes from usb request, and transfers them into the physical</span>
<span class="cm"> * endpoint. If there are no bytes to transfer, doesn&#39;t write anything</span>
<span class="cm"> * to physical endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns how many bytes were actually transferred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">remain</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf_8</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">);</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">remain</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCDR</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">);</span>

	<span class="n">buf_8</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">remain</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">udc_ep_writeb</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCDR</span><span class="p">,</span> <span class="o">*</span><span class="n">buf_8</span><span class="o">++</span><span class="p">);</span>

	<span class="n">ep_vdbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;length=%d+%d, udccsr=0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">remain</span><span class="p">,</span>
		<span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_fifo - Transfer packets from OUT endpoint into usb request</span>
<span class="cm"> * @ep: pxa physical endpoint</span>
<span class="cm"> * @req: usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Context: callable when in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Unload as many packets as possible from the fifo we use for usb OUT</span>
<span class="cm"> * transfers and put them into the request. Caller should have made sure</span>
<span class="cm"> * there&#39;s at least one packet ready.</span>
<span class="cm"> * Doesn&#39;t complete the request, that&#39;s the caller&#39;s job</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the request completed, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">is_short</span><span class="p">,</span> <span class="n">completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">epout_has_pkt</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">read_packet</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">inc_ep_stats_bytes</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">!</span><span class="n">USB_DIR_IN</span><span class="p">);</span>

		<span class="n">is_short</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span><span class="p">);</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;read udccsr:%03x, count:%d bytes%s req %p %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">),</span> <span class="n">count</span><span class="p">,</span> <span class="n">is_short</span> <span class="o">?</span> <span class="s">&quot;/S&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

		<span class="cm">/* completion */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_short</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* finished that packet.  the next one may be waiting... */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">completed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_fifo - transfer packets from usb request into an IN endpoint</span>
<span class="cm"> * @ep: pxa physical endpoint</span>
<span class="cm"> * @req: pxa usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Write to an IN endpoint fifo, as many packets as possible.</span>
<span class="cm"> * irqs will use this to write the rest later.</span>
<span class="cm"> * caller guarantees at least one packet buffer is ready (or a zlp).</span>
<span class="cm"> * Doesn&#39;t complete the request, that&#39;s the caller&#39;s job</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if request fully transferred, 0 if partial transfer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">is_short</span><span class="p">,</span> <span class="n">is_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">udccsr</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">is_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">udccsr</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udccsr</span> <span class="o">&amp;</span> <span class="n">UDCCSR_PC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep_vdbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;Clearing Transmit Complete, udccsr=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udccsr</span><span class="p">);</span>
			<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR_PC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udccsr</span> <span class="o">&amp;</span> <span class="n">UDCCSR_TRN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep_vdbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;Clearing Underrun on, udccsr=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udccsr</span><span class="p">);</span>
			<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR_TRN</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">write_packet</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
		<span class="n">inc_ep_stats_bytes</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">);</span>
		<span class="n">totcount</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/* last packet is usually short (or a zlp) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">is_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">is_short</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">)</span>
					<span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">zero</span><span class="p">)</span>
				<span class="n">is_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">is_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* interrupt/iso maxpacket may not fill the fifo */</span>
			<span class="n">is_short</span> <span class="o">=</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_short</span><span class="p">)</span>
			<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR_SP</span><span class="p">);</span>

		<span class="cm">/* requests complete when all IN data is in the FIFO */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_last</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_full</span><span class="p">(</span><span class="n">ep</span><span class="p">));</span>

	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;wrote count:%d bytes%s%s, left:%d req=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">totcount</span><span class="p">,</span> <span class="n">is_last</span> <span class="o">?</span> <span class="s">&quot;/L&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">is_short</span> <span class="o">?</span> <span class="s">&quot;/S&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">completed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_ep0_fifo - Transfer packets from control endpoint into usb request</span>
<span class="cm"> * @ep: control endpoint</span>
<span class="cm"> * @req: pxa usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Special ep0 version of the above read_fifo. Reads as many bytes from control</span>
<span class="cm"> * endpoint as can be read, and stores them into usb request (limited by request</span>
<span class="cm"> * maximum length).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if usb request only partially filled, 1 if fully filled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_ep0_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">is_short</span><span class="p">,</span> <span class="n">completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">epout_has_pkt</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">read_packet</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_OPC</span><span class="p">);</span>
		<span class="n">inc_ep_stats_bytes</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">!</span><span class="n">USB_DIR_IN</span><span class="p">);</span>

		<span class="n">is_short</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span><span class="p">);</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;read udccsr:%03x, count:%d bytes%s req %p %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">),</span> <span class="n">count</span><span class="p">,</span> <span class="n">is_short</span> <span class="o">?</span> <span class="s">&quot;/S&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_short</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">&gt;=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">completed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_ep0_fifo - Send a request to control endpoint (ep0 in)</span>
<span class="cm"> * @ep: control endpoint</span>
<span class="cm"> * @req: request</span>
<span class="cm"> *</span>
<span class="cm"> * Context: callable when in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Sends a request (or a part of the request) to the control endpoint (ep0 in).</span>
<span class="cm"> * If the request doesn&#39;t fit, the remaining part will be sent from irq.</span>
<span class="cm"> * The request is considered fully written only if either :</span>
<span class="cm"> *   - last write transferred all remaining bytes, but fifo was not fully filled</span>
<span class="cm"> *   - last write was a 0 length write</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if request fully written, 0 if request only partially sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_ep0_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">is_last</span><span class="p">,</span> <span class="n">is_short</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">write_packet</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">EP0_FIFO_SIZE</span><span class="p">);</span>
	<span class="n">inc_ep_stats_bytes</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">);</span>

	<span class="n">is_short</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">EP0_FIFO_SIZE</span><span class="p">);</span>
	<span class="n">is_last</span> <span class="o">=</span> <span class="p">((</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">EP0_FIFO_SIZE</span><span class="p">));</span>

	<span class="cm">/* Sends either a short packet or a 0 length packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_short</span><span class="p">))</span>
		<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_IPR</span><span class="p">);</span>

	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;in %d bytes%s%s, %d left, req=%p, udccsr0=0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">count</span><span class="p">,</span> <span class="n">is_short</span> <span class="o">?</span> <span class="s">&quot;/S&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">is_last</span> <span class="o">?</span> <span class="s">&quot;/L&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">is_last</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_queue - Queue a request into an IN endpoint</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> * @_req: usb request</span>
<span class="cm"> * @gfp_flags: flags</span>
<span class="cm"> *</span>
<span class="cm"> * Context: normally called when !in_interrupt, but callable when in_interrupt()</span>
<span class="cm"> * in the special case of ep0 setup :</span>
<span class="cm"> *   (irq-&gt;handle_ep0_ctrl_req-&gt;gadget_setup-&gt;pxa_ep_queue)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if succedeed, error otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_ep_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">,</span>
			<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span>	<span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">is_first_req</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">recursion_detected</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">_req</span> <span class="o">||</span> <span class="o">!</span><span class="n">_req</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">||</span> <span class="o">!</span><span class="n">_req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;bogus device state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* iso is always one packet per request, that&#39;s the only way</span>
<span class="cm">	 * we can report per-packet status.  that also helps with dma.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">EPXFERTYPE_is_ISO</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">recursion_detected</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">in_handle_ep</span><span class="p">;</span>

	<span class="n">is_first_req</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;queue req %p(first=%s), len %d buf %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">_req</span><span class="p">,</span> <span class="n">is_first_req</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
			<span class="n">_req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">_req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_locked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;refusing to queue req %p (already queued)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_locked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">_req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="n">_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">_req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ep_add_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">WAIT_ACK_SET_CONF_INTERF</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ep_end_in_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;got a request of %d bytes while&quot;</span>
					<span class="s">&quot;in state WAIT_ACK_SET_CONF_INTERF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">length</span><span class="p">);</span>
				<span class="n">ep_del_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EL2HLT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ep0_idle</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IN_DATA_STAGE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_full</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">write_ep0_fifo</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">))</span>
					<span class="n">ep0_end_in_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">OUT_DATA_STAGE</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">epout_has_pkt</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">read_ep0_fifo</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">))</span>
					<span class="n">ep0_end_out_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;odd state %s to send me a request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">EP0_STNAME</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">ep_del_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EL2HLT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">recursion_detected</span><span class="p">)</span>
			<span class="n">handle_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out_locked:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_dequeue - Dequeue one request</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> * @_req: usb request</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if no error, -EINVAL or -ECONNRESET otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_ep_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span>	<span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span> <span class="o">||</span> <span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* make sure it&#39;s actually queued on this endpoint */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">==</span> <span class="n">_req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">req_done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_set_halt - Halts operations on one endpoint</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> * @value:</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if no error, -EINVAL, -EROFS, -EAGAIN otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_ep_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span>	<span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span> <span class="o">||</span> <span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This path (reset toggle+halt) is needed to implement</span>
<span class="cm">		 * SET_INTERFACE on normal hardware.  but it can&#39;t be</span>
<span class="cm">		 * done from software on the PXA UDC, and the hardware</span>
<span class="cm">		 * forgets to do it as part of SET_INTERFACE automagic.</span>
<span class="cm">		 */</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;only host can clear halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span>	<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ep_is_full</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* FST, FEF bits are the same for control and non control endpoints */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR_FST</span> <span class="o">|</span> <span class="n">UDCCSR_FEF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="n">set_ep0state</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">STALL</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_fifo_status - Get how many bytes in physical endpoint</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes in OUT fifos. Broken for IN fifos.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_ep_fifo_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span>	<span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span> <span class="o">||</span> <span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span> <span class="o">||</span> <span class="n">ep_is_empty</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">ep_count_bytes_remain</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_fifo_flush - Flushes one endpoint</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Discards all data in one endpoint(IN or OUT), except control endpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_ep_fifo_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span>	<span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span> <span class="o">||</span> <span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)))</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;called while queue list not empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* for OUT, just read and discard the FIFO contents. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_empty</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
			<span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCDR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* most IN status is the same, but ISO can&#39;t stall */</span>
		<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span>
				<span class="n">UDCCSR_PC</span> <span class="o">|</span> <span class="n">UDCCSR_FEF</span> <span class="o">|</span> <span class="n">UDCCSR_TRN</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">EPXFERTYPE_is_ISO</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">UDCCSR_SST</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_enable - Enables usb endpoint</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> * @desc: usb endpoint descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Nothing much to do here, as ep configuration is done once and for all</span>
<span class="cm"> * before udc is enabled. After udc enable, no physical endpoint configuration</span>
<span class="cm"> * can be changed.</span>
<span class="cm"> * Function makes sanity checks and flushes the endpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span>	<span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span>		<span class="o">*</span><span class="n">udc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">;</span>
		<span class="n">ep_warn</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;usb_ep %s already enabled, doing nothing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">_ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">find_pxa_ep</span><span class="p">(</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">udc_usb_ep</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span> <span class="o">||</span> <span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;unable to match pxa_ep for ep %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">_ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">usb_endpoint_type</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;type mismatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">&lt;</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;bad maxpacket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;bogus device state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* flush fifo (mostly for OUT buffers) */</span>
	<span class="n">pxa_ep_fifo_flush</span><span class="p">(</span><span class="n">_ep</span><span class="p">);</span>

	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_ep_disable - Disable usb endpoint</span>
<span class="cm"> * @_ep: usb endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Same as for pxa_ep_enable, no physical endpoint configuration can be</span>
<span class="cm"> * changed.</span>
<span class="cm"> * Function flushes the endpoint and related requests.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udc_usb_ep</span>	<span class="o">*</span><span class="n">udc_usb_ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udc_usb_ep</span><span class="p">,</span> <span class="n">usb_ep</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span> <span class="o">||</span> <span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>

	<span class="n">pxa_ep_fifo_flush</span><span class="p">(</span><span class="n">_ep</span><span class="p">);</span>
	<span class="n">udc_usb_ep</span><span class="o">-&gt;</span><span class="n">pxa_ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_ep_ops</span> <span class="n">pxa_ep_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">pxa_ep_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">pxa_ep_disable</span><span class="p">,</span>

	<span class="p">.</span><span class="n">alloc_request</span>	<span class="o">=</span> <span class="n">pxa_ep_alloc_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_request</span>	<span class="o">=</span> <span class="n">pxa_ep_free_request</span><span class="p">,</span>

	<span class="p">.</span><span class="n">queue</span>		<span class="o">=</span> <span class="n">pxa_ep_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue</span>	<span class="o">=</span> <span class="n">pxa_ep_dequeue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_halt</span>	<span class="o">=</span> <span class="n">pxa_ep_set_halt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_status</span>	<span class="o">=</span> <span class="n">pxa_ep_fifo_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_flush</span>	<span class="o">=</span> <span class="n">pxa_ep_fifo_flush</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * dplus_pullup - Connect or disconnect pullup resistor to D+ pin</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @on: 0 if disconnect pullup resistor, 1 otherwise</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * Handle D+ pullup resistor, make the device visible to the usb bus, and</span>
<span class="cm"> * declare it as a full speed usb device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dplus_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup</span><span class="p">))</span>
			<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup</span><span class="p">,</span>
				       <span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup_inverted</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">udc_command</span><span class="p">)</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">udc_command</span><span class="p">(</span><span class="n">PXA2XX_UDC_CMD_CONNECT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup</span><span class="p">))</span>
			<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup</span><span class="p">,</span>
				       <span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup_inverted</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">udc_command</span><span class="p">)</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">udc_command</span><span class="p">(</span><span class="n">PXA2XX_UDC_CMD_DISCONNECT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_on</span> <span class="o">=</span> <span class="n">on</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_get_frame - Returns usb frame number</span>
<span class="cm"> * @_gadget: usb gadget</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_udc_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">_gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_gadget_udc</span><span class="p">(</span><span class="n">_gadget</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCFNR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7ff</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_wakeup - Force udc device out of suspend</span>
<span class="cm"> * @_gadget: usb gadget</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_udc_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">_gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_gadget_udc</span><span class="p">(</span><span class="n">_gadget</span><span class="p">);</span>

	<span class="cm">/* host may not have enabled remote wakeup */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCR_DWRE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
	<span class="n">udc_set_mask_UDCCR</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR_UDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">udc_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">udc_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * should_enable_udc - Tells if UDC should be enabled</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * The UDC should be enabled if :</span>

<span class="cm"> *  - the pullup resistor is connected</span>
<span class="cm"> *  - and a gadget driver is bound</span>
<span class="cm"> *  - and vbus is sensed (or no vbus sense is available)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if UDC should be enabled, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">should_enable_udc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">put_on</span><span class="p">;</span>

	<span class="n">put_on</span> <span class="o">=</span> <span class="p">((</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_on</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">put_on</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_sensed</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">put_on</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * should_disable_udc - Tells if UDC should be disabled</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * The UDC should be disabled if :</span>
<span class="cm"> *  - the pullup resistor is not connected</span>
<span class="cm"> *  - or no gadget driver is bound</span>
<span class="cm"> *  - or no vbus is sensed (when vbus sesing is available)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if UDC should be disabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">should_disable_udc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">put_off</span><span class="p">;</span>

	<span class="n">put_off</span> <span class="o">=</span> <span class="p">((</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_on</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">put_off</span> <span class="o">|=</span> <span class="p">((</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_sensed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">put_off</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_pullup - Offer manual D+ pullup control</span>
<span class="cm"> * @_gadget: usb gadget using the control</span>
<span class="cm"> * @is_active: 0 if disconnect, else connect D+ pullup resistor</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if OK, -EOPNOTSUPP if udc driver doesn&#39;t handle D+ pullup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_udc_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">_gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_gadget_udc</span><span class="p">(</span><span class="n">_gadget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">udc_command</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">dplus_pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">is_active</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_enable_udc</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_disable_udc</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">udc_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">udc_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_vbus_session - Called by external transceiver to enable/disable udc</span>
<span class="cm"> * @_gadget: usb gadget</span>
<span class="cm"> * @is_active: 0 if should disable the udc, 1 if should enable</span>
<span class="cm"> *</span>
<span class="cm"> * Enables the udc, and optionnaly activates D+ pullup resistor. Or disables the</span>
<span class="cm"> * udc, and deactivates D+ pullup resistor.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_udc_vbus_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">_gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_gadget_udc</span><span class="p">(</span><span class="n">_gadget</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_sensed</span> <span class="o">=</span> <span class="n">is_active</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_enable_udc</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_disable_udc</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_vbus_draw - Called by gadget driver after SET_CONFIGURATION completed</span>
<span class="cm"> * @_gadget: usb gadget</span>
<span class="cm"> * @mA: current drawn</span>
<span class="cm"> *</span>
<span class="cm"> * Context: !in_interrupt()</span>
<span class="cm"> *</span>
<span class="cm"> * Called after a configuration was chosen by a USB host, to inform how much</span>
<span class="cm"> * current can be drawn by the device from VBus line.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or -EOPNOTSUPP if no transceiver is handling the udc</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_udc_vbus_draw</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">_gadget</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mA</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">to_gadget_udc</span><span class="p">(</span><span class="n">_gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">usb_phy_set_power</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">,</span> <span class="n">mA</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pxa27x_udc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">));</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pxa27x_udc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_gadget_ops</span> <span class="n">pxa_udc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_frame</span>	<span class="o">=</span> <span class="n">pxa_udc_get_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wakeup</span>		<span class="o">=</span> <span class="n">pxa_udc_wakeup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pullup</span>		<span class="o">=</span> <span class="n">pxa_udc_pullup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vbus_session</span>	<span class="o">=</span> <span class="n">pxa_udc_vbus_session</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vbus_draw</span>	<span class="o">=</span> <span class="n">pxa_udc_vbus_draw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">pxa27x_udc_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">pxa27x_udc_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * udc_disable - disable udc device controller</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * Disables the udc device : disables clocks, udc interrupts, control endpoint</span>
<span class="cm"> * interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">udc_clear_mask_UDCCR</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR_UDE</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">ep0_idle</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * udc_init_data - Initialize udc device data structures</span>
<span class="cm"> * @dev: udc device</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes gadget endpoint list, endpoints locks. No action is taken</span>
<span class="cm"> * on the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">udc_init_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* device/ep0 records init */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep_list</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udc_usb_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pxa_ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ep0_idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* PXA endpoints init */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_PXA_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">is_ep0</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* USB endpoints init */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_USB_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udc_usb_ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">usb_ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * udc_enable - Enables the udc device</span>
<span class="cm"> * @dev: udc device</span>
<span class="cm"> *</span>
<span class="cm"> * Enables the udc device : enables clocks, udc interrupts, control endpoint</span>
<span class="cm"> * interrupts, sets usb as UDC client and setups endpoints.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">udc_clear_mask_UDCCR</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR_UDE</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">ep0_idle</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">));</span>

	<span class="n">udc_set_mask_UDCCR</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR_UDE</span><span class="p">);</span>
	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">UDCCSR0_ACM</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCR_EMCE</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Configuration errors, udc disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Caller must be able to sleep in order to cope with startup transients</span>
<span class="cm">	 */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* enable suspend/resume and reset irqs */</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCICR1</span><span class="p">,</span>
			<span class="n">UDCICR1_IECC</span> <span class="o">|</span> <span class="n">UDCICR1_IERU</span>
			<span class="o">|</span> <span class="n">UDCICR1_IESU</span> <span class="o">|</span> <span class="n">UDCICR1_IERS</span><span class="p">);</span>

	<span class="cm">/* enable ep0 irqs */</span>
	<span class="n">pio_irq_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa27x_start - Register gadget driver</span>
<span class="cm"> * @driver: gadget driver</span>
<span class="cm"> * @bind: bind function</span>
<span class="cm"> *</span>
<span class="cm"> * When a driver is successfully registered, it will receive control requests</span>
<span class="cm"> * including set_configuration(), which enables non-control requests.  Then</span>
<span class="cm"> * usb traffic follows until a disconnect is reported.  Then a host may connect</span>
<span class="cm"> * again, or the driver might get unbound.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the udc is not automatically enabled. Check function</span>
<span class="cm"> * should_enable_udc().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if no error, -EINVAL, -ENODEV, -EBUSY otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa27x_udc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">max_speed</span> <span class="o">&lt;</span> <span class="n">USB_SPEED_FULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">bind</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* first hook up the driver ... */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">dplus_pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device_add error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">add_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bind to driver %s --&gt; error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bind_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;registered gadget driver &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">otg_set_peripheral</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t bind to transceiver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">transceiver_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_enable_udc</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">transceiver_fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
<span class="nl">bind_fail:</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">add_fail:</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * stop_activity - Stops udc endpoints</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @driver: gadget driver</span>
<span class="cm"> *</span>
<span class="cm"> * Disables all udc endpoints (even control endpoint), report disconnect to</span>
<span class="cm"> * the gadget user.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* don&#39;t disconnect drivers more than once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span>
		<span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_USB_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pxa_ep_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udc_usb_ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">usb_ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="p">)</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa27x_udc_stop - Unregister the gadget driver</span>
<span class="cm"> * @driver: gadget driver</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if no error, -ENODEV, -EINVAL otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa27x_udc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">the_controller</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="n">driver</span> <span class="o">!=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">dplus_pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unregistered gadget driver &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">otg_set_peripheral</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * handle_ep0_ctrl_req - handle control endpoint control request</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @req: control request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_ep0_ctrl_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pxa27x_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="n">r</span><span class="p">;</span>
		<span class="n">u32</span>			<span class="n">word</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have_extrabytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the PXA320 manual, in the section about Back-to-Back setup</span>
<span class="cm">	 * packets, it describes this situation.  The solution is to set OPC to</span>
<span class="cm">	 * get rid of the status packet, and then continue with the setup</span>
<span class="cm">	 * packet. Generalize to pxa27x CPUs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epout_has_pkt</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ep_count_bytes_remain</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_OPC</span><span class="p">);</span>

	<span class="cm">/* read SETUP packet */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ep_is_empty</span><span class="p">(</span><span class="n">ep</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">stall</span><span class="p">;</span>
		<span class="n">u</span><span class="p">.</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCDR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">have_extrabytes</span> <span class="o">=</span> <span class="o">!</span><span class="n">ep_is_empty</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_empty</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCDR</span><span class="p">);</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;wrong to have extra bytes for setup : 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;SETUP %02x.%02x v%04x i%04x l%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">bRequest</span><span class="p">,</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">wValue</span><span class="p">),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">wIndex</span><span class="p">),</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">wLength</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">have_extrabytes</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">stall</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
		<span class="n">set_ep0state</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">IN_DATA_STAGE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_ep0state</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">OUT_DATA_STAGE</span><span class="p">);</span>

	<span class="cm">/* Tell UDC to enter Data Stage */</span>
	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_SA</span> <span class="o">|</span> <span class="n">UDCCSR0_OPC</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">stall</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">stall:</span>
	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;protocol STALL, udccsr0=%03x err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_FST</span> <span class="o">|</span> <span class="n">UDCCSR0_FTF</span><span class="p">);</span>
	<span class="n">set_ep0state</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">STALL</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * handle_ep0 - Handle control endpoint data transfers</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @fifo_irq: 1 if triggered by fifo service type irq</span>
<span class="cm"> * @opc_irq: 1 if triggered by output packet complete type irq</span>
<span class="cm"> *</span>
<span class="cm"> * Context : when in_interrupt() or with ep-&gt;lock held</span>
<span class="cm"> *</span>
<span class="cm"> * Tries to transfer all pending request data into the endpoint and/or</span>
<span class="cm"> * transfer all pending data in the endpoint into usb requests.</span>
<span class="cm"> * Handles states of ep0 automata.</span>
<span class="cm"> *</span>
<span class="cm"> * PXA27x hardware handles several standard usb control requests without</span>
<span class="cm"> * driver notification.  The requests fully handled by hardware are :</span>
<span class="cm"> *  SET_ADDRESS, SET_FEATURE, CLEAR_FEATURE, GET_CONFIGURATION, GET_INTERFACE,</span>
<span class="cm"> *  GET_STATUS</span>
<span class="cm"> * The requests handled by hardware, but with irq notification are :</span>
<span class="cm"> *  SYNCH_FRAME, SET_CONFIGURATION, SET_INTERFACE</span>
<span class="cm"> * The remaining standard requests really handled by handle_ep0 are :</span>
<span class="cm"> *  GET_DESCRIPTOR, SET_DESCRIPTOR, specific requests.</span>
<span class="cm"> * Requests standardized outside of USB 2.0 chapter 9 are handled more</span>
<span class="cm"> * uniformly, by gadget drivers.</span>
<span class="cm"> *</span>
<span class="cm"> * The control endpoint state machine is _not_ USB spec compliant, it&#39;s even</span>
<span class="cm"> * hardly compliant with Intel PXA270 developers guide.</span>
<span class="cm"> * The key points which inferred this state machine are :</span>
<span class="cm"> *   - on every setup token, bit UDCCSR0_SA is raised and held until cleared by</span>
<span class="cm"> *     software.</span>
<span class="cm"> *   - on every OUT packet received, UDCCSR0_OPC is raised and held until</span>
<span class="cm"> *     cleared by software.</span>
<span class="cm"> *   - clearing UDCCSR0_OPC always flushes ep0. If in setup stage, never do it</span>
<span class="cm"> *     before reading ep0.</span>
<span class="cm"> *     This is true only for PXA27x. This is not true anymore for PXA3xx family</span>
<span class="cm"> *     (check Back-to-Back setup packet in developers guide).</span>
<span class="cm"> *   - irq can be called on a &quot;packet complete&quot; event (opc_irq=1), while</span>
<span class="cm"> *     UDCCSR0_OPC is not yet raised (delta can be as big as 100ms</span>
<span class="cm"> *     from experimentation).</span>
<span class="cm"> *   - as UDCCSR0_SA can be activated while in irq handling, and clearing</span>
<span class="cm"> *     UDCCSR0_OPC would flush the setup data, we almost never clear UDCCSR0_OPC</span>
<span class="cm"> *     =&gt; we never actually read the &quot;status stage&quot; packet of an IN data stage</span>
<span class="cm"> *     =&gt; this is not documented in Intel documentation</span>
<span class="cm"> *   - hardware as no idea of STATUS STAGE, it only handle SETUP STAGE and DATA</span>
<span class="cm"> *     STAGE. The driver add STATUS STAGE to send last zero length packet in</span>
<span class="cm"> *     OUT_STATUS_STAGE.</span>
<span class="cm"> *   - special attention was needed for IN_STATUS_STAGE. If a packet complete</span>
<span class="cm"> *     event is detected, we terminate the status stage without ackowledging the</span>
<span class="cm"> *     packet (not to risk to loose a potential SETUP packet)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_ep0</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo_irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opc_irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">udccsr0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span>		<span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa27x_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

	<span class="n">udccsr0</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">);</span>
	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;state=%s, req=%p, udccsr0=0x%03x, udcbcr=%d, irq_msk=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">EP0_STNAME</span><span class="p">(</span><span class="n">udc</span><span class="p">),</span> <span class="n">req</span><span class="p">,</span> <span class="n">udccsr0</span><span class="p">,</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCBCR</span><span class="p">),</span>
		<span class="p">(</span><span class="n">fifo_irq</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">opc_irq</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udccsr0</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_SST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;clearing stall status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">);</span>
		<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_SST</span><span class="p">);</span>
		<span class="n">ep0_idle</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udccsr0</span> <span class="o">&amp;</span> <span class="n">UDCCSR0_SA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">set_ep0state</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">SETUP_STAGE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WAIT_FOR_SETUP</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Hardware bug : beware, we cannot clear OPC, since we would</span>
<span class="cm">		 * miss a potential OPC irq for a setup packet.</span>
<span class="cm">		 * So, we only do ... nothing, and hope for a next irq with</span>
<span class="cm">		 * UDCCSR0_SA set.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SETUP_STAGE</span>:
		<span class="n">udccsr0</span> <span class="o">&amp;=</span> <span class="n">UDCCSR0_CTRL_REQ_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">udccsr0</span> <span class="o">==</span> <span class="n">UDCCSR0_CTRL_REQ_MASK</span><span class="p">))</span>
			<span class="n">handle_ep0_ctrl_req</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IN_DATA_STAGE</span>:			<span class="cm">/* GET_DESCRIPTOR */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">epout_has_pkt</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
			<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_OPC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_full</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="n">write_ep0_fifo</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">completed</span><span class="p">)</span>
			<span class="n">ep0_end_in_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OUT_DATA_STAGE</span>:			<span class="cm">/* SET_DESCRIPTOR */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">epout_has_pkt</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="p">)</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="n">read_ep0_fifo</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">completed</span><span class="p">)</span>
			<span class="n">ep0_end_out_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STALL</span>:
		<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_FST</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IN_STATUS_STAGE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Hardware bug : beware, we cannot clear OPC, since we would</span>
<span class="cm">		 * miss a potential PC irq for a setup packet.</span>
<span class="cm">		 * So, we only put the ep0 into WAIT_FOR_SETUP state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opc_irq</span><span class="p">)</span>
			<span class="n">ep0_idle</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OUT_STATUS_STAGE</span>:
	<span class="k">case</span> <span class="n">WAIT_ACK_SET_CONF_INTERF</span>:
		<span class="n">ep_warn</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;should never get in %s state here!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">EP0_STNAME</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="n">ep0_idle</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * handle_ep - Handle endpoint data tranfers</span>
<span class="cm"> * @ep: pxa physical endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Tries to transfer all pending request data into the endpoint and/or</span>
<span class="cm"> * transfer all pending data in the endpoint into usb requests.</span>
<span class="cm"> *</span>
<span class="cm"> * Is always called when in_interrupt() and with ep-&gt;lock released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa27x_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">completed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">udccsr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_in</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">in_handle_ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">recursion_detected</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">in_handle_ep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udccsr</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)))</span>
			<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pxa27x_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;req:%p, udccsr 0x%03x loop=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">req</span><span class="p">,</span> <span class="n">udccsr</span><span class="p">,</span> <span class="n">loop</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">udccsr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UDCCSR_SST</span> <span class="o">|</span> <span class="n">UDCCSR_TRN</span><span class="p">)))</span>
			<span class="n">udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">,</span>
					<span class="n">udccsr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UDCCSR_SST</span> <span class="o">|</span> <span class="n">UDCCSR_TRN</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_in</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ep_is_full</span><span class="p">(</span><span class="n">ep</span><span class="p">)))</span>
				<span class="n">completed</span> <span class="o">=</span> <span class="n">write_fifo</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">epout_has_pkt</span><span class="p">(</span><span class="n">ep</span><span class="p">)))</span>
				<span class="n">completed</span> <span class="o">=</span> <span class="n">read_fifo</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">completed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_in</span><span class="p">)</span>
				<span class="n">ep_end_in_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ep_end_out_req</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">completed</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">in_handle_ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">recursion_detected:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa27x_change_configuration - Handle SET_CONF usb request notification</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @config: usb configuration</span>
<span class="cm"> *</span>
<span class="cm"> * Post the request to upper level.</span>
<span class="cm"> * Don&#39;t use any pxa specific harware configuration capabilities</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa27x_change_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">req</span> <span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;config=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_interface</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_alternate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_SET_CONFIGURATION</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">wIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">wLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_ep0state</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">WAIT_ACK_SET_CONF_INTERF</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">UDCCSR0_AREN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa27x_change_interface - Handle SET_INTERF usb request notification</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> * @iface: interface number</span>
<span class="cm"> * @alt: alternate setting number</span>
<span class="cm"> *</span>
<span class="cm"> * Post the request to upper level.</span>
<span class="cm"> * Don&#39;t use any pxa specific harware configuration capabilities</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa27x_change_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iface</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>  <span class="n">req</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;interface=%d, alternate setting=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="n">alt</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_interface</span> <span class="o">=</span> <span class="n">iface</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_alternate</span> <span class="o">=</span> <span class="n">alt</span><span class="p">;</span>

	<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_SET_INTERFACE</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">alt</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">iface</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">wLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_ep0state</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">WAIT_ACK_SET_CONF_INTERF</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">UDCCSR0_AREN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * irq_handle_data - Handle data transfer</span>
<span class="cm"> * @irq: irq IRQ number</span>
<span class="cm"> * @udc: dev pxa_udc device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Called from irq handler, transferts data to or from endpoint to queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_handle_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">udcisr0</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCISR0_EP_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">udcisr1</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCISR1_EP_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udcisr0</span> <span class="o">&amp;</span> <span class="n">UDCISR_INT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR0</span><span class="p">,</span> <span class="n">UDCISR_INT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">UDCISR_INT_MASK</span><span class="p">));</span>
		<span class="n">handle_ep0</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">udcisr0</span> <span class="o">&amp;</span> <span class="n">UDCICR_FIFOERR</span><span class="p">),</span>
				<span class="o">!!</span><span class="p">(</span><span class="n">udcisr0</span> <span class="o">&amp;</span> <span class="n">UDCICR_PKTCOMPL</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">udcisr0</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">udcisr0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">udcisr0</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">udcisr0</span> <span class="o">&amp;</span> <span class="n">UDCISR_INT_MASK</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR0</span><span class="p">,</span> <span class="n">UDCISR_INT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">UDCISR_INT_MASK</span><span class="p">));</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">handle_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">udcisr1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">;</span> <span class="n">udcisr1</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">,</span> <span class="n">UDCISR_INT</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">16</span><span class="p">,</span> <span class="n">UDCISR_INT_MASK</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">udcisr1</span> <span class="o">&amp;</span> <span class="n">UDCISR_INT_MASK</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">handle_ep</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * irq_udc_suspend - Handle IRQ &quot;UDC Suspend&quot;</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_udc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">,</span> <span class="n">UDCISR1_IRSU</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_suspend</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_UNKNOWN</span>
			<span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">ep0_idle</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">  * irq_udc_resume - Handle IRQ &quot;UDC Resume&quot;</span>
<span class="cm">  * @udc: udc device</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_udc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">,</span> <span class="n">UDCISR1_IRRU</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_resume</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_UNKNOWN</span>
			<span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * irq_udc_reconfig - Handle IRQ &quot;UDC Change Configuration&quot;</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_udc_reconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">config</span><span class="p">,</span> <span class="n">interface</span><span class="p">,</span> <span class="n">alternate</span><span class="p">,</span> <span class="n">config_change</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">udccr</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>

	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">,</span> <span class="n">UDCISR1_IRCC</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_reconfig</span><span class="o">++</span><span class="p">;</span>

	<span class="n">config</span> <span class="o">=</span> <span class="p">(</span><span class="n">udccr</span> <span class="o">&amp;</span> <span class="n">UDCCR_ACN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDCCR_ACN_S</span><span class="p">;</span>
	<span class="n">config_change</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">!=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">);</span>
	<span class="n">pxa27x_change_configuration</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>

	<span class="n">interface</span> <span class="o">=</span> <span class="p">(</span><span class="n">udccr</span> <span class="o">&amp;</span> <span class="n">UDCCR_AIN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDCCR_AIN_S</span><span class="p">;</span>
	<span class="n">alternate</span> <span class="o">=</span> <span class="p">(</span><span class="n">udccr</span> <span class="o">&amp;</span> <span class="n">UDCCR_AAISN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UDCCR_AAISN_S</span><span class="p">;</span>
	<span class="n">pxa27x_change_interface</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">interface</span><span class="p">,</span> <span class="n">alternate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config_change</span><span class="p">)</span>
		<span class="n">update_pxa_ep_matches</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc_set_mask_UDCCR</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR_SMAC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * irq_udc_reset - Handle IRQ &quot;UDC Reset&quot;</span>
<span class="cm"> * @udc: udc device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_udc_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">udccr</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">udc_writel</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">,</span> <span class="n">UDCISR1_IRRS</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">irqs_reset</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">udccr</span> <span class="o">&amp;</span> <span class="n">UDCCR_UDA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB reset start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">);</span>

	<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">);</span>
	<span class="n">ep_write_UDCCSR</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR0_FTF</span> <span class="o">|</span> <span class="n">UDCCSR0_OPC</span><span class="p">);</span>
	<span class="n">ep0_idle</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_irq - Main irq handler</span>
<span class="cm"> * @irq: irq number</span>
<span class="cm"> * @_dev: udc device</span>
<span class="cm"> *</span>
<span class="cm"> * Handles all udc interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pxa_udc_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">_dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">udcisr0</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR0</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">udcisr1</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCISR1</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">udccr</span> <span class="o">=</span> <span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">udcisr1_spec</span><span class="p">;</span>

	<span class="n">dev_vdbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Interrupt, UDCISR0:0x%08x, UDCISR1:0x%08x, &quot;</span>
		 <span class="s">&quot;UDCCR:0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udcisr0</span><span class="p">,</span> <span class="n">udcisr1</span><span class="p">,</span> <span class="n">udccr</span><span class="p">);</span>

	<span class="n">udcisr1_spec</span> <span class="o">=</span> <span class="n">udcisr1</span> <span class="o">&amp;</span> <span class="mh">0xf8000000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">udcisr1_spec</span> <span class="o">&amp;</span> <span class="n">UDCISR1_IRSU</span><span class="p">))</span>
		<span class="n">irq_udc_suspend</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">udcisr1_spec</span> <span class="o">&amp;</span> <span class="n">UDCISR1_IRRU</span><span class="p">))</span>
		<span class="n">irq_udc_resume</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">udcisr1_spec</span> <span class="o">&amp;</span> <span class="n">UDCISR1_IRCC</span><span class="p">))</span>
		<span class="n">irq_udc_reconfig</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">udcisr1_spec</span> <span class="o">&amp;</span> <span class="n">UDCISR1_IRRS</span><span class="p">))</span>
		<span class="n">irq_udc_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">udcisr0</span> <span class="o">&amp;</span> <span class="n">UDCCISR0_EP_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">udcisr1</span> <span class="o">&amp;</span> <span class="n">UDCCISR1_EP_MASK</span><span class="p">))</span>
		<span class="n">irq_handle_data</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pxa_udc</span> <span class="n">memory</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">gadget</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pxa_udc_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ep0</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">memory</span><span class="p">.</span><span class="n">udc_usb_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">usb_ep</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">driver_name</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">init_name</span>	<span class="o">=</span> <span class="s">&quot;gadget&quot;</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>

	<span class="p">.</span><span class="n">udc_usb_ep</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">USB_EP_CTRL</span><span class="p">,</span>
		<span class="n">USB_EP_OUT_BULK</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="n">USB_EP_IN_BULK</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
		<span class="n">USB_EP_IN_ISO</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
		<span class="n">USB_EP_OUT_ISO</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="n">USB_EP_IN_INT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="p">},</span>

	<span class="p">.</span><span class="n">pxa_ep</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">PXA_EP_CTRL</span><span class="p">,</span>
		<span class="cm">/* Endpoints for gadget zero */</span>
		<span class="n">PXA_EP_OUT_BULK</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_BULK</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="cm">/* Endpoints for ether gadget, file storage gadget */</span>
		<span class="n">PXA_EP_OUT_BULK</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_BULK</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_ISO</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_OUT_ISO</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_INT</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span>   <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="cm">/* Endpoints for RNDIS, serial */</span>
		<span class="n">PXA_EP_OUT_BULK</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_BULK</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_INT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="cm">/*</span>
<span class="cm">		 * All the following endpoints are only for completion.  They</span>
<span class="cm">		 * won&#39;t never work, as multiple interfaces are really broken on</span>
<span class="cm">		 * the pxa.</span>
<span class="cm">		*/</span>
		<span class="n">PXA_EP_OUT_BULK</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_BULK</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="cm">/* Endpoint for CDC Ether */</span>
		<span class="n">PXA_EP_OUT_BULK</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">PXA_EP_IN_BULK</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_probe - probes the udc device</span>
<span class="cm"> * @_dev: platform device</span>
<span class="cm"> *</span>
<span class="cm"> * Perform basic init : allocates udc clock, creates sysfs files, requests</span>
<span class="cm"> * irq.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pxa_udc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memory</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gpio</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">usb_get_transceiver</span><span class="p">();</span>

	<span class="n">gpio</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="s">&quot;USB D+ pullup&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span>
				       <span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup_inverted</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t request gpio %d : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gpio</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to map UDC I/O memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_sensed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">the_controller</span> <span class="o">=</span> <span class="n">udc</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="n">udc_init_data</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">pxa_eps_setup</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="cm">/* irq setup after old hardware state is cleaned up */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pxa_udc_irq</span><span class="p">,</span>
			<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: can&#39;t get irq %i, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">driver_name</span><span class="p">,</span> <span class="n">IRQ_USB</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_add_udc</span><span class="p">;</span>

	<span class="n">pxa_init_debugfs</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_add_udc:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
<span class="nl">err_irq:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">err_map:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err_clk:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_remove - removes the udc device driver</span>
<span class="cm"> * @_dev: platform device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">pxa_udc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">mach</span><span class="o">-&gt;</span><span class="n">gpio_pullup</span><span class="p">;</span>

	<span class="n">usb_del_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">usb_gadget_unregister_driver</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="n">pxa_cleanup_debugfs</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>

	<span class="n">usb_put_transceiver</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">the_controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_udc_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc_readl</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UDCCR_UDE</span><span class="p">)</span>
		<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PXA27x</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pxa27x_clear_otgph</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define pxa27x_clear_otgph()   do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> * pxa_udc_suspend - Suspend udc device</span>
<span class="cm"> * @_dev: platform device</span>
<span class="cm"> * @state: suspend state</span>
<span class="cm"> *</span>
<span class="cm"> * Suspends udc : saves configuration registers (UDCCR*), then disables the udc</span>
<span class="cm"> * device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_udc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udccsr0</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_PXA_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccsr_value</span> <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccr_value</span>  <span class="o">=</span> <span class="n">udc_ep_readl</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">);</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;udccsr:0x%03x, udccr:0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccsr_value</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccr_value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_resume</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_on</span><span class="p">;</span>
	<span class="n">dplus_pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_udc_resume - Resume udc device</span>
<span class="cm"> * @_dev: platform device</span>
<span class="cm"> *</span>
<span class="cm"> * Resumes udc : restores configuration registers (UDCCR*), then enables the udc</span>
<span class="cm"> * device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_udc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udccsr0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UDCCSR0_FST</span> <span class="o">|</span> <span class="n">UDCCSR0_DME</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_PXA_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pxa_ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCSR</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccsr_value</span><span class="p">);</span>
		<span class="n">udc_ep_writel</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">UDCCR</span><span class="p">,</span>  <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccr_value</span><span class="p">);</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;udccsr:0x%03x, udccr:0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccsr_value</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udccr_value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dplus_pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_resume</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_enable_udc</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span>
		<span class="n">udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do not handle OTG yet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * OTGPH bit is set when sleep mode is entered.</span>
<span class="cm">	 * it indicates that OTG pad is retaining its state.</span>
<span class="cm">	 * Upon exit from sleep mode and before clearing OTGPH,</span>
<span class="cm">	 * Software must configure the USB OTG pad, UDC, and UHC</span>
<span class="cm">	 * to the state they were in before entering sleep mode.</span>
<span class="cm">	 */</span>
	<span class="n">pxa27x_clear_otgph</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* work with hotplug and coldplug */</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:pxa27x-udc&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">udc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;pxa27x-udc&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">pxa_udc_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">pxa_udc_shutdown</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">pxa_udc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">pxa_udc_resume</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">udc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_is_pxa27x</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_is_pxa3xx</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_driver</span><span class="p">,</span> <span class="n">pxa_udc_probe</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">udc_init</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">udc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">udc_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Robert Jarzmik&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
