<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › gadget › lpc32xx_udc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpc32xx_udc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * USB Gadget driver for LPC32xx</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *    Kevin Wells &lt;kevin.wells@nxp.com&gt;</span>
<span class="cm"> *    Mike James</span>
<span class="cm"> *    Roland Stigge &lt;stigge@antcom.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Philips Semiconductors</span>
<span class="cm"> * Copyright (C) 2009 NXP Semiconductors</span>
<span class="cm"> * Copyright (C) 2012 Roland Stigge</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This driver is based on original work done by Mike James for</span>
<span class="cm"> *       the LPC3180.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/usb/isp1301.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;mach/hardware.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/system.h&gt;</span>

<span class="cp">#include &lt;mach/platform.h&gt;</span>
<span class="cp">#include &lt;mach/irqs.h&gt;</span>
<span class="cp">#include &lt;mach/board.h&gt;</span>
<span class="cp">#ifdef CONFIG_USB_GADGET_DEBUG_FILES</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * USB device configuration structure</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">usc_chg_event</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">lpc32xx_usbd_cfg</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">vbus_drv_pol</span><span class="p">;</span>   <span class="cm">/* 0=active low drive for VBUS via ISP1301 */</span>
	<span class="n">usc_chg_event</span> <span class="n">conn_chgb</span><span class="p">;</span> <span class="cm">/* Connection change event (optional) */</span>
	<span class="n">usc_chg_event</span> <span class="n">susp_chgb</span><span class="p">;</span> <span class="cm">/* Suspend/resume event (optional) */</span>
	<span class="n">usc_chg_event</span> <span class="n">rmwk_chgb</span><span class="p">;</span> <span class="cm">/* Enable/disable remote wakeup */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * controller driver data structures</span>
<span class="cm"> */</span>

<span class="cm">/* 16 endpoints (not to be confused with 32 hardware endpoints) */</span>
<span class="cp">#define	NUM_ENDPOINTS	16</span>

<span class="cm">/*</span>
<span class="cm"> * IRQ indices make reading the code a little easier</span>
<span class="cm"> */</span>
<span class="cp">#define IRQ_USB_LP	0</span>
<span class="cp">#define IRQ_USB_HP	1</span>
<span class="cp">#define IRQ_USB_DEVDMA	2</span>
<span class="cp">#define IRQ_USB_ATX	3</span>

<span class="cp">#define EP_OUT 0 </span><span class="cm">/* RX (from host) */</span><span class="cp"></span>
<span class="cp">#define EP_IN 1 </span><span class="cm">/* TX (to host) */</span><span class="cp"></span>

<span class="cm">/* Returns the interrupt mask for the selected hardware endpoint */</span>
<span class="cp">#define EP_MASK_SEL(ep, dir) (1 &lt;&lt; (((ep) * 2) + dir))</span>

<span class="cp">#define EP_INT_TYPE 0</span>
<span class="cp">#define EP_ISO_TYPE 1</span>
<span class="cp">#define EP_BLK_TYPE 2</span>
<span class="cp">#define EP_CTL_TYPE 3</span>

<span class="cm">/* EP0 states */</span>
<span class="cp">#define WAIT_FOR_SETUP 0 </span><span class="cm">/* Wait for setup packet */</span><span class="cp"></span>
<span class="cp">#define DATA_IN        1 </span><span class="cm">/* Expect dev-&gt;host transfer */</span><span class="cp"></span>
<span class="cp">#define DATA_OUT       2 </span><span class="cm">/* Expect host-&gt;dev transfer */</span><span class="cp"></span>

<span class="cm">/* DD (DMA Descriptor) structure, requires word alignment, this is already</span>
<span class="cm"> * defined in the LPC32XX USB device header file, but this version is slightly</span>
<span class="cm"> * modified to tag some work data with each DMA descriptor. */</span>
<span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">dd_next_phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_setup</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_buffer_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_iso_ps_mem_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">this_dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iso_status</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="cm">/* 5 spare */</span>
	<span class="n">u32</span> <span class="n">dd_next_v</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Logical endpoint structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>		<span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span>	<span class="o">*</span><span class="n">udc</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">hwep_num_base</span><span class="p">;</span> <span class="cm">/* Physical hardware EP */</span>
	<span class="n">u32</span>			<span class="n">hwep_num</span><span class="p">;</span> <span class="cm">/* Maps to hardware endpoint */</span>
	<span class="n">u32</span>			<span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lep</span><span class="p">;</span>

	<span class="n">bool</span>			<span class="n">is_in</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">req_pending</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">eptype</span><span class="p">;</span>

	<span class="n">u32</span>                     <span class="n">totalints</span><span class="p">;</span>

	<span class="n">bool</span>			<span class="n">wedge</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Common UDC structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>	<span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">pde</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">isp1301_i2c_client</span><span class="p">;</span>

	<span class="cm">/* Board and device specific */</span>
	<span class="k">struct</span> <span class="n">lpc32xx_usbd_cfg</span>	<span class="o">*</span><span class="n">board</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">io_p_start</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">io_p_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">udp_baseaddr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">udp_irq</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">usb_pll_clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">usb_slv_clk</span><span class="p">;</span>

	<span class="cm">/* DMA support */</span>
	<span class="n">u32</span>			<span class="o">*</span><span class="n">udca_v_base</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">udca_p_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">dd_cache</span><span class="p">;</span>

	<span class="cm">/* Common EP and control data */</span>
	<span class="n">u32</span>			<span class="n">enabled_devints</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">enabled_hwepints</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">dev_status</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">realized_eps</span><span class="p">;</span>

	<span class="cm">/* VBUS detection, pullup, and power flags */</span>
	<span class="n">u8</span>			<span class="n">vbus</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">last_vbus</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pullup</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">poweron</span><span class="p">;</span>

	<span class="cm">/* Work queues related to I2C support */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">pullup_job</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">vbus_job</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">power_job</span><span class="p">;</span>

	<span class="cm">/* USB device peripheral - various */</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span>	<span class="n">ep</span><span class="p">[</span><span class="n">NUM_ENDPOINTS</span><span class="p">];</span>
	<span class="n">bool</span>			<span class="n">enabled</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">clocked</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">suspended</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">selfpowered</span><span class="p">;</span>
	<span class="kt">int</span>                     <span class="n">ep0state</span><span class="p">;</span>
	<span class="n">atomic_t</span>                <span class="n">enabled_ep_cnt</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>       <span class="n">ep_disable_wait_queue</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Endpoint request</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_request</span>	<span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span> <span class="o">*</span><span class="n">dd_desc_ptr</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">mapped</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">send_zlp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="nf">to_udc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_udc</span><span class="p">,</span> <span class="n">gadget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ep_dbg(epp, fmt, arg...) \</span>
<span class="cp">	dev_dbg(epp-&gt;udc-&gt;dev, &quot;%s: &quot; fmt, __func__, ## arg)</span>
<span class="cp">#define ep_err(epp, fmt, arg...) \</span>
<span class="cp">	dev_err(epp-&gt;udc-&gt;dev, &quot;%s: &quot; fmt, __func__, ## arg)</span>
<span class="cp">#define ep_info(epp, fmt, arg...) \</span>
<span class="cp">	dev_info(epp-&gt;udc-&gt;dev, &quot;%s: &quot; fmt, __func__, ## arg)</span>
<span class="cp">#define ep_warn(epp, fmt, arg...) \</span>
<span class="cp">	dev_warn(epp-&gt;udc-&gt;dev, &quot;%s:&quot; fmt, __func__, ## arg)</span>

<span class="cp">#define UDCA_BUFF_SIZE (128)</span>

<span class="cm">/* TODO: When the clock framework is introduced in LPC32xx, IO_ADDRESS will</span>
<span class="cm"> * be replaced with an inremap()ed pointer, see USB_OTG_CLK_CTRL()</span>
<span class="cm"> * */</span>
<span class="cp">#define USB_CTRL		IO_ADDRESS(LPC32XX_CLK_PM_BASE + 0x64)</span>
<span class="cp">#define USB_CLOCK_MASK		(AHB_M_CLOCK_ON | OTG_CLOCK_ON | \</span>
<span class="cp">				 DEV_CLOCK_ON | I2C_CLOCK_ON)</span>

<span class="cm">/* USB_CTRL bit defines */</span>
<span class="cp">#define USB_SLAVE_HCLK_EN	(1 &lt;&lt; 24)</span>
<span class="cp">#define USB_HOST_NEED_CLK_EN	(1 &lt;&lt; 21)</span>
<span class="cp">#define USB_DEV_NEED_CLK_EN	(1 &lt;&lt; 22)</span>

<span class="cp">#define USB_OTG_CLK_CTRL(udc)	((udc)-&gt;udp_baseaddr + 0xFF4)</span>
<span class="cp">#define USB_OTG_CLK_STAT(udc)	((udc)-&gt;udp_baseaddr + 0xFF8)</span>

<span class="cm">/* USB_OTG_CLK_CTRL bit defines */</span>
<span class="cp">#define AHB_M_CLOCK_ON		(1 &lt;&lt; 4)</span>
<span class="cp">#define OTG_CLOCK_ON		(1 &lt;&lt; 3)</span>
<span class="cp">#define I2C_CLOCK_ON		(1 &lt;&lt; 2)</span>
<span class="cp">#define DEV_CLOCK_ON		(1 &lt;&lt; 1)</span>
<span class="cp">#define HOST_CLOCK_ON		(1 &lt;&lt; 0)</span>

<span class="cp">#define USB_OTG_STAT_CONTROL(udc) (udc-&gt;udp_baseaddr + 0x110)</span>

<span class="cm">/* USB_OTG_STAT_CONTROL bit defines */</span>
<span class="cp">#define TRANSPARENT_I2C_EN	(1 &lt;&lt; 7)</span>
<span class="cp">#define HOST_EN			(1 &lt;&lt; 0)</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USB device controller register offsets</span>
<span class="cm"> **********************************************************************/</span>

<span class="cp">#define USBD_DEVINTST(x)	((x) + 0x200)</span>
<span class="cp">#define USBD_DEVINTEN(x)	((x) + 0x204)</span>
<span class="cp">#define USBD_DEVINTCLR(x)	((x) + 0x208)</span>
<span class="cp">#define USBD_DEVINTSET(x)	((x) + 0x20C)</span>
<span class="cp">#define USBD_CMDCODE(x)		((x) + 0x210)</span>
<span class="cp">#define USBD_CMDDATA(x)		((x) + 0x214)</span>
<span class="cp">#define USBD_RXDATA(x)		((x) + 0x218)</span>
<span class="cp">#define USBD_TXDATA(x)		((x) + 0x21C)</span>
<span class="cp">#define USBD_RXPLEN(x)		((x) + 0x220)</span>
<span class="cp">#define USBD_TXPLEN(x)		((x) + 0x224)</span>
<span class="cp">#define USBD_CTRL(x)		((x) + 0x228)</span>
<span class="cp">#define USBD_DEVINTPRI(x)	((x) + 0x22C)</span>
<span class="cp">#define USBD_EPINTST(x)		((x) + 0x230)</span>
<span class="cp">#define USBD_EPINTEN(x)		((x) + 0x234)</span>
<span class="cp">#define USBD_EPINTCLR(x)	((x) + 0x238)</span>
<span class="cp">#define USBD_EPINTSET(x)	((x) + 0x23C)</span>
<span class="cp">#define USBD_EPINTPRI(x)	((x) + 0x240)</span>
<span class="cp">#define USBD_REEP(x)		((x) + 0x244)</span>
<span class="cp">#define USBD_EPIND(x)		((x) + 0x248)</span>
<span class="cp">#define USBD_EPMAXPSIZE(x)	((x) + 0x24C)</span>
<span class="cm">/* DMA support registers only below */</span>
<span class="cm">/* Set, clear, or get enabled state of the DMA request status. If</span>
<span class="cm"> * enabled, an IN or OUT token will start a DMA transfer for the EP */</span>
<span class="cp">#define USBD_DMARST(x)		((x) + 0x250)</span>
<span class="cp">#define USBD_DMARCLR(x)		((x) + 0x254)</span>
<span class="cp">#define USBD_DMARSET(x)		((x) + 0x258)</span>
<span class="cm">/* DMA UDCA head pointer */</span>
<span class="cp">#define USBD_UDCAH(x)		((x) + 0x280)</span>
<span class="cm">/* EP DMA status, enable, and disable. This is used to specifically</span>
<span class="cm"> * enabled or disable DMA for a specific EP */</span>
<span class="cp">#define USBD_EPDMAST(x)		((x) + 0x284)</span>
<span class="cp">#define USBD_EPDMAEN(x)		((x) + 0x288)</span>
<span class="cp">#define USBD_EPDMADIS(x)	((x) + 0x28C)</span>
<span class="cm">/* DMA master interrupts enable and pending interrupts */</span>
<span class="cp">#define USBD_DMAINTST(x)	((x) + 0x290)</span>
<span class="cp">#define USBD_DMAINTEN(x)	((x) + 0x294)</span>
<span class="cm">/* DMA end of transfer interrupt enable, disable, status */</span>
<span class="cp">#define USBD_EOTINTST(x)	((x) + 0x2A0)</span>
<span class="cp">#define USBD_EOTINTCLR(x)	((x) + 0x2A4)</span>
<span class="cp">#define USBD_EOTINTSET(x)	((x) + 0x2A8)</span>
<span class="cm">/* New DD request interrupt enable, disable, status */</span>
<span class="cp">#define USBD_NDDRTINTST(x)	((x) + 0x2AC)</span>
<span class="cp">#define USBD_NDDRTINTCLR(x)	((x) + 0x2B0)</span>
<span class="cp">#define USBD_NDDRTINTSET(x)	((x) + 0x2B4)</span>
<span class="cm">/* DMA error interrupt enable, disable, status */</span>
<span class="cp">#define USBD_SYSERRTINTST(x)	((x) + 0x2B8)</span>
<span class="cp">#define USBD_SYSERRTINTCLR(x)	((x) + 0x2BC)</span>
<span class="cp">#define USBD_SYSERRTINTSET(x)	((x) + 0x2C0)</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USBD_DEVINTST/USBD_DEVINTEN/USBD_DEVINTCLR/USBD_DEVINTSET/</span>
<span class="cm"> * USBD_DEVINTPRI register definitions</span>
<span class="cm"> **********************************************************************/</span>
<span class="cp">#define USBD_ERR_INT		(1 &lt;&lt; 9)</span>
<span class="cp">#define USBD_EP_RLZED		(1 &lt;&lt; 8)</span>
<span class="cp">#define USBD_TXENDPKT		(1 &lt;&lt; 7)</span>
<span class="cp">#define USBD_RXENDPKT		(1 &lt;&lt; 6)</span>
<span class="cp">#define USBD_CDFULL		(1 &lt;&lt; 5)</span>
<span class="cp">#define USBD_CCEMPTY		(1 &lt;&lt; 4)</span>
<span class="cp">#define USBD_DEV_STAT		(1 &lt;&lt; 3)</span>
<span class="cp">#define USBD_EP_SLOW		(1 &lt;&lt; 2)</span>
<span class="cp">#define USBD_EP_FAST		(1 &lt;&lt; 1)</span>
<span class="cp">#define USBD_FRAME		(1 &lt;&lt; 0)</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USBD_EPINTST/USBD_EPINTEN/USBD_EPINTCLR/USBD_EPINTSET/</span>
<span class="cm"> * USBD_EPINTPRI register definitions</span>
<span class="cm"> **********************************************************************/</span>
<span class="cm">/* End point selection macro (RX) */</span>
<span class="cp">#define USBD_RX_EP_SEL(e)	(1 &lt;&lt; ((e) &lt;&lt; 1))</span>

<span class="cm">/* End point selection macro (TX) */</span>
<span class="cp">#define USBD_TX_EP_SEL(e)	(1 &lt;&lt; (((e) &lt;&lt; 1) + 1))</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USBD_REEP/USBD_DMARST/USBD_DMARCLR/USBD_DMARSET/USBD_EPDMAST/</span>
<span class="cm"> * USBD_EPDMAEN/USBD_EPDMADIS/</span>
<span class="cm"> * USBD_NDDRTINTST/USBD_NDDRTINTCLR/USBD_NDDRTINTSET/</span>
<span class="cm"> * USBD_EOTINTST/USBD_EOTINTCLR/USBD_EOTINTSET/</span>
<span class="cm"> * USBD_SYSERRTINTST/USBD_SYSERRTINTCLR/USBD_SYSERRTINTSET</span>
<span class="cm"> * register definitions</span>
<span class="cm"> **********************************************************************/</span>
<span class="cm">/* Endpoint selection macro */</span>
<span class="cp">#define USBD_EP_SEL(e)		(1 &lt;&lt; (e))</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * SBD_DMAINTST/USBD_DMAINTEN</span>
<span class="cm"> **********************************************************************/</span>
<span class="cp">#define USBD_SYS_ERR_INT	(1 &lt;&lt; 2)</span>
<span class="cp">#define USBD_NEW_DD_INT		(1 &lt;&lt; 1)</span>
<span class="cp">#define USBD_EOT_INT		(1 &lt;&lt; 0)</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USBD_RXPLEN register definitions</span>
<span class="cm"> **********************************************************************/</span>
<span class="cp">#define USBD_PKT_RDY		(1 &lt;&lt; 11)</span>
<span class="cp">#define USBD_DV			(1 &lt;&lt; 10)</span>
<span class="cp">#define USBD_PK_LEN_MASK	0x3FF</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USBD_CTRL register definitions</span>
<span class="cm"> **********************************************************************/</span>
<span class="cp">#define USBD_LOG_ENDPOINT(e)	((e) &lt;&lt; 2)</span>
<span class="cp">#define USBD_WR_EN		(1 &lt;&lt; 1)</span>
<span class="cp">#define USBD_RD_EN		(1 &lt;&lt; 0)</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USBD_CMDCODE register definitions</span>
<span class="cm"> **********************************************************************/</span>
<span class="cp">#define USBD_CMD_CODE(c)	((c) &lt;&lt; 16)</span>
<span class="cp">#define USBD_CMD_PHASE(p)	((p) &lt;&lt; 8)</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * USBD_DMARST/USBD_DMARCLR/USBD_DMARSET register definitions</span>
<span class="cm"> **********************************************************************/</span>
<span class="cp">#define USBD_DMAEP(e)		(1 &lt;&lt; (e))</span>

<span class="cm">/* DD (DMA Descriptor) structure, requires word alignment */</span>
<span class="k">struct</span> <span class="n">lpc32xx_usbd_dd</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dd_next</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_setup</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_buffer_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dd_iso_ps_mem_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* dd_setup bit defines */</span>
<span class="cp">#define DD_SETUP_ATLE_DMA_MODE	0x01</span>
<span class="cp">#define DD_SETUP_NEXT_DD_VALID	0x04</span>
<span class="cp">#define DD_SETUP_ISO_EP		0x10</span>
<span class="cp">#define DD_SETUP_PACKETLEN(n)	(((n) &amp; 0x7FF) &lt;&lt; 5)</span>
<span class="cp">#define DD_SETUP_DMALENBYTES(n)	(((n) &amp; 0xFFFF) &lt;&lt; 16)</span>

<span class="cm">/* dd_status bit defines */</span>
<span class="cp">#define DD_STATUS_DD_RETIRED	0x01</span>
<span class="cp">#define DD_STATUS_STS_MASK	0x1E</span>
<span class="cp">#define DD_STATUS_STS_NS	0x00 </span><span class="cm">/* Not serviced */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_STS_BS	0x02 </span><span class="cm">/* Being serviced */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_STS_NC	0x04 </span><span class="cm">/* Normal completion */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_STS_DUR	0x06 </span><span class="cm">/* Data underrun (short packet) */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_STS_DOR	0x08 </span><span class="cm">/* Data overrun */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_STS_SE	0x12 </span><span class="cm">/* System error */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_PKT_VAL	0x20 </span><span class="cm">/* Packet valid */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_LSB_EX	0x40 </span><span class="cm">/* LS byte extracted (ATLE) */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_MSB_EX	0x80 </span><span class="cm">/* MS byte extracted (ATLE) */</span><span class="cp"></span>
<span class="cp">#define DD_STATUS_MLEN(n)	(((n) &gt;&gt; 8) &amp; 0x3F)</span>
<span class="cp">#define DD_STATUS_CURDMACNT(n)	(((n) &gt;&gt; 16) &amp; 0xFFFF)</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Protocol engine bits below</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Device Interrupt Bit Definitions */</span>
<span class="cp">#define FRAME_INT		0x00000001</span>
<span class="cp">#define EP_FAST_INT		0x00000002</span>
<span class="cp">#define EP_SLOW_INT		0x00000004</span>
<span class="cp">#define DEV_STAT_INT		0x00000008</span>
<span class="cp">#define CCEMTY_INT		0x00000010</span>
<span class="cp">#define CDFULL_INT		0x00000020</span>
<span class="cp">#define RxENDPKT_INT		0x00000040</span>
<span class="cp">#define TxENDPKT_INT		0x00000080</span>
<span class="cp">#define EP_RLZED_INT		0x00000100</span>
<span class="cp">#define ERR_INT			0x00000200</span>

<span class="cm">/* Rx &amp; Tx Packet Length Definitions */</span>
<span class="cp">#define PKT_LNGTH_MASK		0x000003FF</span>
<span class="cp">#define PKT_DV			0x00000400</span>
<span class="cp">#define PKT_RDY			0x00000800</span>

<span class="cm">/* USB Control Definitions */</span>
<span class="cp">#define CTRL_RD_EN		0x00000001</span>
<span class="cp">#define CTRL_WR_EN		0x00000002</span>

<span class="cm">/* Command Codes */</span>
<span class="cp">#define CMD_SET_ADDR		0x00D00500</span>
<span class="cp">#define CMD_CFG_DEV		0x00D80500</span>
<span class="cp">#define CMD_SET_MODE		0x00F30500</span>
<span class="cp">#define CMD_RD_FRAME		0x00F50500</span>
<span class="cp">#define DAT_RD_FRAME		0x00F50200</span>
<span class="cp">#define CMD_RD_TEST		0x00FD0500</span>
<span class="cp">#define DAT_RD_TEST		0x00FD0200</span>
<span class="cp">#define CMD_SET_DEV_STAT	0x00FE0500</span>
<span class="cp">#define CMD_GET_DEV_STAT	0x00FE0500</span>
<span class="cp">#define DAT_GET_DEV_STAT	0x00FE0200</span>
<span class="cp">#define CMD_GET_ERR_CODE	0x00FF0500</span>
<span class="cp">#define DAT_GET_ERR_CODE	0x00FF0200</span>
<span class="cp">#define CMD_RD_ERR_STAT		0x00FB0500</span>
<span class="cp">#define DAT_RD_ERR_STAT		0x00FB0200</span>
<span class="cp">#define DAT_WR_BYTE(x)		(0x00000100 | ((x) &lt;&lt; 16))</span>
<span class="cp">#define CMD_SEL_EP(x)		(0x00000500 | ((x) &lt;&lt; 16))</span>
<span class="cp">#define DAT_SEL_EP(x)		(0x00000200 | ((x) &lt;&lt; 16))</span>
<span class="cp">#define CMD_SEL_EP_CLRI(x)	(0x00400500 | ((x) &lt;&lt; 16))</span>
<span class="cp">#define DAT_SEL_EP_CLRI(x)	(0x00400200 | ((x) &lt;&lt; 16))</span>
<span class="cp">#define CMD_SET_EP_STAT(x)	(0x00400500 | ((x) &lt;&lt; 16))</span>
<span class="cp">#define CMD_CLR_BUF		0x00F20500</span>
<span class="cp">#define DAT_CLR_BUF		0x00F20200</span>
<span class="cp">#define CMD_VALID_BUF		0x00FA0500</span>

<span class="cm">/* Device Address Register Definitions */</span>
<span class="cp">#define DEV_ADDR_MASK		0x7F</span>
<span class="cp">#define DEV_EN			0x80</span>

<span class="cm">/* Device Configure Register Definitions */</span>
<span class="cp">#define CONF_DVICE		0x01</span>

<span class="cm">/* Device Mode Register Definitions */</span>
<span class="cp">#define AP_CLK			0x01</span>
<span class="cp">#define INAK_CI			0x02</span>
<span class="cp">#define INAK_CO			0x04</span>
<span class="cp">#define INAK_II			0x08</span>
<span class="cp">#define INAK_IO			0x10</span>
<span class="cp">#define INAK_BI			0x20</span>
<span class="cp">#define INAK_BO			0x40</span>

<span class="cm">/* Device Status Register Definitions */</span>
<span class="cp">#define DEV_CON			0x01</span>
<span class="cp">#define DEV_CON_CH		0x02</span>
<span class="cp">#define DEV_SUS			0x04</span>
<span class="cp">#define DEV_SUS_CH		0x08</span>
<span class="cp">#define DEV_RST			0x10</span>

<span class="cm">/* Error Code Register Definitions */</span>
<span class="cp">#define ERR_EC_MASK		0x0F</span>
<span class="cp">#define ERR_EA			0x10</span>

<span class="cm">/* Error Status Register Definitions */</span>
<span class="cp">#define ERR_PID			0x01</span>
<span class="cp">#define ERR_UEPKT		0x02</span>
<span class="cp">#define ERR_DCRC		0x04</span>
<span class="cp">#define ERR_TIMOUT		0x08</span>
<span class="cp">#define ERR_EOP			0x10</span>
<span class="cp">#define ERR_B_OVRN		0x20</span>
<span class="cp">#define ERR_BTSTF		0x40</span>
<span class="cp">#define ERR_TGL			0x80</span>

<span class="cm">/* Endpoint Select Register Definitions */</span>
<span class="cp">#define EP_SEL_F		0x01</span>
<span class="cp">#define EP_SEL_ST		0x02</span>
<span class="cp">#define EP_SEL_STP		0x04</span>
<span class="cp">#define EP_SEL_PO		0x08</span>
<span class="cp">#define EP_SEL_EPN		0x10</span>
<span class="cp">#define EP_SEL_B_1_FULL		0x20</span>
<span class="cp">#define EP_SEL_B_2_FULL		0x40</span>

<span class="cm">/* Endpoint Status Register Definitions */</span>
<span class="cp">#define EP_STAT_ST		0x01</span>
<span class="cp">#define EP_STAT_DA		0x20</span>
<span class="cp">#define EP_STAT_RF_MO		0x40</span>
<span class="cp">#define EP_STAT_CND_ST		0x80</span>

<span class="cm">/* Clear Buffer Register Definitions */</span>
<span class="cp">#define CLR_BUF_PO		0x01</span>

<span class="cm">/* DMA Interrupt Bit Definitions */</span>
<span class="cp">#define EOT_INT			0x01</span>
<span class="cp">#define NDD_REQ_INT		0x02</span>
<span class="cp">#define SYS_ERR_INT		0x04</span>

<span class="cp">#define	DRIVER_VERSION	&quot;1.03&quot;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;lpc32xx_udc&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * proc interface support</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_USB_GADGET_DEBUG_FILES</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">epnames</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;INT&quot;</span><span class="p">,</span> <span class="s">&quot;ISO&quot;</span><span class="p">,</span> <span class="s">&quot;BULK&quot;</span><span class="p">,</span> <span class="s">&quot;CTRL&quot;</span><span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">debug_filename</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;driver/udc&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">proc_ep_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%12s, maxpacket %4d %3s&quot;</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; type %4s&quot;</span><span class="p">,</span> <span class="n">epnames</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">eptype</span><span class="p">]);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; ints: %12d&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">totalints</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">(queue empty)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">length</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">;</span>

			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">req %p len %d/%d buf %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
				   <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_udc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s: version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vbus %s, pullup %s, %s powered%s, gadget %s</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">?</span> <span class="s">&quot;present&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">,</span>
		   <span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">?</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">?</span> <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;enabled&quot;</span><span class="p">)</span> <span class="o">:</span>
		   <span class="s">&quot;disabled&quot;</span><span class="p">,</span>
		   <span class="n">udc</span><span class="o">-&gt;</span><span class="n">selfpowered</span> <span class="o">?</span> <span class="s">&quot;self&quot;</span> <span class="o">:</span> <span class="s">&quot;VBUS&quot;</span><span class="p">,</span>
		   <span class="n">udc</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">?</span> <span class="s">&quot;, suspended&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		   <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;(none)&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_ep_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
				<span class="n">proc_ep_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_udc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">proc_udc_show</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_udc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pde</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">debug_filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">udc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">create_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cm">/* Primary initialization sequence for the ISP1301 transceiver */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1301_udc_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* LPC32XX only supports DAT_SE0 USB mode */</span>
	<span class="cm">/* This sequence is important */</span>

	<span class="cm">/* Disable transparent UART mode first */</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="p">(</span><span class="n">ISP1301_I2C_MODE_CONTROL_1</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">),</span>
		<span class="n">MC1_UART_EN</span><span class="p">);</span>

	<span class="cm">/* Set full speed and SE0 mode */</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="p">(</span><span class="n">ISP1301_I2C_MODE_CONTROL_1</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_MODE_CONTROL_1</span><span class="p">,</span> <span class="p">(</span><span class="n">MC1_SPEED_REG</span> <span class="o">|</span> <span class="n">MC1_DAT_SE0</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The PSW_OE enable bit state is reversed in the ISP1301 User&#39;s Guide</span>
<span class="cm">	 */</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="p">(</span><span class="n">ISP1301_I2C_MODE_CONTROL_2</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_MODE_CONTROL_2</span><span class="p">,</span> <span class="p">(</span><span class="n">MC2_BI_DI</span> <span class="o">|</span> <span class="n">MC2_SPD_SUSP_CTRL</span><span class="p">));</span>

	<span class="cm">/* Driver VBUS_DRV high or low depending on board setup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">vbus_drv_pol</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_OTG_CONTROL_1</span><span class="p">,</span> <span class="n">OTG1_VBUS_DRV</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_OTG_CONTROL_1</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span>
			<span class="n">OTG1_VBUS_DRV</span><span class="p">);</span>

	<span class="cm">/* Bi-directional mode with suspend control</span>
<span class="cm">	 * Enable both pulldowns for now - the pullup will be enable when VBUS</span>
<span class="cm">	 * is detected */</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="p">(</span><span class="n">ISP1301_I2C_OTG_CONTROL_1</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_OTG_CONTROL_1</span><span class="p">,</span>
		<span class="p">(</span><span class="mi">0</span> <span class="o">|</span> <span class="n">OTG1_DM_PULLDOWN</span> <span class="o">|</span> <span class="n">OTG1_DP_PULLDOWN</span><span class="p">));</span>

	<span class="cm">/* Discharge VBUS (just in case) */</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_OTG_CONTROL_1</span><span class="p">,</span> <span class="n">OTG1_VBUS_DISCHRG</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="p">(</span><span class="n">ISP1301_I2C_OTG_CONTROL_1</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">),</span>
		<span class="n">OTG1_VBUS_DISCHRG</span><span class="p">);</span>

	<span class="cm">/* Clear and enable VBUS high edge interrupt */</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_INTERRUPT_LATCH</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_INTERRUPT_FALLING</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_INTERRUPT_FALLING</span><span class="p">,</span> <span class="n">INT_VBUS_VLD</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_INTERRUPT_RISING</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
		<span class="n">ISP1301_I2C_INTERRUPT_RISING</span><span class="p">,</span> <span class="n">INT_VBUS_VLD</span><span class="p">);</span>

	<span class="cm">/* Enable usb_need_clk clock after transceiver is initialized */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_CTRL</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">)),</span> <span class="n">USB_CTRL</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ISP1301 Vendor ID  : 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">i2c_smbus_read_word_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ISP1301 Product ID : 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">i2c_smbus_read_word_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ISP1301 Version ID : 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">i2c_smbus_read_word_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Enables or disables the USB device pullup via the ISP1301 transceiver */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1301_pullup_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">)</span>
		<span class="cm">/* Enable pullup for bus signalling */</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_OTG_CONTROL_1</span><span class="p">,</span> <span class="n">OTG1_DP_PULLUP</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* Enable pullup for bus signalling */</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_OTG_CONTROL_1</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span>
			<span class="n">OTG1_DP_PULLUP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pullup_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_udc</span><span class="p">,</span> <span class="n">pullup_job</span><span class="p">);</span>

	<span class="n">isp1301_pullup_set</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1301_pullup_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">en_pullup</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">en_pullup</span> <span class="o">==</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup</span> <span class="o">=</span> <span class="n">en_pullup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
		<span class="n">isp1301_pullup_set</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* defer slow i2c pull up setting */</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_job</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/* Powers up or down the ISP1301 transceiver */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1301_set_powerstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Power up ISP1301 - this ISP1301 will automatically wakeup</span>
<span class="cm">		   when VBUS is detected */</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_MODE_CONTROL_2</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span>
			<span class="n">MC2_GLOBAL_PWR_DN</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* Power down ISP1301 */</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_MODE_CONTROL_2</span><span class="p">,</span> <span class="n">MC2_GLOBAL_PWR_DN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_udc</span><span class="p">,</span> <span class="n">power_job</span><span class="p">);</span>

	<span class="n">isp1301_set_powerstate</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">poweron</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * USB protocol engine command/data read/write helper functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Issues a single command to the USB device state machine */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_protocol_cmd_w</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to</span><span class="p">;</span>

	<span class="cm">/* EP may lock on CLRI if this read isn&#39;t done */</span>
	<span class="n">u32</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_DEVINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pass</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">USBD_CCEMPTY</span><span class="p">,</span> <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

		<span class="cm">/* Write command code */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">USBD_CMDCODE</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="n">to</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">USBD_DEVINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">))</span> <span class="o">&amp;</span>
			 <span class="n">USBD_CCEMPTY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">to</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Issues 2 commands (or command and data) to the USB device state machine */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd</span><span class="p">,</span>
					   <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Issues a single command to the USB device state machine and reads</span>
<span class="cm"> * response data */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">udc_protocol_cmd_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="cm">/* Write a command and read data from the protocol engine */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">USBD_CDFULL</span> <span class="o">|</span> <span class="n">USBD_CCEMPTY</span><span class="p">),</span>
		     <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Write command code */</span>
	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_DEVINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USBD_DEVINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">USBD_CDFULL</span><span class="p">))</span>
	       <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">to</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Protocol engine didn&#39;t receive response (CDFULL)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_CMDDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * USB device interrupt mask support functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Enable one or more USB device interrupts */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uda_enable_devint</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">devmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_devints</span> <span class="o">|=</span> <span class="n">devmask</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_devints</span><span class="p">,</span> <span class="n">USBD_DEVINTEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Disable one or more USB device interrupts */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uda_disable_devint</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_devints</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_devints</span><span class="p">,</span> <span class="n">USBD_DEVINTEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Clear one or more USB device interrupts */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uda_clear_devint</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Endpoint interrupt disable/enable functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Enable one or more USB endpoint interrupts */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uda_enable_hwepint</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_hwepints</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_hwepints</span><span class="p">,</span> <span class="n">USBD_EPINTEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Disable one or more USB endpoint interrupts */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uda_disable_hwepint</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_hwepints</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_hwepints</span><span class="p">,</span> <span class="n">USBD_EPINTEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Clear one or more USB endpoint interrupts */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uda_clear_hwepint</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwep</span><span class="p">),</span> <span class="n">USBD_EPINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Enable DMA for the HW channel */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">udc_ep_dma_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwep</span><span class="p">),</span> <span class="n">USBD_EPDMAEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Disable DMA for the HW channel */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">udc_ep_dma_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwep</span><span class="p">),</span> <span class="n">USBD_EPDMADIS</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Endpoint realize/unrealize functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Before an endpoint can be used, it needs to be realized</span>
<span class="cm"> * in the USB protocol engine - this realizes the endpoint.</span>
<span class="cm"> * The interrupt (FIFO or DMA) is not enabled with this function */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_realize_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">maxpacket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">USBD_EP_RLZED</span><span class="p">,</span> <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hwep</span><span class="p">,</span> <span class="n">USBD_EPIND</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">realized_eps</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">realized_eps</span><span class="p">,</span> <span class="n">USBD_REEP</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">maxpacket</span><span class="p">,</span> <span class="n">USBD_EPMAXPSIZE</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Wait until endpoint is realized in hardware */</span>
	<span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USBD_DEVINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">))</span> <span class="o">&amp;</span>
		  <span class="n">USBD_EP_RLZED</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">to</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;EP not correctly realized in hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">USBD_EP_RLZED</span><span class="p">,</span> <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Unrealize an EP */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_unrealize_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">realized_eps</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">realized_eps</span><span class="p">,</span> <span class="n">USBD_REEP</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Endpoint support functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Select and clear endpoint interrupt */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">udc_selep_clrint</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SEL_EP_CLRI</span><span class="p">(</span><span class="n">hwep</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">udc_protocol_cmd_r</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">DAT_SEL_EP_CLRI</span><span class="p">(</span><span class="n">hwep</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Disables the endpoint in the USB protocol engine */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_disable_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_EP_STAT</span><span class="p">(</span><span class="n">hwep</span><span class="p">),</span>
				<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">EP_STAT_DA</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Stalls the endpoint - endpoint will return STALL */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_stall_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_EP_STAT</span><span class="p">(</span><span class="n">hwep</span><span class="p">),</span>
				<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">EP_STAT_ST</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Clear stall or reset endpoint */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_clrstall_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_EP_STAT</span><span class="p">(</span><span class="n">hwep</span><span class="p">),</span>
				<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Select an endpoint for endpoint status, clear, validate */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_select_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SEL_EP</span><span class="p">(</span><span class="n">hwep</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Endpoint buffer management functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Clear the current endpoint&#39;s buffer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_clr_buffer_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_select_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_CLR_BUF</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Validate the current endpoint&#39;s buffer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_val_buffer_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_select_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_VALID_BUF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">udc_clearep_getsts</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear EP interrupt */</span>
	<span class="n">uda_clear_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">udc_selep_clrint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * USB EP DMA support</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Allocate a DMA Descriptor */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span> <span class="o">*</span><span class="nf">udc_dd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span>			<span class="n">dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span>	<span class="o">*</span><span class="n">dd</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span> <span class="o">*</span><span class="p">)</span> <span class="n">dma_pool_alloc</span><span class="p">(</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dd_cache</span><span class="p">,</span> <span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">this_dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free a DMA Descriptor */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_dd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dd_cache</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">this_dma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * USB setup and shutdown functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Enables or disables most of the USB system clocks when low power mode is</span>
<span class="cm"> * needed. Clocks are typically started on a connection event, and disabled</span>
<span class="cm"> * when a cable is disconnected */</span>
<span class="cp">#define OTGOFF_CLK_MASK (AHB_M_CLOCK_ON | I2C_CLOCK_ON)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_clk_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* 48MHz PLL up */</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>

		<span class="cm">/* Enable the USB device clock */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_CTRL</span><span class="p">)</span> <span class="o">|</span> <span class="n">USB_DEV_NEED_CLK_EN</span><span class="p">,</span>
			     <span class="n">USB_CTRL</span><span class="p">);</span>

		<span class="cm">/* Set to enable all needed USB OTG clocks */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">USB_CLOCK_MASK</span><span class="p">,</span> <span class="n">USB_OTG_CLK_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="p">));</span>

		<span class="k">while</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_OTG_CLK_STAT</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">USB_CLOCK_MASK</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">USB_CLOCK_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">to</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot enable USB OTG clocking</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Never disable the USB_HCLK during normal operation */</span>

		<span class="cm">/* 48MHz PLL dpwn */</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>

		<span class="cm">/* Enable the USB device clock */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_DEV_NEED_CLK_EN</span><span class="p">,</span>
			     <span class="n">USB_CTRL</span><span class="p">);</span>

		<span class="cm">/* Set to enable all needed USB OTG clocks */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">OTGOFF_CLK_MASK</span><span class="p">,</span> <span class="n">USB_OTG_CLK_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="p">));</span>

		<span class="k">while</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_OTG_CLK_STAT</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span> <span class="o">&amp;</span>
			 <span class="n">OTGOFF_CLK_MASK</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">OTGOFF_CLK_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">to</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot disable USB OTG clocking</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Set/reset USB device address */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_set_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Address will be latched at the end of the status phase, or</span>
<span class="cm">	   latched immediately if function is called twice */</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_ADDR</span><span class="p">,</span>
				<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">DEV_EN</span> <span class="o">|</span> <span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Setup up a IN request for DMA transfer - this consists of determining the</span>
<span class="cm"> * list of DMA addresses for the transfer, allocating DMA Descriptors,</span>
<span class="cm"> * installing the DD into the UDCA, and then enabling the DMA for that EP */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">udc_ep_in_req_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hwep</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* There will always be a request waiting here */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* Place the DD Descriptor into the UDCA */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">[</span><span class="n">hwep</span><span class="p">]</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_desc_ptr</span><span class="o">-&gt;</span><span class="n">this_dma</span><span class="p">;</span>

	<span class="cm">/* Enable DMA and interrupt for the HW EP */</span>
	<span class="n">udc_ep_dma_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>

	<span class="cm">/* Clear ZLP if last packet is not of MAXP size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">%</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">send_zlp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup up a OUT request for DMA transfer - this consists of determining the</span>
<span class="cm"> * list of DMA addresses for the transfer, allocating DMA Descriptors,</span>
<span class="cm"> * installing the DD into the UDCA, and then enabling the DMA for that EP */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">udc_ep_out_req_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hwep</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* There will always be a request waiting here */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* Place the DD Descriptor into the UDCA */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">[</span><span class="n">hwep</span><span class="p">]</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_desc_ptr</span><span class="o">-&gt;</span><span class="n">this_dma</span><span class="p">;</span>

	<span class="cm">/* Enable DMA and interrupt for the HW EP */</span>
	<span class="n">udc_ep_dma_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Disable device */</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_CFG_DEV</span><span class="p">,</span> <span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_DEV_STAT</span><span class="p">,</span> <span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="cm">/* Disable all device interrupts (including EP0) */</span>
	<span class="n">uda_disable_devint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mh">0x3FF</span><span class="p">);</span>

	<span class="cm">/* Disable and reset all endpoint interrupts */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uda_disable_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">uda_clear_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">udc_disable_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">udc_unrealize_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Disable and clear all interrupts and DMA */</span>
		<span class="n">udc_ep_dma_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">),</span> <span class="n">USBD_EOTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">),</span> <span class="n">USBD_NDDRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">),</span> <span class="n">USBD_SYSERRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">),</span> <span class="n">USBD_DMARCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Disable DMA interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBD_DMAINTEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBD_UDCAH</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Start with known state */</span>
	<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="cm">/* Enable device */</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_DEV_STAT</span><span class="p">,</span> <span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">DEV_CON</span><span class="p">));</span>

	<span class="cm">/* EP interrupts on high priority, FRAME interrupt on low priority */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">USBD_EP_FAST</span><span class="p">,</span> <span class="n">USBD_DEVINTPRI</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFF</span><span class="p">,</span> <span class="n">USBD_EPINTPRI</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Clear any pending device interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x3FF</span><span class="p">,</span> <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Setup UDCA - not yet used (DMA) */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_p_base</span><span class="p">,</span> <span class="n">USBD_UDCAH</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Only enable EP0 in and out for now, EP0 only works in FIFO mode */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_realize_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">);</span>
		<span class="n">uda_enable_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">udc_select_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">udc_clrstall_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">udc_clr_buffer_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Device interrupt setup */</span>
	<span class="n">uda_clear_devint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="p">(</span><span class="n">USBD_ERR_INT</span> <span class="o">|</span> <span class="n">USBD_DEV_STAT</span> <span class="o">|</span> <span class="n">USBD_EP_SLOW</span> <span class="o">|</span>
			       <span class="n">USBD_EP_FAST</span><span class="p">));</span>
	<span class="n">uda_enable_devint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="p">(</span><span class="n">USBD_ERR_INT</span> <span class="o">|</span> <span class="n">USBD_DEV_STAT</span> <span class="o">|</span> <span class="n">USBD_EP_SLOW</span> <span class="o">|</span>
				<span class="n">USBD_EP_FAST</span><span class="p">));</span>

	<span class="cm">/* Set device address to 0 - called twice to force a latch in the USB</span>
<span class="cm">	   engine without the need of a setup packet status closure */</span>
	<span class="n">udc_set_address</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">udc_set_address</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Enable master DMA interrupts */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">USBD_SYS_ERR_INT</span> <span class="o">|</span> <span class="n">USBD_EOT_INT</span><span class="p">),</span>
		     <span class="n">USBD_DMAINTEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * USB device board specific events handled via callbacks</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* Connection change event - notify board function of change */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uda_power_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Just notify of a connection change event (optional) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">conn_chgb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">conn_chgb</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Suspend/resume event - notify board function of change */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uda_resm_susp_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Just notify of a Suspend/resume change event (optional) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">susp_chgb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">susp_chgb</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remote wakeup enable/disable - notify board function of change */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uda_remwkp_cgh</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">rmwk_chgb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span><span class="o">-&gt;</span><span class="n">rmwk_chgb</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev_status</span> <span class="o">&amp;</span>
				      <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Reads data from FIFO, adjusts for alignment and data size */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_pop_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">p16</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p32</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">cbytes</span><span class="p">;</span>

	<span class="cm">/* Use optimal data transfer method based on source address and size */</span>
	<span class="k">switch</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* 32-bit aligned */</span>
		<span class="n">p32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">cbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3</span><span class="p">);</span>

		<span class="cm">/* Copy 32-bit aligned data first */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cbytes</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
			<span class="o">*</span><span class="n">p32</span><span class="o">++</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_RXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

		<span class="cm">/* Handle any remaining bytes */</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">cbytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_RXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">bl</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
				<span class="n">data</span><span class="p">[</span><span class="n">cbytes</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* 8-bit aligned */</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="cm">/* Each byte has to be handled independently */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_RXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

			<span class="n">bl</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bl</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">bl</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bl</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">data</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* 16-bit aligned */</span>
		<span class="n">p16</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">cbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3</span><span class="p">);</span>

		<span class="cm">/* Copy 32-bit sized objects first with 16-bit alignment */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cbytes</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_RXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
			<span class="o">*</span><span class="n">p16</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
			<span class="o">*</span><span class="n">p16</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Handle any remaining bytes */</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">cbytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_RXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">bl</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
				<span class="n">data</span><span class="p">[</span><span class="n">cbytes</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Read data from the FIFO for an endpoint. This function is for endpoints (such</span>
<span class="cm"> * as EP0) that don&#39;t use DMA. This function should only be called if a packet</span>
<span class="cm"> * is known to be ready to read for the endpoint. Note that the endpoint must</span>
<span class="cm"> * be selected in the protocol engine prior to this call. */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">udc_read_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmpv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">hwrep</span> <span class="o">=</span> <span class="p">((</span><span class="n">hwep</span> <span class="o">&amp;</span> <span class="mh">0x1E</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CTRL_RD_EN</span><span class="p">;</span>

	<span class="cm">/* Setup read of endpoint */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hwrep</span><span class="p">,</span> <span class="n">USBD_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Wait until packet is ready */</span>
	<span class="k">while</span> <span class="p">((((</span><span class="n">tmpv</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_RXPLEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">)))</span> <span class="o">&amp;</span>
		 <span class="n">PKT_RDY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">to</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No packet ready on FIFO EP read</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Mask out count */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmpv</span> <span class="o">&amp;</span> <span class="n">PKT_LNGTH_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">udc_pop_fifo</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(((</span><span class="n">hwep</span> <span class="o">&amp;</span> <span class="mh">0x1E</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">USBD_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Clear the buffer */</span>
	<span class="n">udc_clr_buffer_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Stuffs data into the FIFO, adjusts for alignment and data size */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_stuff_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">p16</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p32</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">cbytes</span><span class="p">;</span>

	<span class="cm">/* Use optimal data transfer method based on source address and size */</span>
	<span class="k">switch</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* 32-bit aligned */</span>
		<span class="n">p32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">cbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3</span><span class="p">);</span>

		<span class="cm">/* Copy 32-bit aligned data first */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cbytes</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="o">*</span><span class="n">p32</span><span class="o">++</span><span class="p">,</span> <span class="n">USBD_TXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

		<span class="cm">/* Handle any remaining bytes */</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">cbytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">bl</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
				<span class="n">tmp</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="n">cbytes</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">USBD_TXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* 8-bit aligned */</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="cm">/* Each byte has to be handled independently */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bl</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bl</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
				<span class="n">bl</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

			<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bl</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">tmp</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">USBD_TXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* 16-bit aligned */</span>
		<span class="n">p16</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">cbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3</span><span class="p">);</span>

		<span class="cm">/* Copy 32-bit aligned data first */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cbytes</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p16</span><span class="o">++</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">p16</span><span class="o">++</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">USBD_TXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* Handle any remaining bytes */</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">cbytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">bl</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
				<span class="n">tmp</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="n">cbytes</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">USBD_TXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Write data to the FIFO for an endpoint. This function is for endpoints (such</span>
<span class="cm"> * as EP0) that don&#39;t use DMA. Note that the endpoint must be selected in the</span>
<span class="cm"> * protocol engine prior to this call. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_write_hwep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hwep</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hwwep</span> <span class="o">=</span> <span class="p">((</span><span class="n">hwep</span> <span class="o">&amp;</span> <span class="mh">0x1E</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CTRL_WR_EN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Setup write of endpoint */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hwwep</span><span class="p">,</span> <span class="n">USBD_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">USBD_TXPLEN</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Need at least 1 byte to trigger TX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBD_TXDATA</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">udc_stuff_fifo</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(((</span><span class="n">hwep</span> <span class="o">&amp;</span> <span class="mh">0x1E</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">USBD_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="n">udc_val_buffer_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">hwep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* USB device reset - resets USB to a default state with just EP0</span>
<span class="cm">   enabled */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uda_usb_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Re-init device controller and EP0 */</span>
	<span class="n">udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_FULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Send a ZLP on EP0 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_ep0_send_zlp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_write_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Get current frame number */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">udc_get_current_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">flo</span><span class="p">,</span> <span class="n">fhi</span><span class="p">;</span>

	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_RD_FRAME</span><span class="p">);</span>
	<span class="n">flo</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">udc_protocol_cmd_r</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">DAT_RD_FRAME</span><span class="p">);</span>
	<span class="n">fhi</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">udc_protocol_cmd_r</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">DAT_RD_FRAME</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">fhi</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">flo</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set the device as configured - enables all endpoints */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">udc_set_device_configured</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_CFG_DEV</span><span class="p">,</span> <span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">CONF_DVICE</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Set the device as unconfigured - disables all endpoints */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">udc_set_device_unconfigured</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_CFG_DEV</span><span class="p">,</span> <span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* reinit == restore initial software state */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_reinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep_list</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">ep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">ep_list</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be called with lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">done</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lep</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
			<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
					<span class="n">direction</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
						<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
						<span class="n">direction</span><span class="p">);</span>

		<span class="cm">/* Free DDs */</span>
		<span class="n">udc_dd_free</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_desc_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span>
		<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;%s done %p, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be called with lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nuke</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uda_disable_hwepint</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
		<span class="n">udc_disable_hwep</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* IN endpoint 0 transfer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">udc_ep0_in_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">tsend</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="cm">/* Nothing to send */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span>
				 <span class="n">queue</span><span class="p">);</span>

	<span class="n">tsend</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Send a ZLP */</span>
		<span class="n">udc_ep0_send_zlp</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&gt;</span> <span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span>
		<span class="n">ts</span> <span class="o">=</span> <span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">;</span> <span class="cm">/* Just send what we can */</span>

	<span class="cm">/* Write data to the EP0 FIFO and start transfer */</span>
	<span class="n">udc_write_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">,</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">),</span> <span class="n">ts</span><span class="p">);</span>

	<span class="cm">/* Increment data pointer */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">+=</span> <span class="n">ts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsend</span> <span class="o">&gt;=</span> <span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Stay in data transfer state */</span>

	<span class="cm">/* Transfer request is complete */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="n">done</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* OUT endpoint 0 transfer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">udc_ep0_out_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">tr</span><span class="p">,</span> <span class="n">bufferspace</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span>
				 <span class="n">queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Just dequeue request */</span>
			<span class="n">done</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Get data from FIFO */</span>
		<span class="n">bufferspace</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bufferspace</span> <span class="o">&gt;</span> <span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span>
			<span class="n">bufferspace</span> <span class="o">=</span> <span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">;</span>

		<span class="cm">/* Copy data to buffer */</span>
		<span class="n">prefetchw</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">);</span>
		<span class="n">tr</span> <span class="o">=</span> <span class="n">udc_read_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_OUT</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span><span class="p">,</span>
				   <span class="n">bufferspace</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">+=</span> <span class="n">bufferspace</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tr</span> <span class="o">&lt;</span> <span class="n">ep0</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is the last packet */</span>
			<span class="n">done</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be called with lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span>
		<span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">isp1301_pullup_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc_reinit</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Activate or kill host pullup</span>
<span class="cm"> * Can be called with or without lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">)</span>
		<span class="n">is_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_on</span> <span class="o">!=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">)</span>
		<span class="n">isp1301_pullup_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">is_on</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be called without lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">nuke</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>

	<span class="cm">/* restore the endpoint&#39;s pristine config */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Clear all DMA statuses for this EP */</span>
	<span class="n">udc_ep_dma_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_EOTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_NDDRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_SYSERRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_DMARCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Remove the DD pointer in the UDCA */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable and reset endpoint and interrupt */</span>
	<span class="n">uda_clear_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="n">udc_unrealize_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_ep_cnt</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_disable_wait_queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be called without lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Verify EP data */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">_ep</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_ENDPOINT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad ep or descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">maxpacket</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">&gt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad ep descriptor&#39;s packet size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t touch EP0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t re-enable EP0!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is driver ready? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bogus device state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">&gt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">maxpacket</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Bad INT endpoint maxpacket %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">maxpacket</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">maxpacket</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">case</span> <span class="mi">16</span>:
		<span class="k">case</span> <span class="mi">32</span>:
		<span class="k">case</span> <span class="mi">64</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Bad BULK endpoint maxpacket %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">maxpacket</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Initialize endpoint to match the selected descriptor */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span> <span class="o">=</span> <span class="n">maxpacket</span><span class="p">;</span>

	<span class="cm">/* Map hardware endpoint from base and direction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
		<span class="cm">/* IN endpoints are offset 1 from the OUT endpoint */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num_base</span> <span class="o">+</span> <span class="n">EP_IN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num_base</span><span class="p">;</span>

	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;EP enabled: %s, HW:%d, MP:%d IN:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
	       <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">maxpacket</span><span class="p">,</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span> <span class="o">==</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Realize the endpoint, interrupt is enabled later when</span>
<span class="cm">	 * buffers are queued, IN EPs will NAK until buffers are ready */</span>
	<span class="n">udc_realize_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">);</span>
	<span class="n">udc_clr_buffer_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="n">uda_disable_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="n">udc_clrstall_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>

	<span class="cm">/* Clear all DMA statuses for this EP */</span>
	<span class="n">udc_ep_dma_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_EOTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_NDDRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_SYSERRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="n">USBD_DMARCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_ep_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a USB request list</span>
<span class="cm"> * Can be called with or without lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="nf">lpc32xx_ep_alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span>
						    <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">),</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * De-allocate a USB request list</span>
<span class="cm"> * Can be called with or without lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpc32xx_ep_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be called without lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_ep_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_req</span> <span class="o">||</span> <span class="o">!</span><span class="n">_req</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">||</span> <span class="o">!</span><span class="n">_req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num_base</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid ep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">udc</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lep</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>

		<span class="cm">/* Map DMA pointer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
			<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dma_sync_single_for_device</span><span class="p">(</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* For the request, build a list of DDs */</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">udc_dd_alloc</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Error allocating DD */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_desc_ptr</span> <span class="o">=</span> <span class="n">dd</span><span class="p">;</span>

		<span class="cm">/* Setup the DMA descriptor */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_next_phy</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_next_v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_buffer_addr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">dma</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Special handling for ISO EPs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">eptype</span> <span class="o">==</span> <span class="n">EP_ISO_TYPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_setup</span> <span class="o">=</span> <span class="n">DD_SETUP_ISO_EP</span> <span class="o">|</span>
				<span class="n">DD_SETUP_PACKETLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">DD_SETUP_DMALENBYTES</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_iso_ps_mem_addr</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">this_dma</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">iso_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">iso_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_setup</span> <span class="o">=</span> <span class="n">DD_SETUP_PACKETLEN</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">.</span><span class="n">maxpacket</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">DD_SETUP_DMALENBYTES</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ep_dbg</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;%s queue req %p len %d buf %p (in=%d) z=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">_ep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="n">_req</span><span class="p">,</span> <span class="n">_req</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">_req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">,</span> <span class="n">_req</span><span class="o">-&gt;</span><span class="n">zero</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">_req</span><span class="o">-&gt;</span><span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">send_zlp</span> <span class="o">=</span> <span class="n">_req</span><span class="o">-&gt;</span><span class="n">zero</span><span class="p">;</span>

	<span class="cm">/* Kickstart empty queues */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Handle expected data direction */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* IN packet to host */</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">DATA_IN</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">udc_ep0_in_req</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* OUT packet from host */</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">DATA_OUT</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">udc_ep0_out_req</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* IN packet to host and kick off transfer */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span><span class="p">)</span>
				<span class="n">udc_ep_in_req_dma</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* OUT packet from host and kick off list */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span><span class="p">)</span>
				<span class="n">udc_ep_out_req_dma</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be called without lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_ep_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* make sure it&#39;s actually queued on this endpoint */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">==</span> <span class="n">_req</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">!=</span> <span class="n">_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be called without lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_ep_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t halt an IN EP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* stall */</span>
		<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_EP_STAT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">),</span>
					<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">EP_STAT_ST</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* End stall */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">wedge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_EP_STAT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">),</span>
					<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set the halt feature and ignores clear requests */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_ep_set_wedge</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_ep</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">udc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">wedge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">usb_ep_set_halt</span><span class="p">(</span><span class="n">_ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ep_ops</span> <span class="n">lpc32xx_ep_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">lpc32xx_ep_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">lpc32xx_ep_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_request</span>	<span class="o">=</span> <span class="n">lpc32xx_ep_alloc_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_request</span>	<span class="o">=</span> <span class="n">lpc32xx_ep_free_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queue</span>		<span class="o">=</span> <span class="n">lpc32xx_ep_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue</span>	<span class="o">=</span> <span class="n">lpc32xx_ep_dequeue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_halt</span>	<span class="o">=</span> <span class="n">lpc32xx_ep_set_halt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_wedge</span>	<span class="o">=</span> <span class="n">lpc32xx_ep_set_wedge</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Send a ZLP on a non-0 IN EP */</span>
<span class="kt">void</span> <span class="nf">udc_send_in_zlp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear EP status */</span>
	<span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>

	<span class="cm">/* Send ZLP via FIFO mechanism */</span>
	<span class="n">udc_write_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle EP completion for ZLP</span>
<span class="cm"> * This function will only be called when a delayed ZLP needs to be sent out</span>
<span class="cm"> * after a DMA transfer has filled both buffers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">udc_handle_eps</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">epstatus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">uda_clear_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>

	<span class="cm">/* If this interrupt isn&#39;t enabled, return now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_hwepints</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Get endpoint status */</span>
	<span class="n">epstatus</span> <span class="o">=</span> <span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This should never happen, but protect against writing to the</span>
<span class="cm">	 * buffer when full.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epstatus</span> <span class="o">&amp;</span> <span class="n">EP_SEL_F</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_send_in_zlp</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="n">uda_disable_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If there isn&#39;t a request waiting, something went wrong */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Start another request if ready */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
				<span class="n">udc_ep_in_req_dma</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">udc_ep_out_req_dma</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* DMA end of transfer completion */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_handle_dma_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">epstatus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_USB_GADGET_DEBUG_FILES</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">totalints</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_request</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;DMA interrupt on no req!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_desc_ptr</span><span class="p">;</span>

	<span class="cm">/* DMA descriptor should always be retired for this call */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_status</span> <span class="o">&amp;</span> <span class="n">DD_STATUS_DD_RETIRED</span><span class="p">))</span>
		<span class="n">ep_warn</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;DMA descriptor did not retire</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Disable DMA */</span>
	<span class="n">udc_ep_dma_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">),</span> <span class="n">USBD_EOTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">),</span> <span class="n">USBD_NDDRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* System error? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USBD_SYSERRTINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">))</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">),</span>
			     <span class="n">USBD_SYSERRTINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;AHB critical error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* The error could have occurred on a packet of a multipacket</span>
<span class="cm">		 * transfer, so recovering the transfer is not possible. Close</span>
<span class="cm">		 * the request with an error */</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Handle the current DD&#39;s status */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_status</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DD_STATUS_STS_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DD_STATUS_STS_NS</span>:
		<span class="cm">/* DD not serviced? This shouldn&#39;t happen! */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;DMA critical EP error: DD not serviced (0x%x)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">status</span><span class="p">);</span>

		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DD_STATUS_STS_BS</span>:
		<span class="cm">/* Interrupt only fires on EOT - This shouldn&#39;t happen! */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;DMA critical EP error: EOT prior to service completion (0x%x)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">status</span><span class="p">);</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DD_STATUS_STS_NC</span>:
	<span class="k">case</span> <span class="n">DD_STATUS_STS_DUR</span>:
		<span class="cm">/* Really just a short packet, not an underrun */</span>
		<span class="cm">/* This is a good status and what we expect */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Data overrun, system error, or unknown */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ep_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s">&quot;DMA critical EP error: System error (0x%x)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">status</span><span class="p">);</span>
		<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ISO endpoints are handled differently */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">eptype</span> <span class="o">==</span> <span class="n">EP_ISO_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">iso_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">actual</span> <span class="o">+=</span> <span class="n">DD_STATUS_CURDMACNT</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* Send a ZLP if necessary. This will be done for non-int</span>
<span class="cm">	 * packets which have a size that is a divisor of MAXP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">send_zlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If at least 1 buffer is available, send the ZLP now.</span>
<span class="cm">		 * Otherwise, the ZLP send needs to be deferred until a</span>
<span class="cm">		 * buffer is available.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EP_SEL_F</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
			<span class="n">uda_enable_hwepint</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
			<span class="n">epstatus</span> <span class="o">=</span> <span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>

			<span class="cm">/* Let the EP interrupt handle the ZLP */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">udc_send_in_zlp</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Transfer request is complete */</span>
	<span class="n">done</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Start another request if ready */</span>
	<span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">((</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
			<span class="n">udc_ep_in_req_dma</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">udc_ep_out_req_dma</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">req_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Endpoint 0 functions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_handle_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_GET_DEV_STAT</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">udc_protocol_cmd_r</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">DAT_GET_DEV_STAT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">DEV_RST</span><span class="p">)</span>
		<span class="n">uda_usb_reset</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">DEV_CON_CH</span><span class="p">)</span>
		<span class="n">uda_power_event</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">DEV_CON</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">DEV_SUS_CH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">DEV_SUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Power down transceiver */</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">poweron</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_job</span><span class="p">);</span>
				<span class="n">uda_resm_susp_event</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_UNKNOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uda_resm_susp_event</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* Power up transceiver */</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">poweron</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_job</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udc_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reqtype</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wIndex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ep0buff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reqtype</span> <span class="o">&amp;</span> <span class="n">USB_RECIP_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_RECIP_INTERFACE</span>:
		<span class="k">break</span><span class="p">;</span> <span class="cm">/* Not supported */</span>

	<span class="k">case</span> <span class="n">USB_RECIP_DEVICE</span>:
		<span class="n">ep0buff</span> <span class="o">=</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">selfpowered</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_SELF_POWERED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">))</span>
			<span class="n">ep0buff</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_RECIP_ENDPOINT</span>:
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">tmp</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="n">NUM_ENDPOINTS</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span> <span class="cm">/* Something&#39;s wrong */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span> <span class="cm">/* Not an IN endpoint */</span>

		<span class="cm">/* Get status of the endpoint */</span>
		<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SEL_EP</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">));</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">udc_protocol_cmd_r</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">DAT_SEL_EP</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">EP_SEL_ST</span><span class="p">)</span>
			<span class="n">ep0buff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_ENDPOINT_HALT</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ep0buff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Return data */</span>
	<span class="n">udc_write_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep0buff</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_handle_ep0_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="o">*</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">ctrlpkt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wLength</span><span class="p">,</span> <span class="n">reqtype</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Nuke previous transfers */</span>
	<span class="n">nuke</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">);</span>

	<span class="cm">/* Get setup packet */</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">udc_read_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_OUT</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ctrlpkt</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_warn</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="s">&quot;Incorrectly sized setup packet (s/b 8, is %d)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bytes</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Native endianness */</span>
	<span class="n">wIndex</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrlpkt</span><span class="p">.</span><span class="n">wIndex</span><span class="p">);</span>
	<span class="n">wValue</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrlpkt</span><span class="p">.</span><span class="n">wValue</span><span class="p">);</span>
	<span class="n">wLength</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrlpkt</span><span class="p">.</span><span class="n">wLength</span><span class="p">);</span>
	<span class="n">reqtype</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrlpkt</span><span class="p">.</span><span class="n">bRequestType</span><span class="p">);</span>

	<span class="cm">/* Set direction of EP0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">reqtype</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">))</span>
		<span class="n">ep0</span><span class="o">-&gt;</span><span class="n">is_in</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ep0</span><span class="o">-&gt;</span><span class="n">is_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Handle SETUP packet */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrlpkt</span><span class="p">.</span><span class="n">bRequest</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_REQ_CLEAR_FEATURE</span>:
	<span class="k">case</span> <span class="n">USB_REQ_SET_FEATURE</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">reqtype</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="p">(</span><span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">)</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">wValue</span> <span class="o">!=</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">stall</span><span class="p">;</span> <span class="cm">/* Nothing else handled */</span>

			<span class="cm">/* Tell board about event */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">)</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev_status</span> <span class="o">&amp;=</span>
					<span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev_status</span> <span class="o">|=</span>
					<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_DEVICE_REMOTE_WAKEUP</span><span class="p">);</span>
			<span class="n">uda_remwkp_cgh</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">zlp_send</span><span class="p">;</span>

		<span class="k">case</span> <span class="p">(</span><span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">)</span>:
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">wIndex</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">wValue</span> <span class="o">!=</span> <span class="n">USB_ENDPOINT_HALT</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="n">NUM_ENDPOINTS</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Find hardware endpoint from logical endpoint */</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">tmp</span><span class="p">];</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hwep_num</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="n">USB_REQ_SET_FEATURE</span><span class="p">)</span>
				<span class="n">udc_stall_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wedge</span><span class="p">)</span>
				<span class="n">udc_clrstall_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">zlp_send</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="k">case</span> <span class="n">USB_REQ_SET_ADDRESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">reqtype</span> <span class="o">==</span> <span class="p">(</span><span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">udc_set_address</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">wValue</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">zlp_send</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_REQ_GET_STATUS</span>:
		<span class="n">udc_get_status</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">reqtype</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span> <span class="cm">/* Let GadgetFS handle the descriptor instead */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* device-2-host (IN) or no data setup command, process</span>
<span class="cm">		 * immediately */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrlpkt</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="n">USB_REQ_SET_CONFIGURATION</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Configuration is set after endpoints are realized */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Set configuration */</span>
				<span class="n">udc_set_device_configured</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

				<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_MODE</span><span class="p">,</span>
							<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">AP_CLK</span> <span class="o">|</span>
							<span class="n">INAK_BI</span> <span class="o">|</span> <span class="n">INAK_II</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Clear configuration */</span>
				<span class="n">udc_set_device_unconfigured</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

				<span class="cm">/* Disable NAK interrupts */</span>
				<span class="n">udc_protocol_cmd_data_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_SET_MODE</span><span class="p">,</span>
							<span class="n">DAT_WR_BYTE</span><span class="p">(</span><span class="n">AP_CLK</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* setup processing failed, force stall */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;req %02x.%02x protocol STALL; stat %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">reqtype</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">stall</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep0</span><span class="o">-&gt;</span><span class="n">is_in</span><span class="p">)</span>
		<span class="n">udc_ep0_send_zlp</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span> <span class="cm">/* ZLP IN packet on data phase */</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">stall:</span>
	<span class="n">udc_stall_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">zlp_send:</span>
	<span class="n">udc_ep0_send_zlp</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* IN endpoint 0 transfer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_handle_ep0_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">epstatus</span><span class="p">;</span>

	<span class="cm">/* Clear EP interrupt */</span>
	<span class="n">epstatus</span> <span class="o">=</span> <span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB_GADGET_DEBUG_FILES</span>
	<span class="n">ep0</span><span class="o">-&gt;</span><span class="n">totalints</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Stalled? Clear stall and reset buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epstatus</span> <span class="o">&amp;</span> <span class="n">EP_SEL_ST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_clrstall_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">);</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is a buffer available? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epstatus</span> <span class="o">&amp;</span> <span class="n">EP_SEL_F</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Handle based on current state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">==</span> <span class="n">DATA_IN</span><span class="p">)</span>
			<span class="n">udc_ep0_in_req</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Unknown state for EP0 oe end of DATA IN phase */</span>
			<span class="n">nuke</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* OUT endpoint 0 transfer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udc_handle_ep0_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_ep</span> <span class="o">*</span><span class="n">ep0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">epstatus</span><span class="p">;</span>

	<span class="cm">/* Clear EP interrupt */</span>
	<span class="n">epstatus</span> <span class="o">=</span> <span class="n">udc_clearep_getsts</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_OUT</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_USB_GADGET_DEBUG_FILES</span>
	<span class="n">ep0</span><span class="o">-&gt;</span><span class="n">totalints</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Stalled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epstatus</span> <span class="o">&amp;</span> <span class="n">EP_SEL_ST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_clrstall_hwep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">EP_OUT</span><span class="p">);</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* A NAK may occur if a packet couldn&#39;t be received yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epstatus</span> <span class="o">&amp;</span> <span class="n">EP_SEL_EPN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Setup packet incoming? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epstatus</span> <span class="o">&amp;</span> <span class="n">EP_SEL_STP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nuke</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Data available? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epstatus</span> <span class="o">&amp;</span> <span class="n">EP_SEL_F</span><span class="p">)</span>
		<span class="cm">/* Handle based on current state */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">WAIT_FOR_SETUP</span>:
			<span class="n">udc_handle_ep0_setup</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DATA_OUT</span>:
			<span class="n">udc_ep0_out_req</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* Unknown state for EP0 */</span>
			<span class="n">nuke</span><span class="p">(</span><span class="n">ep0</span><span class="p">,</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">);</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep0state</span> <span class="o">=</span> <span class="n">WAIT_FOR_SETUP</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Must be called without lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_udc</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">udc_get_current_frame</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">frame</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_set_selfpowered</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_udc</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="cm">/* Always self-powered */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">selfpowered</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_on</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vbus is here!  turn everything on that&#39;s ready</span>
<span class="cm"> * Must be called without lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_vbus_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_udc</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Doesn&#39;t need lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc_clk_set</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">udc_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">is_active</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Wait for all the endpoints to disable,</span>
<span class="cm">		 *  before disabling clocks. Don&#39;t wait if</span>
<span class="cm">		 *  endpoints are not enabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_ep_cnt</span><span class="p">))</span>
			<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_disable_wait_queue</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_ep_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">udc_clk_set</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Can be called with or without lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">to_udc</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>

	<span class="cm">/* Doesn&#39;t need lock */</span>
	<span class="n">pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">is_on</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lpc32xx_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">));</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpc32xx_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_gadget_ops</span> <span class="n">lpc32xx_udc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_frame</span>		<span class="o">=</span> <span class="n">lpc32xx_get_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wakeup</span>			<span class="o">=</span> <span class="n">lpc32xx_wakeup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_selfpowered</span>	<span class="o">=</span> <span class="n">lpc32xx_set_selfpowered</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vbus_session</span>		<span class="o">=</span> <span class="n">lpc32xx_vbus_session</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pullup</span>			<span class="o">=</span> <span class="n">lpc32xx_pullup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>			<span class="o">=</span> <span class="n">lpc32xx_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>			<span class="o">=</span> <span class="n">lpc32xx_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nop_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* nothing to free */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">gadget</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_udc_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ep0</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ep</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">driver_name</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dev</span>	<span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">init_name</span> <span class="o">=</span> <span class="s">&quot;gadget&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">nop_release</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep0&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Can be 0 or 1, has special handling */</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_CTL_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep1-int&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* 2 or 3, will be set later */</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_INT_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep2-bulk&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* 4 or 5, will be set later */</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_BLK_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep3-iso&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">1023</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* 6 or 7, will be set later */</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_ISO_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep4-int&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* 8 or 9, will be set later */</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_INT_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep5-bulk&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* 10 or 11, will be set later */</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_BLK_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep6-iso&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">1023</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* 12 or 13, will be set later */</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_ISO_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep7-int&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_INT_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep8-bulk&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_BLK_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep9-iso&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">1023</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_ISO_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep10-int&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_INT_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep11-bulk&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_BLK_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep12-iso&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">1023</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_ISO_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep13-int&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_INT_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep14-bulk&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_BLK_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ep</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ep</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep15-bulk&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_ep_ops</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">udc</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxpacket</span>	<span class="o">=</span> <span class="mi">1023</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num_base</span>	<span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hwep_num</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lep</span>		<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
		<span class="p">.</span><span class="n">eptype</span>		<span class="o">=</span> <span class="n">EP_BLK_TYPE</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* ISO and status interrupts */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">lpc32xx_usb_lp_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">devstat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">_udc</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Read the device status register */</span>
	<span class="n">devstat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_DEVINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="n">devstat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USBD_EP_FAST</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">devstat</span><span class="p">,</span> <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="n">devstat</span> <span class="o">=</span> <span class="n">devstat</span> <span class="o">&amp;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_devints</span><span class="p">;</span>

	<span class="cm">/* Device specific handling needed? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devstat</span> <span class="o">&amp;</span> <span class="n">USBD_DEV_STAT</span><span class="p">)</span>
		<span class="n">udc_handle_dev</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="cm">/* Start of frame? (devstat &amp; FRAME_INT):</span>
<span class="cm">	 * The frame interrupt isn&#39;t really needed for ISO support,</span>
<span class="cm">	 * as the driver will queue the necessary packets */</span>

	<span class="cm">/* Error? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devstat</span> <span class="o">&amp;</span> <span class="n">ERR_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All types of errors, from cable removal during transfer to</span>
<span class="cm">		 * misc protocol and bit errors. These are mostly for just info,</span>
<span class="cm">		 * as the USB hardware will work around these. If these errors</span>
<span class="cm">		 * happen alot, something is wrong. */</span>
		<span class="n">udc_protocol_cmd_w</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">CMD_RD_ERR_STAT</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">udc_protocol_cmd_r</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="n">DAT_RD_ERR_STAT</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device error (0x%x)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* EP interrupts */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">lpc32xx_usb_hp_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">_udc</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Read the device status register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">USBD_EP_FAST</span><span class="p">,</span> <span class="n">USBD_DEVINTCLR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Endpoints */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_EPINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>

	<span class="cm">/* Special handling for EP0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EP_MASK_SEL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EP_OUT</span><span class="p">)</span> <span class="o">|</span> <span class="n">EP_MASK_SEL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Handle EP0 IN */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EP_MASK_SEL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">)))</span>
			<span class="n">udc_handle_ep0_in</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

		<span class="cm">/* Handle EP0 OUT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EP_MASK_SEL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EP_OUT</span><span class="p">)))</span>
			<span class="n">udc_handle_ep0_out</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* All other EPs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EP_MASK_SEL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EP_OUT</span><span class="p">)</span> <span class="o">|</span> <span class="n">EP_MASK_SEL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EP_IN</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* Handle other EP interrupts */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hwep_num</span><span class="p">))</span>
				<span class="n">udc_handle_eps</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">lpc32xx_usb_devdma_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">_udc</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Handle EP DMA EOT interrupts */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">USBD_EOTINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">))</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USBD_EPDMAST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">))</span> <span class="o">&amp;</span>
		 <span class="n">readl</span><span class="p">(</span><span class="n">USBD_NDDRTINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">)))</span> <span class="o">|</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">USBD_SYSERRTINTST</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ENDPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hwep_num</span><span class="p">))</span>
			<span class="n">udc_handle_dma_ep</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * VBUS detection, pullup handler, and Gadget cable state notification</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vbus_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpc32xx_udc</span><span class="p">,</span>
					       <span class="n">vbus_job</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Discharge VBUS real quick */</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_OTG_CONTROL_1</span><span class="p">,</span> <span class="n">OTG1_VBUS_DISCHRG</span><span class="p">);</span>

		<span class="cm">/* Give VBUS some time (100mS) to discharge */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="cm">/* Disable VBUS discharge resistor */</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_OTG_CONTROL_1</span> <span class="o">|</span> <span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span>
			<span class="n">OTG1_VBUS_DISCHRG</span><span class="p">);</span>

		<span class="cm">/* Clear interrupt */</span>
		<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
			<span class="n">ISP1301_I2C_INTERRUPT_LATCH</span> <span class="o">|</span>
			<span class="n">ISP1301_I2C_REG_CLEAR_ADDR</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Get the VBUS status from the transceiver */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">,</span>
						 <span class="n">ISP1301_I2C_OTG_CONTROL_2</span><span class="p">);</span>

		<span class="cm">/* VBUS on or off? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">OTG_B_SESS_VLD</span><span class="p">)</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* VBUS changed? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_vbus</span> <span class="o">!=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_vbus</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">;</span>
			<span class="n">lpc32xx_vbus_session</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Re-enable after completion */</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_ATX</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">lpc32xx_usb_vbus_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">_udc</span><span class="p">;</span>

	<span class="cm">/* Defer handling of VBUS IRQ to work queue */</span>
	<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_ATX</span><span class="p">]);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_job</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">max_speed</span> <span class="o">&lt;</span> <span class="n">USB_SPEED_FULL</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">bind</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad parameter.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;UDC already has a gadget driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">selfpowered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bind() returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">selfpowered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bound to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Force VBUS process once to check for cable insertion */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">last_vbus</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_job</span><span class="p">);</span>

	<span class="cm">/* Do not re-enable ATX IRQ (3) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IRQ_USB_LP</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IRQ_USB_ATX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span> <span class="n">driver</span> <span class="o">!=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Disable USB pullup */</span>
	<span class="n">isp1301_pullup_enable</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IRQ_USB_LP</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">IRQ_USB_ATX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">stop_activity</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Wait for all the endpoints to disable,</span>
<span class="cm">		 *  before disabling clocks. Don&#39;t wait if</span>
<span class="cm">		 *  endpoints are not enabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_ep_cnt</span><span class="p">))</span>
			<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_disable_wait_queue</span><span class="p">,</span>
				<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_ep_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">udc_clk_set</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">unbind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unbound from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpc32xx_udc_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Force disconnect on reboot */</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">;</span>

	<span class="n">pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callbacks to be overridden by options passed via OF (TODO)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpc32xx_usbd_conn_chg</span><span class="p">(</span><span class="kt">int</span> <span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Do nothing, it might be nice to enable an LED</span>
<span class="cm">	 * based on conn state being !0 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpc32xx_usbd_susp_chg</span><span class="p">(</span><span class="kt">int</span> <span class="n">susp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Device suspend if susp != 0 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpc32xx_rmwkup_chg</span><span class="p">(</span><span class="kt">int</span> <span class="n">remote_wakup_enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Enable or disable USB remote wakeup */</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lpc32xx_usbd_cfg</span> <span class="n">lpc32xx_usbddata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vbus_drv_pol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">conn_chgb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_usbd_conn_chg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">susp_chgb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_usbd_susp_chg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmwk_chgb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_rmwkup_chg</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="n">u64</span> <span class="n">lpc32xx_usbd_dmamask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="mh">0x7F</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lpc32xx_udc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">controller</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">isp1301_node</span><span class="p">;</span>

	<span class="cm">/* init software state */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isp1301_node</span> <span class="o">=</span> <span class="n">of_parse_phandle</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span>
						<span class="s">&quot;transceiver&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">isp1301_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span> <span class="o">=</span> <span class="n">isp1301_get_client</span><span class="p">(</span><span class="n">isp1301_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ISP1301 I2C device at address 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">udc</span><span class="o">-&gt;</span><span class="n">isp1301_i2c_client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_usbd_dmamask</span><span class="p">;</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">board</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpc32xx_usbddata</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Resources are mapped as follows:</span>
<span class="cm">	 *  IORESOURCE_MEM, base address and size of USB space</span>
<span class="cm">	 *  IORESOURCE_IRQ, USB device low priority interrupt number</span>
<span class="cm">	 *  IORESOURCE_IRQ, USB device high priority interrupt number</span>
<span class="cm">	 *  IORESOURCE_IRQ, USB device interrupt number</span>
<span class="cm">	 *  IORESOURCE_IRQ, USB transceiver interrupt number</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Get IRQs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;irq resource %d not available!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_start</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_size</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_start</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_size</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;someone&#39;s using UDC memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_start</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IO map failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">io_map_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable AHB slave USB clock, needed for further USB clock control */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">USB_SLAVE_HCLK_EN</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span> <span class="n">USB_CTRL</span><span class="p">);</span>

	<span class="cm">/* Get required clocks */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ck_pll5&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to acquire USB PLL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">pll_get_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ck_usbd&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to acquire USB device clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">usb_clk_get_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup PLL clock to 48MHz */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">clk_enable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to start USB PLL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">pll_enable_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">clk_set_rate</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">,</span> <span class="mi">48000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to set USB clock rate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">pll_set_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_CTRL</span><span class="p">)</span> <span class="o">|</span> <span class="n">USB_DEV_NEED_CLK_EN</span><span class="p">,</span> <span class="n">USB_CTRL</span><span class="p">);</span>

	<span class="cm">/* Enable USB device clock */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">clk_enable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to start USB device clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">usb_clk_enable_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set to enable all needed USB OTG clocks */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">USB_CLOCK_MASK</span><span class="p">,</span> <span class="n">USB_OTG_CLK_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="p">));</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_OTG_CLK_STAT</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">USB_CLOCK_MASK</span><span class="p">)</span> <span class="o">!=</span>
		<span class="n">USB_CLOCK_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB OTG clocks not correctly enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Setup deferred workqueue data */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">poweron</span> <span class="o">=</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">pullup_job</span><span class="p">,</span> <span class="n">pullup_work</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">vbus_job</span><span class="p">,</span> <span class="n">vbus_work</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">power_job</span><span class="p">,</span> <span class="n">power_work</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* All clocks are now on */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">isp1301_udc_configure</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="cm">/* Allocate memory for the UDCA */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDCA_BUFF_SIZE</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error getting UDCA region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">i2c_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_p_base</span> <span class="o">=</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA buffer(0x%x bytes), P:0x%08x, V:0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">UDCA_BUFF_SIZE</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_p_base</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">);</span>

	<span class="cm">/* Setup the DD DMA memory pool */</span>
	<span class="n">udc</span><span class="o">-&gt;</span><span class="n">dd_cache</span> <span class="o">=</span> <span class="n">dma_pool_create</span><span class="p">(</span><span class="s">&quot;udc_dd&quot;</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpc32xx_usbd_dd_gad</span><span class="p">),</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dd_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error getting DD DMA region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">dma_alloc_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear USB peripheral and initialize gadget endpoints */</span>
	<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">udc_reinit</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device registration failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dev_register_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Request IRQs - low and high priority USB device IRQs are routed to</span>
<span class="cm">	 * the same handler, while the DMA interrupt is routed elsewhere */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_LP</span><span class="p">],</span> <span class="n">lpc32xx_usb_lp_irq</span><span class="p">,</span>
			     <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;udc_lp&quot;</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;LP request irq %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_LP</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">irq_lp_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_HP</span><span class="p">],</span> <span class="n">lpc32xx_usb_hp_irq</span><span class="p">,</span>
			     <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;udc_hp&quot;</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HP request irq %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_HP</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">irq_hp_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_DEVDMA</span><span class="p">],</span>
			     <span class="n">lpc32xx_usb_devdma_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;udc_dma&quot;</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DEV request irq %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_DEVDMA</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">irq_dev_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The transceiver interrupt is used for VBUS detection and will</span>
<span class="cm">	   kick off the VBUS handler function */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_ATX</span><span class="p">],</span> <span class="n">lpc32xx_usb_vbus_irq</span><span class="p">,</span>
			     <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;udc_otg&quot;</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VBUS request irq %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_ATX</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">irq_xcvr_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize wait queue */</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">ep_disable_wait_queue</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">enabled_ep_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Keep all IRQs disabled until GadgetFS starts up */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IRQ_USB_LP</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">IRQ_USB_ATX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">add_gadget_fail</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">udc</span><span class="p">);</span>
	<span class="n">device_init_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">create_debug_file</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="cm">/* Disable clocks for now */</span>
	<span class="n">udc_clk_set</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">add_gadget_fail:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_ATX</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>
<span class="nl">irq_xcvr_fail:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_DEVDMA</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>
<span class="nl">irq_dev_fail:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_HP</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>
<span class="nl">irq_hp_fail:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_LP</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>
<span class="nl">irq_lp_fail:</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">dev_register_fail:</span>
	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dd_cache</span><span class="p">);</span>
<span class="nl">dma_alloc_fail:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDCA_BUFF_SIZE</span><span class="p">,</span>
			  <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_p_base</span><span class="p">);</span>
<span class="nl">i2c_fail:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>
<span class="nl">usb_clk_enable_fail:</span>
<span class="nl">pll_set_fail:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>
<span class="nl">pll_enable_fail:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>
<span class="nl">usb_clk_get_fail:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>
<span class="nl">pll_get_fail:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">);</span>
<span class="nl">io_map_fail:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_start</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_size</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s probe failed, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">lpc32xx_udc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">usb_del_gadget_udc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">udc_clk_set</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">udc_disable</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>
	<span class="n">pullup</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_ATX</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>

	<span class="n">device_init_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">remove_debug_file</span><span class="p">(</span><span class="n">udc</span><span class="p">);</span>

	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dd_cache</span><span class="p">);</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UDCA_BUFF_SIZE</span><span class="p">,</span>
			  <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_v_base</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">udca_p_base</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_DEVDMA</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_HP</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_irq</span><span class="p">[</span><span class="n">IRQ_USB_LP</span><span class="p">],</span> <span class="n">udc</span><span class="p">);</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">gadget</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_pll_clk</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">udp_baseaddr</span><span class="p">);</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_start</span><span class="p">,</span> <span class="n">udc</span><span class="o">-&gt;</span><span class="n">io_p_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_udc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Power down ISP */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">poweron</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">isp1301_set_powerstate</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Disable clocking */</span>
		<span class="n">udc_clk_set</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Keep clock flag on, so we know to re-enable clocks</span>
<span class="cm">		   on resume */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Kill OTG and I2C clocks */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USB_OTG_CLK_CTRL</span><span class="p">(</span><span class="n">udc</span><span class="p">));</span>
		<span class="k">while</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">USB_OTG_CLK_STAT</span><span class="p">(</span><span class="n">udc</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">OTGOFF_CLK_MASK</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">OTGOFF_CLK_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">to</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;USB OTG clocks not correctly enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Kill global USB clock */</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpc32xx_udc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpc32xx_udc</span> <span class="o">*</span><span class="n">udc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">clocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable global USB clock */</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">udc</span><span class="o">-&gt;</span><span class="n">usb_slv_clk</span><span class="p">);</span>

		<span class="cm">/* Enable clocking */</span>
		<span class="n">udc_clk_set</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* ISP back to normal power mode */</span>
		<span class="n">udc</span><span class="o">-&gt;</span><span class="n">poweron</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">isp1301_set_powerstate</span><span class="p">(</span><span class="n">udc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define	lpc32xx_udc_suspend	NULL</span>
<span class="cp">#define	lpc32xx_udc_resume	NULL</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_OF</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">lpc32xx_udc_of_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;nxp,lpc3220-udc&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">lpc32xx_udc_of_match</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">lpc32xx_udc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">lpc32xx_udc_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">lpc32xx_udc_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">lpc32xx_udc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">lpc32xx_udc_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">driver_name</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">of_match_ptr</span><span class="p">(</span><span class="n">lpc32xx_udc_of_match</span><span class="p">),</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">udc_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpc32xx_udc_driver</span><span class="p">,</span> <span class="n">lpc32xx_udc_probe</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">udc_init_module</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">udc_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpc32xx_udc_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">udc_exit_module</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;LPC32XX udc driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Kevin Wells &lt;kevin.wells@nxp.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Roland Stigge &lt;stigge@antcom.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:lpc32xx_udc&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
