<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › misc › usbtest.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>usbtest.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* FIXME make these public somewhere; usbdevfs.h? */</span>
<span class="k">struct</span> <span class="n">usbtest_param</span> <span class="p">{</span>
	<span class="cm">/* inputs */</span>
	<span class="kt">unsigned</span>		<span class="n">test_num</span><span class="p">;</span>	<span class="cm">/* 0..(TEST_CASES-1) */</span>
	<span class="kt">unsigned</span>		<span class="n">iterations</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">vary</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">sglen</span><span class="p">;</span>

	<span class="cm">/* outputs */</span>
	<span class="k">struct</span> <span class="n">timeval</span>		<span class="n">duration</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define USBTEST_REQUEST	_IOWR(&#39;U&#39;, 100, struct usbtest_param)</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define	GENERIC		</span><span class="cm">/* let probe() bind using module params */</span><span class="cp"></span>

<span class="cm">/* Some devices that can be used for testing will have &quot;real&quot; drivers.</span>
<span class="cm"> * Entries for those need to be enabled here by hand, after disabling</span>
<span class="cm"> * that &quot;real&quot; driver.</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><h1>define    IBOT2       /* grab iBOT2 webcams */</h1>

<h1>define    KEYSPAN_19Qi    /* grab un-renumerated serial adapter */</h1></td><td class="code"><div class="highlight"><pre><span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">struct</span> <span class="n">usbtest_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ep_in</span><span class="p">;</span>		<span class="cm">/* bulk/intr source */</span>
	<span class="n">u8</span>			<span class="n">ep_out</span><span class="p">;</span>		<span class="cm">/* bulk/intr sink */</span>
	<span class="kt">unsigned</span>		<span class="n">autoconf</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">ctrl_out</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">iso</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* try iso in/out */</span>
	<span class="kt">int</span>			<span class="n">alt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* this is accessed only through usbfs ioctl calls.</span>
<span class="cm"> * one ioctl to issue a test ... one lock per device.</span>
<span class="cm"> * tests create other threads if they need them.</span>
<span class="cm"> * urbs and buffers are allocated dynamically,</span>
<span class="cm"> * and data generated deterministically.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbtest_info</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">in_pipe</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">out_pipe</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">in_iso_pipe</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">out_iso_pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>	<span class="o">*</span><span class="n">iso_in</span><span class="p">,</span> <span class="o">*</span><span class="n">iso_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">lock</span><span class="p">;</span>

<span class="cp">#define TBUF_SIZE	256</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="nf">testdev_to_usbdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* set up all urbs so they can be used with either bulk or interrupt */</span>
<span class="cp">#define	INTERRUPT_RATE		1	</span><span class="cm">/* msec/transfer */</span><span class="cp"></span>

<span class="cp">#define ERROR(tdev, fmt, args...) \</span>
<span class="cp">	dev_err(&amp;(tdev)-&gt;intf-&gt;dev , fmt , ## args)</span>
<span class="cp">#define WARNING(tdev, fmt, args...) \</span>
<span class="cp">	dev_warn(&amp;(tdev)-&gt;intf-&gt;dev , fmt , ## args)</span>

<span class="cp">#define GUARD_BYTE	0xA5</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">get_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>				<span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span>	<span class="o">*</span><span class="n">alt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">iso_in</span><span class="p">,</span> <span class="o">*</span><span class="n">iso_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>		<span class="o">*</span><span class="n">udev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span> <span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">ep</span><span class="p">;</span>

		<span class="n">in</span> <span class="o">=</span> <span class="n">out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iso_in</span> <span class="o">=</span> <span class="n">iso_out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">alt</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/* take the first altsetting with in-bulk + out-bulk;</span>
<span class="cm">		 * ignore other endpoints and altsettings.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ep</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">ep</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">e</span><span class="p">;</span>

			<span class="n">e</span> <span class="o">=</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span> <span class="o">+</span> <span class="n">ep</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iso</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">try_iso</span><span class="p">;</span>
				<span class="cm">/* FALLTHROUGH */</span>
			<span class="nl">default:</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">)</span>
					<span class="n">in</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span>
					<span class="n">out</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="nl">try_iso:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iso_in</span><span class="p">)</span>
					<span class="n">iso_in</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iso_out</span><span class="p">)</span>
					<span class="n">iso_out</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">in</span> <span class="o">&amp;&amp;</span> <span class="n">out</span><span class="p">)</span>  <span class="o">||</span>  <span class="n">iso_in</span> <span class="o">||</span> <span class="n">iso_out</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
				<span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
				<span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">in</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">out</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iso_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iso_in</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iso_in</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_iso_pipe</span> <span class="o">=</span> <span class="n">usb_rcvisocpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
				<span class="n">iso_in</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span>
					<span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iso_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iso_out</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iso_out</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_iso_pipe</span> <span class="o">=</span> <span class="n">usb_sndisocpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
				<span class="n">iso_out</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span>
					<span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Support for testing basic non-queued I/O streams.</span>
<span class="cm"> *</span>
<span class="cm"> * These just package urbs as requests that can be easily canceled.</span>
<span class="cm"> * Each urb&#39;s data buffer is dynamically allocated; callers can fill</span>
<span class="cm"> * them with non-zero test data (or test for it) when appropriate.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">simple_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">usbtest_alloc_urb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pipe</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bytes</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">transfer_flags</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">simple_callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
			<span class="o">?</span> <span class="p">(</span><span class="n">INTERRUPT_RATE</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">INTERRUPT_RATE</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">transfer_flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">)</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">bytes</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bytes</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* To test unaligned transfers add an offset and fill the</span>
<span class="cm">		unused memory with a guard value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">GUARD_BYTE</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For inbound transfers use guard byte so that test fails if</span>
<span class="cm">		data not correctly copied */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
			<span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="n">GUARD_BYTE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">simple_alloc_urb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pipe</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usbtest_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">pattern</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">mod_pattern</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">mod_pattern</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mod_pattern</span><span class="p">,</span> <span class="s">&quot;i/o pattern (0 == zeroes)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">simple_fill_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:			<span class="cm">/* mod63 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">63</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">buffer_offset</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ARCH_KMALLOC_MINALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_guard_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">guard</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">-</span> <span class="n">buffer_offset</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">guard</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">guard</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">guard</span> <span class="o">!=</span> <span class="n">GUARD_BYTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;guard byte[%d] %d (not %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">guard</span><span class="p">,</span> <span class="n">GUARD_BYTE</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">simple_check_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">expected</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">check_guard_bytes</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">buf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* all-zeroes has no synchronization issues */</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* mod63 stays in sync with short-terminated transfers,</span>
<span class="cm">		 * or otherwise when host and gadget agree on how large</span>
<span class="cm">		 * each usb transfer request should be.  resync is done</span>
<span class="cm">		 * with set_interface or set_config.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="mi">1</span>:			<span class="cm">/* mod63 */</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">63</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* always fail unsupported patterns */</span>
		<span class="nl">default:</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="o">!*</span><span class="n">buf</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;buf[%d] = %d (not %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">simple_free_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">buffer_offset</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">)</span>
		<span class="n">usb_free_coherent</span><span class="p">(</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">simple_io</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span>	<span class="o">*</span><span class="n">tdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">iterations</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">vary</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">expected</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">label</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">completion</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">completion</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iterations</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completion</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">simple_fill_buf</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_ZERO_PACKET</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* NOTE:  no timeouts; can&#39;t be broken out of by interrupt */</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completion</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_check_buf</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vary</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">+=</span> <span class="n">vary</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">%=</span> <span class="n">max</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">vary</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="o">?</span> <span class="n">vary</span> <span class="o">:</span> <span class="n">max</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* FIXME if endpoint halted, clear halt (and log) */</span>
	<span class="p">}</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">expected</span> <span class="o">!=</span> <span class="n">retval</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s failed, iterations left %d, status %d (not %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">label</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* We use scatterlist primitives to test queued I/O.</span>
<span class="cm"> * Yes, this also tests the scatterlist primitives.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sg_virt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span>
<span class="nf">alloc_sglist</span><span class="p">(</span><span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">size</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">kmalloc_array</span><span class="p">(</span><span class="n">nents</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span>		<span class="o">*</span><span class="n">buf</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="n">j</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_sglist</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* kmalloc pages are always physically contiguous! */</span>
		<span class="n">sg_set_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="cm">/* already zeroed */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">63</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vary</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">vary</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">%=</span> <span class="n">max</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">vary</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="o">?</span> <span class="n">vary</span> <span class="o">:</span> <span class="n">max</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perform_sglist</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span>	<span class="o">*</span><span class="n">tdev</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">iterations</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pipe</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_sg_request</span>	<span class="o">*</span><span class="n">req</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">nents</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">tdev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iterations</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_sg_init</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
				<span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
					<span class="o">?</span> <span class="p">(</span><span class="n">INTERRUPT_RATE</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
					<span class="o">:</span> <span class="n">INTERRUPT_RATE</span><span class="p">,</span>
				<span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">usb_sg_wait</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

		<span class="cm">/* FIXME check resulting data pattern */</span>

		<span class="cm">/* FIXME if endpoint halted, clear halt (and log) */</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME for unlink or fault handling tests, don&#39;t report</span>
<span class="cm">	 * failure if retval is as we expected ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;perform_sglist failed, &quot;</span>
				<span class="s">&quot;iterations left %d, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">iterations</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* unqueued control message testing</span>
<span class="cm"> *</span>
<span class="cm"> * there&#39;s a nice set of device functional requirements in chapter 9 of the</span>
<span class="cm"> * usb 2.0 spec, which we can apply to ANY device, even ones that don&#39;t use</span>
<span class="cm"> * special test firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * we know the device is configured (or suspended) by the time it&#39;s visible</span>
<span class="cm"> * through usbfs.  we can&#39;t change that, so we won&#39;t test enumeration (which</span>
<span class="cm"> * worked &#39;well enough&#39; to get here, this time), power management (ditto),</span>
<span class="cm"> * or remote wakeup (which needs human interaction).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">realworld</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">realworld</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">realworld</span><span class="p">,</span> <span class="s">&quot;clear to demand stricter spec compliance&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_altsetting</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_GET_INTERFACE</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="o">|</span><span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_altsetting</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alternate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>		<span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>		<span class="o">*</span><span class="n">udev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alternate</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">alternate</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
			<span class="n">alternate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_good_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_config_descriptor</span>	<span class="o">*</span><span class="n">config</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">config</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">config</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_config_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">tdev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_DT_CONFIG</span>:
	<span class="k">case</span> <span class="n">USB_DT_OTHER_SPEED_CONFIG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">!=</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;bogus config descriptor length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* this bit &#39;must be 1&#39; but often isn&#39;t */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realworld</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;high bit of config attributes not set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* reserved == 0 */</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;reserved config bits set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">wTotalLength</span><span class="p">)</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>	<span class="cm">/* read it all */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">wTotalLength</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TBUF_SIZE</span><span class="p">)</span>	<span class="cm">/* max partial read */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;bogus config descriptor read size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sanity test for standard requests working with usb_control_mesg() and some</span>
<span class="cm"> * of the utility functions which use it.</span>
<span class="cm"> *</span>
<span class="cm"> * this doesn&#39;t test how endpoint halts behave or data toggles get set, since</span>
<span class="cm"> * we won&#39;t do I/O to bulk/interrupt endpoints here (which is how to change</span>
<span class="cm"> * halt or toggle).  toggle testing is impractical without support from hcds.</span>
<span class="cm"> *</span>
<span class="cm"> * this avoids failing devices linux would normally work with, by not testing</span>
<span class="cm"> * config/altsetting operations for devices that only support their defaults.</span>
<span class="cm"> * such devices rarely support those needless operations.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE that since this is a sanity test, it&#39;s not examining boundary cases</span>
<span class="cm"> * to see if usbcore, hcd, and device all behave right.  such testing would</span>
<span class="cm"> * involve varied read sizes and other operation sequences.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ch9_postconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* [9.2.3] if there&#39;s more than one altsetting, we need to be able to</span>
<span class="cm">	 * set and get each one.  mostly trusts the descriptors from usbcore.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* 9.2.3 constrains the range here */</span>
		<span class="n">alt</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bAlternateSetting</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alt</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">alt</span> <span class="o">&gt;=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;invalid alt [%d].bAltSetting = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">alt</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* [real world] get/set unimplemented if there&#39;s only one */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">realworld</span> <span class="o">&amp;&amp;</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* [9.4.10] set_interface */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">set_altsetting</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">alt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t set_interface = %d, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">alt</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* [9.4.4] get_interface always works */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">get_altsetting</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">alt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;get alt should be %d, was %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">alt</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="cm">/* [real world] get_config unimplemented if there&#39;s only one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realworld</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bNumConfigurations</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">expected</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span><span class="p">;</span>

		<span class="cm">/* [9.4.2] get_configuration always works</span>
<span class="cm">		 * ... although some cheap devices (like one TI Hub I&#39;ve got)</span>
<span class="cm">		 * won&#39;t return config descriptors except before set_config.</span>
<span class="cm">		 */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">USB_REQ_GET_CONFIGURATION</span><span class="p">,</span>
				<span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;get config --&gt; %d %d (1 %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">retval</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expected</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* there&#39;s always [9.4.3] a device descriptor [9.6.1] */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_DT_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dev descriptor --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* there&#39;s always [9.4.3] at least one config descriptor [9.6.3] */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bNumConfigurations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_DT_CONFIG</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">TBUF_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_good_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">retval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;config [%d] descriptor --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* FIXME cross-checking udev-&gt;config[i] to make sure usbcore</span>
<span class="cm">		 * parsed it right (etc) would be good testing paranoia</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/* and sometimes [9.2.6.6] speed dependent descriptors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdUSB</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0200</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_qualifier_descriptor</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* device qualifier [9.6.2] */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
				<span class="n">USB_DT_DEVICE_QUALIFIER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_qualifier_descriptor</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;hs dev qualifier --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">retval</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* usb2.0 but not high-speed capable; fine */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_qualifier_descriptor</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dev qualifier --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_qualifier_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

		<span class="cm">/* might not have [9.6.2] any other-speed configs [9.6.4] */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">max</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">bNumConfigurations</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
					<span class="n">USB_DT_OTHER_SPEED_CONFIG</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">TBUF_SIZE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_good_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">retval</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;other speed config --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">retval</span><span class="p">);</span>
					<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME fetch strings from at least the device descriptor */</span>

	<span class="cm">/* [9.4.5] get_status always works */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;get dev status --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME configuration.bmAttributes says if we could try to set/clear</span>
<span class="cm">	 * the device&#39;s remote wakeup feature ... if we can, test that here</span>
<span class="cm">	 */</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
			<span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;get interface status --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME get status for each endpoint in the interface */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* use ch9 requests to test whether:</span>
<span class="cm"> *   (a) queues work for control, keeping N subtests queued and</span>
<span class="cm"> *       active (auto-resubmit) for M loops through the queue.</span>
<span class="cm"> *   (b) protocol stalls (control-only) will autorecover.</span>
<span class="cm"> *       it&#39;s not like bulk/intr; no halt clearing.</span>
<span class="cm"> *   (c) short control reads are reported and handled.</span>
<span class="cm"> *   (d) queues are always processed in-order</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ctrl_ctx</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">complete</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">pending</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">**</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbtest_param</span>	<span class="o">*</span><span class="n">param</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">last</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NUM_SUBCASES	15		</span><span class="cm">/* how many test subcases here? */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">subcase</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="n">setup</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">number</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">expected</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ctrl_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctrl_ctx</span>		<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="o">*</span><span class="n">reqp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subcase</span>		<span class="o">*</span><span class="n">subcase</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="n">reqp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">;</span>
	<span class="n">subcase</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">reqp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">subcase</span><span class="p">,</span> <span class="n">setup</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* queue must transfer and complete in fifo order, unless</span>
<span class="cm">	 * usb_unlink_urb() is used to unlink something not at the</span>
<span class="cm">	 * physical queue head (not tested).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;subcase %d completed out of order, last %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="cm">/* succeed or fault in only one way? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">subcase</span><span class="o">-&gt;</span><span class="n">expected</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* async unlink for cleanup? */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* some faults are allowed, not required */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subcase</span><span class="o">-&gt;</span><span class="n">expected</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span>
			  <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">subcase</span><span class="o">-&gt;</span><span class="n">expected</span>	<span class="cm">/* happened */</span>
			   <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))))</span>			<span class="cm">/* didn&#39;t */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* sometimes more than one fault is allowed */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;subtest %d error, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* unexpected status codes mean errors; ideally, in hardware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">error:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;control queue %02x.%02x, err %d, &quot;</span>
					<span class="s">&quot;%d left, subcase %d, len %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">reqp</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">,</span>
					<span class="n">status</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>

			<span class="cm">/* FIXME this &quot;unlink everything&quot; exit route should</span>
<span class="cm">			 * be a separate test case.</span>
<span class="cm">			 */</span>

			<span class="cm">/* unlink whatever&#39;s still pending */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">[</span>
							<span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">subcase</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">)</span>
							<span class="o">%</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">];</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">urb</span> <span class="o">||</span> <span class="o">!</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
				<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span>:
				<span class="k">case</span> <span class="o">-</span><span class="n">EIDRM</span>:
					<span class="k">continue</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="n">ERROR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;urb unlink --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">status</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* resubmit if we need to, else mark this as done */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;can&#39;t resubmit ctrl %02x.%02x, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">bRequestType</span><span class="p">,</span> <span class="n">reqp</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* signal completion when nothing&#39;s queued */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">test_ctrl_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbtest_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">**</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctrl_ctx</span>		<span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span> <span class="o">/</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">context</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">complete</span><span class="p">);</span>
	<span class="n">context</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">*</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">last</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* allocate and init the urbs we&#39;ll queue.</span>
<span class="cm">	 * as with bulk/intr sglists, sglen is the queue depth; it also</span>
<span class="cm">	 * controls which subtests run (more tests than sglen) or rerun.</span>
<span class="cm">	 */</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>			<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="kt">unsigned</span>		<span class="n">len</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">u</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="n">req</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">subcase</span>		<span class="o">*</span><span class="n">reqp</span><span class="p">;</span>

		<span class="cm">/* sign of this variable means:</span>
<span class="cm">		 *  -: tested code must return this (negative) error code</span>
<span class="cm">		 *  +: tested code may return this (negative too) error code</span>
<span class="cm">		 */</span>
		<span class="kt">int</span>			<span class="n">expected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* requests here are mostly expected to succeed on any</span>
<span class="cm">		 * device, but some are chosen to trigger protocol stalls</span>
<span class="cm">		 * or short reads.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_GET_DESCRIPTOR</span><span class="p">;</span>
		<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="o">|</span><span class="n">USB_RECIP_DEVICE</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">NUM_SUBCASES</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:		<span class="cm">/* get device descriptor */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USB_DT_DEVICE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_descriptor</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* get first config descriptor (only) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">USB_DT_CONFIG</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_config_descriptor</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:		<span class="cm">/* get altsetting (OFTEN STALLS) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_GET_INTERFACE</span><span class="p">;</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="o">|</span><span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
			<span class="cm">/* index = 0 means first interface */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:		<span class="cm">/* get interface status */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_GET_STATUS</span><span class="p">;</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="o">|</span><span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
			<span class="cm">/* interface 0 */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:		<span class="cm">/* get device status */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_GET_STATUS</span><span class="p">;</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="o">|</span><span class="n">USB_RECIP_DEVICE</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">5</span>:		<span class="cm">/* get device qualifier (MAY STALL) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span> <span class="p">(</span><span class="n">USB_DT_DEVICE_QUALIFIER</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_qualifier_descriptor</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
				<span class="n">expected</span> <span class="o">=</span> <span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">6</span>:		<span class="cm">/* get first config descriptor, plus interface */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">USB_DT_CONFIG</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_config_descriptor</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface_descriptor</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">7</span>:		<span class="cm">/* get interface descriptor (ALWAYS STALLS) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span> <span class="p">(</span><span class="n">USB_DT_INTERFACE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="cm">/* interface == 0 */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface_descriptor</span><span class="p">);</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* NOTE: two consecutive stalls in the queue here.</span>
<span class="cm">		 *  that tests fault recovery a bit more aggressively. */</span>
		<span class="k">case</span> <span class="mi">8</span>:		<span class="cm">/* clear endpoint halt (MAY STALL) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">;</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">;</span>
			<span class="cm">/* wValue 0 == ep halt */</span>
			<span class="cm">/* wIndex 0 == ep0 (shouldn&#39;t halt!) */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">9</span>:		<span class="cm">/* get endpoint status */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_GET_STATUS</span><span class="p">;</span>
			<span class="n">req</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span><span class="o">|</span><span class="n">USB_RECIP_ENDPOINT</span><span class="p">;</span>
			<span class="cm">/* endpoint 0 */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">10</span>:	<span class="cm">/* trigger short read (EREMOTEIO) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">USB_DT_CONFIG</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* NOTE: two consecutive _different_ faults in the queue. */</span>
		<span class="k">case</span> <span class="mi">11</span>:	<span class="cm">/* get endpoint descriptor (ALWAYS STALLS) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USB_DT_ENDPOINT</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="cm">/* endpoint == 0 */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface_descriptor</span><span class="p">);</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* NOTE: sometimes even a third fault in the queue! */</span>
		<span class="k">case</span> <span class="mi">12</span>:	<span class="cm">/* get string 0 descriptor (MAY STALL) */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USB_DT_STRING</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="cm">/* string == 0, for language IDs */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface_descriptor</span><span class="p">);</span>
			<span class="cm">/* may succeed when &gt; 4 languages */</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="n">EREMOTEIO</span><span class="p">;</span>	<span class="cm">/* or EPIPE, if no strings */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">13</span>:	<span class="cm">/* short read, resembling case 10 */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">USB_DT_CONFIG</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* last data packet &quot;should&quot; be DATA1, not DATA0 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">512</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">-</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bMaxPacketSize0</span><span class="p">;</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">14</span>:	<span class="cm">/* short read; try to fill the last packet */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">USB_DT_DEVICE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* device descriptor size == 18 bytes */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bMaxPacketSize0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">8</span>:
				<span class="n">len</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">16</span>:
				<span class="n">len</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">expected</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bogus number of ctrl queue testcases!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">context</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">req</span><span class="p">.</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
		<span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

		<span class="n">reqp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">reqp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reqp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
		<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">NUM_SUBCASES</span><span class="p">;</span>
		<span class="n">reqp</span><span class="o">-&gt;</span><span class="n">expected</span> <span class="o">=</span> <span class="n">expected</span><span class="p">;</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">setup_packet</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">reqp</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">;</span>

		<span class="n">u</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">;</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">ctrl_complete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* queue the urbs */</span>
	<span class="n">context</span><span class="p">.</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t submit urb[%d], status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">context</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
			<span class="n">context</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">pending</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">context</span><span class="p">.</span><span class="n">pending</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* FIXME  set timer and time out; provide a disconnect hook */</span>

	<span class="cm">/* wait for the last one to complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">pending</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">complete</span><span class="p">);</span>

<span class="nl">cleanup:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">);</span>
		<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">context</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#undef NUM_SUBCASES</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink1_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="cm">/* we &quot;know&quot; -EPIPE (stall) never happens */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlink1</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">async</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">completion</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completion</span><span class="p">);</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">completion</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">unlink1_callback</span><span class="p">;</span>

	<span class="cm">/* keep the endpoint busy.  there are lots of hc/hcd-internal</span>
<span class="cm">	 * states, and testing should get to all of them over time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME want additional tests for when endpoint is STALLing</span>
<span class="cm">	 * due to errors, or is just NAKing requests.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;submit fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* unlinking that should always work.  variable delay tests more</span>
<span class="cm">	 * hcd states and code paths, even with little other system load.</span>
<span class="cm">	 */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">INTERRUPT_RATE</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">completion_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completion</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span>:
			<span class="k">case</span> <span class="o">-</span><span class="n">EIDRM</span>:
				<span class="cm">/* we can&#39;t unlink urbs while they&#39;re completing</span>
<span class="cm">				 * or if they&#39;ve completed, and we haven&#39;t</span>
<span class="cm">				 * resubmitted. &quot;normal&quot; drivers would prevent</span>
<span class="cm">				 * resubmission, but since we&#39;re testing unlink</span>
<span class="cm">				 * paths, we can&#39;t.</span>
<span class="cm">				 */</span>
				<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unlink retry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;unlink fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completion</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">retval</span> <span class="o">-</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">||</span> <span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">)</span> <span class="o">?</span>
				<span class="mi">0</span> <span class="o">:</span> <span class="n">retval</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlink_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* test sync and async paths */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">unlink1</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">unlink1</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">struct</span> <span class="n">queued_ctx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">complete</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">pending</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">**</span><span class="n">urbs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_queued_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">queued_ctx</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]</span> <span class="o">||</span> <span class="n">urb</span> <span class="o">==</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="cm">/* What error should we report if the URB completed normally? */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

 <span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">))</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlink_queued</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">num</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">queued_ctx</span>	<span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">buf_dma</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">complete</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pending</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* One more than the actual value */</span>
	<span class="n">ctx</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">ctx</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Allocate and init the urbs we&#39;ll queue */</span>
	<span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">free_urbs</span><span class="p">;</span>
		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				<span class="n">unlink_queued_callback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">buf_dma</span><span class="p">;</span>
		<span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Submit all the URBs and then unlink URBs num - 4 and num - 2. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pending</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;submit urbs[%d] fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pending</span><span class="p">);</span>
			<span class="n">ctx</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">num</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]);</span>
		<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pending</span><span class="p">))</span>		<span class="cm">/* The extra count */</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">complete</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">complete</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

 <span class="nl">free_urbs:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">urbs</span><span class="p">);</span>
 <span class="nl">free_buf:</span>
	<span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_dma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">verify_not_halted</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* shouldn&#39;t look or act halted */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;ep %02x couldn&#39;t get no-halt status, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;ep %02x bogus status: %04x != 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">verify_halted</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* should look and act halted */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;ep %02x couldn&#39;t get halt status, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;ep %02x bogus status: %04x != 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">,</span> <span class="s">&quot;verify_still_halted&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* shouldn&#39;t look or act halted now */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">verify_not_halted</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* set halt (protocol test only), verify it worked */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_SET_FEATURE</span><span class="p">,</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">,</span>
			<span class="n">USB_ENDPOINT_HALT</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;ep %02x couldn&#39;t set halt, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">verify_halted</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* clear halt (tests API + protocol), verify it worked */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="s">&quot;ep %02x couldn&#39;t clear halt, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">verify_not_halted</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* NOTE:  could also verify SET_INTERFACE clear halts ... */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">halt_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">)</span> <span class="o">|</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_halt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_halt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Control OUT tests use the vendor control requests from Intel&#39;s</span>
<span class="cm"> * USB 2.0 compliance test device:  write a buffer, read it back.</span>
<span class="cm"> *</span>
<span class="cm"> * Intel&#39;s spec only _requires_ that it work for one packet, which</span>
<span class="cm"> * is pretty weak.   Some HCDs place limits here; most devices will</span>
<span class="cm"> * need to be able to handle more than one OUT data packet.  We&#39;ll</span>
<span class="cm"> * try whatever we&#39;re told to try.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ctrl_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">vary</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">what</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mh">0xffff</span> <span class="o">||</span> <span class="n">vary</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* NOTE:  hardware might well act differently if we pushed it</span>
<span class="cm">	 * with lots back-to-back queued requests.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* write patterned data */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="mh">0x5b</span><span class="p">,</span> <span class="n">USB_DIR_OUT</span><span class="o">|</span><span class="n">USB_TYPE_VENDOR</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">what</span> <span class="o">=</span> <span class="s">&quot;write&quot;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ctrl_out, wlen %d (expected %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">retval</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* read it back -- assuming nothing intervened!!  */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="mh">0x5c</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="o">|</span><span class="n">USB_TYPE_VENDOR</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">what</span> <span class="o">=</span> <span class="s">&quot;read&quot;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ctrl_out, rlen %d (expected %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">retval</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* fail if we can&#39;t verify */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ctrl_out, byte %d is %d not %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">j</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">what</span> <span class="o">=</span> <span class="s">&quot;verify&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">vary</span><span class="p">;</span>

		<span class="cm">/* [real world] the &quot;zero bytes IN&quot; case isn&#39;t really used.</span>
<span class="cm">		 * hardware can easily trip up in this weird case, since its</span>
<span class="cm">		 * status stage is IN, not OUT like other ep0in transfers.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">realworld</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ctrl_out %s failed, code %d, count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">what</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* ISO tests ... mimics common usage</span>
<span class="cm"> *  - buffer length is split into N packets (mostly maxpacket sized)</span>
<span class="cm"> *  - multi-buffers according to sglen</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">iso_context</span> <span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">pending</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">submit_error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">packet_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iso_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">packet_count</span> <span class="o">+=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">check_guard_bytes</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">errors</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">submit_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;iso resubmit err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">status</span><span class="p">);</span>
			<span class="cm">/* FALLTHROUGH */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:			<span class="cm">/* disconnected */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:		<span class="cm">/* endpoint disabled */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">submit_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;iso test, %lu errors out of %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">packet_count</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">iso_alloc_urb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pipe</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>	<span class="o">*</span><span class="n">desc</span><span class="p">,</span>
	<span class="kt">long</span>			<span class="n">bytes</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">offset</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">,</span> <span class="n">maxp</span><span class="p">,</span> <span class="n">packets</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="mh">0x7ff</span> <span class="o">&amp;</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">maxp</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">));</span>
	<span class="n">packets</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">maxp</span><span class="p">);</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="n">packets</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">=</span> <span class="n">packets</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">bytes</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
							<span class="n">GFP_KERNEL</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">GUARD_BYTE</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* For inbound transfers use guard byte so that test fails if</span>
<span class="cm">		data not correctly copied */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
			<span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="n">GUARD_BYTE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">bytes</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* here, only the last packet will be short */</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">maxp</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>

		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">maxp</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">iso_callback</span><span class="p">;</span>
	<span class="cm">/* urb-&gt;context = SET BY CALLER */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterval</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">URB_ISO_ASAP</span> <span class="o">|</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">test_iso_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbtest_param</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span>	<span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urbs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="cm">/* FIXME no limit */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">context</span><span class="p">);</span>
	<span class="n">context</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span> <span class="o">*</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">urbs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">urbs</span><span class="p">);</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;... iso period %d %sframes, wMaxPacket %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterval</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		<span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;micro&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iso_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span>
					<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">packets</span> <span class="o">+=</span> <span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
		<span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">packets</span> <span class="o">*=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;... total %lu msec (%lu packets)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">packets</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterval</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="o">/</span> <span class="p">((</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">packets</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">context</span><span class="p">.</span><span class="n">pending</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;submit iso[%d], error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">context</span><span class="p">.</span><span class="n">pending</span><span class="o">--</span><span class="p">;</span>
			<span class="n">context</span><span class="p">.</span><span class="n">submit_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Isochronous transfers are expected to fail sometimes.  As an</span>
<span class="cm">	 * arbitrary limit, we will report an error if any submissions</span>
<span class="cm">	 * fail or if the transfer failure rate is &gt; 10%.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">submit_error</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">errors</span> <span class="o">&gt;</span> <span class="n">context</span><span class="p">.</span><span class="n">packet_count</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urbs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_unaligned_bulk</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span> <span class="o">*</span><span class="n">tdev</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">iterations</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">transfer_flags</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usbtest_alloc_urb</span><span class="p">(</span>
		<span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">tdev</span><span class="p">),</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">transfer_flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">tdev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>
	<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* We only have this one interface to user space, through usbfs.</span>
<span class="cm"> * User mode code can scan usbfs to find N different devices (maybe on</span>
<span class="cm"> * different busses) to use when testing, and allocate one thread per</span>
<span class="cm"> * test.  So discovery is simplified, and we have no device naming issues.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t use these only as stress/load tests.  Use them along with with</span>
<span class="cm"> * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,</span>
<span class="cm"> * video capture, and so on.  Run different tests at different times, in</span>
<span class="cm"> * different sequences.  Nothing here should interact with other devices,</span>
<span class="cm"> * except indirectly by consuming USB bandwidth and CPU resources for test</span>
<span class="cm"> * threads and request completion.  But the only way to know that for sure</span>
<span class="cm"> * is to test when HC queues are in use by many devices.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING:  Because usbfs grabs udev-&gt;dev.sem before calling this ioctl(),</span>
<span class="cm"> * it locks out usbcore in certain code paths.  Notably, if you disconnect</span>
<span class="cm"> * the device-under-test, khubd will wait block forever waiting for the</span>
<span class="cm"> * ioctl to complete ... so that usb_disconnect() can abort the pending</span>
<span class="cm"> * urbs and then call usbtest_disconnect().  To abort a test, you&#39;re best</span>
<span class="cm"> * off just killing the userspace task and waiting for it to exit.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">usbtest_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">testdev_to_usbdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbtest_param</span>	<span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_sg_request</span>	<span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span>		<span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>

	<span class="cm">/* FIXME USBDEVFS_CONNECTINFO doesn&#39;t say how fast the device is. */</span>

	<span class="n">pattern</span> <span class="o">=</span> <span class="n">mod_pattern</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">!=</span> <span class="n">USBTEST_REQUEST</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>

	<span class="cm">/* FIXME: What if a system sleep starts while a test is running? */</span>

	<span class="cm">/* some devices, like ez-usb default devices, need a non-default</span>
<span class="cm">	 * altsetting to have any active endpoints.  some tests change</span>
<span class="cm">	 * altsettings; force a default so most tests don&#39;t need to check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">alt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">res</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">set_altsetting</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">alt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;set altsetting to %d failed, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">alt</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just a bunch of test cases that every HCD is expected to handle.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some may need specific firmware, though it&#39;d be good to have</span>
<span class="cm">	 * one firmware image to handle all the test cases.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME add more tests!  cancel requests, verify the data, control</span>
<span class="cm">	 * queueing, concurrent read+write threads, and so on.</span>
<span class="cm">	 */</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">test_num</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TEST 0:  NOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Simple non-queued bulk I/O tests */</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;TEST 1:  write %d bytes %u times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk sink (maybe accepts short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;test1&quot;</span><span class="p">);</span>
		<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;TEST 2:  read %d bytes %u times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk source (maybe generates short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;test2&quot;</span><span class="p">);</span>
		<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;TEST 3:  write/%d 0..%d bytes %u times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk sink (maybe accepts short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;test3&quot;</span><span class="p">);</span>
		<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;TEST 4:  read/%d 0..%d bytes %u times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">simple_alloc_urb</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk source (maybe generates short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_io</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;test4&quot;</span><span class="p">);</span>
		<span class="n">simple_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Queued bulk I/O tests */</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 5:  write %d sglists %d entries of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">alloc_sglist</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk sink (maybe accepts short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">perform_sglist</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="n">free_sglist</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">6</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 6:  read %d sglists %d entries of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">alloc_sglist</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk source (maybe generates short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">perform_sglist</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="n">free_sglist</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">7</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 7:  write/%d %d sglists %d entries 0..%d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">alloc_sglist</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk sink (maybe accepts short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">perform_sglist</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="n">free_sglist</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 8:  read/%d %d sglists %d entries 0..%d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">alloc_sglist</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIRMWARE:  bulk source (maybe generates short writes) */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">perform_sglist</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="n">free_sglist</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* non-queued sanity tests for control (chapter 9 subset) */</span>
	<span class="k">case</span> <span class="mi">9</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 9:  ch9 (subset) control tests, %d times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">;</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* NOP */</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ch9_postconfig</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ch9 subset failed, &quot;</span>
					<span class="s">&quot;iterations left %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* queued control messaging */</span>
	<span class="k">case</span> <span class="mi">10</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;TEST 10:  queue %d control calls, %d times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_ctrl_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* simple non-queued unlinks (ring with one urb) */</span>
	<span class="k">case</span> <span class="mi">11</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TEST 11:  unlink %d reads of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">;</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* NOP */</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">unlink_simple</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">,</span>
						<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unlink reads failed %d, &quot;</span>
				<span class="s">&quot;iterations left %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">12</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TEST 12:  unlink %d writes of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">;</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* NOP */</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">unlink_simple</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span>
						<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unlink writes failed %d, &quot;</span>
				<span class="s">&quot;iterations left %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* ep halt tests */</span>
	<span class="k">case</span> <span class="mi">13</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TEST 13:  set/clear %d halts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">;</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* NOP */</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">halt_simple</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;halts failed, iterations left %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* control write tests */</span>
	<span class="k">case</span> <span class="mi">14</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ctrl_out</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TEST 14:  %d ep0out, %d..%d vary %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">realworld</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ctrl_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* iso write tests */</span>
	<span class="k">case</span> <span class="mi">15</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_iso_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 15:  write %d iso, %d entries of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="cm">/* FIRMWARE:  iso sink */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_iso_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_iso_pipe</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iso_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* iso read tests */</span>
	<span class="k">case</span> <span class="mi">16</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_iso_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 16:  read %d iso, %d entries of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="cm">/* FIRMWARE:  iso source */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_iso_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_iso_pipe</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iso_in</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* FIXME scatterlist cancel (needs helper thread) */</span>

	<span class="cm">/* Tests for bulk I/O using DMA mapping by core and odd address */</span>
	<span class="k">case</span> <span class="mi">17</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 17:  write odd addr %d bytes %u times core map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_unaligned_bulk</span><span class="p">(</span>
				<span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;test17&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">18</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 18:  read odd addr %d bytes %u times core map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_unaligned_bulk</span><span class="p">(</span>
				<span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;test18&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Tests for bulk I/O using premapped coherent buffer and odd address */</span>
	<span class="k">case</span> <span class="mi">19</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 19:  write odd addr %d bytes %u times premapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_unaligned_bulk</span><span class="p">(</span>
				<span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">,</span> <span class="s">&quot;test19&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">20</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 20:  read odd addr %d bytes %u times premapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_unaligned_bulk</span><span class="p">(</span>
				<span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">,</span> <span class="s">&quot;test20&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* control write tests with unaligned buffer */</span>
	<span class="k">case</span> <span class="mi">21</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ctrl_out</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;TEST 21:  %d ep0out odd addr, %d..%d vary %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">realworld</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ctrl_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">vary</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* unaligned iso tests */</span>
	<span class="k">case</span> <span class="mi">22</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_iso_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 22:  write %d iso odd, %d entries of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_iso_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_iso_pipe</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iso_out</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">23</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_iso_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;TEST 23:  read %d iso odd, %d entries of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">test_iso_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_iso_pipe</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iso_in</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* unlink URBs from a bulk-OUT queue */</span>
	<span class="k">case</span> <span class="mi">24</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">||</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TEST 17:  unlink from %d queues of &quot;</span>
				<span class="s">&quot;%d %d-byte writes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">iterations</span><span class="p">;</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">unlink_queued</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">,</span>
						<span class="n">param</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;unlink queued writes failed %d, &quot;</span>
					<span class="s">&quot;iterations left %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">duration</span><span class="p">);</span>
	<span class="n">param</span><span class="o">-&gt;</span><span class="n">duration</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-=</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">param</span><span class="o">-&gt;</span><span class="n">duration</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-=</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">duration</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">duration</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">+=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">duration</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">force_interrupt</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">force_interrupt</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">force_interrupt</span><span class="p">,</span> <span class="s">&quot;0 = test default; else interrupt&quot;</span><span class="p">);</span>

<span class="cp">#ifdef	GENERIC</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vendor</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="s">&quot;vendor code (from usb-if)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">product</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="s">&quot;product code (from vendor)&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">usbtest_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbtest_info</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">rtest</span><span class="p">,</span> <span class="o">*</span><span class="n">wtest</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">irtest</span><span class="p">,</span> <span class="o">*</span><span class="n">iwtest</span><span class="p">;</span>

	<span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

<span class="cp">#ifdef	GENERIC</span>
	<span class="cm">/* specify devices by module parameters? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* vendor match required, product match optional */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vendor</span> <span class="o">||</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">vendor</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&amp;&amp;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">product</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;matched module params, &quot;</span>
					<span class="s">&quot;vend=0x%04x prod=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbtest_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>

	<span class="cm">/* cacheline-aligned scratch for i/o */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">TBUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE this doesn&#39;t yet test the handful of difference that are</span>
<span class="cm">	 * visible with high speed interrupts:  bigger maxpacket (1K) and</span>
<span class="cm">	 * &quot;high bandwidth&quot; modes (up to 3 packets/uframe).</span>
<span class="cm">	 */</span>
	<span class="n">rtest</span> <span class="o">=</span> <span class="n">wtest</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="n">irtest</span> <span class="o">=</span> <span class="n">iwtest</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force_interrupt</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">=</span> <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">);</span>
			<span class="n">rtest</span> <span class="o">=</span> <span class="s">&quot; intr-in&quot;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">=</span> <span class="n">usb_sndintpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">);</span>
			<span class="n">wtest</span> <span class="o">=</span> <span class="s">&quot; intr-out&quot;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">autoconf</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">get_endpoints</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WARNING</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t get endpoints, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">status</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* may find bulk or ISO pipes */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
							<span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span>
							<span class="n">info</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_pipe</span><span class="p">)</span>
			<span class="n">rtest</span> <span class="o">=</span> <span class="s">&quot; bulk-in&quot;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_pipe</span><span class="p">)</span>
			<span class="n">wtest</span> <span class="o">=</span> <span class="s">&quot; bulk-out&quot;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_iso_pipe</span><span class="p">)</span>
			<span class="n">irtest</span> <span class="o">=</span> <span class="s">&quot; iso-in&quot;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_iso_pipe</span><span class="p">)</span>
			<span class="n">iwtest</span> <span class="o">=</span> <span class="s">&quot; iso-out&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s {control%s%s%s%s%s} tests%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usb_speed_string</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">),</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">ctrl_out</span> <span class="o">?</span> <span class="s">&quot; in/out&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">rtest</span><span class="p">,</span> <span class="n">wtest</span><span class="p">,</span>
			<span class="n">irtest</span><span class="p">,</span> <span class="n">iwtest</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">alt</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot; (+alt)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbtest_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbtest_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbtest_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbtest_dev</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Basic testing only needs a device that can source or sink bulk traffic.</span>
<span class="cm"> * Any device can test control transfers (default with GENERIC binding).</span>
<span class="cm"> *</span>
<span class="cm"> * Several entries work with the default EP0 implementation that&#39;s built</span>
<span class="cm"> * into EZ-USB chips.  There&#39;s a default vendor ID which can be overridden</span>
<span class="cm"> * by (very) small config EEPROMS, but otherwise all these devices act</span>
<span class="cm"> * identically until firmware is loaded:  only EP0 works.  It turns out</span>
<span class="cm"> * to be easy to make other endpoints work, without modifying that EP0</span>
<span class="cm"> * behavior.  For now, we expect that kind of firmware.</span>
<span class="cm"> */</span>

<span class="cm">/* an21xx or fx versions of ez-usb */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">ez1_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;EZ-USB device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_in</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_out</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* fx2 version of ez-usb */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">ez2_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;FX2 device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_in</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_out</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ezusb family device with dedicated usb test firmware,</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">fw_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;usb test device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_in</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_out</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">autoconf</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* iso and ctrl_out need autoconf */</span>
	<span class="p">.</span><span class="n">ctrl_out</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iso</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* iso_ep&#39;s are #8 in/out */</span>
<span class="p">};</span>

<span class="cm">/* peripheral running Linux and &#39;zero.c&#39; test firmware, or</span>
<span class="cm"> * its user-mode cousin. different versions of this use</span>
<span class="cm"> * different hardware with the same vendor/product codes.</span>
<span class="cm"> * host side MUST rely on the endpoint descriptors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">gz_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;Linux gadget zero&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">autoconf</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctrl_out</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">um_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;Linux user mode test driver&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">autoconf</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">um2_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;Linux user mode ISO test driver&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">autoconf</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iso</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef IBOT2</span>
<span class="cm">/* this is a nice source of high speed bulk data;</span>
<span class="cm"> * uses an FX2, with firmware provided in the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">ibot2_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;iBOT2 webcam&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_in</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef GENERIC</span>
<span class="cm">/* we can use any device to test control traffic */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usbtest_info</span> <span class="n">generic_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;Generic USB device&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alt</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>

	<span class="cm">/*-------------------------------------------------------------*/</span>

	<span class="cm">/* EZ-USB devices which download firmware to replace (or in our</span>
<span class="cm">	 * case augment) the default device implementation.</span>
<span class="cm">	 */</span>

	<span class="cm">/* generic EZ-USB FX controller */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0547</span><span class="p">,</span> <span class="mh">0x2235</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ez1_info</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* CY3671 development board with EZ-USB FX */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0547</span><span class="p">,</span> <span class="mh">0x0080</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ez1_info</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* generic EZ-USB FX2 controller (or development board) */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x04b4</span><span class="p">,</span> <span class="mh">0x8613</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ez2_info</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* re-enumerated usb test device firmware */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0xfff0</span><span class="p">,</span> <span class="mh">0xfff0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fw_info</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* &quot;Gadget Zero&quot; firmware runs under Linux */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0525</span><span class="p">,</span> <span class="mh">0xa4a0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gz_info</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* so does a user-mode variant */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0525</span><span class="p">,</span> <span class="mh">0xa4a4</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">um_info</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* ... and a user-mode variant that talks iso */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0525</span><span class="p">,</span> <span class="mh">0xa4a3</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">um2_info</span><span class="p">,</span>
	<span class="p">},</span>

<span class="cp">#ifdef KEYSPAN_19Qi</span>
	<span class="cm">/* Keyspan 19qi uses an21xx (original EZ-USB) */</span>
	<span class="cm">/* this does not coexist with the real Keyspan 19qi driver! */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x06cd</span><span class="p">,</span> <span class="mh">0x010b</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ez1_info</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>

	<span class="cm">/*-------------------------------------------------------------*/</span>

<span class="cp">#ifdef IBOT2</span>
	<span class="cm">/* iBOT2 makes a nice source of high speed bulk-in data */</span>
	<span class="cm">/* this does not coexist with a real iBOT2 driver! */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0b62</span><span class="p">,</span> <span class="mh">0x0059</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ibot2_info</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>

	<span class="cm">/*-------------------------------------------------------------*/</span>

<span class="cp">#ifdef GENERIC</span>
	<span class="cm">/* module params can specify devices to use for control tests */</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">generic_info</span><span class="p">,</span> <span class="p">},</span>
<span class="cp">#endif</span>

	<span class="cm">/*-------------------------------------------------------------*/</span>

	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">usbtest_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;usbtest&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">usbtest_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">usbtest_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">usbtest_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">usbtest_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">usbtest_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">usbtest_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef GENERIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vendor</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;params: vend=0x%04x prod=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">product</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">usb_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbtest_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">usbtest_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">usbtest_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbtest_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">usbtest_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;USB Core/HCD Testing Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
