<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › wusbcore › rh.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>rh.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Wireless USB Host Controller</span>
<span class="cm"> * Root Hub operations</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * We fake a root hub that has fake ports (as many as simultaneous</span>
<span class="cm"> * devices the Wireless USB Host Controller can deal with). For each</span>
<span class="cm"> * port we keep an state in @wusbhc-&gt;port[index] identical to the one</span>
<span class="cm"> * specified in the USB2.0[ch11] spec and some extra device</span>
<span class="cm"> * information that complements the one in &#39;struct usb_device&#39; (as</span>
<span class="cm"> * this lacs a hcpriv pointer).</span>
<span class="cm"> *</span>
<span class="cm"> * Note this is common to WHCI and HWA host controllers.</span>
<span class="cm"> *</span>
<span class="cm"> * Through here we enable most of the state changes that the USB stack</span>
<span class="cm"> * will use to connect or disconnect devices. We need to do some</span>
<span class="cm"> * forced adaptation of Wireless USB device states vs. wired:</span>
<span class="cm"> *</span>
<span class="cm"> *        USB:                 WUSB:</span>
<span class="cm"> *</span>
<span class="cm"> * Port   Powered-off          port slot n/a</span>
<span class="cm"> *        Powered-on           port slot available</span>
<span class="cm"> *        Disconnected         port slot available</span>
<span class="cm"> *        Connected            port slot assigned device</span>
<span class="cm"> *        		       device sent DN_Connect</span>
<span class="cm"> *                             device was authenticated</span>
<span class="cm"> *        Enabled              device is authenticated, transitioned</span>
<span class="cm"> *                             from unauth -&gt; auth -&gt; default address</span>
<span class="cm"> *                             -&gt; enabled</span>
<span class="cm"> *        Reset                disconnect</span>
<span class="cm"> *        Disable              disconnect</span>
<span class="cm"> *</span>
<span class="cm"> * This maps the standard USB port states with the WUSB device states</span>
<span class="cm"> * so we can fake ports without having to modify the USB stack.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: this process will change in the future</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * ENTRY POINTS</span>
<span class="cm"> *</span>
<span class="cm"> * Our entry points into here are, as in hcd.c, the USB stack root hub</span>
<span class="cm"> * ops defined in the usb_hcd struct:</span>
<span class="cm"> *</span>
<span class="cm"> * wusbhc_rh_status_data()	Provide hub and port status data bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * wusbhc_rh_control()          Execution of all the major requests</span>
<span class="cm"> *                              you can do to a hub (Set|Clear</span>
<span class="cm"> *                              features, get descriptors, status, etc).</span>
<span class="cm"> *</span>
<span class="cm"> * wusbhc_rh_[suspend|resume]() That</span>
<span class="cm"> *</span>
<span class="cm"> * wusbhc_rh_start_port_reset() ??? unimplemented</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;wusbhc.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Reset a fake port</span>
<span class="cm"> *</span>
<span class="cm"> * Using a Reset Device IE is too heavyweight as it causes the device</span>
<span class="cm"> * to enter the UnConnected state and leave the cluster, this can mean</span>
<span class="cm"> * that when the device reconnects it is connected to a different fake</span>
<span class="cm"> * port.</span>
<span class="cm"> *</span>
<span class="cm"> * Instead, reset authenticated devices with a SetAddress(0), followed</span>
<span class="cm"> * by a SetAddresss(AuthAddr).</span>
<span class="cm"> *</span>
<span class="cm"> * For unauthenticated devices just pretend to reset but do nothing.</span>
<span class="cm"> * If the device initialization continues to fail it will eventually</span>
<span class="cm"> * time out after TrustTimeout and enter the UnConnected state.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * Supposedly we are the only thread accesing @wusbhc-&gt;port; in any</span>
<span class="cm"> * case, maybe we should move the mutex locking from</span>
<span class="cm"> * wusbhc_devconnect_auth() to here.</span>
<span class="cm"> *</span>
<span class="cm"> * @port_idx refers to the wusbhc&#39;s port index, not the USB port number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusbhc_rh_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_RESET</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">change</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_RESET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">WUSB_DEV_ADDR_UNAUTH</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_dev_update_address</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_RESET</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">change</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_RESET</span> <span class="o">|</span> <span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">;</span>	

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the hub change status bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * The bits in the change status bitmap are cleared when a</span>
<span class="cm"> * ClearPortFeature request is issued (USB2.0[11.12.3,11.12.4].</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING!! This gets called from atomic context; we cannot get the</span>
<span class="cm"> *           mutex--the only race condition we can find is some bit</span>
<span class="cm"> *           changing just after we copy it, which shouldn&#39;t be too</span>
<span class="cm"> *           big of a problem [and we can&#39;t make it an spinlock</span>
<span class="cm"> *           because other parts need to take it and sleep] .</span>
<span class="cm"> *</span>
<span class="cm"> *           @usb_hcd is refcounted, so it won&#39;t disappear under us</span>
<span class="cm"> *           and before killing a host, the polling of the root hub</span>
<span class="cm"> *           would be stopped anyway.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusbhc_rh_status_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">usb_hcd_to_wusbhc</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">_buf</span><span class="p">;</span>

	<span class="cm">/* WE DON&#39;T LOCK, see comment */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span> <span class="o">+</span> <span class="mi">1</span> <span class="cm">/* hub bit */</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* round to bytes */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">change</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wusbhc_rh_status_data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return the hub&#39;s descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: almost cut and paste from ehci-hub.c</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusbhc_rh_get_hub_descr</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span>
				   <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wLength</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">descr</span><span class="o">-&gt;</span><span class="n">bDescLength</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">descr</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>	<span class="cm">/* HUB type */</span>
	<span class="n">descr</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span>
	<span class="n">descr</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span>
		<span class="mh">0x00</span>			<span class="cm">/* All ports power at once */</span>
		<span class="o">|</span> <span class="mh">0x00</span>			<span class="cm">/* not part of compound device */</span>
		<span class="o">|</span> <span class="mh">0x10</span>			<span class="cm">/* No overcurrent protection */</span>
		<span class="o">|</span> <span class="mh">0x00</span>			<span class="cm">/* 8 FS think time FIXME ?? */</span>
		<span class="o">|</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="cm">/* No port indicators */</span>
	<span class="n">descr</span><span class="o">-&gt;</span><span class="n">bPwrOn2PwrGood</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">descr</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="n">temp</span><span class="p">],</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear a hub feature</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * Nothing to do, so no locking needed ;)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusbhc_rh_clear_hub_feat</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">feature</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">C_HUB_LOCAL_POWER</span>:
		<span class="cm">/* FIXME: maybe plug bit 0 to the power input status,</span>
<span class="cm">		 * if any?</span>
<span class="cm">		 * see wusbhc_rh_get_hub_status() */</span>
	<span class="k">case</span> <span class="n">C_HUB_OVER_CURRENT</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return hub status (it is always zero...)</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * Nothing to do, so no locking needed ;)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusbhc_rh_get_hub_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: maybe plug bit 0 to the power input status (if any)? */</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set a port feature</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusbhc_rh_set_port_feat</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">feature</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="n">selector</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port_idx</span> <span class="o">&gt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* According to USB2.0[11.24.2.13]p2, these features</span>
<span class="cm">		 * are not required to be implemented. */</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_ENABLE</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
		<span class="cm">/* No such thing, but we fake it works */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_POWER</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_RESET</span>:
		<span class="k">return</span> <span class="n">wusbhc_rh_port_reset</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_ENABLE</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(port_idx %d) set feat %d/%d UNIMPLEMENTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port_idx</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(port_idx %d) set feat %d/%d UNKNOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port_idx</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear a port feature...</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusbhc_rh_clear_port_feat</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">feature</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="n">selector</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port_idx</span> <span class="o">&gt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:	<span class="cm">/* fake port always on */</span>
		<span class="cm">/* According to USB2.0[11.24.2.7.1.4], no need to implement? */</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
		<span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">change</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_C_RESET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span>:
		<span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">change</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_ENABLE</span>:
		<span class="n">__wusbhc_dev_disable</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_ENABLE</span>:
		<span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">change</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span>:
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(port_idx %d) Clear feat %d/%d UNIMPLEMENTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port_idx</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(port_idx %d) Clear feat %d/%d UNKNOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port_idx</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the port&#39;s status</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusbhc_rh_get_port_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">port_idx</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="o">*</span><span class="n">_buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">_buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port_idx</span> <span class="o">&gt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">change</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Entry point for Root Hub operations</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc is assumed referenced and @wusbhc-&gt;mutex unlocked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusbhc_rh_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reqntype</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
		      <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">usb_hcd_to_wusbhc</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reqntype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_rh_get_hub_descr</span><span class="p">(</span>
			<span class="n">wusbhc</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ClearHubFeature</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_rh_clear_hub_feat</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wValue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubStatus</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_rh_get_hub_status</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SetPortFeature</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_rh_set_port_feat</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ClearPortFeature</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_rh_clear_port_feat</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
						   <span class="p">(</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetPortStatus</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_rh_get_port_status</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
						   <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SetHubFeature</span>:
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (%p [%p], %x, %x, %x, %p, %x) &quot;</span>
			<span class="s">&quot;UNIMPLEMENTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">wusbhc</span><span class="p">,</span> <span class="n">reqntype</span><span class="p">,</span>
			<span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
		<span class="cm">/* dump_stack(); */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wusbhc_rh_control</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wusbhc_rh_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">usb_hcd_to_wusbhc</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (%p [%p]) UNIMPLEMENTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">usb_hcd</span><span class="p">,</span> <span class="n">wusbhc</span><span class="p">);</span>
	<span class="cm">/* dump_stack(); */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wusbhc_rh_suspend</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wusbhc_rh_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">usb_hcd_to_wusbhc</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (%p [%p]) UNIMPLEMENTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">usb_hcd</span><span class="p">,</span> <span class="n">wusbhc</span><span class="p">);</span>
	<span class="cm">/* dump_stack(); */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wusbhc_rh_resume</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wusbhc_rh_start_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">usb_hcd_to_wusbhc</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (%p [%p], port_idx %u) UNIMPLEMENTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wusbhc_rh_start_port_reset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusb_port_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Alloc fake port specific fields and status.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusbhc_rh_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">port_size</span><span class="p">,</span> <span class="n">itr</span><span class="p">;</span>
	<span class="n">port_size</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">port_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_port_alloc</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">itr</span> <span class="o">&lt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span>
		<span class="n">wusb_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">itr</span><span class="p">]);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_port_alloc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wusbhc_rh_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
