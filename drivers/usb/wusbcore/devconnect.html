<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › wusbcore › devconnect.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>devconnect.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * WUSB Wire Adapter: Control/Data Streaming Interface (WUSB[8])</span>
<span class="cm"> * Device Connect handling</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: docs</span>
<span class="cm"> * FIXME: this file needs to be broken up, it&#39;s grown too big</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * WUSB1.0[7.1, 7.5.1, ]</span>
<span class="cm"> *</span>
<span class="cm"> * WUSB device connection is kind of messy. Some background:</span>
<span class="cm"> *</span>
<span class="cm"> *     When a device wants to connect it scans the UWB radio channels</span>
<span class="cm"> *     looking for a WUSB Channel; a WUSB channel is defined by MMCs</span>
<span class="cm"> *     (Micro Managed Commands or something like that) [see</span>
<span class="cm"> *     Design-overview for more on this] .</span>
<span class="cm"> *</span>
<span class="cm"> * So, device scans the radio, finds MMCs and thus a host and checks</span>
<span class="cm"> * when the next DNTS is. It sends a Device Notification Connect</span>
<span class="cm"> * (DN_Connect); the host picks it up (through nep.c and notif.c, ends</span>
<span class="cm"> * up in wusb_devconnect_ack(), which creates a wusb_dev structure in</span>
<span class="cm"> * wusbhc-&gt;port[port_number].wusb_dev), assigns an unauth address</span>
<span class="cm"> * to the device (this means from 0x80 to 0xfe) and sends, in the MMC</span>
<span class="cm"> * a Connect Ack Information Element (ConnAck IE).</span>
<span class="cm"> *</span>
<span class="cm"> * So now the device now has a WUSB address. From now on, we use</span>
<span class="cm"> * that to talk to it in the RPipes.</span>
<span class="cm"> *</span>
<span class="cm"> * ASSUMPTIONS:</span>
<span class="cm"> *</span>
<span class="cm"> *  - We use the the as device address the port number where it is</span>
<span class="cm"> *    connected (port 0 doesn&#39;t exist). For unauth, it is 128 + that.</span>
<span class="cm"> *</span>
<span class="cm"> * ROADMAP:</span>
<span class="cm"> *</span>
<span class="cm"> *   This file contains the logic for doing that--entry points:</span>
<span class="cm"> *</span>
<span class="cm"> *   wusb_devconnect_ack()      Ack a device until _acked() called.</span>
<span class="cm"> *                              Called by notif.c:wusb_handle_dn_connect()</span>
<span class="cm"> *                              when a DN_Connect is received.</span>
<span class="cm"> *</span>
<span class="cm"> *     wusb_devconnect_acked()  Ack done, release resources.</span>
<span class="cm"> *</span>
<span class="cm"> *   wusb_handle_dn_alive()     Called by notif.c:wusb_handle_dn()</span>
<span class="cm"> *                              for processing a DN_Alive pong from a device.</span>
<span class="cm"> *</span>
<span class="cm"> *   wusb_handle_dn_disconnect()Called by notif.c:wusb_handle_dn() to</span>
<span class="cm"> *                              process a disconenct request from a</span>
<span class="cm"> *                              device.</span>
<span class="cm"> *</span>
<span class="cm"> *   __wusb_dev_disable()       Called by rh.c:wusbhc_rh_clear_port_feat() when</span>
<span class="cm"> *                              disabling a port.</span>
<span class="cm"> *</span>
<span class="cm"> *   wusb_devconnect_create()   Called when creating the host by</span>
<span class="cm"> *                              lc.c:wusbhc_create().</span>
<span class="cm"> *</span>
<span class="cm"> *   wusb_devconnect_destroy()  Cleanup called removing the host. Called</span>
<span class="cm"> *                              by lc.c:wusbhc_destroy().</span>
<span class="cm"> *</span>
<span class="cm"> *   Each Wireless USB host maintains a list of DN_Connect requests</span>
<span class="cm"> *   (actually we maintain a list of pending Connect Acks, the</span>
<span class="cm"> *   wusbhc-&gt;ca_list).</span>
<span class="cm"> *</span>
<span class="cm"> * LIFE CYCLE OF port-&gt;wusb_dev</span>
<span class="cm"> *</span>
<span class="cm"> *   Before the @wusbhc structure put()s the reference it owns for</span>
<span class="cm"> *   port-&gt;wusb_dev [and clean the wusb_dev pointer], it needs to</span>
<span class="cm"> *   lock @wusbhc-&gt;mutex.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;wusbhc.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">wusbhc_devconnect_acked_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusb_dev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">set_gtk_req</span><span class="p">);</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">set_gtk_urb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="nf">wusb_dev_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wusb_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">devconnect_acked_work</span><span class="p">,</span> <span class="n">wusbhc_devconnect_acked_work</span><span class="p">);</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">set_gtk_urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">req</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">set_gtk_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_STANDARD</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_SET_DESCRIPTOR</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USB_DT_KEY</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">gtk_index</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">gtk</span><span class="p">.</span><span class="n">descr</span><span class="p">.</span><span class="n">bLength</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">wusb_dev</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">wusb_dev_free</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Using the Connect-Ack list, fill out the @wusbhc Connect-Ack WUSB IE</span>
<span class="cm"> * properly so that it can be added to the MMC.</span>
<span class="cm"> *</span>
<span class="cm"> * We just get the @wusbhc-&gt;ca_list and fill out the first four ones or</span>
<span class="cm"> * less (per-spec WUSB1.0[7.5, before T7-38). If the ConnectAck WUSB</span>
<span class="cm"> * IE is not allocated, we alloc it.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc-&gt;mutex must be taken</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusbhc_fill_cack_ie</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">dev_itr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wuie_connect_ack</span> <span class="o">*</span><span class="n">cack_ie</span><span class="p">;</span>

	<span class="n">cack_ie</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_ie</span><span class="p">;</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_itr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_list</span><span class="p">,</span> <span class="n">cack_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cack_ie</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">CDID</span> <span class="o">=</span> <span class="n">dev_itr</span><span class="o">-&gt;</span><span class="n">cdid</span><span class="p">;</span>
		<span class="n">cack_ie</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">bDeviceAddress</span> <span class="o">=</span> <span class="n">dev_itr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">WUIE_ELT_MAX</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cack_ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cack_ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cack_ie</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register a new device that wants to connect</span>
<span class="cm"> *</span>
<span class="cm"> * A new device wants to connect, so we add it to the Connect-Ack</span>
<span class="cm"> * list. We give it an address in the unauthorized range (bit 8 set);</span>
<span class="cm"> * user space will have to drive authorization further on.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev_addr: address to use for the device (which is also the port</span>
<span class="cm"> *            number).</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc-&gt;mutex must be taken</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="nf">wusbhc_cack_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">wusb_dn_connect</span> <span class="o">*</span><span class="n">dnc</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pr_cdid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_connection</span> <span class="o">=</span> <span class="n">wusb_dn_connect_new_connection</span><span class="p">(</span><span class="n">dnc</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">dev_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Is it registered already? */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_list</span><span class="p">,</span> <span class="n">cack_node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cdid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dnc</span><span class="o">-&gt;</span><span class="n">CDID</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cdid</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">wusb_dev</span><span class="p">;</span>
	<span class="cm">/* We don&#39;t have it, create an entry, register it */</span>
	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_dev_alloc</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wusb_dev_init</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cdid</span> <span class="o">=</span> <span class="n">dnc</span><span class="o">-&gt;</span><span class="n">CDID</span><span class="p">;</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">port_idx</span> <span class="o">=</span> <span class="n">port_idx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Devices are always available within the cluster reservation</span>
<span class="cm">	 * and since the hardware will take the intersection of the</span>
<span class="cm">	 * per-device availability and the cluster reservation, the</span>
<span class="cm">	 * per-device availability can simply be set to always</span>
<span class="cm">	 * available.</span>
<span class="cm">	 */</span>
	<span class="n">bitmap_fill</span><span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">availability</span><span class="p">.</span><span class="n">bm</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>

	<span class="cm">/* FIXME: handle reconnects instead of assuming connects are</span>
<span class="cm">	   always new. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">new_connection</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">new_connection</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_connection</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">port_idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">WUSB_DEV_ADDR_UNAUTH</span><span class="p">;</span>

		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Connecting new WUSB device to address %u, &quot;</span>
			<span class="s">&quot;port %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_addr</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_set_dev_addr</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">,</span> <span class="n">dev_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">entry_ts</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cack_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_list</span><span class="p">);</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">wusbhc_fill_cack_ie</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">wusb_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a Connect-Ack context entry from the HCs view</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc-&gt;mutex must be taken</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusbhc_cack_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cack_node</span><span class="p">);</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">wusbhc_fill_cack_ie</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @wusbhc-&gt;mutex must be taken */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">wusbhc_devconnect_acked</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wusbhc_cack_rm</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_count</span><span class="p">)</span>
		<span class="n">wusbhc_mmcie_set</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">wusbhc_mmcie_rm</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusbhc_devconnect_acked_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span><span class="p">,</span>
						 <span class="n">devconnect_acked_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">wusbhc_devconnect_acked</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">wusb_dev_put</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ack a device for connection</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: docs</span>
<span class="cm"> *</span>
<span class="cm"> * @pr_cdid:	Printable CDID...hex Use @dnc-&gt;cdid for the real deal.</span>
<span class="cm"> *</span>
<span class="cm"> * So we get the connect ack IE (may have been allocated already),</span>
<span class="cm"> * find an empty connect block, an empty virtual port, create an</span>
<span class="cm"> * address with it (see below), make it an unauth addr [bit 7 set] and</span>
<span class="cm"> * set the MMC.</span>
<span class="cm"> *</span>
<span class="cm"> * Addresses: because WUSB hosts have no downstream hubs, we can do a</span>
<span class="cm"> *            1:1 mapping between &#39;port number&#39; and device</span>
<span class="cm"> *            address. This simplifies many things, as during this</span>
<span class="cm"> *            initial connect phase the USB stack has no knoledge of</span>
<span class="cm"> *            the device and hasn&#39;t assigned an address yet--we know</span>
<span class="cm"> *            USB&#39;s choose_address() will use the same euristics we</span>
<span class="cm"> *            use here, so we can assume which address will be assigned.</span>
<span class="cm"> *</span>
<span class="cm"> *            USB stack always assigns address 1 to the root hub, so</span>
<span class="cm"> *            to the port number we add 2 (thus virtual port #0 is</span>
<span class="cm"> *            addr #2).</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc shall be referenced</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">wusbhc_devconnect_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dn_connect</span> <span class="o">*</span><span class="n">dnc</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pr_cdid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span> <span class="n">devnum</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="cm">/* Check we are not handling it already */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">wusb_dev</span>
		    <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dnc</span><span class="o">-&gt;</span><span class="n">CDID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cdid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dnc</span><span class="o">-&gt;</span><span class="n">CDID</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Look up those fake ports we have for a free one */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_POWER</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Host controller can&#39;t connect more devices &quot;</span>
			<span class="s">&quot;(%u already connected); device %s rejected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">,</span> <span class="n">pr_cdid</span><span class="p">);</span>
		<span class="cm">/* NOTE: we could send a WUIE_Disconnect here, but we haven&#39;t</span>
<span class="cm">		 *       event acked, so the device will eventually timeout the</span>
<span class="cm">		 *       connection, right? */</span>
		<span class="k">goto</span> <span class="n">error_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">devnum</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Make sure we are using no crypto on that &quot;virtual port&quot; */</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">set_ptk</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Grab a filled in Connect-Ack context, fill out the</span>
<span class="cm">	 * Connect-Ack Wireless USB IE, set the MMC */</span>
	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusbhc_cack_add</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">dnc</span><span class="p">,</span> <span class="n">pr_cdid</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unlock</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_mmcie_set</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unlock</span><span class="p">;</span>
	<span class="cm">/* Give the device at least 2ms (WUSB1.0[7.5.1p3]), let&#39;s do</span>
<span class="cm">	 * three for a good measure */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_dev</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">change</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span><span class="p">;</span>
	<span class="cm">/* Now the port status changed to connected; khubd will</span>
<span class="cm">	 * pick the change up and try to reset the port to bring it to</span>
<span class="cm">	 * the enabled state--so this process returns up to the stack</span>
<span class="cm">	 * and it calls back into wusbhc_rh_port_reset().</span>
<span class="cm">	 */</span>
<span class="nl">error_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disconnect a Wireless USB device from its fake port</span>
<span class="cm"> *</span>
<span class="cm"> * Marks the port as disconnected so that khubd can pick up the change</span>
<span class="cm"> * and drops our knowledge about the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes there is a device connected</span>
<span class="cm"> *</span>
<span class="cm"> * @port_index: zero based port number</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: @wusbhc-&gt;mutex is locked</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: From here it is not very safe to access anything hanging off</span>
<span class="cm"> *	    wusb_dev</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wusbhc_dev_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">wusb_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">USB_PORT_STAT_CONNECTION</span> <span class="o">|</span> <span class="n">USB_PORT_STAT_ENABLE</span>
			  <span class="o">|</span> <span class="n">USB_PORT_STAT_SUSPEND</span> <span class="o">|</span> <span class="n">USB_PORT_STAT_RESET</span>
			  <span class="o">|</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span> <span class="o">|</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">change</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">|</span> <span class="n">USB_PORT_STAT_C_ENABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;disconnecting device from port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">port_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cack_node</span><span class="p">))</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cack_node</span><span class="p">);</span>
		<span class="cm">/* For the one in cack_add() */</span>
		<span class="n">wusb_dev_put</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* After a device disconnects, change the GTK (see [WUSB]</span>
<span class="cm">	 * section 6.2.11.2). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="n">wusbhc_gtk_rekey</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>

	<span class="cm">/* The Wireless USB part has forgotten about the device already; now</span>
<span class="cm">	 * khubd&#39;s timer will pick up the disconnection and remove the USB</span>
<span class="cm">	 * device from the system</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Refresh the list of keep alives to emit in the MMC</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices don&#39;t respond to keep alives unless they&#39;ve been</span>
<span class="cm"> * authenticated, so skip unauthenticated devices.</span>
<span class="cm"> *</span>
<span class="cm"> * We only publish the first four devices that have a coming timeout</span>
<span class="cm"> * condition. Then when we are done processing those, we go for the</span>
<span class="cm"> * next ones. We ignore the ones that have timed out already (they&#39;ll</span>
<span class="cm"> * be purged).</span>
<span class="cm"> *</span>
<span class="cm"> * This might cause the first devices to timeout the last devices in</span>
<span class="cm"> * the port array...FIXME: come up with a better algorithm?</span>
<span class="cm"> *</span>
<span class="cm"> * Note we can&#39;t do much about MMC&#39;s ops errors; we hope next refresh</span>
<span class="cm"> * will kind of handle it.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: @wusbhc-&gt;mutex is locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wusbhc_keep_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_port</span> <span class="o">*</span><span class="n">wusb_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wuie_keep_alive</span> <span class="o">*</span><span class="n">ie</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_ie</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">keep_alives</span><span class="p">,</span> <span class="n">old_keep_alives</span><span class="p">;</span>

	<span class="n">old_keep_alives</span> <span class="o">=</span> <span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">keep_alives</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">keep_alives</span> <span class="o">&lt;</span> <span class="n">WUIE_ELT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span>
	     <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">tt</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">trust_timeout</span><span class="p">);</span>

		<span class="n">wusb_port</span> <span class="o">=</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_port</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">usb_dev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">authenticated</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">entry_ts</span> <span class="o">+</span> <span class="n">tt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;KEEPALIVE: device %u timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">__wusbhc_dev_disconnect</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_port</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">entry_ts</span> <span class="o">+</span> <span class="n">tt</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Approaching timeout cut out, need to refresh */</span>
			<span class="n">ie</span><span class="o">-&gt;</span><span class="n">bDeviceAddress</span><span class="p">[</span><span class="n">keep_alives</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keep_alives</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>	<span class="cm">/* pad to even number ([WUSB] section 7.5.9) */</span>
		<span class="n">ie</span><span class="o">-&gt;</span><span class="n">bDeviceAddress</span><span class="p">[</span><span class="n">keep_alives</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">keep_alives</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ie</span><span class="o">-&gt;</span><span class="n">bDeviceAddress</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keep_alives</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wusbhc_mmcie_set</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_keep_alives</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wusbhc_mmcie_rm</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do a run through all devices checking for timeouts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusbhc_keep_alive_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dw</span> <span class="o">=</span> <span class="n">to_delayed_work</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span>	<span class="n">container_of</span><span class="p">(</span><span class="n">dw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusbhc</span><span class="p">,</span> <span class="n">keep_alive_timer</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">__wusbhc_keep_alive</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">wusbd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_timer</span><span class="p">,</span>
			   <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">trust_timeout</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the wusb_dev from its device address.</span>
<span class="cm"> *</span>
<span class="cm"> * The device can be found directly from the address (see</span>
<span class="cm"> * wusb_cack_add() for where the device address is set to port_idx</span>
<span class="cm"> * +2), except when the address is zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="nf">wusbhc_find_dev_by_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="cm">/* unconnected */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">port</span> <span class="o">&gt;=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Look for the device with address 0. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">&amp;&amp;</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">wusb_dev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a DN_Alive notification (WUSB1.0[7.6.1])</span>
<span class="cm"> *</span>
<span class="cm"> * This just updates the device activity timestamp and then refreshes</span>
<span class="cm"> * the keep alive IE.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc shall be referenced and unlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusbhc_handle_dn_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">entry_ts</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">__wusbhc_keep_alive</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a DN_Connect notification (WUSB1.0[7.6.1])</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc</span>
<span class="cm"> * @pkt_hdr</span>
<span class="cm"> * @size:    Size of the buffer where the notification resides; if the</span>
<span class="cm"> *           notification data suggests there should be more data than</span>
<span class="cm"> *           available, an error will be signaled and the whole buffer</span>
<span class="cm"> *           consumed.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc-&gt;mutex shall be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusbhc_handle_dn_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">wusb_dn_hdr</span> <span class="o">*</span><span class="n">dn_hdr</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dn_connect</span> <span class="o">*</span><span class="n">dnc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">pr_cdid</span><span class="p">[</span><span class="n">WUSB_CKHDID_STRSIZE</span><span class="p">];</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">beacon_behaviour</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;reserved&quot;</span><span class="p">,</span>
		<span class="s">&quot;self-beacon&quot;</span><span class="p">,</span>
		<span class="s">&quot;directed-beacon&quot;</span><span class="p">,</span>
		<span class="s">&quot;no-beacon&quot;</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dnc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DN CONNECT: short notification (%zu &lt; %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dnc</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dnc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dn_hdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dn_connect</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">ckhdid_printf</span><span class="p">(</span><span class="n">pr_cdid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pr_cdid</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dnc</span><span class="o">-&gt;</span><span class="n">CDID</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DN CONNECT: device %s @ %x (%s) wants to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pr_cdid</span><span class="p">,</span>
		 <span class="n">wusb_dn_connect_prev_dev_addr</span><span class="p">(</span><span class="n">dnc</span><span class="p">),</span>
		 <span class="n">beacon_behaviour</span><span class="p">[</span><span class="n">wusb_dn_connect_beacon_behavior</span><span class="p">(</span><span class="n">dnc</span><span class="p">)],</span>
		 <span class="n">wusb_dn_connect_new_connection</span><span class="p">(</span><span class="n">dnc</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;connect&quot;</span> <span class="o">:</span> <span class="s">&quot;reconnect&quot;</span><span class="p">);</span>
	<span class="cm">/* ACK the connect */</span>
	<span class="n">wusbhc_devconnect_ack</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">dnc</span><span class="p">,</span> <span class="n">pr_cdid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a DN_Disconnect notification (WUSB1.0[7.6.1])</span>
<span class="cm"> *</span>
<span class="cm"> * Device is going down -- do the disconnect.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc shall be referenced and unlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusbhc_handle_dn_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DN DISCONNECT: device 0x%02x going down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">__wusbhc_dev_disconnect</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">port_idx</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a Device Notification coming a host</span>
<span class="cm"> *</span>
<span class="cm"> * The Device Notification comes from a host (HWA, DWA or WHCI)</span>
<span class="cm"> * wrapped in a set of headers. Somebody else has peeled off those</span>
<span class="cm"> * headers for us and we just get one Device Notifications.</span>
<span class="cm"> *</span>
<span class="cm"> * Invalid DNs (e.g., too short) are discarded.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc shall be referenced</span>
<span class="cm"> *</span>
<span class="cm"> * FIXMES:</span>
<span class="cm"> *  - implement priorities as in WUSB1.0[Table 7-55]?</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wusbhc_handle_dn</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">srcaddr</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">wusb_dn_hdr</span> <span class="o">*</span><span class="n">dn_hdr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dn_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DN data shorter than DN header (%d &lt; %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dn_hdr</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusbhc_find_dev_by_addr</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">srcaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">dn_hdr</span><span class="o">-&gt;</span><span class="n">bType</span> <span class="o">!=</span> <span class="n">WUSB_DN_CONNECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ignoring DN %d from unconnected device %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dn_hdr</span><span class="o">-&gt;</span><span class="n">bType</span><span class="p">,</span> <span class="n">srcaddr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dn_hdr</span><span class="o">-&gt;</span><span class="n">bType</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WUSB_DN_CONNECT</span>:
		<span class="n">wusbhc_handle_dn_connect</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">dn_hdr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WUSB_DN_ALIVE</span>:
		<span class="n">wusbhc_handle_dn_alive</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WUSB_DN_DISCONNECT</span>:
		<span class="n">wusbhc_handle_dn_disconnect</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WUSB_DN_MASAVAILCHANGED</span>:
	<span class="k">case</span> <span class="n">WUSB_DN_RWAKE</span>:
	<span class="k">case</span> <span class="n">WUSB_DN_SLEEP</span>:
		<span class="cm">/* FIXME: handle these DNs. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WUSB_DN_EPRDY</span>:
		<span class="cm">/* The hardware handles these. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown DN %u (%d octets) from %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">dn_hdr</span><span class="o">-&gt;</span><span class="n">bType</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="n">srcaddr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wusbhc_handle_dn</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Disconnect a WUSB device from a the cluster</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc</span>
<span class="cm"> * @port     Fake port where the device is (wusbhc index, not USB port number).</span>
<span class="cm"> *</span>
<span class="cm"> * In Wireless USB, a disconnect is basically telling the device he is</span>
<span class="cm"> * being disconnected and forgetting about him.</span>
<span class="cm"> *</span>
<span class="cm"> * We send the device a Device Disconnect IE (WUSB1.0[7.5.11]) for 100</span>
<span class="cm"> * ms and then keep going.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t do much in case of error; we always pretend we disabled</span>
<span class="cm"> * the port and disconnected the device. If physically the request</span>
<span class="cm"> * didn&#39;t get there (many things can fail in the way there), the stack</span>
<span class="cm"> * will reject the device&#39;s communication attempts.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc should be refcounted and locked</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wusbhc_dev_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wuie_disconnect</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>

	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* reset no device? ignore */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DISCONNECT: no device at port %u, ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port_idx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__wusbhc_dev_disconnect</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">));</span>

	<span class="n">ie</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ie</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ie</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ie</span><span class="p">);</span>
	<span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bIEIdentifier</span> <span class="o">=</span> <span class="n">WUIE_ID_DEVICE_DISCONNECT</span><span class="p">;</span>
	<span class="n">ie</span><span class="o">-&gt;</span><span class="n">bDeviceAddress</span> <span class="o">=</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_mmcie_set</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DISCONNECT: can&#39;t set MMC: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* At least 6 MMCs, assuming at least 1 MMC per zone. */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
		<span class="n">wusbhc_mmcie_rm</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ie</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ie</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk over the BOS descriptor, verify and grok it</span>
<span class="cm"> *</span>
<span class="cm"> * @usb_dev: referenced</span>
<span class="cm"> * @wusb_dev: referenced and unlocked</span>
<span class="cm"> *</span>
<span class="cm"> * The BOS descriptor is defined at WUSB1.0[7.4.1], and it defines a</span>
<span class="cm"> * &quot;flexible&quot; way to wrap all kinds of descriptors inside an standard</span>
<span class="cm"> * descriptor (wonder why they didn&#39;t use normal descriptors,</span>
<span class="cm"> * btw). Not like they lack code.</span>
<span class="cm"> *</span>
<span class="cm"> * At the end we go to look for the WUSB Device Capabilities</span>
<span class="cm"> * (WUSB1.0[7.4.1.1]) that is wrapped in a device capability descriptor</span>
<span class="cm"> * that is part of the BOS descriptor set. That tells us what does the</span>
<span class="cm"> * device support (dual role, beacon type, UWB PHY rates).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusb_dev_bos_grok</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">usb_bos_descriptor</span> <span class="o">*</span><span class="n">bos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">desc_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">itr</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>

	<span class="cm">/* Walk over BOS capabilities, verify them */</span>
	<span class="n">itr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bos</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bos</span><span class="p">);</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">itr</span> <span class="o">+</span> <span class="n">desc_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bos</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">itr</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_dev_cap_header</span> <span class="o">*</span><span class="n">cap_hdr</span> <span class="o">=</span> <span class="n">itr</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">cap_size</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">cap_type</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">itr</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cap_hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device BUG? premature end of BOS header &quot;</span>
				<span class="s">&quot;data [offset 0x%02x]: only %zu bytes left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">itr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bos</span><span class="p">),</span> <span class="n">top</span> <span class="o">-</span> <span class="n">itr</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_bad_cap</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cap_size</span> <span class="o">=</span> <span class="n">cap_hdr</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
		<span class="n">cap_type</span> <span class="o">=</span> <span class="n">cap_hdr</span><span class="o">-&gt;</span><span class="n">bDevCapabilityType</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap_size</span> <span class="o">&gt;</span> <span class="n">top</span> <span class="o">-</span> <span class="n">itr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device BUG? premature end of BOS data &quot;</span>
				<span class="s">&quot;[offset 0x%02x cap %02x %zu bytes]: &quot;</span>
				<span class="s">&quot;only %zu bytes left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">itr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bos</span><span class="p">),</span>
				<span class="n">cap_type</span><span class="p">,</span> <span class="n">cap_size</span><span class="p">,</span> <span class="n">top</span> <span class="o">-</span> <span class="n">itr</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_bad_cap</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cap_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_CAP_TYPE_WIRELESS_USB</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cap_size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusb_cap_descr</span><span class="p">))</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device BUG? WUSB Capability &quot;</span>
					<span class="s">&quot;descriptor is %zu bytes vs %zu &quot;</span>
					<span class="s">&quot;needed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cap_size</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusb_cap_descr</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusb_cap_descr</span> <span class="o">=</span> <span class="n">itr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG? Unknown BOS capability 0x%02x &quot;</span>
				<span class="s">&quot;(%zu bytes) at offset 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cap_type</span><span class="p">,</span>
				<span class="n">cap_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">itr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bos</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">itr</span> <span class="o">+=</span> <span class="n">cap_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_bad_cap:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add information from the BOS descriptors to the device</span>
<span class="cm"> *</span>
<span class="cm"> * @usb_dev: referenced</span>
<span class="cm"> * @wusb_dev: referenced and unlocked</span>
<span class="cm"> *</span>
<span class="cm"> * So what we do is we alloc a space for the BOS descriptor of 64</span>
<span class="cm"> * bytes; read the first four bytes which include the wTotalLength</span>
<span class="cm"> * field (WUSB1.0[T7-26]) and if it fits in those 64 bytes, read the</span>
<span class="cm"> * whole thing. If not we realloc to that size.</span>
<span class="cm"> *</span>
<span class="cm"> * Then we call the groking function, that will fill up</span>
<span class="cm"> * wusb_dev-&gt;wusb_cap_descr, which is what we&#39;ll need later on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusb_dev_bos_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_bos_descriptor</span> <span class="o">*</span><span class="n">bos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">desc_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">bos</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bos</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">USB_DT_BOS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bos</span><span class="p">,</span> <span class="n">desc_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get BOS descriptor or too short: %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_get_descriptor</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">desc_size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">wTotalLength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc_size</span> <span class="o">&gt;=</span> <span class="n">alloc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bos</span><span class="p">);</span>
		<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">desc_size</span><span class="p">;</span>
		<span class="n">bos</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bos</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">USB_DT_BOS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bos</span><span class="p">,</span> <span class="n">desc_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get  BOS descriptor or too short (need &quot;</span>
			<span class="s">&quot;%zu bytes): %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc_size</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_get_descriptor</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bos</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">wTotalLength</span><span class="p">)</span> <span class="o">!=</span> <span class="n">desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get  BOS descriptor or too short (need &quot;</span>
			<span class="s">&quot;%zu bytes): %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc_size</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_get_descriptor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_dev_bos_grok</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">,</span> <span class="n">bos</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_bad_bos</span><span class="p">;</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">bos</span> <span class="o">=</span> <span class="n">bos</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_bad_bos:</span>
<span class="nl">error_get_descriptor:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bos</span><span class="p">);</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusb_cap_descr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusb_dev_bos_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="p">);</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusb_cap_descr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_wireless_cap_descriptor</span> <span class="n">wusb_cap_descr_default</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wusb_cap_descr_default</span><span class="p">),</span>
	<span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="n">USB_DT_DEVICE_CAPABILITY</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bDevCapabilityType</span> <span class="o">=</span> <span class="n">USB_CAP_TYPE_WIRELESS_USB</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bmAttributes</span> <span class="o">=</span> <span class="n">USB_WIRELESS_BEACON_NONE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wPHYRates</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USB_WIRELESS_PHY_53</span><span class="p">),</span>
	<span class="p">.</span><span class="n">bmTFITXPowerInfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmFFITXPowerInfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmBandGroup</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">),</span>	<span class="cm">/* WUSB1.0[7.4.1] bottom */</span>
	<span class="p">.</span><span class="n">bReserved</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * USB stack&#39;s device addition Notifier Callback</span>
<span class="cm"> *</span>
<span class="cm"> * Called from drivers/usb/core/hub.c when a new device is added; we</span>
<span class="cm"> * use this hook to perform certain WUSB specific setup work on the</span>
<span class="cm"> * new device. As well, it is the first time we can connect the</span>
<span class="cm"> * wusb_dev and the usb_dev. So we note it down in wusb_dev and take a</span>
<span class="cm"> * reference that we&#39;ll drop.</span>
<span class="cm"> *</span>
<span class="cm"> * First we need to determine if the device is a WUSB device (else we</span>
<span class="cm"> * ignore it). For that we use the speed setting (USB_SPEED_WIRELESS)</span>
<span class="cm"> * [FIXME: maybe we&#39;d need something more definitive]. If so, we track</span>
<span class="cm"> * it&#39;s usb_busd and from there, the WUSB HC.</span>
<span class="cm"> *</span>
<span class="cm"> * Because all WUSB HCs are contained in a &#39;struct wusbhc&#39;, voila, we</span>
<span class="cm"> * get the wusbhc for the device.</span>
<span class="cm"> *</span>
<span class="cm"> * We have a reference on @usb_dev (as we are called at the end of its</span>
<span class="cm"> * enumeration).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: @usb_dev locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusb_dev_add_ncb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port_idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* skip non wusb and wusb RHs */</span>

	<span class="n">usb_set_device_state</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">USB_STATE_UNAUTHENTICATED</span><span class="p">);</span>

	<span class="n">wusbhc</span> <span class="o">=</span> <span class="n">wusbhc_get_by_usb_dev</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusbhc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_nodev</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">__wusb_dev_get_by_usb_dev</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">);</span>
	<span class="n">port_idx</span> <span class="o">=</span> <span class="n">wusb_port_no_to_idx</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_nodev</span><span class="p">;</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_dev_get</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_dev_sec_add</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot enable security: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_sec_add</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Now query the device for it&#39;s BOS and attach it to wusb_dev */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_dev_bos_add</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot get BOS descriptors: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_bos_add</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_dev_sysfs_add</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_add_sysfs</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">wusb_dev_put</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">wusbhc_put</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="nl">error_nodev:</span>
	<span class="k">return</span><span class="p">;</span>

	<span class="n">wusb_dev_sysfs_rm</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
<span class="nl">error_add_sysfs:</span>
	<span class="n">wusb_dev_bos_rm</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
<span class="nl">error_bos_add:</span>
	<span class="n">wusb_dev_sec_rm</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
<span class="nl">error_sec_add:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">__wusbhc_dev_disconnect</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Undo all the steps done at connection by the notifier callback</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: @usb_dev locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusb_dev_rm_ncb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* skip non wusb and wusb RHs */</span>

	<span class="n">wusb_dev_sysfs_rm</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">wusb_dev_bos_rm</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">wusb_dev_sec_rm</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wusb_dev_put</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle notifications from the USB stack (notifier call back)</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when the USB stack does a</span>
<span class="cm"> * usb_{bus,device}_{add,remove}() so we can do WUSB specific</span>
<span class="cm"> * handling. It is called with [for the case of</span>
<span class="cm"> * USB_DEVICE_{ADD,REMOVE} with the usb_dev locked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusb_usb_ncb</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_DEVICE_ADD</span>:
		<span class="n">wusb_dev_add_ncb</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_DEVICE_REMOVE</span>:
		<span class="n">wusb_dev_rm_ncb</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_BUS_ADD</span>:
		<span class="cm">/* ignore (for now) */</span>
	<span class="k">case</span> <span class="n">USB_BUS_REMOVE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">NOTIFY_BAD</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a referenced wusb_dev given a @wusbhc and @usb_dev</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="nf">__wusb_dev_get_by_usb_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port_idx</span><span class="p">;</span>

	<span class="n">port_idx</span> <span class="o">=</span> <span class="n">wusb_port_no_to_idx</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">port_idx</span> <span class="o">&gt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">);</span>
	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_port_by_idx</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">port_idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>		<span class="cm">/* ops, device is gone */</span>
		<span class="n">wusb_dev_get</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wusb_dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__wusb_dev_get_by_usb_dev</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">wusb_dev_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">_wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_wusb_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span><span class="p">,</span> <span class="n">refcnt</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">cack_node</span><span class="p">);</span>
	<span class="n">wusb_dev_free</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wusb_dev_destroy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create all the device connect handling infrastructure</span>
<span class="cm"> *</span>
<span class="cm"> * This is basically the device info array, Connect Acknowledgement</span>
<span class="cm"> * (cack) lists, keep-alive timers (and delayed work thread).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusbhc_devconnect_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">bIEIdentifier</span> <span class="o">=</span> <span class="n">WUIE_ID_KEEP_ALIVE</span><span class="p">;</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_timer</span><span class="p">,</span> <span class="n">wusbhc_keep_alive_run</span><span class="p">);</span>

	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">bIEIdentifier</span> <span class="o">=</span> <span class="n">WUIE_ID_CONNECTACK</span><span class="p">;</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_ie</span><span class="p">.</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">cack_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release all resources taken by the devconnect stuff</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wusbhc_devconnect_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* no op */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wusbhc_devconnect_start - start accepting device connections</span>
<span class="cm"> * @wusbhc: the WUSB HC</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the Host Info IE to accept all new connections.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: This also enables the keep alives but this is not necessary</span>
<span class="cm"> * until there are connected and authenticated devices.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusbhc_devconnect_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wuie_host_info</span> <span class="o">*</span><span class="n">hi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">hi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hi</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">hi</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span>       <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hi</span><span class="p">);</span>
	<span class="n">hi</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bIEIdentifier</span> <span class="o">=</span> <span class="n">WUIE_ID_HOST_INFO</span><span class="p">;</span>
	<span class="n">hi</span><span class="o">-&gt;</span><span class="n">attributes</span>        <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="n">WUIE_HI_CAP_ALL</span><span class="p">);</span>
	<span class="n">hi</span><span class="o">-&gt;</span><span class="n">CHID</span>              <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">chid</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc_mmcie_set</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot add Host Info MMCIE: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_mmcie_set</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">wuie_host_info</span> <span class="o">=</span> <span class="n">hi</span><span class="p">;</span>

	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">wusbd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_timer</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">trust_timeout</span><span class="o">*</span><span class="n">CONFIG_HZ</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_mmcie_set:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wusbhc_devconnect_stop - stop managing connected devices</span>
<span class="cm"> * @wusbhc: the WUSB HC</span>
<span class="cm"> *</span>
<span class="cm"> * Disconnects any devices still connected, stops the keep alives and</span>
<span class="cm"> * removes the Host Info IE.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wusbhc_devconnect_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">ports_max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wusb_dev</span><span class="p">)</span>
			<span class="n">__wusbhc_dev_disconnect</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">keep_alive_timer</span><span class="p">);</span>
	<span class="n">wusbhc_mmcie_rm</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">wuie_host_info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">wuie_host_info</span><span class="p">);</span>
	<span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">wuie_host_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wusb_set_dev_addr - set the WUSB device address used by the host</span>
<span class="cm"> * @wusbhc: the WUSB HC the device is connect to</span>
<span class="cm"> * @wusb_dev: the WUSB device</span>
<span class="cm"> * @addr: new device address</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusb_set_dev_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev_info_set</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device %d: failed to set device &quot;</span>
			<span class="s">&quot;address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">port_idx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device %d: %s addr %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">port_idx</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">WUSB_DEV_ADDR_UNAUTH</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;unauth&quot;</span> <span class="o">:</span> <span class="s">&quot;auth&quot;</span><span class="p">,</span>
			 <span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
