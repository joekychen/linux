<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › wusbcore › wa-xfer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>wa-xfer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * WUSB Wire Adapter</span>
<span class="cm"> * Data transfer and URB enqueing</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * How transfers work: get a buffer, break it up in segments (segment</span>
<span class="cm"> * size is a multiple of the maxpacket size). For each segment issue a</span>
<span class="cm"> * segment request (struct wa_xfer_*), then send the data buffer if</span>
<span class="cm"> * out or nothing if in (all over the DTO endpoint).</span>
<span class="cm"> *</span>
<span class="cm"> * For each submitted segment request, a notification will come over</span>
<span class="cm"> * the NEP endpoint and a transfer result (struct xfer_result) will</span>
<span class="cm"> * arrive in the DTI URB. Read it, get the xfer ID, see if there is</span>
<span class="cm"> * data coming (inbound transfer), schedule a read and handle it.</span>
<span class="cm"> *</span>
<span class="cm"> * Sounds simple, it is a pain to implement.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * ENTRY POINTS</span>
<span class="cm"> *</span>
<span class="cm"> *   FIXME</span>
<span class="cm"> *</span>
<span class="cm"> * LIFE CYCLE / STATE DIAGRAM</span>
<span class="cm"> *</span>
<span class="cm"> *   FIXME</span>
<span class="cm"> *</span>
<span class="cm"> * THIS CODE IS DISGUSTING</span>
<span class="cm"> *</span>
<span class="cm"> *   Warned you are; it&#39;s my second try and still not happy with it.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *</span>
<span class="cm"> *   - No iso</span>
<span class="cm"> *</span>
<span class="cm"> *   - Supports DMA xfers, control, bulk and maybe interrupt</span>
<span class="cm"> *</span>
<span class="cm"> *   - Does not recycle unused rpipes</span>
<span class="cm"> *</span>
<span class="cm"> *     An rpipe is assigned to an endpoint the first time it is used,</span>
<span class="cm"> *     and then it&#39;s there, assigned, until the endpoint is disabled</span>
<span class="cm"> *     (destroyed [{h,d}wahc_op_ep_disable()]. The assignment of the</span>
<span class="cm"> *     rpipe to the endpoint is done under the wa-&gt;rpipe_sem semaphore</span>
<span class="cm"> *     (should be a mutex).</span>
<span class="cm"> *</span>
<span class="cm"> *     Two methods it could be done:</span>
<span class="cm"> *</span>
<span class="cm"> *     (a) set up a timer every time an rpipe&#39;s use count drops to 1</span>
<span class="cm"> *         (which means unused) or when a transfer ends. Reset the</span>
<span class="cm"> *         timer when a xfer is queued. If the timer expires, release</span>
<span class="cm"> *         the rpipe [see rpipe_ep_disable()].</span>
<span class="cm"> *</span>
<span class="cm"> *     (b) when looking for free rpipes to attach [rpipe_get_by_ep()],</span>
<span class="cm"> *         when none are found go over the list, check their endpoint</span>
<span class="cm"> *         and their activity record (if no last-xfer-done-ts in the</span>
<span class="cm"> *         last x seconds) take it</span>
<span class="cm"> *</span>
<span class="cm"> *     However, due to the fact that we have a set of limited</span>
<span class="cm"> *     resources (max-segments-at-the-same-time per xfer,</span>
<span class="cm"> *     xfers-per-ripe, blocks-per-rpipe, rpipes-per-host), at the end</span>
<span class="cm"> *     we are going to have to rebuild all this based on an scheduler,</span>
<span class="cm"> *     to where we have a list of transactions to do and based on the</span>
<span class="cm"> *     availability of the different required components (blocks,</span>
<span class="cm"> *     rpipes, segment slots, etc), we go scheduling them. Painful.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &quot;wa-hc.h&quot;</span>
<span class="cp">#include &quot;wusbhc.h&quot;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">WA_SEGS_MAX</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">wa_seg_status</span> <span class="p">{</span>
	<span class="n">WA_SEG_NOTREADY</span><span class="p">,</span>
	<span class="n">WA_SEG_READY</span><span class="p">,</span>
	<span class="n">WA_SEG_DELAYED</span><span class="p">,</span>
	<span class="n">WA_SEG_SUBMITTED</span><span class="p">,</span>
	<span class="n">WA_SEG_PENDING</span><span class="p">,</span>
	<span class="n">WA_SEG_DTI_PENDING</span><span class="p">,</span>
	<span class="n">WA_SEG_DONE</span><span class="p">,</span>
	<span class="n">WA_SEG_ERROR</span><span class="p">,</span>
	<span class="n">WA_SEG_ABORTED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Life cycle governed by &#39;struct urb&#39; (the refcount of the struct is</span>
<span class="cm"> * that of the &#39;struct urb&#39; and usb_free_urb() would free the whole</span>
<span class="cm"> * struct).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wa_seg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">dto_urb</span><span class="p">;</span>		<span class="cm">/* for data output? */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>	<span class="cm">/* for rpipe-&gt;req_list */</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>		<span class="cm">/* out xfer */</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>			<span class="cm">/* which segment we are */</span>
	<span class="k">enum</span> <span class="n">wa_seg_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>			<span class="cm">/* bytes xfered or error */</span>
	<span class="k">struct</span> <span class="n">wa_xfer_hdr</span> <span class="n">xfer_hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">xfer_extra</span><span class="p">[];</span>		<span class="cm">/* xtra space for xfer_hdr_ctl */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_seg_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* usb_init_urb() repeats a lot of work, so we do it here */</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">.</span><span class="n">kref</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Protected by xfer-&gt;lock</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refcnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">;</span>		<span class="cm">/* Wire adapter we are plugged to */</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>		<span class="cm">/* URB we are transferring for */</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">**</span><span class="n">seg</span><span class="p">;</span>		<span class="cm">/* transfer segments */</span>
	<span class="n">u8</span> <span class="n">segs</span><span class="p">,</span> <span class="n">segs_submitted</span><span class="p">,</span> <span class="n">segs_done</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">is_inbound</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">is_dma</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">seg_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">;</span>			<span class="cm">/* allocation mask */</span>

	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>	<span class="cm">/* for activity timestamps */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wa_xfer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Destroy a transfer structure</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the xfer-&gt;seg[index] thingies follow the URB life cycle,</span>
<span class="cm"> * so we need to put them, not free them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">_xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_xfer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_xfer</span><span class="p">,</span> <span class="n">refcnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span><span class="p">)</span>
				<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="p">);</span>
			<span class="n">usb_put_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="n">wa_xfer_destroy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfer is referenced</span>
<span class="cm"> *</span>
<span class="cm"> * xfer-&gt;lock has to be unlocked</span>
<span class="cm"> *</span>
<span class="cm"> * We take xfer-&gt;lock for setting the result; this is a barrier</span>
<span class="cm"> * against drivers/usb/core/hcd.c:unlink1() being called after we call</span>
<span class="cm"> * usb_hcd_giveback_urb() and wa_urb_dequeue() trying to get a</span>
<span class="cm"> * reference to the transfer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_giveback</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* FIXME: segmentation broken -- kills DWA */</span>
	<span class="n">wusbhc_giveback_urb</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">wusb</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
	<span class="n">wa_put</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">);</span>
	<span class="n">wa_xfer_put</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfer is referenced</span>
<span class="cm"> *</span>
<span class="cm"> * xfer-&gt;lock has to be unlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">)</span>
		<span class="n">wusb_dev_put</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="n">rpipe_put</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="n">wa_xfer_giveback</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If transfer is done, wrap it up and return true</span>
<span class="cm"> *</span>
<span class="cm"> * xfer-&gt;lock has to be locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">__wa_xfer_is_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">found_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span> <span class="o">==</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_submitted</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seg</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">WA_SEG_DONE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">found_short</span> <span class="o">&amp;&amp;</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: bad short segments (%zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">xfer</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span>
			    <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">!=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">found_short</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: DONE short %d &quot;</span>
				<span class="s">&quot;result %zu urb-&gt;actual_length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">found_short</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WA_SEG_ERROR</span>:
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: ERROR result %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WA_SEG_ABORTED</span>:
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u ABORTED: result %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: is_done bad state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">xfer</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize a transfer&#39;s ID</span>
<span class="cm"> *</span>
<span class="cm"> * We need to use a sequential number; if we use the pointer or the</span>
<span class="cm"> * hash of the pointer, it can repeat over sequential transfers and</span>
<span class="cm"> * then it will confuse the HWA....wonder why in hell they put a 32</span>
<span class="cm"> * bit handle in there then.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_id_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_id_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the xfer&#39;s ID associated with xfer</span>
<span class="cm"> *</span>
<span class="cm"> * Need to generate a</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">wa_xfer_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search for a transfer list ID on the HCD&#39;s URB list</span>
<span class="cm"> *</span>
<span class="cm"> * For 32 bit architectures, we use the pointer itself; for 64 bits, a</span>
<span class="cm"> * 32-bit hash of the pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * @returns NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="nf">wa_xfer_get_by_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer_itr</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">xfer_itr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">xfer_itr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wa_xfer_get</span><span class="p">(</span><span class="n">xfer_itr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfer_itr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xfer_itr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">wa_xfer_abort_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer_abort</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wa_xfer_abort_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_xfer_abort_buffer</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">usb_put_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Aborts an ongoing transaction</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes the transfer is referenced and locked and in a submitted</span>
<span class="cm"> * state (mainly that there is an endpoint/rpipe assigned).</span>
<span class="cm"> *</span>
<span class="cm"> * The callback (see above) does nothing but freeing up the data by</span>
<span class="cm"> * putting the URB. Because the URB is allocated at the head of the</span>
<span class="cm"> * struct, the whole space we allocated is kfreed.</span>
<span class="cm"> *</span>
<span class="cm"> * We&#39;ll get an &#39;aborted transaction&#39; xfer result on DTI, that&#39;ll</span>
<span class="cm"> * politely ignore because at this point the transaction has been</span>
<span class="cm"> * marked as aborted already.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wa_xfer_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer_abort_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_kmalloc</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">bLength</span> <span class="o">=</span>  <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">WA_XFER_ABORT</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">wRPipe</span> <span class="o">=</span> <span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">dwTransferID</span> <span class="o">=</span> <span class="n">wa_xfer_id</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>

	<span class="n">usb_init_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span>
		<span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span>
				<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dto_epd</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">),</span> <span class="n">__wa_xfer_abort_cb</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_submit</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>				<span class="cm">/* callback frees! */</span>


<span class="nl">error_submit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p: Can&#39;t submit abort request: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="nl">error_kmalloc:</span>
	<span class="k">return</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * @returns &lt; 0 on error, transfer segment request size if ok</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__wa_xfer_setup_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">wa_xfer_type</span> <span class="o">*</span><span class="n">pxfer_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">maxpktsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bmAttribute</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
		<span class="o">*</span><span class="n">pxfer_type</span> <span class="o">=</span> <span class="n">WA_XFER_TYPE_CTL</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer_ctl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
		<span class="o">*</span><span class="n">pxfer_type</span> <span class="o">=</span> <span class="n">WA_XFER_TYPE_BI</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer_bi</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;FIXME: ISOC not implemented</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* never happens */</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* shut gcc up */</span>
	<span class="p">};</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_dma</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wBlocks</span><span class="p">)</span>
		<span class="o">*</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">wa_descr</span><span class="o">-&gt;</span><span class="n">bRPipeBlockSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Compute the segment size and make sure it is a multiple of</span>
<span class="cm">	 * the maxpktsize (WUSB1.0[8.3.3.1])...not really too much of</span>
<span class="cm">	 * a check (FIXME) */</span>
	<span class="n">maxpktsize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">&lt;</span> <span class="n">maxpktsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HW BUG? seg_size %zu smaller than maxpktsize &quot;</span>
			<span class="s">&quot;%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">,</span> <span class="n">maxpktsize</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">/</span> <span class="n">maxpktsize</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxpktsize</span><span class="p">;</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">+</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">/</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span> <span class="o">&gt;=</span> <span class="n">WA_SEGS_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG? ops, number of segments %d bigger than %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">/</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">),</span>
			<span class="n">WA_SEGS_MAX</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pxfer_type</span> <span class="o">==</span> <span class="n">WA_XFER_TYPE_CTL</span><span class="p">)</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fill in the common request header and xfer-type specific data. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wa_xfer_setup_hdr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">wa_xfer_hdr</span> <span class="o">*</span><span class="n">xfer_hdr0</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">wa_xfer_type</span> <span class="n">xfer_type</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">xfer_hdr_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="n">xfer_hdr0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">xfer_hdr</span><span class="p">;</span>
	<span class="n">xfer_hdr0</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">=</span> <span class="n">xfer_hdr_size</span><span class="p">;</span>
	<span class="n">xfer_hdr0</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">xfer_type</span><span class="p">;</span>
	<span class="n">xfer_hdr0</span><span class="o">-&gt;</span><span class="n">wRPipe</span> <span class="o">=</span> <span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">;</span>
	<span class="n">xfer_hdr0</span><span class="o">-&gt;</span><span class="n">dwTransferID</span> <span class="o">=</span> <span class="n">wa_xfer_id</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">xfer_hdr0</span><span class="o">-&gt;</span><span class="n">bTransferSegment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">xfer_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WA_XFER_TYPE_CTL</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">wa_xfer_ctl</span> <span class="o">*</span><span class="n">xfer_ctl</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">xfer_hdr0</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_xfer_ctl</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
		<span class="n">xfer_ctl</span><span class="o">-&gt;</span><span class="n">bmAttribute</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer_ctl</span><span class="o">-&gt;</span><span class="n">baSetupData</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">xfer_ctl</span><span class="o">-&gt;</span><span class="n">baSetupData</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">WA_XFER_TYPE_BI</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WA_XFER_TYPE_ISO</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FIXME: ISOC not implemented</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback for the OUT data phase of the segment request</span>
<span class="cm"> *</span>
<span class="cm"> * Check wa_seg_cb(); most comments also apply here because this</span>
<span class="cm"> * function does almost the same thing and they work closely</span>
<span class="cm"> * together.</span>
<span class="cm"> *</span>
<span class="cm"> * If the seg request has failed but this DTO phase has succeeded,</span>
<span class="cm"> * wa_seg_cb() has already failed the segment and moved the</span>
<span class="cm"> * status to WA_SEG_ERROR, so this will go through &#39;case 0&#39; and</span>
<span class="cm"> * effectively do nothing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_seg_dto_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rpipe_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: data out done (%d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">WA_SEG_PENDING</span><span class="p">)</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_PENDING</span><span class="p">;</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:	<span class="cm">/* URB unlinked; no need to do anything */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* as it was done by the who unlinked us */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="cm">/* Other errors ... */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: data out error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edc_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">nep_edc</span><span class="p">,</span> <span class="n">EDC_MAX_ERRORS</span><span class="p">,</span>
			    <span class="n">EDC_ERROR_TIMEFRAME</span><span class="p">)){</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTO: URB max acceptable errors &quot;</span>
				<span class="s">&quot;exceeded, resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">WA_SEG_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ERROR</span><span class="p">;</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
			<span class="n">__wa_xfer_abort</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
			<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
			<span class="n">done</span> <span class="o">=</span> <span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_ready</span><span class="p">)</span>
			<span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback for the segment request</span>
<span class="cm"> *</span>
<span class="cm"> * If successful transition state (unless already transitioned or</span>
<span class="cm"> * outbound transfer); otherwise, take a note of the error, mark this</span>
<span class="cm"> * segment done and try completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Note we don&#39;t access until we are sure that the transfer hasn&#39;t</span>
<span class="cm"> * been cancelled (ECONNRESET, ENOENT), which could mean that</span>
<span class="cm"> * seg-&gt;xfer could be already gone.</span>
<span class="cm"> *</span>
<span class="cm"> * We have to check before setting the status to WA_SEG_PENDING</span>
<span class="cm"> * because sometimes the xfer result callback arrives before this</span>
<span class="cm"> * callback (geeeeeeze), so it might happen that we are already in</span>
<span class="cm"> * another state. As well, we don&#39;t set it if the transfer is inbound,</span>
<span class="cm"> * as in that case, wa_seg_dto_cb will do it when the OUT data phase</span>
<span class="cm"> * finishes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_seg_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rpipe_ready</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: request done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span> <span class="o">&amp;&amp;</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">WA_SEG_PENDING</span><span class="p">)</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_PENDING</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:	<span class="cm">/* URB unlinked; no need to do anything */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* as it was done by the who unlinked us */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="cm">/* Other errors ... */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: request error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edc_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">nep_edc</span><span class="p">,</span> <span class="n">EDC_MAX_ERRORS</span><span class="p">,</span>
			    <span class="n">EDC_ERROR_TIMEFRAME</span><span class="p">)){</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTO: URB max acceptable errors &quot;</span>
				<span class="s">&quot;exceeded, resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="p">);</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ERROR</span><span class="p">;</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
		<span class="n">__wa_xfer_abort</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_ready</span><span class="p">)</span>
			<span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the segs array and initialize each of them</span>
<span class="cm"> *</span>
<span class="cm"> * The segments are freed by wa_xfer_destroy() when the xfer use count</span>
<span class="cm"> * drops to zero; however, because each segment is given the same life</span>
<span class="cm"> * cycle as the USB URB it contains, it is actually freed by</span>
<span class="cm"> * usb_put_urb() on the contained USB URB (twisted, eh?).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wa_xfer_setup_segs</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">xfer_hdr_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">xfer_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">xfer_hdr_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">dto_epd</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dto_epd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buf_itr</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">buf_itr_size</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_segs_kzalloc</span><span class="p">;</span>
	<span class="n">buf_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seg</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_seg_kzalloc</span><span class="p">;</span>
		<span class="n">wa_seg_init</span><span class="p">(</span><span class="n">seg</span><span class="p">);</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">xfer</span><span class="p">;</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span>
				  <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span>
						  <span class="n">dto_epd</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">),</span>
				  <span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">xfer_hdr</span><span class="p">,</span> <span class="n">xfer_hdr_size</span><span class="p">,</span>
				  <span class="n">wa_seg_cb</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
		<span class="n">buf_itr_size</span> <span class="o">=</span> <span class="n">buf_size</span> <span class="o">&gt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">?</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">:</span> <span class="n">buf_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">buf_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error_dto_alloc</span><span class="p">;</span>
			<span class="n">usb_fill_bulk_urb</span><span class="p">(</span>
				<span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span>
				<span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span>
						<span class="n">dto_epd</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">),</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wa_seg_dto_cb</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_dma</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span>
					<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">+</span> <span class="n">buf_itr</span><span class="p">;</span>
				<span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span>
					<span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span>
					<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">buf_itr</span><span class="p">;</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">buf_itr_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_READY</span><span class="p">;</span>
		<span class="n">buf_itr</span> <span class="o">+=</span> <span class="n">buf_itr_size</span><span class="p">;</span>
		<span class="n">buf_size</span> <span class="o">-=</span> <span class="n">buf_itr_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_dto_alloc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]);</span>
	<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
<span class="nl">error_seg_kzalloc:</span>
	<span class="cm">/* use the fact that cnt is left at were it failed */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="nl">error_segs_kzalloc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates all the stuff needed to submit a transfer</span>
<span class="cm"> *</span>
<span class="cm"> * Breaks the whole data buffer in a list of segments, each one has a</span>
<span class="cm"> * structure allocated to it and linked in xfer-&gt;seg[index]</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: merge setup_segs() and the last part of this function, no</span>
<span class="cm"> *        need to do two for loops when we could run everything in a</span>
<span class="cm"> *        single one</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wa_xfer_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wa_xfer_type</span> <span class="n">xfer_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* shut up GCC */</span>
	<span class="kt">size_t</span> <span class="n">xfer_hdr_size</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">transfer_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer_hdr</span> <span class="o">*</span><span class="n">xfer_hdr0</span><span class="p">,</span> <span class="o">*</span><span class="n">xfer_hdr</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">__wa_xfer_setup_sizes</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xfer_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_setup_sizes</span><span class="p">;</span>
	<span class="n">xfer_hdr_size</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__wa_xfer_setup_segs</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="n">xfer_hdr_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p: Failed to allocate %d segments: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_setup_segs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fill the first header */</span>
	<span class="n">xfer_hdr0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">xfer_hdr</span><span class="p">;</span>
	<span class="n">wa_xfer_id_init</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">__wa_xfer_setup_hdr0</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="n">xfer_hdr0</span><span class="p">,</span> <span class="n">xfer_type</span><span class="p">,</span> <span class="n">xfer_hdr_size</span><span class="p">);</span>

	<span class="cm">/* Fill remainig headers */</span>
	<span class="n">xfer_hdr</span> <span class="o">=</span> <span class="n">xfer_hdr0</span><span class="p">;</span>
	<span class="n">transfer_size</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="n">xfer_hdr0</span><span class="o">-&gt;</span><span class="n">dwTransferLength</span> <span class="o">=</span> <span class="n">transfer_size</span> <span class="o">&gt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">?</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">:</span> <span class="n">transfer_size</span><span class="p">;</span>
	<span class="n">transfer_size</span> <span class="o">-=</span>  <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfer_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">xfer_hdr</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">xfer_hdr</span><span class="p">,</span> <span class="n">xfer_hdr0</span><span class="p">,</span> <span class="n">xfer_hdr_size</span><span class="p">);</span>
		<span class="n">xfer_hdr</span><span class="o">-&gt;</span><span class="n">bTransferSegment</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">xfer_hdr</span><span class="o">-&gt;</span><span class="n">dwTransferLength</span> <span class="o">=</span> <span class="n">transfer_size</span> <span class="o">&gt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span> <span class="o">?</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">transfer_size</span><span class="p">);</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_READY</span><span class="p">;</span>
		<span class="n">transfer_size</span> <span class="o">-=</span>  <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfer_hdr</span><span class="o">-&gt;</span><span class="n">bTransferSegment</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>	<span class="cm">/* this is the last segment */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_setup_segs:</span>
<span class="nl">error_setup_sizes:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * rpipe-&gt;seg_lock is held!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wa_seg_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;xfer %p#%u: REQ submit failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_seg_submit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;xfer %p#%u: DTO submit failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_dto_submit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_SUBMITTED</span><span class="p">;</span>
	<span class="n">rpipe_avail_dec</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_dto_submit:</span>
	<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
<span class="nl">error_seg_submit:</span>
	<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ERROR</span><span class="p">;</span>
	<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Execute more queued request segments until the maximum concurrent allowed</span>
<span class="cm"> *</span>
<span class="cm"> * The ugly unlock/lock sequence on the error path is needed as the</span>
<span class="cm"> * xfer-&gt;lock normally nests the seg_lock and not viceversa.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_delayed_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">segs_available</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
	      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">seg</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_seg</span><span class="p">,</span>
				 <span class="n">list_node</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__wa_seg_submit</span><span class="p">(</span><span class="n">rpipe</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u submitted from delayed [%d segments available] %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">segs_available</span><span class="p">),</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">__wa_xfer_abort</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * xfer-&gt;lock is taken</span>
<span class="cm"> *</span>
<span class="cm"> * On failure submitting we just stop submitting and return error;</span>
<span class="cm"> * wa_urb_enqueue_b() will execute the completion path</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wa_xfer_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">maxrequests</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRequests</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">available</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">empty</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">segs_available</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxrequests</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">available</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">segs_available</span><span class="p">);</span>
		<span class="n">empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_list</span><span class="p">);</span>
		<span class="n">seg</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: available %u empty %u (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">available</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span>
			<span class="n">available</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">empty</span> <span class="o">?</span> <span class="s">&quot;delayed&quot;</span> <span class="o">:</span> <span class="s">&quot;submitted&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">available</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: delayed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_DELAYED</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">__wa_seg_submit</span><span class="p">(</span><span class="n">rpipe</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__wa_xfer_abort</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error_seg_submit</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_submitted</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">error_seg_submit:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Second part of a URB/transfer enqueuement</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes this comes from wa_urb_enqueue() [maybe through</span>
<span class="cm"> * wa_urb_enqueue_run()]. At this point:</span>
<span class="cm"> *</span>
<span class="cm"> * xfer-&gt;wa	filled and refcounted</span>
<span class="cm"> * xfer-&gt;ep	filled with rpipe refcounted if</span>
<span class="cm"> *              delayed == 0</span>
<span class="cm"> * xfer-&gt;urb 	filled and refcounted (this is the case when called</span>
<span class="cm"> *              from wa_urb_enqueue() as we come from usb_submit_urb()</span>
<span class="cm"> *              and when called by wa_urb_enqueue_run(), as we took an</span>
<span class="cm"> *              extra ref dropped by _run() after we return).</span>
<span class="cm"> * xfer-&gt;gfp	filled</span>
<span class="cm"> *</span>
<span class="cm"> * If we fail at __wa_xfer_submit(), then we just check if we are done</span>
<span class="cm"> * and if so, we run the completion procedure. However, if we are not</span>
<span class="cm"> * yet done, we do nothing and wait for the completion handlers from</span>
<span class="cm"> * the submitted URBs or from the xfer-result path to kick in. If xfer</span>
<span class="cm"> * result never kicks in, the xfer will timeout from the USB code and</span>
<span class="cm"> * dequeue() will be called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_urb_enqueue_b</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">wusb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">rpipe_get_by_ep</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_rpipe_get</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="cm">/* FIXME: segmentation broken -- kills DWA */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>		<span class="cm">/* get a WUSB dev */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_dev_gone</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">__wusb_dev_get_by_usb_dev</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_dev_gone</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">wusb_dev</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_dequeued</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">__wa_xfer_setup</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_xfer_setup</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__wa_xfer_submit</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_xfer_submit</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* this is basically wa_xfer_completion() broken up wa_xfer_giveback()</span>
<span class="cm">	 * does a wa_xfer_put() that will call wa_xfer_destroy() and clean</span>
<span class="cm">	 * upundo setup().</span>
<span class="cm">	 */</span>
<span class="nl">error_xfer_setup:</span>
<span class="nl">error_dequeued:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* FIXME: segmentation broken, kills DWA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusb_dev</span><span class="p">)</span>
		<span class="n">wusb_dev_put</span><span class="p">(</span><span class="n">wusb_dev</span><span class="p">);</span>
<span class="nl">error_dev_gone:</span>
	<span class="n">rpipe_put</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
<span class="nl">error_rpipe_get:</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">wa_xfer_giveback</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error_xfer_submit:</span>
	<span class="n">done</span> <span class="o">=</span> <span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Execute the delayed transfers in the Wire Adapter @wa</span>
<span class="cm"> *</span>
<span class="cm"> * We need to be careful here, as dequeue() could be called in the</span>
<span class="cm"> * middle.  That&#39;s why we do the whole thing under the</span>
<span class="cm"> * wa-&gt;xfer_list_lock. If dequeue() jumps in, it first locks urb-&gt;lock</span>
<span class="cm"> * and then checks the list -- so as we would be acquiring in inverse</span>
<span class="cm"> * order, we just drop the lock once we have the xfer and reacquire it</span>
<span class="cm"> * later.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wa_urb_enqueue_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wahc</span><span class="p">,</span> <span class="n">xfer_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_delayed_list</span><span class="p">,</span>
				 <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">);</span>

		<span class="n">urb</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
		<span class="n">wa_urb_enqueue_b</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>	<span class="cm">/* taken when queuing */</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wa_urb_enqueue_run</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Submit a transfer to the Wire Adapter in a delayed way</span>
<span class="cm"> *</span>
<span class="cm"> * The process of enqueuing involves possible sleeps() [see</span>
<span class="cm"> * enqueue_b(), for the rpipe_get() and the mutex_lock()]. If we are</span>
<span class="cm"> * in an atomic section, we defer the enqueue_b() call--else we call direct.</span>
<span class="cm"> *</span>
<span class="cm"> * @urb: We own a reference to it done by the HCI Linux USB stack that</span>
<span class="cm"> *       will be given up by calling usb_hcd_giveback_urb() or by</span>
<span class="cm"> *       returning error from this function -&gt; ergo we don&#39;t have to</span>
<span class="cm"> *       refcount it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wa_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">my_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cant_sleep</span> <span class="o">=</span> <span class="n">irqs_disabled</span><span class="p">()</span> <span class="o">|</span> <span class="n">in_atomic</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">==</span> <span class="nb">NULL</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG? urb %p: NULL xfer buffer &amp; NODMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">xfer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">xfer</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_kmalloc</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>	<span class="cm">/* cancelled */</span>
		<span class="k">goto</span> <span class="n">error_dequeued</span><span class="p">;</span>		<span class="cm">/* before starting? */</span>
	<span class="n">wa_xfer_init</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span> <span class="o">=</span> <span class="n">wa_get</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">gfp</span> <span class="o">=</span> <span class="n">gfp</span><span class="p">;</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">xfer</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p urb %p pipe 0x%02x [%d bytes] %s %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">xfer</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span> <span class="o">?</span> <span class="s">&quot;dma&quot;</span> <span class="o">:</span> <span class="s">&quot;nodma&quot;</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span> <span class="o">?</span> <span class="s">&quot;inbound&quot;</span> <span class="o">:</span> <span class="s">&quot;outbound&quot;</span><span class="p">,</span>
		<span class="n">cant_sleep</span> <span class="o">?</span> <span class="s">&quot;deferred&quot;</span> <span class="o">:</span> <span class="s">&quot;inline&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cant_sleep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_get_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">my_flags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_delayed_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">my_flags</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">wusbd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wa_urb_enqueue_b</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_dequeued:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
<span class="nl">error_kmalloc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wa_urb_enqueue</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dequeue a URB and make sure uwb_hcd_giveback_urb() [completion</span>
<span class="cm"> * handler] is called.</span>
<span class="cm"> *</span>
<span class="cm"> * Until a transfer goes successfully through wa_urb_enqueue() it</span>
<span class="cm"> * needs to be dequeued with completion calling; when stuck in delayed</span>
<span class="cm"> * or before wa_xfer_setup() is called, we need to do completion.</span>
<span class="cm"> *</span>
<span class="cm"> *  not setup  If there is no hcpriv yet, that means that that enqueue</span>
<span class="cm"> *             still had no time to set the xfer up. Because</span>
<span class="cm"> *             urb-&gt;status should be other than -EINPROGRESS,</span>
<span class="cm"> *             enqueue() will catch that and bail out.</span>
<span class="cm"> *</span>
<span class="cm"> * If the transfer has gone through setup, we just need to clean it</span>
<span class="cm"> * up. If it has gone through submit(), we have to abort it [with an</span>
<span class="cm"> * asynch request] and then make sure we cancel each segment.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wa_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">flags2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rpipe_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xfer</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* NOthing setup yet enqueue will see urb-&gt;status !=</span>
<span class="cm">		 * -EINPROGRESS (by hcd layer) and bail out with</span>
<span class="cm">		 * error, no need to do completion</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="cm">/* Check the delayed list -&gt; if there, release and complete */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dequeue_delayed</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>  	<span class="cm">/* still hasn&#39;t reached */</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>	<span class="cm">/* setup(), enqueue_b() completes */</span>
	<span class="cm">/* Ok, the xfer is in flight already, it&#39;s been setup and submitted.*/</span>
	<span class="n">__wa_xfer_abort</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seg</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">WA_SEG_NOTREADY</span>:
		<span class="k">case</span> <span class="n">WA_SEG_READY</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;xfer %p#%u: dequeue bad state %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">xfer</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WA_SEG_DELAYED</span>:
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ABORTED</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WA_SEG_SUBMITTED</span>:
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ABORTED</span><span class="p">;</span>
			<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">dto_urb</span><span class="p">);</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WA_SEG_PENDING</span>:
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ABORTED</span><span class="p">;</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WA_SEG_DTI_PENDING</span>:
			<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span><span class="p">);</span>
			<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ABORTED</span><span class="p">;</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">WA_SEG_DONE</span>:
		<span class="k">case</span> <span class="n">WA_SEG_ERROR</span>:
		<span class="k">case</span> <span class="n">WA_SEG_ABORTED</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>	<span class="cm">/* -ENOENT or -ECONNRESET */</span>
	<span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_ready</span><span class="p">)</span>
		<span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">dequeue_delayed:</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_list_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">wa_xfer_giveback</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>		<span class="cm">/* we got a ref in enqueue() */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wa_urb_dequeue</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Translation from WA status codes (WUSB1.0 Table 8.15) to errno</span>
<span class="cm"> * codes</span>
<span class="cm"> *</span>
<span class="cm"> * Positive errno values are internal inconsistencies and should be</span>
<span class="cm"> * flagged louder. Negative are to be passed up to the user in the</span>
<span class="cm"> * normal way.</span>
<span class="cm"> *</span>
<span class="cm"> * @status: USB WA status code -- high two bits are stripped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wa_xfer_status_to_errno</span><span class="p">(</span><span class="n">u8</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">errno</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">real_status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">xlat</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_SUCCESS</span><span class="p">]</span> <span class="o">=</span> 		<span class="mi">0</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_HALTED</span><span class="p">]</span> <span class="o">=</span> 		<span class="o">-</span><span class="n">EPIPE</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_DATA_BUFFER_ERROR</span><span class="p">]</span> <span class="o">=</span> 	<span class="o">-</span><span class="n">ENOBUFS</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_BABBLE</span><span class="p">]</span> <span class="o">=</span> 		<span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_RESERVED</span><span class="p">]</span> <span class="o">=</span> 			<span class="n">EINVAL</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_NOT_FOUND</span><span class="p">]</span> <span class="o">=</span>		<span class="mi">0</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_INSUFFICIENT_RESOURCE</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_TRANSACTION_ERROR</span><span class="p">]</span> <span class="o">=</span> 	<span class="o">-</span><span class="n">EILSEQ</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_ABORTED</span><span class="p">]</span> <span class="o">=</span> 		<span class="o">-</span><span class="n">EINTR</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_RPIPE_NOT_READY</span><span class="p">]</span> <span class="o">=</span> 	<span class="n">EINVAL</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_INVALID_FORMAT</span><span class="p">]</span> <span class="o">=</span> 		<span class="n">EINVAL</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_UNEXPECTED_SEGMENT_NUMBER</span><span class="p">]</span> <span class="o">=</span> 	<span class="n">EINVAL</span><span class="p">,</span>
		<span class="p">[</span><span class="n">WA_XFER_STATUS_RPIPE_TYPE_MISMATCH</span><span class="p">]</span> <span class="o">=</span> 	<span class="n">EINVAL</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">status</span> <span class="o">&amp;=</span> <span class="mh">0x3f</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">xlat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s(): BUG? &quot;</span>
			       <span class="s">&quot;Unknown WA transfer status 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">real_status</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">errno</span> <span class="o">=</span> <span class="n">xlat</span><span class="p">[</span><span class="n">status</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">errno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s(): BUG? &quot;</span>
			       <span class="s">&quot;Inconsistent WA status: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">real_status</span><span class="p">);</span>
		<span class="n">errno</span> <span class="o">=</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">errno</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process a xfer result completion message</span>
<span class="cm"> *</span>
<span class="cm"> * inbound transfers: need to schedule a DTI read</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: this functio needs to be broken up in parts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_result_chew</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">seg_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer_result</span> <span class="o">*</span><span class="n">xfer_result</span> <span class="o">=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_result</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">usb_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rpipe_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">seg_idx</span> <span class="o">=</span> <span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">bTransferSegment</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">seg_idx</span> <span class="o">&gt;=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_bad_seg</span><span class="p">;</span>
	<span class="n">seg</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>
	<span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">usb_status</span> <span class="o">=</span> <span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">bTransferStatus</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: bTransferStatus 0x%02x (seg %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">xfer</span><span class="p">,</span> <span class="n">seg_idx</span><span class="p">,</span> <span class="n">usb_status</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">WA_SEG_ABORTED</span>
	    <span class="o">||</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">WA_SEG_ERROR</span><span class="p">)</span>	<span class="cm">/* already handled */</span>
		<span class="k">goto</span> <span class="n">segment_aborted</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">WA_SEG_SUBMITTED</span><span class="p">)</span>	<span class="cm">/* ops, got here */</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_PENDING</span><span class="p">;</span>	<span class="cm">/* before wa_seg{_dto}_cb() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">WA_SEG_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: Bad segment state %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer</span><span class="p">,</span> <span class="n">seg_idx</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_PENDING</span><span class="p">;</span>	<span class="cm">/* workaround/&quot;fix&quot; it */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">wa_xfer_status_to_errno</span><span class="p">(</span><span class="n">usb_status</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI: xfer %p#%u failed (0x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">usb_status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_complete</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME: we ignore warnings, tally them for stats */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_status</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> 		<span class="cm">/* Warning?... */</span>
		<span class="n">usb_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* ... pass */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_inbound</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* IN data phase: read to buffer */</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_DTI_PENDING</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">is_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span>
				<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span>
				<span class="o">+</span> <span class="n">seg_idx</span> <span class="o">*</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">;</span>
			<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span>
				<span class="o">|=</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span>
				<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span>
				<span class="o">+</span> <span class="n">seg_idx</span> <span class="o">*</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">seg_size</span><span class="p">;</span>
			<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span>
				<span class="o">&amp;=</span> <span class="o">~</span><span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">dwTransferLength</span><span class="p">);</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_submit_buf_in</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* OUT data phase, complete it -- */</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_DONE</span><span class="p">;</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">dwTransferLength</span><span class="p">);</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_ready</span><span class="p">)</span>
		<span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error_submit_buf_in:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edc_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_edc</span><span class="p">,</span> <span class="n">EDC_MAX_ERRORS</span><span class="p">,</span> <span class="n">EDC_ERROR_TIMEFRAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI: URB max acceptable errors &quot;</span>
			<span class="s">&quot;exceeded, resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: can&#39;t submit DTI data phase: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">seg_idx</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="nl">error_complete:</span>
	<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ERROR</span><span class="p">;</span>
	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="n">__wa_xfer_abort</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">done</span> <span class="o">=</span> <span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_ready</span><span class="p">)</span>
		<span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error_bad_seg:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">wa_urb_dequeue</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: bad segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="n">seg_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edc_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_edc</span><span class="p">,</span> <span class="n">EDC_MAX_ERRORS</span><span class="p">,</span> <span class="n">EDC_ERROR_TIMEFRAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI: URB max acceptable errors &quot;</span>
			<span class="s">&quot;exceeded, resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">segment_aborted:</span>
	<span class="cm">/* nothing to do, as the aborter did the completion */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback for the IN data phase</span>
<span class="cm"> *</span>
<span class="cm"> * If successful transition state; otherwise, take a note of the</span>
<span class="cm"> * error, mark this segment done and try completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Note we don&#39;t access until we are sure that the transfer hasn&#39;t</span>
<span class="cm"> * been cancelled (ECONNRESET, ENOENT), which could mean that</span>
<span class="cm"> * seg-&gt;xfer could be already gone.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_buf_in_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_seg</span> <span class="o">*</span><span class="n">seg</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rpipe_ready</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: data in done (%zu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_DONE</span><span class="p">;</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_ready</span><span class="p">)</span>
			<span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:	<span class="cm">/* URB unlinked; no need to do anything */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* as it was done by the who unlinked us */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="cm">/* Other errors ... */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wa</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">rpipe</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xfer %p#%u: data in error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer</span><span class="p">,</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edc_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">nep_edc</span><span class="p">,</span> <span class="n">EDC_MAX_ERRORS</span><span class="p">,</span>
			    <span class="n">EDC_ERROR_TIMEFRAME</span><span class="p">)){</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTO: URB max acceptable errors &quot;</span>
				<span class="s">&quot;exceeded, resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">WA_SEG_ERROR</span><span class="p">;</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">segs_done</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rpipe_ready</span> <span class="o">=</span> <span class="n">rpipe_avail_inc</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
		<span class="n">__wa_xfer_abort</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">__wa_xfer_is_done</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="n">wa_xfer_completion</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_ready</span><span class="p">)</span>
			<span class="n">wa_xfer_delayed_run</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle an incoming transfer result buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Given a transfer result buffer, it completes the transfer (possibly</span>
<span class="cm"> * scheduling and buffer in read) and then resubmits the DTI URB for a</span>
<span class="cm"> * new transfer result read.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The xfer_result DTI URB state machine</span>
<span class="cm"> *</span>
<span class="cm"> * States: OFF | RXR (Read-Xfer-Result) | RBI (Read-Buffer-In)</span>
<span class="cm"> *</span>
<span class="cm"> * We start in OFF mode, the first xfer_result notification [through</span>
<span class="cm"> * wa_handle_notif_xfer()] moves us to RXR by posting the DTI-URB to</span>
<span class="cm"> * read.</span>
<span class="cm"> *</span>
<span class="cm"> * We receive a buffer -- if it is not a xfer_result, we complain and</span>
<span class="cm"> * repost the DTI-URB. If it is a xfer_result then do the xfer seg</span>
<span class="cm"> * request accounting. If it is an IN segment, we move to RBI and post</span>
<span class="cm"> * a BUF-IN-URB to the right buffer. The BUF-IN-URB callback will</span>
<span class="cm"> * repost the DTI-URB and move to RXR state. if there was no IN</span>
<span class="cm"> * segment, it will repost the DTI-URB.</span>
<span class="cm"> *</span>
<span class="cm"> * We go back to OFF when we detect a ENOENT or ESHUTDOWN (or too many</span>
<span class="cm"> * errors) in the URBs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wa_xfer_result_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer_result</span> <span class="o">*</span><span class="n">xfer_result</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">xfer_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_xfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">usb_status</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span> <span class="o">!=</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* We have a xfer result buffer; check it */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI: xfer result %d bytes at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">xfer_result</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI Error: xfer result--bad size &quot;</span>
				<span class="s">&quot;xfer result (%d bytes vs %zu needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">xfer_result</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xfer_result</span> <span class="o">=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">xfer_result</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI Error: xfer result--&quot;</span>
				<span class="s">&quot;bad header length %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bLength</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bNotifyType</span> <span class="o">!=</span> <span class="n">WA_XFER_RESULT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI Error: xfer result--&quot;</span>
				<span class="s">&quot;bad header type 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">bNotifyType</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">usb_status</span> <span class="o">=</span> <span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">bTransferStatus</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_status</span> <span class="o">==</span> <span class="n">WA_XFER_STATUS_ABORTED</span>
		    <span class="o">||</span> <span class="n">usb_status</span> <span class="o">==</span> <span class="n">WA_XFER_STATUS_NOT_FOUND</span><span class="p">)</span>
			<span class="cm">/* taken care of already */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">xfer_id</span> <span class="o">=</span> <span class="n">xfer_result</span><span class="o">-&gt;</span><span class="n">dwTransferID</span><span class="p">;</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="n">wa_xfer_get_by_id</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">xfer_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIXME: transaction might have been cancelled */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI Error: xfer result--&quot;</span>
				<span class="s">&quot;unknown xfer 0x%08x (status 0x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xfer_id</span><span class="p">,</span> <span class="n">usb_status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wa_xfer_result_chew</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">xfer</span><span class="p">);</span>
		<span class="n">wa_xfer_put</span><span class="p">(</span><span class="n">xfer</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* (we killed the URB)...so, no broadcast */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* going away! */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI: going down! %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Unknown error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edc_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_edc</span><span class="p">,</span> <span class="n">EDC_MAX_ERRORS</span><span class="p">,</span>
			    <span class="n">EDC_ERROR_TIMEFRAME</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI: URB max acceptable errors &quot;</span>
				<span class="s">&quot;exceeded, resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI: URB error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Resubmit the DTI URB */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI Error: Could not submit DTI URB (%d), &quot;</span>
			<span class="s">&quot;resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer complete notification</span>
<span class="cm"> *</span>
<span class="cm"> * Called from the notif.c code. We get a notification on EP2 saying</span>
<span class="cm"> * that some endpoint has some transfer result data available. We are</span>
<span class="cm"> * about to read it.</span>
<span class="cm"> *</span>
<span class="cm"> * To speed up things, we always have a URB reading the DTI URB; we</span>
<span class="cm"> * don&#39;t really set it up and start it until the first xfer complete</span>
<span class="cm"> * notification arrives, which is what we do here.</span>
<span class="cm"> *</span>
<span class="cm"> * Follow up in wa_xfer_result_cb(), as that&#39;s where the whole state</span>
<span class="cm"> * machine starts.</span>
<span class="cm"> *</span>
<span class="cm"> * So here we just initialize the DTI URB for reading transfer result</span>
<span class="cm"> * notifications and also the buffer-in URB, for reading buffers. Then</span>
<span class="cm"> * we just submit the DTI URB.</span>
<span class="cm"> *</span>
<span class="cm"> * @wa shall be referenced</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wa_handle_notif_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_notif_hdr</span> <span class="o">*</span><span class="n">notif_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_notif_xfer</span> <span class="o">*</span><span class="n">notif_xfer</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">dti_epd</span> <span class="o">=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_epd</span><span class="p">;</span>

	<span class="n">notif_xfer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">notif_hdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_notif_xfer</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">notif_hdr</span><span class="o">-&gt;</span><span class="n">bNotifyType</span> <span class="o">!=</span> <span class="n">WA_NOTIF_TRANSFER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="mh">0x80</span> <span class="o">|</span> <span class="n">notif_xfer</span><span class="o">-&gt;</span><span class="n">bEndpoint</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dti_epd</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: hardcoded limitation, adapt */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG: DTI ep is %u, not %u (hack me)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">notif_xfer</span><span class="o">-&gt;</span><span class="n">bEndpoint</span><span class="p">,</span> <span class="n">dti_epd</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>	<span class="cm">/* DTI URB already started */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t allocate DTI URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_dti_urb_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span>
		<span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="mh">0x80</span> <span class="o">|</span> <span class="n">notif_xfer</span><span class="o">-&gt;</span><span class="n">bEndpoint</span><span class="p">),</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_result</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">xfer_result_size</span><span class="p">,</span>
		<span class="n">wa_xfer_result_cb</span><span class="p">,</span> <span class="n">wa</span><span class="p">);</span>

	<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t allocate BUF-IN URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_buf_in_urb_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span>
		<span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="mh">0x80</span> <span class="o">|</span> <span class="n">notif_xfer</span><span class="o">-&gt;</span><span class="n">bEndpoint</span><span class="p">),</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wa_buf_in_cb</span><span class="p">,</span> <span class="n">wa</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DTI Error: Could not submit DTI URB (%d), &quot;</span>
			<span class="s">&quot;resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_dti_urb_submit</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error_dti_urb_submit:</span>
	<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">buf_in_urb</span><span class="p">);</span>
<span class="nl">error_buf_in_urb_alloc:</span>
	<span class="n">usb_put_urb</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span><span class="p">);</span>
	<span class="n">wa</span><span class="o">-&gt;</span><span class="n">dti_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">error_dti_urb_alloc:</span>
<span class="nl">error:</span>
	<span class="n">wa_reset_all</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
