<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › wusbcore › wa-rpipe.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>wa-rpipe.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * WUSB Wire Adapter</span>
<span class="cm"> * rpipe management</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: docs</span>
<span class="cm"> *</span>
<span class="cm"> * RPIPE</span>
<span class="cm"> *</span>
<span class="cm"> *   Targeted at different downstream endpoints</span>
<span class="cm"> *</span>
<span class="cm"> *   Descriptor: use to config the remote pipe.</span>
<span class="cm"> *</span>
<span class="cm"> *   The number of blocks could be dynamic (wBlocks in descriptor is</span>
<span class="cm"> *   0)--need to schedule them then.</span>
<span class="cm"> *</span>
<span class="cm"> * Each bit in wa-&gt;rpipe_bm represents if an rpipe is being used or</span>
<span class="cm"> * not. Rpipes are represented with a &#39;struct wa_rpipe&#39; that is</span>
<span class="cm"> * attached to the hcpriv member of a &#39;struct usb_host_endpoint&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * When you need to xfer data to an endpoint, you get an rpipe for it</span>
<span class="cm"> * with wa_ep_rpipe_get(), which gives you a reference to the rpipe</span>
<span class="cm"> * and keeps a single one (the first one) with the endpoint. When you</span>
<span class="cm"> * are done transferring, you drop that reference. At the end the</span>
<span class="cm"> * rpipe is always allocated and bound to the endpoint. There it might</span>
<span class="cm"> * be recycled when not used.</span>
<span class="cm"> *</span>
<span class="cm"> * Addresses:</span>
<span class="cm"> *</span>
<span class="cm"> *  We use a 1:1 mapping mechanism between port address (0 based</span>
<span class="cm"> *  index, actually) and the address. The USB stack knows about this.</span>
<span class="cm"> *</span>
<span class="cm"> *  USB Stack port number    4 (1 based)</span>
<span class="cm"> *  WUSB code port index     3 (0 based)</span>
<span class="cm"> *  USB Address             5 (2 based -- 0 is for default, 1 for root hub)</span>
<span class="cm"> *</span>
<span class="cm"> *  Now, because we don&#39;t use the concept as default address exactly</span>
<span class="cm"> *  like the (wired) USB code does, we need to kind of skip it. So we</span>
<span class="cm"> *  never take addresses from the urb-&gt;pipe, but from the</span>
<span class="cm"> *  urb-&gt;dev-&gt;devnum, to make sure that we always have the right</span>
<span class="cm"> *  destination address.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &quot;wusbhc.h&quot;</span>
<span class="cp">#include &quot;wa-hc.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rpipe_get_descr</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">usb_rpipe_descriptor</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Get the RPIPE descriptor -- we cannot use the usb_get_descriptor()</span>
<span class="cm">	 * function because the arguments are different.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_GET_DESCRIPTOR</span><span class="p">,</span>
		<span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_RPIPE</span><span class="p">,</span>
		<span class="n">USB_DT_RPIPE</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">descr</span><span class="p">),</span>
		<span class="mi">1000</span> <span class="cm">/* FIXME: arbitrary */</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpipe %u: get descriptor failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">descr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpipe %u: got short descriptor &quot;</span>
			<span class="s">&quot;(%zd vs %zd bytes needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">index</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">descr</span><span class="p">));</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * The descriptor is assumed to be properly initialized (ie: you got</span>
<span class="cm"> * it through __rpipe_get_descr()).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rpipe_set_descr</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">usb_rpipe_descriptor</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* we cannot use the usb_get_descriptor() function because the</span>
<span class="cm">	 * arguments are different.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_SET_DESCRIPTOR</span><span class="p">,</span>
		<span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_RPIPE</span><span class="p">,</span>
		<span class="n">USB_DT_RPIPE</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">descr</span><span class="p">),</span>
		<span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpipe %u: set descriptor failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">descr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpipe %u: sent short descriptor &quot;</span>
			<span class="s">&quot;(%zd vs %zd bytes required)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">index</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">descr</span><span class="p">));</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpipe_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">seg_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">rpipe_get_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">rpipe_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rpipe_idx</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span><span class="p">,</span> <span class="n">rpipe_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_idx</span> <span class="o">&lt;</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">rpipe_idx</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rpipe_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpipe_put_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">rpipe_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">rpipe_idx</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rpipe_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">_rpipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_rpipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wa_rpipe</span><span class="p">,</span> <span class="n">refcnt</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">index</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span>
		<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rpipe_put_idx</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">wa_put</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">wa</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpipe_destroy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Locate an idle rpipe, create an structure for it and return it</span>
<span class="cm"> *</span>
<span class="cm"> * @wa 	  is referenced and unlocked</span>
<span class="cm"> * @crs   enum rpipe_attr, required endpoint characteristics</span>
<span class="cm"> *</span>
<span class="cm"> * The rpipe can be used only sequentially (not in parallel).</span>
<span class="cm"> *</span>
<span class="cm"> * The rpipe is moved into the &quot;ready&quot; state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpipe_get_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">**</span><span class="n">prpipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="n">u8</span> <span class="n">crs</span><span class="p">,</span>
			  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rpipe_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">rpipe</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rpipe</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">rpipe_init</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>

	<span class="cm">/* Look for an idle pipe */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rpipe_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rpipe_idx</span> <span class="o">&lt;</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span><span class="p">;</span> <span class="n">rpipe_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpipe_idx</span> <span class="o">=</span> <span class="n">rpipe_get_idx</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">rpipe_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rpipe_idx</span> <span class="o">&gt;=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span><span class="p">)</span>	<span class="cm">/* no more pipes :( */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span>  <span class="n">__rpipe_get_descr</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">,</span> <span class="n">rpipe_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get descriptor for rpipe %u: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rpipe_idx</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bmCharacteristics</span> <span class="o">&amp;</span> <span class="n">crs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="n">rpipe_put_idx</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">rpipe_idx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">prpipe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">rpipe_idx</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span><span class="p">);</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">wa</span> <span class="o">=</span> <span class="n">wa_get</span><span class="p">(</span><span class="n">wa</span><span class="p">);</span>
	<span class="o">*</span><span class="n">prpipe</span> <span class="o">=</span> <span class="n">rpipe</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rpipe_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span>
		<span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_REQ_RPIPE_RESET</span><span class="p">,</span>
		<span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_RPIPE</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span> <span class="cm">/* FIXME: arbitrary */</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rpipe %u: reset failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">index</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fake companion descriptor for ep0</span>
<span class="cm"> *</span>
<span class="cm"> * See WUSB1.0[7.4.4], most of this is zero for bulk/int/ctl</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_wireless_ep_comp_descriptor</span> <span class="n">epc0</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">epc0</span><span class="p">),</span>
	<span class="p">.</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="n">USB_DT_WIRELESS_ENDPOINT_COMP</span><span class="p">,</span>
<span class="cm">/*	.bMaxBurst = 1, */</span>
	<span class="p">.</span><span class="n">bMaxSequence</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Look for EP companion descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Get there, look for Inara in the endpoint&#39;s extra descriptors</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_wireless_ep_comp_descriptor</span> <span class="o">*</span><span class="nf">rpipe_epc_find</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">itr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">itr_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_wireless_ep_comp_descriptor</span> <span class="o">*</span><span class="n">epcd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epcd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">epc0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">itr</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
	<span class="n">itr_size</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">extralen</span><span class="p">;</span>
	<span class="n">epcd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">itr_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">itr_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HW Bug? ep 0x%02x: extra descriptors &quot;</span>
				<span class="s">&quot;at offset %zu: only %zu bytes left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
				<span class="n">itr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">,</span> <span class="n">itr_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">itr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">==</span> <span class="n">USB_DT_WIRELESS_ENDPOINT_COMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epcd</span> <span class="o">=</span> <span class="n">itr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">&gt;</span> <span class="n">itr_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HW Bug? ep 0x%02x: extra descriptor &quot;</span>
				<span class="s">&quot;at offset %zu (type 0x%02x) &quot;</span>
				<span class="s">&quot;length %d but only %zu bytes left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
				<span class="n">itr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">,</span>
				<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">,</span> <span class="n">itr_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">itr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
		<span class="n">itr_size</span> <span class="o">-=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">epcd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Aim an rpipe to its device &amp; endpoint destination</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure we change the address to unauthenticathed if the device</span>
<span class="cm"> * is WUSB and it is not authenticated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpipe_aim</span><span class="p">(</span><span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>	<span class="cm">/* better code for lack of companion? */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_wireless_ep_comp_descriptor</span> <span class="o">*</span><span class="n">epcd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">unauth</span><span class="p">;</span>

	<span class="n">epcd</span> <span class="o">=</span> <span class="n">rpipe_epc_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epcd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ep 0x%02x: can&#39;t find companion descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unauth</span> <span class="o">=</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">authenticated</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__rpipe_reset</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">segs_available</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRequests</span><span class="p">));</span>
	<span class="cm">/* FIXME: block allocation system; request with queuing and timeout */</span>
	<span class="cm">/* FIXME: compute so seg_size &gt; ep-&gt;maxpktsize */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wBlocks</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>		<span class="cm">/* given */</span>
	<span class="cm">/* ep0 maxpktsize is 0x200 (WUSB1.0[4.8.1]) */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wMaxPacketSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">);</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bHSHubAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* reserved: zero */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bHSHubPort</span> <span class="o">=</span> <span class="n">wusb_port_no_to_idx</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">);</span>
	<span class="cm">/* FIXME: use maximum speed as supported or recommended by device */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bSpeed</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span>
		<span class="n">UWB_PHY_RATE_53</span> <span class="o">:</span> <span class="n">UWB_PHY_RATE_200</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;addr %u (0x%02x) rpipe #%u ep# %u speed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">|</span> <span class="n">unauth</span><span class="p">,</span>
		<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">),</span>
		<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span> <span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bSpeed</span><span class="p">);</span>

	<span class="cm">/* see security.c:wusb_update_address() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">))</span>
		<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bDeviceAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bDeviceAddress</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">|</span> <span class="n">unauth</span><span class="p">;</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
	<span class="cm">/* FIXME: bDataSequence */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bDataSequence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* FIXME: dwCurrentWindow */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">dwCurrentWindow</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* FIXME: bMaxDataSequence */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bMaxDataSequence</span> <span class="o">=</span> <span class="n">epcd</span><span class="o">-&gt;</span><span class="n">bMaxSequence</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bInterval</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterval</span><span class="p">;</span>
	<span class="cm">/* FIXME: bOverTheAirInterval */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bOverTheAirInterval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* 0 if not isoc */</span>
	<span class="cm">/* FIXME: xmit power &amp; preamble blah blah */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bmAttribute</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="cm">/* rpipe-&gt;descr.bmCharacteristics RO */</span>
	<span class="cm">/* FIXME: bmRetryOptions */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">bmRetryOptions</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
	<span class="cm">/* FIXME: use for assessing link quality? */</span>
	<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wNumTransactionErrors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__rpipe_set_descr</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">,</span>
				   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot aim rpipe: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check an aimed rpipe to make sure it points to where we want</span>
<span class="cm"> *</span>
<span class="cm"> * We use bit 19 of the Linux USB pipe bitmap for unauth vs auth</span>
<span class="cm"> * space; when it is like that, we or 0x80 to make an unauth address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpipe_check_aim</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* better code for lack of companion? */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">unauth</span> <span class="o">=</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">authenticated</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">portnum</span> <span class="o">=</span> <span class="n">wusb_port_no_to_idx</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">);</span>

<span class="cp">#define AIM_CHECK(rdf, val, text)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (rpipe-&gt;descr.rdf != (val)) {			\</span>
<span class="cp">			dev_err(dev,					\</span>
<span class="cp">				&quot;rpipe aim discrepancy: &quot; #rdf &quot; &quot; text &quot;\n&quot;, \</span>
<span class="cp">				rpipe-&gt;descr.rdf, (val));		\</span>
<span class="cp">			result = -EINVAL;				\</span>
<span class="cp">			WARN_ON(1);					\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>
	<span class="n">AIM_CHECK</span><span class="p">(</span><span class="n">wMaxPacketSize</span><span class="p">,</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">),</span>
		  <span class="s">&quot;(%u vs %u)&quot;</span><span class="p">);</span>
	<span class="n">AIM_CHECK</span><span class="p">(</span><span class="n">bHSHubPort</span><span class="p">,</span> <span class="n">portnum</span><span class="p">,</span> <span class="s">&quot;(%u vs %u)&quot;</span><span class="p">);</span>
	<span class="n">AIM_CHECK</span><span class="p">(</span><span class="n">bSpeed</span><span class="p">,</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span>
			<span class="n">UWB_PHY_RATE_53</span> <span class="o">:</span> <span class="n">UWB_PHY_RATE_200</span><span class="p">,</span>
		  <span class="s">&quot;(%u vs %u)&quot;</span><span class="p">);</span>
	<span class="n">AIM_CHECK</span><span class="p">(</span><span class="n">bDeviceAddress</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">|</span> <span class="n">unauth</span><span class="p">,</span> <span class="s">&quot;(%u vs %u)&quot;</span><span class="p">);</span>
	<span class="n">AIM_CHECK</span><span class="p">(</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="s">&quot;(%u vs %u)&quot;</span><span class="p">);</span>
	<span class="n">AIM_CHECK</span><span class="p">(</span><span class="n">bInterval</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterval</span><span class="p">,</span> <span class="s">&quot;(%u vs %u)&quot;</span><span class="p">);</span>
	<span class="n">AIM_CHECK</span><span class="p">(</span><span class="n">bmAttribute</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">,</span> <span class="s">&quot;(%u vs %u)&quot;</span><span class="p">);</span>
<span class="cp">#undef AIM_CHECK</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_BUG</span>
<span class="cp">#define CONFIG_BUG 0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Make sure there is an rpipe allocated for an endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * If already allocated, we just refcount it; if not, we get an</span>
<span class="cm"> * idle one, aim it to the right location and take it.</span>
<span class="cm"> *</span>
<span class="cm"> * Attaches to ep-&gt;hcpriv and rpipe-&gt;ep to ep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rpipe_get_by_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">eptype</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_mutex</span><span class="p">);</span>
	<span class="n">rpipe</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CONFIG_BUG</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">rpipe_check_aim</span><span class="p">(</span><span class="n">rpipe</span><span class="p">,</span> <span class="n">wa</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__rpipe_get</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ep 0x%02x: reusing rpipe %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* hmm, assign idle rpipe, aim it */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="n">eptype</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">rpipe_get_idle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpipe</span><span class="p">,</span> <span class="n">wa</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">eptype</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">rpipe_aim</span><span class="p">(</span><span class="n">rpipe</span><span class="p">,</span> <span class="n">wa</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rpipe_put</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">rpipe</span><span class="p">;</span>
		<span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
		<span class="n">__rpipe_get</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>	<span class="cm">/* for caching into ep-&gt;hcpriv */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ep 0x%02x: using rpipe %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">));</span>
	<span class="p">}</span>
<span class="nl">error:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the bitmap for each rpipe.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wa_rpipes_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span> <span class="o">=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">wa_descr</span><span class="o">-&gt;</span><span class="n">wNumRPipes</span><span class="p">;</span>
	<span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wa_rpipes_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_empty</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">bitmap_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span><span class="p">,</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipes</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG: pipes not released on exit: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_bm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release resources allocated for an endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * If there is an associated rpipe to this endpoint, Abort any pending</span>
<span class="cm"> * transfers and put it. If the rpipe ends up being destroyed,</span>
<span class="cm"> * __rpipe_destroy() will cleanup ep-&gt;hcpriv.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called before calling hcd-&gt;stop(), so you don&#39;t need to do</span>
<span class="cm"> * anything else in there.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rpipe_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">wahc</span> <span class="o">*</span><span class="n">wa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wa_rpipe</span> <span class="o">*</span><span class="n">rpipe</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_mutex</span><span class="p">);</span>
	<span class="n">rpipe</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpipe</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">index</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rpipe</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">.</span><span class="n">wRPipeIndex</span><span class="p">);</span>

		<span class="n">usb_control_msg</span><span class="p">(</span>
			<span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">USB_REQ_RPIPE_ABORT</span><span class="p">,</span>
			<span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_RPIPE</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span> <span class="cm">/* FIXME: arbitrary */</span><span class="p">);</span>
		<span class="n">rpipe_put</span><span class="p">(</span><span class="n">rpipe</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">rpipe_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpipe_ep_disable</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
