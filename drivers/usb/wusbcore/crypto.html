<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › wusbcore › crypto.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>crypto.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Ultra Wide Band</span>
<span class="cm"> * AES-128 CCM Encryption</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t do any encryption here; we use the Linux Kernel&#39;s AES-128</span>
<span class="cm"> * crypto modules to construct keys and payload blocks in a way</span>
<span class="cm"> * defined by WUSB1.0[6]. Check the erratas, as typos are are patched</span>
<span class="cm"> * there.</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks a zillion to John Keys for his help and clarifications over</span>
<span class="cm"> * the designed-by-a-committee text.</span>
<span class="cm"> *</span>
<span class="cm"> * So the idea is that there is this basic Pseudo-Random-Function</span>
<span class="cm"> * defined in WUSB1.0[6.5] which is the core of everything. It works</span>
<span class="cm"> * by tweaking some blocks, AES crypting them and then xoring</span>
<span class="cm"> * something else with them (this seems to be called CBC(AES) -- can</span>
<span class="cm"> * you tell I know jack about crypto?). So we just funnel it into the</span>
<span class="cm"> * Linux Crypto API.</span>
<span class="cm"> *</span>
<span class="cm"> * We leave a crypto test module so we can verify that vectors match,</span>
<span class="cm"> * every now and then.</span>
<span class="cm"> *</span>
<span class="cm"> * Block size: 16 bytes -- AES seems to do things in &#39;block sizes&#39;. I</span>
<span class="cm"> *             am learning a lot...</span>
<span class="cm"> *</span>
<span class="cm"> *             Conveniently, some data structures that need to be</span>
<span class="cm"> *             funneled through AES are...16 bytes in size!</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/uwb.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/usb/wusb.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">debug_crypto_verify</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">debug_crypto_verify</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_crypto_verify</span><span class="p">,</span> <span class="s">&quot;verify the key generation algorithms&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wusb_key_dump</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;  &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Block of data, as understood by AES-CCM</span>
<span class="cm"> *</span>
<span class="cm"> * The code assumes this structure is nothing but a 16 byte array</span>
<span class="cm"> * (packed in a struct to avoid common mess ups that I usually do with</span>
<span class="cm"> * arrays and enforcing type checking).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aes_ccm_block</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * Counter-mode Blocks (WUSB1.0[6.4])</span>
<span class="cm"> *</span>
<span class="cm"> * According to CCM (or so it seems), for the purpose of calculating</span>
<span class="cm"> * the MIC, the message is broken in N counter-mode blocks, B0, B1,</span>
<span class="cm"> * ... BN.</span>
<span class="cm"> *</span>
<span class="cm"> * B0 contains flags, the CCM nonce and l(m).</span>
<span class="cm"> *</span>
<span class="cm"> * B1 contains l(a), the MAC header, the encryption offset and padding.</span>
<span class="cm"> *</span>
<span class="cm"> * If EO is nonzero, additional blocks are built from payload bytes</span>
<span class="cm"> * until EO is exahusted (FIXME: padding to 16 bytes, I guess). The</span>
<span class="cm"> * padding is not xmitted.</span>
<span class="cm"> */</span>

<span class="cm">/* WUSB1.0[T6.4] */</span>
<span class="k">struct</span> <span class="n">aes_ccm_b0</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* 0x59, per CCM spec */</span>
	<span class="k">struct</span> <span class="n">aes_ccm_nonce</span> <span class="n">ccm_nonce</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">lm</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* WUSB1.0[T6.5] */</span>
<span class="k">struct</span> <span class="n">aes_ccm_b1</span> <span class="p">{</span>
	<span class="n">__be16</span> <span class="n">la</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mac_header</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">eo</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">security_reserved</span><span class="p">;</span>	<span class="cm">/* This is always zero */</span>
	<span class="n">u8</span> <span class="n">padding</span><span class="p">;</span>		<span class="cm">/* 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * Encryption Blocks (WUSB1.0[6.4.4])</span>
<span class="cm"> *</span>
<span class="cm"> * CCM uses Ax blocks to generate a keystream with which the MIC and</span>
<span class="cm"> * the message&#39;s payload are encoded. A0 always encrypts/decrypts the</span>
<span class="cm"> * MIC. Ax (x&gt;0) are used for the successive payload blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * The x is the counter, and is increased for each block.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aes_ccm_a</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* 0x01, per CCM spec */</span>
	<span class="k">struct</span> <span class="n">aes_ccm_nonce</span> <span class="n">ccm_nonce</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">counter</span><span class="p">;</span>	<span class="cm">/* Value of x */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bytewise_xor</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_bo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_bi1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_bi2</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">_bo</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bi1</span> <span class="o">=</span> <span class="n">_bi1</span><span class="p">,</span> <span class="o">*</span><span class="n">bi2</span> <span class="o">=</span> <span class="n">_bi2</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">itr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">itr</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bo</span><span class="p">[</span><span class="n">itr</span><span class="p">]</span> <span class="o">=</span> <span class="n">bi1</span><span class="p">[</span><span class="n">itr</span><span class="p">]</span> <span class="o">^</span> <span class="n">bi2</span><span class="p">[</span><span class="n">itr</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CC-MAC function WUSB1.0[6.5]</span>
<span class="cm"> *</span>
<span class="cm"> * Take a data string and produce the encrypted CBC Counter-mode MIC</span>
<span class="cm"> *</span>
<span class="cm"> * Note the names for most function arguments are made to (more or</span>
<span class="cm"> * less) match those used in the pseudo-function definition given in</span>
<span class="cm"> * WUSB1.0[6.5].</span>
<span class="cm"> *</span>
<span class="cm"> * @tfm_cbc: CBC(AES) blkcipher handle (initialized)</span>
<span class="cm"> *</span>
<span class="cm"> * @tfm_aes: AES cipher handle (initialized)</span>
<span class="cm"> *</span>
<span class="cm"> * @mic: buffer for placing the computed MIC (Message Integrity</span>
<span class="cm"> *       Code). This is exactly 8 bytes, and we expect the buffer to</span>
<span class="cm"> *       be at least eight bytes in length.</span>
<span class="cm"> *</span>
<span class="cm"> * @key: 128 bit symmetric key</span>
<span class="cm"> *</span>
<span class="cm"> * @n: CCM nonce</span>
<span class="cm"> *</span>
<span class="cm"> * @a: ASCII string, 14 bytes long (I guess zero padded if needed;</span>
<span class="cm"> *     we use exactly 14 bytes).</span>
<span class="cm"> *</span>
<span class="cm"> * @b: data stream to be processed; cannot be a global or const local</span>
<span class="cm"> *     (will confuse the scatterlists)</span>
<span class="cm"> *</span>
<span class="cm"> * @blen: size of b...</span>
<span class="cm"> *</span>
<span class="cm"> * Still not very clear how this is done, but looks like this: we</span>
<span class="cm"> * create block B0 (as WUSB1.0[6.5] says), then we AES-crypt it with</span>
<span class="cm"> * @key. We bytewise xor B0 with B1 (1) and AES-crypt that. Then we</span>
<span class="cm"> * take the payload and divide it in blocks (16 bytes), xor them with</span>
<span class="cm"> * the previous crypto result (16 bytes) and crypt it, repeat the next</span>
<span class="cm"> * block with the output of the previous one, rinse wash (I guess this</span>
<span class="cm"> * is what AES CBC mode means...but I truly have no idea). So we use</span>
<span class="cm"> * the CBC(AES) blkcipher, that does precisely that. The IV (Initial</span>
<span class="cm"> * Vector) is 16 bytes and is set to zero, so</span>
<span class="cm"> *</span>
<span class="cm"> * See rfc3610. Linux crypto has a CBC implementation, but the</span>
<span class="cm"> * documentation is scarce, to say the least, and the example code is</span>
<span class="cm"> * so intricated that is difficult to understand how things work. Most</span>
<span class="cm"> * of this is guess work -- bite me.</span>
<span class="cm"> *</span>
<span class="cm"> * (1) Created as 6.5 says, again, using as l(a) &#39;Blen + 14&#39;, and</span>
<span class="cm"> *     using the 14 bytes of @a to fill up</span>
<span class="cm"> *     b1.{mac_header,e0,security_reserved,padding}.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The definition of l(a) in WUSB1.0[6.5] vs the definition of</span>
<span class="cm"> *       l(m) is orthogonal, they bear no relationship, so it is not</span>
<span class="cm"> *       in conflict with the parameter&#39;s relation that</span>
<span class="cm"> *       WUSB1.0[6.4.2]) defines.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: WUSB1.0[A.1]: Host Nonce is missing a nibble? (1e); fixed in</span>
<span class="cm"> *       first errata released on 2005/07.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: we need to clean IV to zero at each invocation to make sure</span>
<span class="cm"> *       we start with a fresh empty Initial Vector, so that the CBC</span>
<span class="cm"> *       works ok.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: blen is not aligned to a block size, we&#39;ll pad zeros, that&#39;s</span>
<span class="cm"> *       what sg[4] is for. Maybe there is a smarter way to do this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusb_ccm_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_blkcipher</span> <span class="o">*</span><span class="n">tfm_cbc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">tfm_aes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mic</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">aes_ccm_nonce</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">aes_ccm_label</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">blen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blkcipher_desc</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aes_ccm_b0</span> <span class="n">b0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aes_ccm_b1</span> <span class="n">b1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aes_ccm_a</span> <span class="n">ax</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">sg_dst</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ivsize</span><span class="p">,</span> <span class="n">dst_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">bzero</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">size_t</span> <span class="n">zero_padding</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These checks should be compile time optimized out</span>
<span class="cm">	 * ensure @a fills b1&#39;s mac_header and following fields</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b1</span><span class="p">.</span><span class="n">la</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aes_ccm_block</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aes_ccm_block</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aes_ccm_block</span><span class="p">));</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">zero_padding</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aes_ccm_block</span><span class="p">)</span>
		<span class="o">-</span> <span class="n">blen</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aes_ccm_block</span><span class="p">);</span>
	<span class="n">zero_padding</span> <span class="o">=</span> <span class="n">blen</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aes_ccm_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zero_padding</span><span class="p">)</span>
		<span class="n">zero_padding</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aes_ccm_block</span><span class="p">)</span> <span class="o">-</span> <span class="n">zero_padding</span><span class="p">;</span>
	<span class="n">dst_size</span> <span class="o">=</span> <span class="n">blen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">+</span> <span class="n">zero_padding</span><span class="p">;</span>
	<span class="n">dst_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">dst_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: can&#39;t alloc destination buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_dst_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iv</span> <span class="o">=</span> <span class="n">crypto_blkcipher_crt</span><span class="p">(</span><span class="n">tfm_cbc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">;</span>
	<span class="n">ivsize</span> <span class="o">=</span> <span class="n">crypto_blkcipher_ivsize</span><span class="p">(</span><span class="n">tfm_cbc</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ivsize</span><span class="p">);</span>

	<span class="cm">/* Setup B0 */</span>
	<span class="n">b0</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mh">0x59</span><span class="p">;</span>	<span class="cm">/* Format B0 */</span>
	<span class="n">b0</span><span class="p">.</span><span class="n">ccm_nonce</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">b0</span><span class="p">.</span><span class="n">lm</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* WUSB1.0[6.5] sez l(m) is 0 */</span>

	<span class="cm">/* Setup B1</span>
<span class="cm">	 *</span>
<span class="cm">	 * The WUSB spec is anything but clear! WUSB1.0[6.5]</span>
<span class="cm">	 * says that to initialize B1 from A with &#39;l(a) = blen +</span>
<span class="cm">	 * 14&#39;--after clarification, it means to use A&#39;s contents</span>
<span class="cm">	 * for MAC Header, EO, sec reserved and padding.</span>
<span class="cm">	 */</span>
	<span class="n">b1</span><span class="p">.</span><span class="n">la</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">blen</span> <span class="o">+</span> <span class="mi">14</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b1</span><span class="p">.</span><span class="n">mac_header</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">));</span>

	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
	<span class="n">sg_set_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">b0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b0</span><span class="p">));</span>
	<span class="n">sg_set_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">b1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b1</span><span class="p">));</span>
	<span class="n">sg_set_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="cm">/* 0 if well behaved :) */</span>
	<span class="n">sg_set_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bzero</span><span class="p">,</span> <span class="n">zero_padding</span><span class="p">);</span>
	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_dst</span><span class="p">,</span> <span class="n">dst_buf</span><span class="p">,</span> <span class="n">dst_size</span><span class="p">);</span>

	<span class="n">desc</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">tfm_cbc</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">crypto_blkcipher_encrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_dst</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">dst_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: can&#39;t compute CBC-MAC tag (MIC): %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_cbc_crypt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now we crypt the MIC Tag (*iv) with Ax -- values per WUSB1.0[6.5]</span>
<span class="cm">	 * The procedure is to AES crypt the A0 block and XOR the MIC</span>
<span class="cm">	 * Tag against it; we only do the first 8 bytes and place it</span>
<span class="cm">	 * directly in the destination buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * POS Crypto API: size is assumed to be AES&#39;s block size.</span>
<span class="cm">	 * Thanks for documenting it -- tip taken from airo.c</span>
<span class="cm">	 */</span>
	<span class="n">ax</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>		<span class="cm">/* as per WUSB 1.0 spec */</span>
	<span class="n">ax</span><span class="p">.</span><span class="n">ccm_nonce</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">ax</span><span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">crypto_cipher_encrypt_one</span><span class="p">(</span><span class="n">tfm_aes</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ax</span><span class="p">);</span>
	<span class="n">bytewise_xor</span><span class="p">(</span><span class="n">mic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ax</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="nl">error_cbc_crypt:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dst_buf</span><span class="p">);</span>
<span class="nl">error_dst_buf:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * WUSB Pseudo Random Function (WUSB1.0[6.5])</span>
<span class="cm"> *</span>
<span class="cm"> * @b: buffer to the source data; cannot be a global or const local</span>
<span class="cm"> *     (will confuse the scatterlists)</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">wusb_prf</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">out_size</span><span class="p">,</span>
		 <span class="k">const</span> <span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">aes_ccm_nonce</span> <span class="o">*</span><span class="n">_n</span><span class="p">,</span>
		 <span class="k">const</span> <span class="k">struct</span> <span class="n">aes_ccm_label</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
		 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blen</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">,</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bitr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aes_ccm_nonce</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">_n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_blkcipher</span> <span class="o">*</span><span class="n">tfm_cbc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">tfm_aes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">sfn_le</span><span class="p">;</span>

	<span class="n">tfm_cbc</span> <span class="o">=</span> <span class="n">crypto_alloc_blkcipher</span><span class="p">(</span><span class="s">&quot;cbc(aes)&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tfm_cbc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tfm_cbc</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: can&#39;t load CBC(AES): %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_alloc_cbc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">crypto_blkcipher_setkey</span><span class="p">(</span><span class="n">tfm_cbc</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: can&#39;t set CBC key: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_setkey_cbc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tfm_aes</span> <span class="o">=</span> <span class="n">crypto_alloc_cipher</span><span class="p">(</span><span class="s">&quot;aes&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tfm_aes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tfm_aes</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: can&#39;t load AES: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_alloc_aes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">crypto_cipher_setkey</span><span class="p">(</span><span class="n">tfm_aes</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: can&#39;t set AES key: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_setkey_aes</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bitr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bitr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">63</span><span class="p">)</span> <span class="o">/</span> <span class="mi">64</span><span class="p">;</span> <span class="n">bitr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sfn_le</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sfn</span><span class="o">++</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">.</span><span class="n">sfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfn_le</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">sfn</span><span class="p">));</span>	<span class="cm">/* n.sfn++... */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_ccm_mac</span><span class="p">(</span><span class="n">tfm_cbc</span><span class="p">,</span> <span class="n">tfm_aes</span><span class="p">,</span> <span class="n">out</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_ccm_mac</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
<span class="nl">error_ccm_mac:</span>
<span class="nl">error_setkey_aes:</span>
	<span class="n">crypto_free_cipher</span><span class="p">(</span><span class="n">tfm_aes</span><span class="p">);</span>
<span class="nl">error_alloc_aes:</span>
<span class="nl">error_setkey_cbc:</span>
	<span class="n">crypto_free_blkcipher</span><span class="p">(</span><span class="n">tfm_cbc</span><span class="p">);</span>
<span class="nl">error_alloc_cbc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* WUSB1.0[A.2] test vectors */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">stv_hsmic_key</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0xa3</span><span class="p">,</span> <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0xe5</span><span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x9d</span><span class="p">,</span>
	<span class="mh">0xd7</span><span class="p">,</span> <span class="mh">0xc1</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span> <span class="mh">0xab</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x3f</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">aes_ccm_nonce</span> <span class="n">stv_hsmic_n</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sfn</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tkid</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span>  <span class="p">},</span>
	<span class="p">.</span><span class="n">dest_addr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xbe</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">}</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">src_addr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mh">0x98</span> <span class="p">}</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Out-of-band MIC Generation verification code</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusb_oob_mic_verify</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mic</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* WUSB1.0[A.2] test vectors</span>
<span class="cm">	 *</span>
<span class="cm">	 * Need to keep it in the local stack as GCC 4.1.3something</span>
<span class="cm">	 * messes up and generates noise.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">usb_handshake</span> <span class="n">stv_hsmic_hs</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">bMessageNumber</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bStatus</span> 	<span class="o">=</span> <span class="mo">00</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tTKID</span> 		<span class="o">=</span> <span class="p">{</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">bReserved</span> 	<span class="o">=</span> <span class="mo">00</span><span class="p">,</span>
		<span class="p">.</span><span class="n">CDID</span> 		<span class="o">=</span> <span class="p">{</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span>
				    <span class="mh">0x36</span><span class="p">,</span> <span class="mh">0x37</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x3a</span><span class="p">,</span> <span class="mh">0x3b</span><span class="p">,</span>
				    <span class="mh">0x3c</span><span class="p">,</span> <span class="mh">0x3d</span><span class="p">,</span> <span class="mh">0x3e</span><span class="p">,</span> <span class="mh">0x3f</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">nonce</span>	 	<span class="o">=</span> <span class="p">{</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span>
				    <span class="mh">0x26</span><span class="p">,</span> <span class="mh">0x27</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span>
				    <span class="mh">0x2c</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0x2f</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">MIC</span>	 	<span class="o">=</span> <span class="p">{</span> <span class="mh">0x75</span><span class="p">,</span> <span class="mh">0x6a</span><span class="p">,</span> <span class="mh">0x97</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="mh">0x0c</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span>
				    <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x7b</span> <span class="p">}</span> <span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">size_t</span> <span class="n">hs_size</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_oob_mic</span><span class="p">(</span><span class="n">mic</span><span class="p">,</span> <span class="n">stv_hsmic_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stv_hsmic_n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stv_hsmic_hs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: WUSB OOB MIC test: failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">stv_hsmic_hs</span><span class="p">.</span><span class="n">MIC</span><span class="p">,</span> <span class="n">mic</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mic</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: OOB MIC test: &quot;</span>
		       <span class="s">&quot;mismatch between MIC result and WUSB1.0[A2]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hs_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_hsmic_hs</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_hsmic_hs</span><span class="p">.</span><span class="n">MIC</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: Handshake2 in: (%zu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hs_size</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stv_hsmic_hs</span><span class="p">,</span> <span class="n">hs_size</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: CCM Nonce in: (%zu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_hsmic_n</span><span class="p">));</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stv_hsmic_n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_hsmic_n</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: MIC out:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="n">mic</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mic</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: MIC out (from WUSB1.0[A.2]):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="n">stv_hsmic_hs</span><span class="p">.</span><span class="n">MIC</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_hsmic_hs</span><span class="p">.</span><span class="n">MIC</span><span class="p">));</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test vectors for Key derivation</span>
<span class="cm"> *</span>
<span class="cm"> * These come from WUSB1.0[6.5.1], the vectors in WUSB1.0[A.1]</span>
<span class="cm"> * (errata corrected in 2005/07).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">stv_key_a1</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0xf0</span><span class="p">,</span> <span class="mh">0xe1</span><span class="p">,</span> <span class="mh">0xd2</span><span class="p">,</span> <span class="mh">0xc3</span><span class="p">,</span> <span class="mh">0xb4</span><span class="p">,</span> <span class="mh">0xa5</span><span class="p">,</span> <span class="mh">0x96</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">,</span>
	<span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span> <span class="mh">0x5a</span><span class="p">,</span> <span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0x3c</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span> <span class="mh">0x1e</span><span class="p">,</span> <span class="mh">0x0f</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">aes_ccm_nonce</span> <span class="n">stv_keydvt_n_a1</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sfn</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tkid</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span>  <span class="p">},</span>
	<span class="p">.</span><span class="n">dest_addr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xbe</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">}</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">src_addr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mh">0x98</span> <span class="p">}</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">wusb_keydvt_out</span> <span class="n">stv_keydvt_out_a1</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kck</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0xa3</span><span class="p">,</span> <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0xe5</span><span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x9d</span><span class="p">,</span>
		<span class="mh">0xd7</span><span class="p">,</span> <span class="mh">0xc1</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span> <span class="mh">0xab</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x3f</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ptk</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0xc8</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">,</span> <span class="mh">0x62</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0xb6</span><span class="p">,</span> <span class="mh">0x7c</span><span class="p">,</span> <span class="mh">0xe9</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span>
		<span class="mh">0x7b</span><span class="p">,</span> <span class="mh">0xc5</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span> <span class="mh">0x36</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">,</span> <span class="mh">0x2d</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Performa a test to make sure we match the vectors defined in</span>
<span class="cm"> * WUSB1.0[A.1](Errata2006/12)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wusb_key_derive_verify</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_keydvt_out</span> <span class="n">keydvt_out</span><span class="p">;</span>
	<span class="cm">/* These come from WUSB1.0[A.1] + 2006/12 errata</span>
<span class="cm">	 * NOTE: can&#39;t make this const or global -- somehow it seems</span>
<span class="cm">	 *       the scatterlists for crypto get confused and we get</span>
<span class="cm">	 *       bad data. There is no doc on this... */</span>
	<span class="k">struct</span> <span class="n">wusb_keydvt_in</span> <span class="n">stv_keydvt_in_a1</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">hnonce</span> <span class="o">=</span> <span class="p">{</span>
			<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x15</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span>
			<span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x19</span><span class="p">,</span> <span class="mh">0x1a</span><span class="p">,</span> <span class="mh">0x1b</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">,</span> <span class="mh">0x1d</span><span class="p">,</span> <span class="mh">0x1e</span><span class="p">,</span> <span class="mh">0x1f</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">dnonce</span> <span class="o">=</span> <span class="p">{</span>
			<span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x26</span><span class="p">,</span> <span class="mh">0x27</span><span class="p">,</span>
			<span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0x2f</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_key_derive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keydvt_out</span><span class="p">,</span> <span class="n">stv_key_a1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stv_keydvt_n_a1</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">stv_keydvt_in_a1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: WUSB key derivation test: &quot;</span>
		       <span class="s">&quot;derivation failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stv_keydvt_out_a1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keydvt_out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">keydvt_out</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: WUSB key derivation test: &quot;</span>
		       <span class="s">&quot;mismatch between key derivation result &quot;</span>
		       <span class="s">&quot;and WUSB1.0[A1] Errata 2006/12</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: keydvt in: key</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="n">stv_key_a1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_key_a1</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: keydvt in: nonce</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">stv_keydvt_n_a1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_keydvt_n_a1</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: keydvt in: hnonce &amp; dnonce</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stv_keydvt_in_a1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stv_keydvt_in_a1</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: keydvt out: KCK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keydvt_out</span><span class="p">.</span><span class="n">kck</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">keydvt_out</span><span class="p">.</span><span class="n">kck</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: keydvt out: PTK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wusb_key_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keydvt_out</span><span class="p">.</span><span class="n">ptk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">keydvt_out</span><span class="p">.</span><span class="n">ptk</span><span class="p">));</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize crypto system</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: we do nothing now, other than verifying. Later on we&#39;ll</span>
<span class="cm"> * cache the encryption stuff, so that&#39;s why we have a separate init.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wusb_crypto_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_crypto_verify</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">wusb_key_derive_verify</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">wusb_oob_mic_verify</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wusb_crypto_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: free cached crypto transforms */</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
