<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › wusbcore › wusbhc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>wusbhc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Wireless USB Host Controller</span>
<span class="cm"> * Common infrastructure for WHCI and HWA WUSB-HC drivers</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This driver implements parts common to all Wireless USB Host</span>
<span class="cm"> * Controllers (struct wusbhc, embedding a struct usb_hcd) and is used</span>
<span class="cm"> * by:</span>
<span class="cm"> *</span>
<span class="cm"> *   - hwahc: HWA, USB-dongle that implements a Wireless USB host</span>
<span class="cm"> *     controller, (Wireless USB 1.0 Host-Wire-Adapter specification).</span>
<span class="cm"> *</span>
<span class="cm"> *   - whci: WHCI, a PCI card with a wireless host controller</span>
<span class="cm"> *     (Wireless Host Controller Interface 1.0 specification).</span>
<span class="cm"> *</span>
<span class="cm"> * Check out the Design-overview.txt file in the source documentation</span>
<span class="cm"> * for other details on the implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Main blocks:</span>
<span class="cm"> *</span>
<span class="cm"> *  rh         Root Hub emulation (part of the HCD glue)</span>
<span class="cm"> *</span>
<span class="cm"> *  devconnect Handle all the issues related to device connection,</span>
<span class="cm"> *             authentication, disconnection, timeout, reseting,</span>
<span class="cm"> *             keepalives, etc.</span>
<span class="cm"> *</span>
<span class="cm"> *  mmc        MMC IE broadcasting handling</span>
<span class="cm"> *</span>
<span class="cm"> * A host controller driver just initializes its stuff and as part of</span>
<span class="cm"> * that, creates a &#39;struct wusbhc&#39; instance that handles all the</span>
<span class="cm"> * common WUSB mechanisms. Links in the function ops that are specific</span>
<span class="cm"> * to it and then registers the host controller. Ready to run.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __WUSBHC_H__</span>
<span class="cp">#define __WUSBHC_H__</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/uwb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/wusb.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Time from a WUSB channel stop request to the last transmitted MMC.</span>
<span class="cm"> *</span>
<span class="cm"> * This needs to be &gt; 4.096 ms in case no MMCs can be transmitted in</span>
<span class="cm"> * zone 0.</span>
<span class="cm"> */</span>
<span class="cp">#define WUSB_CHANNEL_STOP_DELAY_MS 8</span>

<span class="cm">/**</span>
<span class="cm"> * Wireless USB device</span>
<span class="cm"> *</span>
<span class="cm"> * Describe a WUSB device connected to the cluster. This struct</span>
<span class="cm"> * belongs to the &#39;struct wusb_port&#39; it is attached to and it is</span>
<span class="cm"> * responsible for putting and clearing the pointer to it.</span>
<span class="cm"> *</span>
<span class="cm"> * Note this &quot;complements&quot; the &#39;struct usb_device&#39; that the usb_hcd</span>
<span class="cm"> * keeps for each connected USB device. However, it extends some</span>
<span class="cm"> * information that is not available (there is no hcpriv ptr in it!)</span>
<span class="cm"> * *and* most importantly, it&#39;s life cycle is different. It is created</span>
<span class="cm"> * as soon as we get a DN_Connect (connect request notification) from</span>
<span class="cm"> * the device through the WUSB host controller; the USB stack doesn&#39;t</span>
<span class="cm"> * create the device until we authenticate it. FIXME: this will</span>
<span class="cm"> * change.</span>
<span class="cm"> *</span>
<span class="cm"> * @bos:    This is allocated when the BOS descriptors are read from</span>
<span class="cm"> *          the device and freed upon the wusb_dev struct dying.</span>
<span class="cm"> * @wusb_cap_descr: points into @bos, and has been verified to be size</span>
<span class="cm"> *                  safe.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refcnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cack_node</span><span class="p">;</span>	<span class="cm">/* Connect-Ack list */</span>
	<span class="n">u8</span> <span class="n">port_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">beacon_type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_encryption_descriptor</span> <span class="n">ccm1_etd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_ckhdid</span> <span class="n">cdid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry_ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_bos_descriptor</span> <span class="o">*</span><span class="n">bos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_wireless_cap_descriptor</span> <span class="o">*</span><span class="n">wusb_cap_descr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="n">availability</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">devconnect_acked_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">set_gtk_urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">set_gtk_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define WUSB_DEV_ADDR_UNAUTH 0x80</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wusb_dev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="cm">/* no need to init the cack_node */</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusb_dev_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">_wusb_dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="nf">wusb_dev_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wusb_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wusb_dev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="n">wusb_dev_destroy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Wireless USB Host Controller root hub &quot;fake&quot; ports</span>
<span class="cm"> * (state and device information)</span>
<span class="cm"> *</span>
<span class="cm"> * Wireless USB is wireless, so there are no ports; but we</span>
<span class="cm"> * fake&#39;em. Each RC can connect a max of devices at the same time</span>
<span class="cm"> * (given in the Wireless Adapter descriptor, bNumPorts or WHCI&#39;s</span>
<span class="cm"> * caps), referred to in wusbhc-&gt;ports_max.</span>
<span class="cm"> *</span>
<span class="cm"> * See rh.c for more information.</span>
<span class="cm"> *</span>
<span class="cm"> * The @status and @change use the same bits as in USB2.0[11.24.2.7],</span>
<span class="cm"> * so we don&#39;t have to do much when getting the port&#39;s status.</span>
<span class="cm"> *</span>
<span class="cm"> * WUSB1.0[7.1], USB2.0[11.24.2.7.1,fig 11-10],</span>
<span class="cm"> * include/linux/usb_ch9.h (#define USB_PORT_STAT_*)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wusb_port</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">change</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>	<span class="cm">/* connected device&#39;s info */</span>
	<span class="n">u32</span> <span class="n">ptk_tkid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * WUSB Host Controller specifics</span>
<span class="cm"> *</span>
<span class="cm"> * All fields that are common to all Wireless USB controller types</span>
<span class="cm"> * (HWA and WHCI) are grouped here. Host Controller</span>
<span class="cm"> * functions/operations that only deal with general Wireless USB HC</span>
<span class="cm"> * issues use this data type to refer to the host.</span>
<span class="cm"> *</span>
<span class="cm"> * @usb_hcd 	   Instantiation of a USB host controller</span>
<span class="cm"> *                 (initialized by upper layer [HWA=HC or WHCI].</span>
<span class="cm"> *</span>
<span class="cm"> * @dev		   Device that implements this; initialized by the</span>
<span class="cm"> *                 upper layer (HWA-HC, WHCI...); this device should</span>
<span class="cm"> *                 have a refcount.</span>
<span class="cm"> *</span>
<span class="cm"> * @trust_timeout  After this time without hearing for device</span>
<span class="cm"> *                 activity, we consider the device gone and we have to</span>
<span class="cm"> *                 re-authenticate.</span>
<span class="cm"> *</span>
<span class="cm"> *                 Can be accessed w/o locking--however, read to a</span>
<span class="cm"> *                 local variable then use.</span>
<span class="cm"> *</span>
<span class="cm"> * @chid           WUSB Cluster Host ID: this is supposed to be a</span>
<span class="cm"> *                 unique value that doesn&#39;t change across reboots (so</span>
<span class="cm"> *                 that your devices do not require re-association).</span>
<span class="cm"> *</span>
<span class="cm"> *                 Read/Write protected by @mutex</span>
<span class="cm"> *</span>
<span class="cm"> * @dev_info       This array has ports_max elements. It is used to</span>
<span class="cm"> *                 give the HC information about the WUSB devices (see</span>
<span class="cm"> *                 &#39;struct wusb_dev_info&#39;).</span>
<span class="cm"> *</span>
<span class="cm"> *	           For HWA we need to allocate it in heap; for WHCI it</span>
<span class="cm"> *                 needs to be permanently mapped, so we keep it for</span>
<span class="cm"> *                 both and make it easy. Call wusbhc-&gt;dev_info_set()</span>
<span class="cm"> *                 to update an entry.</span>
<span class="cm"> *</span>
<span class="cm"> * @ports_max	   Number of simultaneous device connections (fake</span>
<span class="cm"> *                 ports) this HC will take. Read-only.</span>
<span class="cm"> *</span>
<span class="cm"> * @port      	   Array of port status for each fake root port. Guaranteed to</span>
<span class="cm"> *                 always be the same length during device existence</span>
<span class="cm"> *                 [this allows for some unlocked but referenced reading].</span>
<span class="cm"> *</span>
<span class="cm"> * @mmcies_max	   Max number of Information Elements this HC can send</span>
<span class="cm"> *                 in its MMC. Read-only.</span>
<span class="cm"> *</span>
<span class="cm"> * @start          Start the WUSB channel.</span>
<span class="cm"> *</span>
<span class="cm"> * @stop           Stop the WUSB channel after the specified number of</span>
<span class="cm"> *                 milliseconds.  Channel Stop IEs should be transmitted</span>
<span class="cm"> *                 as required by [WUSB] 4.16.2.1.</span>
<span class="cm"> *</span>
<span class="cm"> * @mmcie_add	   HC specific operation (WHCI or HWA) for adding an</span>
<span class="cm"> *                 MMCIE.</span>
<span class="cm"> *</span>
<span class="cm"> * @mmcie_rm	   HC specific operation (WHCI or HWA) for removing an</span>
<span class="cm"> *                 MMCIE.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_ptk:       Set the PTK and enable encryption for a device. Or, if</span>
<span class="cm"> *                 the supplied key is NULL, disable encryption for that</span>
<span class="cm"> *                 device.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_gtk:       Set the GTK to be used for all future broadcast packets</span>
<span class="cm"> *                 (i.e., MMCs).  With some hardware, setting the GTK may start</span>
<span class="cm"> *                 MMC transmission.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:</span>
<span class="cm"> *</span>
<span class="cm"> *  - If wusb_dev-&gt;usb_dev is not NULL, then usb_dev is valid</span>
<span class="cm"> *    (wusb_dev has a refcount on it). Likewise, if usb_dev-&gt;wusb_dev</span>
<span class="cm"> *    is not NULL, usb_dev-&gt;wusb_dev is valid (usb_dev keeps a</span>
<span class="cm"> *    refcount on it).</span>
<span class="cm"> *</span>
<span class="cm"> *    Most of the times when you need to use it, it will be non-NULL,</span>
<span class="cm"> *    so there is no real need to check for it (wusb_dev will</span>
<span class="cm"> *    disappear before usb_dev).</span>
<span class="cm"> *</span>
<span class="cm"> *  - The following fields need to be filled out before calling</span>
<span class="cm"> *    wusbhc_create(): ports_max, mmcies_max, mmcie_{add,rm}.</span>
<span class="cm"> *</span>
<span class="cm"> *  - there is no wusbhc_init() method, we do everything in</span>
<span class="cm"> *    wusbhc_create().</span>
<span class="cm"> *</span>
<span class="cm"> *  - Creation is done in two phases, wusbhc_create() and</span>
<span class="cm"> *    wusbhc_create_b(); b are the parts that need to be called after</span>
<span class="cm"> *    calling usb_hcd_add(&amp;wusbhc-&gt;usb_hcd).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wusbhc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="n">usb_hcd</span><span class="p">;</span>		<span class="cm">/* HAS TO BE 1st */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_pal</span> <span class="n">pal</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">trust_timeout</span><span class="p">;</span>			<span class="cm">/* in jiffies */</span>
	<span class="k">struct</span> <span class="n">wusb_ckhdid</span> <span class="n">chid</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">phy_rate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wuie_host_info</span> <span class="o">*</span><span class="n">wuie_host_info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>			<span class="cm">/* locks everything else */</span>
	<span class="n">u16</span> <span class="n">cluster_id</span><span class="p">;</span>				<span class="cm">/* Wireless USB Cluster ID */</span>
	<span class="k">struct</span> <span class="n">wusb_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>			<span class="cm">/* Fake port status handling */</span>
	<span class="k">struct</span> <span class="n">wusb_dev_info</span> <span class="o">*</span><span class="n">dev_info</span><span class="p">;</span>		<span class="cm">/* for Set Device Info mgmt */</span>
	<span class="n">u8</span> <span class="n">ports_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">active</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* currently xmit&#39;ing MMCs */</span>
	<span class="k">struct</span> <span class="n">wuie_keep_alive</span> <span class="n">keep_alive_ie</span><span class="p">;</span>	<span class="cm">/* protected by mutex */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">keep_alive_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cack_list</span><span class="p">;</span>		<span class="cm">/* Connect acknowledging */</span>
	<span class="kt">size_t</span> <span class="n">cack_count</span><span class="p">;</span>			<span class="cm">/* protected by &#39;mutex&#39; */</span>
	<span class="k">struct</span> <span class="n">wuie_connect_ack</span> <span class="n">cack_ie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>		<span class="cm">/* cluster bandwidth reservation */</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mmcie_mutex</span><span class="p">;</span>		<span class="cm">/* MMC WUIE handling */</span>
	<span class="k">struct</span> <span class="n">wuie_hdr</span> <span class="o">**</span><span class="n">mmcie</span><span class="p">;</span>		<span class="cm">/* WUIE array */</span>
	<span class="n">u8</span> <span class="n">mmcies_max</span><span class="p">;</span>
	<span class="cm">/* FIXME: make wusbhc_ops? */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmcie_add</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">interval</span><span class="p">,</span> <span class="n">u8</span> <span class="n">repeat_cnt</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wuie_hdr</span> <span class="o">*</span><span class="n">wuie</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmcie_rm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">handle</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_info_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bwa_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">s8</span> <span class="n">stream_index</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_ptk</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_idx</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">tkid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">key_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_gtk</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">tkid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">key_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_num_dnts</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">interval</span><span class="p">,</span> <span class="n">u8</span> <span class="n">slots</span><span class="p">);</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_key_descriptor</span> <span class="n">descr</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>				<span class="cm">/* GTK key data */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">gtk</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">gtk_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gtk_tkid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">gtk_rekey_done_work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pending_set_gtks</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_encryption_descriptor</span> <span class="o">*</span><span class="n">ccm1_etd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define usb_hcd_to_wusbhc(u) container_of((u), struct wusbhc, usb_hcd)</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_b_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_b_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusb_dev_sysfs_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusb_dev_sysfs_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_sec_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_sec_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_sec_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_sec_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_giveback_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wusbhc_reset_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">wusbhc_pal_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wusbhc_pal_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return @usb_dev&#39;s @usb_hcd (properly referenced) or NULL if gone</span>
<span class="cm"> *</span>
<span class="cm"> * @usb_dev: USB device, UNLOCKED and referenced (or otherwise, safe ptr)</span>
<span class="cm"> *</span>
<span class="cm"> * This is a safe assumption as @usb_dev-&gt;bus is referenced all the</span>
<span class="cm"> * time during the @usb_dev life cycle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">usb_hcd_get_by_usb_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">;</span>
	<span class="n">usb_hcd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">usb_get_hcd</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Increment the reference count on a wusbhc.</span>
<span class="cm"> *</span>
<span class="cm"> * @wusbhc&#39;s life cycle is identical to that of the underlying usb_hcd.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="nf">wusbhc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_get_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">usb_hcd</span><span class="p">)</span> <span class="o">?</span> <span class="n">wusbhc</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the wusbhc associated to a @usb_dev</span>
<span class="cm"> *</span>
<span class="cm"> * @usb_dev: USB device, UNLOCKED and referenced (or otherwise, safe ptr)</span>
<span class="cm"> *</span>
<span class="cm"> * @returns: wusbhc for @usb_dev; NULL if the @usb_dev is being torn down.</span>
<span class="cm"> *           WARNING: referenced at the usb_hcd level, unlocked</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: move offline</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="nf">wusbhc_get_by_usb_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_hcd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* but root hubs */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;devnum %d wusb %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span>
			<span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">usb_hcd</span> <span class="o">=</span> <span class="n">usb_hcd_get_by_usb_dev</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">usb_hcd</span><span class="o">-&gt;</span><span class="n">wireless</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wusbhc</span> <span class="o">=</span> <span class="n">usb_hcd_to_wusbhc</span><span class="p">(</span><span class="n">usb_hcd</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wusbhc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">usb_hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">wusbhc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wusbhc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_chid_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">wusb_ckhdid</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Device connect handling */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_devconnect_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_devconnect_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_devconnect_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_devconnect_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_handle_dn</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">srcaddr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">wusb_dn_hdr</span> <span class="o">*</span><span class="n">dn_hdr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__wusbhc_dev_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusb_usb_ncb</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusb_set_dev_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/* Wireless USB fake Root Hub methods */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_rh_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_rh_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_rh_status_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_rh_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_rh_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_rh_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_rh_start_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>

<span class="cm">/* MMC handling */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_mmcie_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_mmcie_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusbhc_mmcie_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">interval</span><span class="p">,</span> <span class="n">u8</span> <span class="n">repeat_cnt</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">wuie_hdr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusbhc_mmcie_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wuie_hdr</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Bandwidth reservation */</span>
<span class="kt">int</span> <span class="n">wusbhc_rsv_establish</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wusbhc_rsv_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * I&#39;ve always said</span>
<span class="cm"> * I wanted a wedding in a church...</span>
<span class="cm"> *</span>
<span class="cm"> * but lately I&#39;ve been thinking about</span>
<span class="cm"> * the Botanical Gardens.</span>
<span class="cm"> *</span>
<span class="cm"> * We could do it by the tulips.</span>
<span class="cm"> * It&#39;ll be beautiful</span>
<span class="cm"> *</span>
<span class="cm"> * --Security!</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusb_dev_sec_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">wusb_dev_sec_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="p">)</span> <span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wusb_dev_4way_handshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">wusb_ckhdid</span> <span class="o">*</span><span class="n">ck</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">wusbhc_gtk_rekey</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">wusb_dev_update_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">);</span>


<span class="cm">/* WUSB Cluster ID handling */</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">wusb_cluster_id_get</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wusb_cluster_id_put</span><span class="p">(</span><span class="n">u8</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * wusb_port_by_idx - return the port associated to a zero-based port index</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: valid without locking as long as wusbhc is referenced (as the</span>
<span class="cm"> *       number of ports doesn&#39;t change). The data pointed to has to</span>
<span class="cm"> *       be verified though :)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">wusb_port</span> <span class="o">*</span><span class="nf">wusb_port_by_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">,</span>
						 <span class="n">u8</span> <span class="n">port_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">port_idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wusb_port_no_to_idx - Convert port number (per usb_dev-&gt;portnum) to</span>
<span class="cm"> * a port_idx.</span>
<span class="cm"> *</span>
<span class="cm"> * USB stack USB ports are 1 based!!</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: only valid for WUSB devices!!!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">wusb_port_no_to_idx</span><span class="p">(</span><span class="n">u8</span> <span class="n">port_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port_no</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">__wusb_dev_get_by_usb_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return a referenced wusb_dev given a @usb_dev</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL if the usb_dev is being torn down.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: move offline</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="nf">wusb_dev_get_by_usb_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="n">wusbhc</span> <span class="o">=</span> <span class="n">wusbhc_get_by_usb_dev</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wusbhc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">__wusb_dev_get_by_usb_dev</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">wusbhc_put</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wusb_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Misc */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wusbd</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifndef __WUSBHC_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
