<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › serial › io_ionsp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>io_ionsp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *	IONSP.H		Definitions for I/O Networks Serial Protocol</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 1997-1998 Inside Out Networks, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	These definitions are used by both kernel-mode driver and the</span>
<span class="cm"> *	peripheral firmware and MUST be kept in sync.</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************************************/</span>

<span class="cm">/************************************************************************</span>

<span class="cm">The data to and from all ports on the peripheral is multiplexed</span>
<span class="cm">through a single endpoint pair (EP1 since it supports 64-byte</span>
<span class="cm">MaxPacketSize). Therefore, the data, commands, and status for</span>
<span class="cm">each port must be preceded by a short header identifying the</span>
<span class="cm">destination port. The header also identifies the bytes that follow</span>
<span class="cm">as data or as command/status info.</span>

<span class="cm">Header format, first byte:</span>

<span class="cm">    CLLLLPPP</span>
<span class="cm">    --------</span>
<span class="cm">    | |	 |------ Port Number:	0-7</span>
<span class="cm">    | |--------- Length:	MSB bits of length</span>
<span class="cm">    |----------- Data/Command:	0 = Data header</span>
<span class="cm">				1 = Cmd / Status (Cmd if OUT, Status if IN)</span>

<span class="cm">This gives 2 possible formats:</span>


<span class="cm">    Data header:		0LLLLPPP	LLLLLLLL</span>
<span class="cm">    ============</span>

<span class="cm">    Where (LLLL,LLLLLLL) is 12-bit length of data that follows for</span>
<span class="cm">    port number (PPP). The length is 0-based (0-FFF means 0-4095</span>
<span class="cm">    bytes). The ~4K limit allows the host driver (which deals in</span>
<span class="cm">    transfer requests instead of individual packets) to write a</span>
<span class="cm">    large chunk of data in a single request. Note, however, that</span>
<span class="cm">    the length must always be &lt;= the current TxCredits for a given</span>
<span class="cm">    port due to buffering limitations on the peripheral.</span>


<span class="cm">    Cmd/Status header:		1ccccPPP	[ CCCCCCCC,	 Params ]...</span>
<span class="cm">    ==================</span>

<span class="cm">    Where (cccc) or (cccc,CCCCCCCC) is the cmd or status identifier.</span>
<span class="cm">    Frequently-used values are encoded as (cccc), longer ones using</span>
<span class="cm">    (cccc,CCCCCCCC). Subsequent bytes are optional parameters and are</span>
<span class="cm">    specific to the cmd or status code. This may include a length</span>
<span class="cm">    for command and status codes that need variable-length parameters.</span>


<span class="cm">In addition, we use another interrupt pipe (endpoint) which the host polls</span>
<span class="cm">periodically for flow control information. The peripheral, when there has</span>
<span class="cm">been a change, sends the following 10-byte packet:</span>

<span class="cm">	RRRRRRRRRRRRRRRR</span>
<span class="cm">	T0T0T0T0T0T0T0T0</span>
<span class="cm">	T1T1T1T1T1T1T1T1</span>
<span class="cm">	T2T2T2T2T2T2T2T2</span>
<span class="cm">	T3T3T3T3T3T3T3T3</span>

<span class="cm">The first field is the 16-bit RxBytesAvail field, which indicates the</span>
<span class="cm">number of bytes which may be read by the host from EP1. This is necessary:</span>
<span class="cm">(a) because OSR2.1 has a bug which causes data loss if the peripheral returns</span>
<span class="cm">fewer bytes than the host expects to read, and (b) because, on Microsoft</span>
<span class="cm">platforms at least, an outstanding read posted on EP1 consumes about 35% of</span>
<span class="cm">the CPU just polling the device for data.</span>

<span class="cm">The next 4 fields are the 16-bit TxCredits for each port, which indicate how</span>
<span class="cm">many bytes the host is allowed to send on EP1 for transmit to a given port.</span>
<span class="cm">After an OPEN_PORT command, the Edgeport sends the initial TxCredits for that</span>
<span class="cm">port.</span>

<span class="cm">All 16-bit fields are sent in little-endian (Intel) format.</span>

<span class="cm">************************************************************************/</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Define format of InterruptStatus packet returned from the
Interrupt pipe</p></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">int_status_pkt</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">RxBytesAvail</span><span class="p">;</span>			<span class="c1">// Additional bytes available to</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>be read from Bulk IN pipe</p></td><td class="code"><div class="highlight"><pre>	<span class="n">__u16</span> <span class="n">TxCredits</span><span class="p">[</span><span class="n">MAX_RS232_PORTS</span><span class="p">];</span>	<span class="c1">// Additional space available in</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>given port's TxBuffer</p></td><td class="code"><div class="highlight"><pre><span class="p">};</span>


<span class="cp">#define GET_INT_STATUS_SIZE(NumPorts) (sizeof(__u16) + (sizeof(__u16) * (NumPorts)))</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Define cmd/status header values and macros to extract them.</p>

<p>Data:        0LLLLPPP LLLLLLLL
Cmd/Stat:    1ccccPPP CCCCCCCC</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_DATA_HDR_SIZE		2</span>
<span class="cp">#define	IOSP_CMD_HDR_SIZE		2</span>

<span class="cp">#define	IOSP_MAX_DATA_LENGTH		0x0FFF		</span><span class="c1">// 12 bits -&gt; 4K</span>

<span class="cp">#define	IOSP_PORT_MASK			0x07		</span><span class="c1">// Mask to isolate port number</span>
<span class="cp">#define	IOSP_CMD_STAT_BIT		0x80		</span><span class="c1">// If set, this is command/status header</span>

<span class="cp">#define IS_CMD_STAT_HDR(Byte1)		((Byte1) &amp; IOSP_CMD_STAT_BIT)</span>
<span class="cp">#define IS_DATA_HDR(Byte1)		(!IS_CMD_STAT_HDR(Byte1))</span>

<span class="cp">#define	IOSP_GET_HDR_PORT(Byte1)		((__u8) ((Byte1) &amp; IOSP_PORT_MASK))</span>
<span class="cp">#define	IOSP_GET_HDR_DATA_LEN(Byte1, Byte2)	((__u16) (((__u16)((Byte1) &amp; 0x78)) &lt;&lt; 5) | (Byte2))</span>
<span class="cp">#define	IOSP_GET_STATUS_CODE(Byte1)		((__u8) (((Byte1) &amp;  0x78) &gt;&gt; 3))</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>These macros build the 1st and 2nd bytes for a data header</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_BUILD_DATA_HDR1(Port, Len)		((__u8) (((Port) | ((__u8) (((__u16) (Len)) &gt;&gt; 5) &amp; 0x78))))</span>
<span class="cp">#define	IOSP_BUILD_DATA_HDR2(Port, Len)		((__u8) (Len))</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>These macros build the 1st and 2nd bytes for a command header</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_BUILD_CMD_HDR1(Port, Cmd)		((__u8) (IOSP_CMD_STAT_BIT | (Port) | ((__u8) ((Cmd) &lt;&lt; 3))))</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><hr />

<p>Define values for commands and command parameters
(sent from Host to Edgeport)</p>

<p>1ccccPPP P1P1P1P1 [ P2P2P2P2P2 ]...</p>

<p>cccc:    00-07   2-byte commands. Write UART register 0-7 with
                value in P1. See 16650.H for definitions of
                UART register numbers and contents.</p>

<pre><code>08-0B   3-byte commands:                    ==== P1 ====    ==== P2 ====
            08  available for expansion
            09  1-param commands        Command Code    Param
            0A  available for expansion
            0B  available for expansion

0C-0D   4-byte commands.    P1 = extended cmd and P2,P3 = params
                Currently unimplemented.

0E-0F   N-byte commands:    P1 = num bytes after P1 (ie, TotalLen - 2)
                P2 = extended cmd, P3..Pn = parameters.
                Currently unimplemented.
</code></pre></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_WRITE_UART_REG(n)	((n) &amp; 0x07)	</span><span class="c1">// UartReg[ n ] := P1</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Register numbers and contents
defined in 16554.H.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><pre><code>            0x08        // Available for expansion.
</code></pre></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_EXT_CMD			0x09		</span><span class="c1">// P1 = Command code (defined below)</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>P2 = Parameter</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Extended Command values, used with IOSP<em>EXT</em>CMD, may
or may not use parameter P2.</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_CMD_OPEN_PORT		0x00		</span><span class="c1">// Enable ints, init UART. (NO PARAM)</span>
<span class="cp">#define	IOSP_CMD_CLOSE_PORT		0x01		</span><span class="c1">// Disable ints, flush buffers. (NO PARAM)</span>
<span class="cp">#define	IOSP_CMD_CHASE_PORT		0x02		</span><span class="c1">// Wait for Edgeport TX buffers to empty. (NO PARAM)</span>
<span class="cp">#define IOSP_CMD_SET_RX_FLOW		0x03		</span><span class="c1">// Set Rx Flow Control in Edgeport</span>
<span class="cp">#define IOSP_CMD_SET_TX_FLOW		0x04		</span><span class="c1">// Set Tx Flow Control in Edgeport</span>
<span class="cp">#define IOSP_CMD_SET_XON_CHAR		0x05		</span><span class="c1">// Set XON Character in Edgeport</span>
<span class="cp">#define IOSP_CMD_SET_XOFF_CHAR		0x06		</span><span class="c1">// Set XOFF Character in Edgeport</span>
<span class="cp">#define IOSP_CMD_RX_CHECK_REQ		0x07		</span><span class="c1">// Request Edgeport to insert a Checkpoint into</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>the receive data stream (Parameter = 1 byte sequence number)</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOSP_CMD_SET_BREAK		0x08		</span><span class="c1">// Turn on the BREAK (LCR bit 6)</span>
<span class="cp">#define IOSP_CMD_CLEAR_BREAK		0x09		</span><span class="c1">// Turn off the BREAK (LCR bit 6)</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>Define macros to simplify building of IOSP cmds</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define MAKE_CMD_WRITE_REG(ppBuf, pLen, Port, Reg, Val)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	(*(ppBuf))[0] = IOSP_BUILD_CMD_HDR1((Port),			\</span>
<span class="cp">					    IOSP_WRITE_UART_REG(Reg));	\</span>
<span class="cp">	(*(ppBuf))[1] = (Val);						\</span>
<span class="cp">									\</span>
<span class="cp">	*ppBuf += 2;							\</span>
<span class="cp">	*pLen  += 2;							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define MAKE_CMD_EXT_CMD(ppBuf, pLen, Port, ExtCmd, Param)		\</span>
<span class="cp">do {									\</span>
<span class="cp">	(*(ppBuf))[0] = IOSP_BUILD_CMD_HDR1((Port), IOSP_EXT_CMD);	\</span>
<span class="cp">	(*(ppBuf))[1] = (ExtCmd);					\</span>
<span class="cp">	(*(ppBuf))[2] = (Param);					\</span>
<span class="cp">									\</span>
<span class="cp">	*ppBuf += 3;							\</span>
<span class="cp">	*pLen  += 3;							\</span>
<span class="cp">} while (0)</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><hr />

<p>Define format of flow control commands
(sent from Host to Edgeport)</p>

<p>11001PPP FlowCmd FlowTypes</p>

<p>Note that the 'FlowTypes' parameter is a bit mask; that is,
more than one flow control type can be active at the same time.
FlowTypes = 0 means 'no flow control'.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>IOSP<em>CMD</em>SET<em>RX</em>FLOW</p>

<p>Tells Edgeport how it can stop incoming UART data</p>

<p>Example for Port 0
P0 = 11001000
 P1 = IOSP<em>CMD</em>SET<em>RX</em>FLOW
 P2 = Bit mask as follows:</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOSP_RX_FLOW_RTS		0x01	</span><span class="c1">// Edgeport drops RTS to stop incoming data</span>
<span class="cp">#define IOSP_RX_FLOW_DTR		0x02	</span><span class="c1">// Edgeport drops DTR to stop incoming data</span>
<span class="cp">#define IOSP_RX_FLOW_DSR_SENSITIVITY	0x04	</span><span class="c1">// Ignores Rx data unless DSR high</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Not currently implemented by firmware.</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOSP_RX_FLOW_XON_XOFF		0x08	</span><span class="c1">// Edgeport sends XOFF char to stop incoming data.</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>Host must have previously programmed the
XON/XOFF values with SET<em>XON/SET</em>XOFF
before enabling this bit.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>IOSP<em>CMD</em>SET<em>TX</em>FLOW</p>

<p>Tells Edgeport what signal(s) will stop it from transmitting UART data</p>

<p>Example for Port 0
P0 = 11001000
 P1 = IOSP<em>CMD</em>SET<em>TX</em>FLOW
 P2 = Bit mask as follows:</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOSP_TX_FLOW_CTS		0x01	</span><span class="c1">// Edgeport stops Tx if CTS low</span>
<span class="cp">#define IOSP_TX_FLOW_DSR		0x02	</span><span class="c1">// Edgeport stops Tx if DSR low</span>
<span class="cp">#define IOSP_TX_FLOW_DCD		0x04	</span><span class="c1">// Edgeport stops Tx if DCD low</span>
<span class="cp">#define IOSP_TX_FLOW_XON_XOFF		0x08	</span><span class="c1">// Edgeport stops Tx upon receiving XOFF char.</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Host must have previously programmed the
XON/XOFF values with SET<em>XON/SET</em>XOFF
before enabling this bit.</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOSP_TX_FLOW_XOFF_CONTINUE	0x10	</span><span class="c1">// If not set, Edgeport stops Tx when</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>sending XOFF in order to fix broken
systems that interpret the next
received char as XON.
If set, Edgeport continues Tx
normally after transmitting XOFF.
Not currently implemented by firmware.</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define IOSP_TX_TOGGLE_RTS		0x20	</span><span class="c1">// Edgeport drives RTS as a true half-duplex</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>Request-to-Send signal: it is raised before
beginning transmission and lowered after
the last Tx char leaves the UART.
Not currently implemented by firmware.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>IOSP<em>CMD</em>SET<em>XON</em>CHAR</p>

<p>Sets the character which Edgeport transmits/interprets as XON.
Note: This command MUST be sent before sending a SET<em>RX</em>FLOW or
SET<em>TX</em>FLOW with the XON_XOFF bit set.</p>

<p>Example for Port 0
P0 = 11001000
 P1 = IOSP<em>CMD</em>SET<em>XON</em>CHAR
 P2 = 0x11</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>IOSP<em>CMD</em>SET<em>XOFF</em>CHAR</p>

<p>Sets the character which Edgeport transmits/interprets as XOFF.
Note: This command must be sent before sending a SET<em>RX</em>FLOW or
SET<em>TX</em>FLOW with the XON_XOFF bit set.</p>

<p>Example for Port 0
P0 = 11001000
 P1 = IOSP<em>CMD</em>SET<em>XOFF</em>CHAR
 P2 = 0x13</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>IOSP<em>CMD</em>RX<em>CHECK</em>REQ</p>

<p>This command is used to assist in the implementation of the
 IOCTL<em>SERIAL</em>PURGE Windows IOCTL.
 This IOSP command tries to place a marker at the end of the RX
 queue in the Edgeport. If the Edgeport RX queue is full then
 the Check will be discarded.
 It is up to the device driver to timeout waiting for the
 RX<em>CHECK</em>RSP.  If a RX<em>CHECK</em>RSP is received, the driver is
sure that all data has been received from the edgeport and
may now purge any internal RX buffers.
 Note tat the sequence numbers may be used to detect lost
 CHECK_REQs.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>Example for Port 0
P0 = 11001000
 P1 = IOSP<em>CMD</em>RX<em>CHECK</em>REQ
 P2 = Sequence number</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>Response will be:
 P1 = IOSP<em>EXT</em>RX<em>CHECK</em>RSP
 P2 = Request Sequence number</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><hr />

<p>Define values for status and status parameters
(received by Host from Edgeport)</p>

<p>1ssssPPP P1P1P1P1 [ P2P2P2P2P2 ]...</p>

<p>ssss:    00-07   2-byte status.  ssss identifies which UART register
                has changed value, and the new value is in P1.
                Note that the ssss values do not correspond to the
                16554 register numbers given in 16554.H. Instead,
                see below for definitions of the ssss numbers
                used in this status message.</p>

<pre><code>08-0B   3-byte status:                  ==== P1 ====    ==== P2 ====
            08  LSR_DATA:       New LSR     Errored byte
            09  1-param responses   Response Code   Param
            0A  OPEN_RSP:       InitialMsr  TxBufferSize
            0B  available for expansion

0C-0D   4-byte status.  P1 = extended status code and P2,P3 = params
            Not currently implemented.

0E-0F   N-byte status:  P1 = num bytes after P1 (ie, TotalLen - 2)
            P2 = extended status, P3..Pn = parameters.
            Not currently implemented.
</code></pre></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************</span>
<span class="cm"> *	SSSS values for 2-byte status messages (0-8)</span>
<span class="cm"> ****************************************************/</span>

<span class="cp">#define	IOSP_STATUS_LSR			0x00	</span><span class="c1">// P1 is new value of LSR register.</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>Bits defined in 16554.H. Edgeport
returns this in order to report
line status errors (overrun,
parity, framing, break). This form
is used when a errored receive data
character was NOT present in the
UART when the LSR error occurred
(ie, when LSR bit 0 = 0).</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_STATUS_MSR			0x01	</span><span class="c1">// P1 is new value of MSR register.</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>Bits defined in 16554.H. Edgeport
returns this in order to report
changes in modem status lines
(CTS, DSR, RI, CD)</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><pre><code>            0x02    // Available for future expansion
            0x03    //
            0x04    //
            0x05    //
            0x06    //
            0x07    //
</code></pre></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************</span>
<span class="cm"> *	SSSS values for 3-byte status messages (8-A)</span>
<span class="cm"> ****************************************************/</span>

<span class="cp">#define	IOSP_STATUS_LSR_DATA		0x08	</span><span class="c1">// P1 is new value of LSR register (same as STATUS_LSR)</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>P2 is errored character read from
   RxFIFO after LSR reported an error.</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_EXT_STATUS			0x09	</span><span class="c1">// P1 is status/response code, param in P2.</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Response Codes (P1 values) for 3-byte status messages</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_EXT_STATUS_CHASE_RSP	0	</span><span class="c1">// Reply to CHASE_PORT cmd. P2 is outcome:</span>
<span class="cp">#define	IOSP_EXT_STATUS_CHASE_PASS	0	</span><span class="c1">//	P2 = 0: All Tx data drained successfully</span>
<span class="cp">#define	IOSP_EXT_STATUS_CHASE_FAIL	1	</span><span class="c1">//	P2 = 1: Timed out (stuck due to flow</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><pre><code>    control from remote device).
</code></pre></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_EXT_STATUS_RX_CHECK_RSP	1	</span><span class="c1">// Reply to RX_CHECK cmd. P2 is sequence number</span>


<span class="cp">#define IOSP_STATUS_OPEN_RSP		0x0A	</span><span class="c1">// Reply to OPEN_PORT cmd.</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>P1 is Initial MSR value
P2 is encoded TxBuffer Size:
TxBufferSize = (P2 + 1) * 64</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><pre><code>            0x0B    // Available for future expansion
</code></pre></td><td class="code"><div class="highlight"><pre><span class="cp">#define GET_TX_BUFFER_SIZE(P2) (((P2) + 1) * 64)</span>




<span class="cm">/****************************************************</span>
<span class="cm"> *	SSSS values for 4-byte status messages</span>
<span class="cm"> ****************************************************/</span>

<span class="cp">#define IOSP_EXT4_STATUS		0x0C	</span><span class="c1">// Extended status code in P1,</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>Params in P2, P3
Currently unimplemented.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><pre><code>            0x0D    // Currently unused, available.
</code></pre></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>Macros to parse status messages</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define	IOSP_GET_STATUS_LEN(code)	((code) &lt; 8 ? 2 : ((code) &lt; 0x0A ? 3 : 4))</span>

<span class="cp">#define	IOSP_STATUS_IS_2BYTE(code)	((code) &lt; 0x08)</span>
<span class="cp">#define	IOSP_STATUS_IS_3BYTE(code)	(((code) &gt;= 0x08) &amp;&amp; ((code) &lt;= 0x0B))</span>
<span class="cp">#define	IOSP_STATUS_IS_4BYTE(code)	(((code) &gt;= 0x0C) &amp;&amp; ((code) &lt;= 0x0D))</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
