<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › xhci-ring.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xhci-ring.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * xHCI host controller driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Sarah Sharp</span>
<span class="cm"> * Some code borrowed from the Linux EHCI driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Ring initialization rules:</span>
<span class="cm"> * 1. Each segment is initialized to zero, except for link TRBs.</span>
<span class="cm"> * 2. Ring cycle state = 0.  This represents Producer Cycle State (PCS) or</span>
<span class="cm"> *    Consumer Cycle State (CCS), depending on ring function.</span>
<span class="cm"> * 3. Enqueue pointer = dequeue pointer = address of first TRB in the segment.</span>
<span class="cm"> *</span>
<span class="cm"> * Ring behavior rules:</span>
<span class="cm"> * 1. A ring is empty if enqueue == dequeue.  This means there will always be at</span>
<span class="cm"> *    least one free TRB in the ring.  This is useful if you want to turn that</span>
<span class="cm"> *    into a link TRB and expand the ring.</span>
<span class="cm"> * 2. When incrementing an enqueue or dequeue pointer, if the next TRB is a</span>
<span class="cm"> *    link TRB, then load the pointer with the address in the link TRB.  If the</span>
<span class="cm"> *    link TRB had its toggle bit set, you may need to update the ring cycle</span>
<span class="cm"> *    state (see cycle bit rules).  You may have to do this multiple times</span>
<span class="cm"> *    until you reach a non-link TRB.</span>
<span class="cm"> * 3. A ring is full if enqueue++ (for the definition of increment above)</span>
<span class="cm"> *    equals the dequeue pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Cycle bit rules:</span>
<span class="cm"> * 1. When a consumer increments a dequeue pointer and encounters a toggle bit</span>
<span class="cm"> *    in a link TRB, it must toggle the ring cycle state.</span>
<span class="cm"> * 2. When a producer increments an enqueue pointer and encounters a toggle bit</span>
<span class="cm"> *    in a link TRB, it must toggle the ring cycle state.</span>
<span class="cm"> *</span>
<span class="cm"> * Producer rules:</span>
<span class="cm"> * 1. Check if ring is full before you enqueue.</span>
<span class="cm"> * 2. Write the ring cycle state to the cycle bit in the TRB you&#39;re enqueuing.</span>
<span class="cm"> *    Update enqueue pointer between each write (which may update the ring</span>
<span class="cm"> *    cycle state).</span>
<span class="cm"> * 3. Notify consumer.  If SW is producer, it rings the doorbell for command</span>
<span class="cm"> *    and endpoint rings.  If HC is the producer for the event ring,</span>
<span class="cm"> *    and it generates an interrupt according to interrupt modulation rules.</span>
<span class="cm"> *</span>
<span class="cm"> * Consumer rules:</span>
<span class="cm"> * 1. Check if TRB belongs to you.  If the cycle bit == your ring cycle state,</span>
<span class="cm"> *    the TRB is owned by the consumer.</span>
<span class="cm"> * 2. Update dequeue pointer (which may update the ring cycle state) and</span>
<span class="cm"> *    continue processing TRBs until you reach a TRB which is not owned by you.</span>
<span class="cm"> * 3. Notify the producer.  SW is the consumer for the event ring, and it</span>
<span class="cm"> *   updates event ring dequeue pointer.  HC is the consumer for the command and</span>
<span class="cm"> *   endpoint rings; it generates events on the event ring for these.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;xhci.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">handle_cmd_in_cmd_wait_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_event_cmd</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Returns zero if the TRB isn&#39;t in this segment, otherwise it returns the DMA</span>
<span class="cm"> * address of the TRB.</span>
<span class="cm"> */</span>
<span class="n">dma_addr_t</span> <span class="nf">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">seg</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segment_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seg</span> <span class="o">||</span> <span class="o">!</span><span class="n">trb</span> <span class="o">||</span> <span class="n">trb</span> <span class="o">&lt;</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* offset in TRBs */</span>
	<span class="n">segment_offset</span> <span class="o">=</span> <span class="n">trb</span> <span class="o">-</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segment_offset</span> <span class="o">&gt;</span> <span class="n">TRBS_PER_SEGMENT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">+</span> <span class="p">(</span><span class="n">segment_offset</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">trb</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Does this link TRB point to the first segment in a ring,</span>
<span class="cm"> * or was the previous TRB the last TRB on the last segment in the ERST?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">last_trb_on_last_seg</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">seg</span><span class="p">,</span> <span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">trb</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[</span><span class="n">TRBS_PER_SEGMENT</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">first_seg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LINK_TOGGLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Is this TRB a link TRB or was the last TRB the last TRB in this event ring</span>
<span class="cm"> * segment?  I.e. would the updated event TRB pointer step off the end of the</span>
<span class="cm"> * event seg?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">last_trb</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">seg</span><span class="p">,</span> <span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">trb</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[</span><span class="n">TRBS_PER_SEGMENT</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enqueue_is_link_trb</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_link_trb</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Updates trb to point to the next TRB in the ring, and updates seg if the next</span>
<span class="cm"> * TRB is in a new segment.  This does not skip over link TRBs, and it does not</span>
<span class="cm"> * effect the ring dequeue or enqueue pointers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">next_trb</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">**</span><span class="n">seg</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">**</span><span class="n">trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="o">*</span><span class="n">seg</span><span class="p">,</span> <span class="o">*</span><span class="n">trb</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">seg</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">seg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="o">*</span><span class="n">trb</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">seg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">trb</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See Cycle bit rules. SW is the consumer for the event ring only.</span>
<span class="cm"> * Don&#39;t make a ring full of link TRBs.  That would be dumb and this would loop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_deq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_updates</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If this is not event ring, there is one more usable TRB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_EVENT</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">last_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">))</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span><span class="o">++</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="o">++</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">);</span>

	<span class="cm">/* Update the dequeue pointer further if that was a link TRB or we&#39;re at</span>
<span class="cm">	 * the end of an event ring segment (which doesn&#39;t have link TRBS)</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">last_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_EVENT</span> <span class="o">&amp;&amp;</span>	<span class="n">last_trb_on_last_seg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See Cycle bit rules. SW is the consumer for the event ring only.</span>
<span class="cm"> * Don&#39;t make a ring full of link TRBs.  That would be dumb and this would loop.</span>
<span class="cm"> *</span>
<span class="cm"> * If we&#39;ve just enqueued a TRB that is in the middle of a TD (meaning the</span>
<span class="cm"> * chain bit is set), then set the chain bit in all the following link TRBs.</span>
<span class="cm"> * If we&#39;ve enqueued the last TRB in a TD, make sure the following link TRBs</span>
<span class="cm"> * have their chain bit cleared (so that each Link TRB is a separate TD).</span>
<span class="cm"> *</span>
<span class="cm"> * Section 6.4.4.1 of the 0.95 spec says link TRBs cannot have the chain bit</span>
<span class="cm"> * set, but other sections talk about dealing with the chain bit set.  This was</span>
<span class="cm"> * fixed in the 0.96 specification errata, but we have to assume that all 0.95</span>
<span class="cm"> * xHCI hardware can&#39;t handle the chain bit being cleared on a link TRB.</span>
<span class="cm"> *</span>
<span class="cm"> * @more_trbs_coming:	Will you enqueue more TRBs before calling</span>
<span class="cm"> *			prepare_transfer()?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_enq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">more_trbs_coming</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">chain</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">chain</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">TRB_CHAIN</span><span class="p">;</span>
	<span class="cm">/* If this is not event ring, there is one less usable TRB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_EVENT</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">last_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">))</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span><span class="o">--</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="o">++</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">);</span>

	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_updates</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Update the dequeue pointer further if that was a link TRB or we&#39;re at</span>
<span class="cm">	 * the end of an event ring segment (which doesn&#39;t have link TRBS)</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">last_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_EVENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the caller doesn&#39;t plan on enqueueing more</span>
<span class="cm">			 * TDs before ringing the doorbell, then we</span>
<span class="cm">			 * don&#39;t want to give the link TRB to the</span>
<span class="cm">			 * hardware just yet.  We&#39;ll give the link TRB</span>
<span class="cm">			 * back in prepare_ring() just before we enqueue</span>
<span class="cm">			 * the TD at the top of the ring.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chain</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">more_trbs_coming</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* If we&#39;re not dealing with 0.95 hardware or</span>
<span class="cm">			 * isoc rings on AMD 0.96 host,</span>
<span class="cm">			 * carry over the chain bit of the previous TRB</span>
<span class="cm">			 * (which may mean the chain bit is cleared).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_ISOC</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_AMD_0x96_HOST</span><span class="p">))</span>
						<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xhci_link_trb_quirk</span><span class="p">(</span><span class="n">xhci</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">next</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span> <span class="o">&amp;=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">TRB_CHAIN</span><span class="p">);</span>
				<span class="n">next</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span> <span class="o">|=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">chain</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Give this link TRB to the hardware */</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span> <span class="o">^=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TRB_CYCLE</span><span class="p">);</span>

			<span class="cm">/* Toggle the cycle bit after the last ring segment. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_trb_on_last_seg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check to see if there&#39;s room to enqueue num_trbs on the ring and make sure</span>
<span class="cm"> * enqueue pointer will not advance into dequeue segment. See rules above.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">room_on_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_trbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_trbs_in_deq_seg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span> <span class="o">&lt;</span> <span class="n">num_trbs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_COMMAND</span> <span class="o">&amp;&amp;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_EVENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_trbs_in_deq_seg</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span> <span class="o">&lt;</span> <span class="n">num_trbs</span> <span class="o">+</span> <span class="n">num_trbs_in_deq_seg</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Ring the host controller doorbell after placing a command on the ring */</span>
<span class="kt">void</span> <span class="nf">xhci_ring_cmd_db</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Ding dong!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">DB_VALUE_HOST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">dba</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/* Flush PCI posted writes */</span>
	<span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">dba</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xhci_ring_ep_doorbell</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">db_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">dba</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_state</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t ring the doorbell for this endpoint if there are pending</span>
<span class="cm">	 * cancellations because we don&#39;t want to interrupt processing.</span>
<span class="cm">	 * We don&#39;t want to restart any stream rings if there&#39;s a set dequeue</span>
<span class="cm">	 * pointer command pending because the device can choose to start any</span>
<span class="cm">	 * stream once the endpoint is on the HW schedule.</span>
<span class="cm">	 * FIXME - check all the stream rings for pending cancellations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HALT_PENDING</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">SET_DEQ_PENDING</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HALTED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">DB_VALUE</span><span class="p">(</span><span class="n">ep_index</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">),</span> <span class="n">db_addr</span><span class="p">);</span>
	<span class="cm">/* The CPU has better things to do at this point than wait for a</span>
<span class="cm">	 * write-posting flush.  It&#39;ll get there soon enough.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cm">/* Ring the doorbell for any rings with pending URBs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ring_doorbell_for_active_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>

	<span class="cm">/* A ring has pending URBs if its TD list is not empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HAS_STREAMS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">)))</span>
			<span class="n">xhci_ring_ep_doorbell</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">stream_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stream_id</span> <span class="o">&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span>
			<span class="n">stream_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xhci_stream_info</span> <span class="o">*</span><span class="n">stream_info</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">stream_rings</span><span class="p">[</span><span class="n">stream_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span>
			<span class="n">xhci_ring_ep_doorbell</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span>
						<span class="n">stream_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the segment that trb is in.  Start searching in start_seg.</span>
<span class="cm"> * If we must move past a segment that has a link TRB with a toggle cycle state</span>
<span class="cm"> * bit set, then we will toggle the value pointed at by cycle_state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="nf">find_trb_seg</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">start_seg</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span>	<span class="o">*</span><span class="n">trb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cycle_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">cur_seg</span> <span class="o">=</span> <span class="n">start_seg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">generic_trb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">trbs</span> <span class="o">&gt;</span> <span class="n">trb</span> <span class="o">||</span>
			<span class="o">&amp;</span><span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[</span><span class="n">TRBS_PER_SEGMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">trb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">generic_trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[</span><span class="n">TRBS_PER_SEGMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">generic</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">generic_trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LINK_TOGGLE</span><span class="p">))</span>
			<span class="o">*</span><span class="n">cycle_state</span> <span class="o">^=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="n">cur_seg</span> <span class="o">=</span> <span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_seg</span> <span class="o">==</span> <span class="n">start_seg</span><span class="p">)</span>
			<span class="cm">/* Looped over the entire list.  Oops! */</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cur_seg</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="nf">xhci_triad_to_transfer_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="cm">/* Common case: no streams */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HAS_STREAMS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="s">&quot;WARN: Slot ID %u, ep index %u has streams, &quot;</span>
				<span class="s">&quot;but URB has no stream ID.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream_id</span> <span class="o">&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">stream_rings</span><span class="p">[</span><span class="n">stream_id</span><span class="p">];</span>

	<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
			<span class="s">&quot;WARN: Slot ID %u, ep index %u has &quot;</span>
			<span class="s">&quot;stream IDs 1 to %u allocated, &quot;</span>
			<span class="s">&quot;but stream ID %u is requested.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">num_streams</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">stream_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the right ring for the given URB.</span>
<span class="cm"> * If the endpoint supports streams, boundary check the URB&#39;s stream ID.</span>
<span class="cm"> * If the endpoint doesn&#39;t support streams, return the singular endpoint ring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="nf">xhci_urb_to_transfer_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xhci_triad_to_transfer_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
		<span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move the xHC&#39;s endpoint ring dequeue pointer past cur_td.</span>
<span class="cm"> * Record the new state of the xHC&#39;s endpoint ring dequeue segment,</span>
<span class="cm"> * dequeue pointer, and new consumer cycle state in state.</span>
<span class="cm"> * Update our internal representation of the ring&#39;s dequeue pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * We do this in three jumps:</span>
<span class="cm"> *  - First we update our new ring state to be the same as when the xHC stopped.</span>
<span class="cm"> *  - Then we traverse the ring to find the segment that contains</span>
<span class="cm"> *    the last TRB in the TD.  We toggle the xHC&#39;s new cycle state when we pass</span>
<span class="cm"> *    any link TRBs with the toggle cycle bit set.</span>
<span class="cm"> *  - Finally we move the dequeue state one TRB further, toggling the cycle bit</span>
<span class="cm"> *    if we&#39;ve moved it past a link TRB with the toggle cycle bit set.</span>
<span class="cm"> *</span>
<span class="cm"> * Some of the uses of xhci_generic_trb are grotty, but if they&#39;re done</span>
<span class="cm"> * with correct __le32 accesses they should work fine.  Only users of this are</span>
<span class="cm"> * in here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_find_new_dequeue_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">cur_td</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_dequeue_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_triad_to_transfer_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span>
			<span class="n">ep_index</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN can&#39;t find new dequeue state &quot;</span>
				<span class="s">&quot;for invalid stream ID %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">stream_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Finding segment containing stopped TRB.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span> <span class="o">=</span> <span class="n">find_trb_seg</span><span class="p">(</span><span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">start_seg</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stopped_trb</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Dig out the cycle state saved by the xHC during the stop ep cmd */</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Finding endpoint context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span> <span class="o">=</span> <span class="mh">0x1</span> <span class="o">&amp;</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">deq</span><span class="p">);</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span> <span class="o">=</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Finding segment containing last TRB in TD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span> <span class="o">=</span> <span class="n">find_trb_seg</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LINK_TOGGLE</span><span class="p">)))</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span> <span class="o">^=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">next_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is only one segment in a ring, find_trb_seg()&#39;s while loop</span>
<span class="cm">	 * will not run, and it will return before it has a chance to see if it</span>
<span class="cm">	 * needs to toggle the cycle bit.  It can&#39;t tell if the stalled transfer</span>
<span class="cm">	 * ended just before the link TRB on a one-segment ring, or if the TD</span>
<span class="cm">	 * wrapped around the top of the ring, because it doesn&#39;t have the TD in</span>
<span class="cm">	 * question.  Look for the one-segment case where stalled TRB&#39;s address</span>
<span class="cm">	 * is greater than the new dequeue pointer address.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">first_seg</span> <span class="o">==</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">first_seg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stopped_trb</span><span class="p">)</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span> <span class="o">^=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Cycle state = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t update the ring cycle state for the producer (us). */</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;New dequeue segment = %p (virtual)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;New dequeue pointer = 0x%llx (DMA)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* flip_cycle means flip the cycle bit of all but the first and last TRB.</span>
<span class="cm"> * (The last TRB actually points to the ring enqueue pointer, which is not part</span>
<span class="cm"> * of this TD.)  This is used to remove partially enqueued isoc TDs from a ring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">td_to_noop</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">cur_td</span><span class="p">,</span> <span class="n">bool</span> <span class="n">flip_cycle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">cur_seg</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">cur_trb</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur_seg</span> <span class="o">=</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">start_seg</span><span class="p">,</span> <span class="n">cur_trb</span> <span class="o">=</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">first_trb</span><span class="p">;</span>
			<span class="nb">true</span><span class="p">;</span>
			<span class="n">next_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_seg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_trb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
			<span class="cm">/* Unchain any chained Link TRBs, but</span>
<span class="cm">			 * leave the pointers intact.</span>
<span class="cm">			 */</span>
			<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">TRB_CHAIN</span><span class="p">);</span>
			<span class="cm">/* Flip the cycle bit (link TRBs can&#39;t be the first</span>
<span class="cm">			 * or last TRB).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flip_cycle</span><span class="p">)</span>
				<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">^=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TRB_CYCLE</span><span class="p">);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Cancel (unchain) link TRB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Address = %p (0x%llx dma); &quot;</span>
					<span class="s">&quot;in seg %p (0x%llx dma)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cur_trb</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">cur_seg</span><span class="p">,</span> <span class="n">cur_trb</span><span class="p">),</span>
					<span class="n">cur_seg</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Preserve only the cycle bit of this TRB */</span>
			<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TRB_CYCLE</span><span class="p">);</span>
			<span class="cm">/* Flip the cycle bit except on the first or last TRB */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flip_cycle</span> <span class="o">&amp;&amp;</span> <span class="n">cur_trb</span> <span class="o">!=</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">first_trb</span> <span class="o">&amp;&amp;</span>
					<span class="n">cur_trb</span> <span class="o">!=</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span>
				<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">^=</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TRB_CYCLE</span><span class="p">);</span>
			<span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
				<span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_TR_NOOP</span><span class="p">));</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;TRB to noop at offset 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
					<span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">cur_seg</span><span class="p">,</span> <span class="n">cur_trb</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_trb</span> <span class="o">==</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">queue_set_tr_deq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">deq_seg</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">deq_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cycle_state</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">xhci_queue_new_dequeue_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_dequeue_state</span> <span class="o">*</span><span class="n">deq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Set TR Deq Ptr cmd, new deq seg = %p (0x%llx dma), &quot;</span>
			<span class="s">&quot;new deq ptr = %p (0x%llx dma), new cycle = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span> <span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">),</span>
			<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span><span class="p">);</span>
	<span class="n">queue_set_tr_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">,</span>
			<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span>
			<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span><span class="p">);</span>
	<span class="cm">/* Stop the TD queueing code from ringing the doorbell until</span>
<span class="cm">	 * this command completes.  The HC won&#39;t set the dequeue pointer</span>
<span class="cm">	 * if the ring is running, and ringing the doorbell starts the</span>
<span class="cm">	 * ring running.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">|=</span> <span class="n">SET_DEQ_PENDING</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_stop_watchdog_timer_in_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_HALT_PENDING</span><span class="p">;</span>
	<span class="cm">/* Can&#39;t del_timer_sync in interrupt, so we attempt to cancel.  If the</span>
<span class="cm">	 * timer is running on another CPU, we don&#39;t decrement stop_cmds_pending</span>
<span class="cm">	 * (since we didn&#39;t successfully stop the watchdog timer).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">stop_cmd_timer</span><span class="p">))</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stop_cmds_pending</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be called with xhci-&gt;lock held in interrupt context */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_giveback_urb_in_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">cur_td</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">adjective</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span>	<span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/* Only giveback urb when this is the last td in urb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span> <span class="o">==</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="n">PIPE_ISOCHRONOUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span>	<span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_AMD_PLL_FIX</span><span class="p">)</span>
					<span class="n">usb_amd_quirk_pll_enable</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">xhci_urb_free_priv</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we get a command completion for a Stop Endpoint Command, we need to</span>
<span class="cm"> * unlink any cancelled TDs from the ring.  There are two ways to do that:</span>
<span class="cm"> *</span>
<span class="cm"> *  1. If the HW was in the middle of processing the TD that needs to be</span>
<span class="cm"> *     cancelled, then we must move the ring&#39;s dequeue pointer past the last TRB</span>
<span class="cm"> *     in the TD with a Set Dequeue Pointer Command.</span>
<span class="cm"> *  2. Otherwise, we turn all the TRBs in the TD into No-op TRBs (with the chain</span>
<span class="cm"> *     bit cleared) so that the HW will skip over them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_stopped_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_event_cmd</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">cur_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">last_unlinked_td</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xhci_dequeue_state</span> <span class="n">deq_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">TRB_TO_SUSPEND_PORT</span><span class="p">(</span>
			     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]))))</span> <span class="p">{</span>
		<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
		<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="p">)</span>
			<span class="n">handle_cmd_in_cmd_wait_list</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span>
				<span class="n">event</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Stop endpoint command &quot;</span>
				<span class="s">&quot;completion for disabled slot %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deq_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">deq_state</span><span class="p">));</span>
	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">TRB_TO_EP_INDEX</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_stop_watchdog_timer_in_irq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_trb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ring_doorbell_for_active_rings</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fix up the ep ring first, so HW stops executing cancelled TDs.</span>
<span class="cm">	 * We have the xHCI lock, so nothing can modify this list until we drop</span>
<span class="cm">	 * it.  We&#39;re also in the event handler, so we can&#39;t get re-interrupted</span>
<span class="cm">	 * if another Stop Endpoint command completes</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span><span class="p">,</span> <span class="n">cancelled_td_list</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Removing canceled TD starting at 0x%llx (dma).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span>
					<span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">start_seg</span><span class="p">,</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">first_trb</span><span class="p">));</span>
		<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_urb_to_transfer_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This shouldn&#39;t happen unless a driver is mucking</span>
<span class="cm">			 * with the stream ID after submission.  This will</span>
<span class="cm">			 * leave the TD on the hardware ring, and the hardware</span>
<span class="cm">			 * will try to execute it, and may access a buffer</span>
<span class="cm">			 * that has already been freed.  In the best case, the</span>
<span class="cm">			 * hardware will execute it, and the event handler will</span>
<span class="cm">			 * ignore the completion event for that TD, since it was</span>
<span class="cm">			 * removed from the td_list for that endpoint.  In</span>
<span class="cm">			 * short, don&#39;t muck with the stream ID after</span>
<span class="cm">			 * submission.</span>
<span class="cm">			 */</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Cancelled URB %p &quot;</span>
					<span class="s">&quot;has invalid stream ID %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span>
					<span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">remove_finished_td</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we stopped on the TD we need to cancel, then we have to</span>
<span class="cm">		 * move the xHC endpoint ring dequeue pointer past this TD.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_td</span> <span class="o">==</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span><span class="p">)</span>
			<span class="n">xhci_find_new_dequeue_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span>
					<span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
					<span class="n">cur_td</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deq_state</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">td_to_noop</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">cur_td</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="nl">remove_finished_td:</span>
		<span class="cm">/*</span>
<span class="cm">		 * The event handler won&#39;t see a completion for this TD anymore,</span>
<span class="cm">		 * so remove it from the endpoint ring&#39;s TD list.  Keep it in</span>
<span class="cm">		 * the cancelled TD list for URB completion later.</span>
<span class="cm">		 */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">last_unlinked_td</span> <span class="o">=</span> <span class="n">cur_td</span><span class="p">;</span>
	<span class="n">xhci_stop_watchdog_timer_in_irq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* If necessary, queue a Set Transfer Ring Dequeue Pointer command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">deq_state</span><span class="p">.</span><span class="n">new_deq_ptr</span> <span class="o">&amp;&amp;</span> <span class="n">deq_state</span><span class="p">.</span><span class="n">new_deq_seg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_queue_new_dequeue_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">deq_state</span><span class="p">);</span>
		<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise ring the doorbell(s) to restart queued transfers */</span>
		<span class="n">ring_doorbell_for_active_rings</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_trb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop the lock and complete the URBs in the cancelled TD list.</span>
<span class="cm">	 * New TDs to be cancelled might be added to the end of the list before</span>
<span class="cm">	 * we can complete all the URBs for the TDs we already unlinked.</span>
<span class="cm">	 * So stop when we&#39;ve completed the URB for the last TD we unlinked.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cur_td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">xhci_td</span><span class="p">,</span> <span class="n">cancelled_td_list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">);</span>

		<span class="cm">/* Clean up the cancelled URB */</span>
		<span class="cm">/* Doesn&#39;t matter what we pass for status, since the core will</span>
<span class="cm">		 * just overwrite it (because the URB has been unlinked).</span>
<span class="cm">		 */</span>
		<span class="n">xhci_giveback_urb_in_irq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">cur_td</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;cancelled&quot;</span><span class="p">);</span>

		<span class="cm">/* Stop processing the cancelled list if the watchdog timer is</span>
<span class="cm">		 * running.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cur_td</span> <span class="o">!=</span> <span class="n">last_unlinked_td</span><span class="p">);</span>

	<span class="cm">/* Return to the event handler with xhci-&gt;lock re-acquired */</span>
<span class="p">}</span>

<span class="cm">/* Watchdog timer function for when a stop endpoint command fails to complete.</span>
<span class="cm"> * In this case, we assume the host controller is broken or dying or dead.  The</span>
<span class="cm"> * host may still be completing some other events, so we have to be careful to</span>
<span class="cm"> * let the event ring handler and the URB dequeueing/enqueueing functions know</span>
<span class="cm"> * through xhci-&gt;state.</span>
<span class="cm"> *</span>
<span class="cm"> * The timer may also fire if the host takes a very long time to respond to the</span>
<span class="cm"> * command, and the stop endpoint command completion handler cannot delete the</span>
<span class="cm"> * timer before the timer function is called.  Another endpoint cancellation may</span>
<span class="cm"> * sneak in before the timer function can grab the lock, and that may queue</span>
<span class="cm"> * another stop endpoint command and add the timer back.  So we cannot use a</span>
<span class="cm"> * simple flag to say whether there is a pending stop endpoint command for a</span>
<span class="cm"> * particular endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Instead we use a combination of that flag and a counter for the number of</span>
<span class="cm"> * pending stop endpoint commands.  If the timer is the tail end of the last</span>
<span class="cm"> * stop endpoint command, and the endpoint&#39;s command is still pending, we assume</span>
<span class="cm"> * the host is dying.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_stop_endpoint_command_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">temp_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">cur_td</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">xhci</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">xhci</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stop_cmds_pending</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Stop EP timer ran, but another timer marked &quot;</span>
				<span class="s">&quot;xHCI as DYING, exiting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">stop_cmds_pending</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HALT_PENDING</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Stop EP timer ran, but no command pending, &quot;</span>
				<span class="s">&quot;exiting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI host not responding to stop endpoint command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Assuming host is dying, halting host.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Oops, HC is dead or dying or at least not responding to the stop</span>
<span class="cm">	 * endpoint command.</span>
<span class="cm">	 */</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">|=</span> <span class="n">XHCI_STATE_DYING</span><span class="p">;</span>
	<span class="cm">/* Disable interrupts from the host controller and start halting it */</span>
	<span class="n">xhci_quiesce</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is bad; the host is not responding to commands and it&#39;s</span>
<span class="cm">		 * not allowing itself to be halted.  At least interrupts are</span>
<span class="cm">		 * disabled. If we call usb_hc_died(), it will attempt to</span>
<span class="cm">		 * disconnect all device drivers under this host.  Those</span>
<span class="cm">		 * disconnect() methods will wait for all URBs to be unlinked,</span>
<span class="cm">		 * so we must complete them.</span>
<span class="cm">		 */</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Non-responsive xHCI host is not halting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Completing active URBs anyway.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* We could turn all TDs on the rings to no-ops.  This won&#39;t</span>
<span class="cm">		 * help if the host has cached part of the ring, and is slow if</span>
<span class="cm">		 * we want to preserve the cycle bit.  Skip it and hope the host</span>
<span class="cm">		 * doesn&#39;t touch the memory.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_HC_SLOTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">temp_ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">ring</span> <span class="o">=</span> <span class="n">temp_ep</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Killing URBs for slot ID %u, &quot;</span>
					<span class="s">&quot;ep index %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cur_td</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">xhci_td</span><span class="p">,</span>
						<span class="n">td_list</span><span class="p">);</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">))</span>
					<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">);</span>
				<span class="n">xhci_giveback_urb_in_irq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">cur_td</span><span class="p">,</span>
						<span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">,</span> <span class="s">&quot;killed&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp_ep</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cur_td</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span>
						<span class="o">&amp;</span><span class="n">temp_ep</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">xhci_td</span><span class="p">,</span>
						<span class="n">cancelled_td_list</span><span class="p">);</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur_td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">);</span>
				<span class="n">xhci_giveback_urb_in_irq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">cur_td</span><span class="p">,</span>
						<span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">,</span> <span class="s">&quot;killed&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Calling usb_hc_died()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">primary_hcd</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI host controller is dead.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_ring_for_set_deq_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">dequeue_temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_trbs_free_temp</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">revert</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">num_trbs_free_temp</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span><span class="p">;</span>
	<span class="n">dequeue_temp</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We have more usable TRBs */</span>
		<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span>
				<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">==</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_ptr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">==</span> <span class="n">dequeue_temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">revert</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">revert</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Unable to find new dequeue pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span> <span class="o">=</span> <span class="n">num_trbs_free_temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we get a completion for a Set Transfer Ring Dequeue Pointer command,</span>
<span class="cm"> * we need to clear the set deq pending flag in the endpoint ring state, so that</span>
<span class="cm"> * the TD queueing code can ring the doorbell again.  We also need to ring the</span>
<span class="cm"> * endpoint doorbell to restart the ring, but only if there aren&#39;t more</span>
<span class="cm"> * cancellations pending.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_set_deq_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_event_cmd</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">TRB_TO_EP_INDEX</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="n">stream_id</span> <span class="o">=</span> <span class="n">TRB_TO_STREAM_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_stream_id_to_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Set TR deq ptr command for &quot;</span>
				<span class="s">&quot;freed stream ID %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">stream_id</span><span class="p">);</span>
		<span class="cm">/* XXX: Harmless??? */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SET_DEQ_PENDING</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="o">!=</span> <span class="n">COMP_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_state</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_state</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">COMP_TRB_ERR</span>:
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Set TR Deq Ptr cmd invalid because &quot;</span>
					<span class="s">&quot;of stream ID configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">COMP_CTX_STATE</span>:
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Set TR Deq Ptr cmd failed due &quot;</span>
					<span class="s">&quot;to incorrect slot or ep state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ep_state</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span><span class="p">);</span>
			<span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="n">EP_STATE_MASK</span><span class="p">;</span>
			<span class="n">slot_state</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="p">);</span>
			<span class="n">slot_state</span> <span class="o">=</span> <span class="n">GET_SLOT_STATE</span><span class="p">(</span><span class="n">slot_state</span><span class="p">);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot state = %u, EP state = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">slot_state</span><span class="p">,</span> <span class="n">ep_state</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">COMP_EBADSLT</span>:
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Set TR Deq Ptr cmd failed because &quot;</span>
					<span class="s">&quot;slot %u was not enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Set TR Deq Ptr cmd with unknown &quot;</span>
					<span class="s">&quot;completion code of %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* OK what do we do now?  The endpoint state is hosed, and we</span>
<span class="cm">		 * should never get to this point if the synchronization between</span>
<span class="cm">		 * queueing, and endpoint state are correct.  This might happen</span>
<span class="cm">		 * if the device gets disconnected after we&#39;ve finished</span>
<span class="cm">		 * cancelling URBs, which might not be an error...</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Successful Set TR Deq Ptr cmd, deq = @%08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">deq</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_seg</span><span class="p">,</span>
					 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_ptr</span><span class="p">)</span> <span class="o">==</span>
		    <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">deq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EP_CTX_CYCLE_MASK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Update the ring&#39;s dequeue segment and dequeue pointer</span>
<span class="cm">			 * to reflect the new position.</span>
<span class="cm">			 */</span>
			<span class="n">update_ring_for_set_deq_completion</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				<span class="n">ep_ring</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Mismatch between completed Set TR Deq &quot;</span>
					<span class="s">&quot;Ptr command &amp; xHCI internal state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ep deq seg = %p, deq ptr = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_seg</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_ptr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SET_DEQ_PENDING</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_seg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">queued_deq_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Restart any rings with pending URBs */</span>
	<span class="n">ring_doorbell_for_active_rings</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_reset_ep_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_event_cmd</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">TRB_TO_EP_INDEX</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="cm">/* This command will only fail if the endpoint wasn&#39;t halted,</span>
<span class="cm">	 * but we don&#39;t care.</span>
<span class="cm">	 */</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Ignoring reset ep completion code of %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)));</span>

	<span class="cm">/* HW with the reset endpoint quirk needs to have a configure endpoint</span>
<span class="cm">	 * command complete before the endpoint can be used.  Queue that here</span>
<span class="cm">	 * because the HW can&#39;t handle two commands being queued in a row.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_RESET_EP_QUIRK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Queueing configure endpoint command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_queue_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span>
				<span class="nb">false</span><span class="p">);</span>
		<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Clear our internal halted state and restart the ring(s) */</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_HALTED</span><span class="p">;</span>
		<span class="n">ring_doorbell_for_active_rings</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Check to see if a command in the device&#39;s command queue matches this one.</span>
<span class="cm"> * Signal the completion or free the command, and return 1.  Return 0 if the</span>
<span class="cm"> * completed command isn&#39;t at the head of the command list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_cmd_in_cmd_wait_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_event_cmd</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">xhci_command</span><span class="p">,</span> <span class="n">cmd_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">!=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">command_trb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">command</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cmd_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_event_cmd</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="n">u64</span> <span class="n">cmd_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cmd_dequeue_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_state</span><span class="p">;</span>

	<span class="n">cmd_dma</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cmd_trb</span><span class="p">);</span>
	<span class="n">cmd_dequeue_dma</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">);</span>
	<span class="cm">/* Is the command ring deq ptr out of sync with the deq seg ptr? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_dequeue_dma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Does the DMA address match our internal dequeue pointer address? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_dma</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">cmd_dequeue_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="o">&amp;</span> <span class="n">TRB_TYPE_BITMASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_ENABLE_SLOT</span><span class="p">)</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="o">==</span> <span class="n">COMP_SUCCESS</span><span class="p">)</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">slot_id</span> <span class="o">=</span> <span class="n">slot_id</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">slot_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">addr_dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_DISABLE_SLOT</span><span class="p">)</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_EP_LIMIT_QUIRK</span><span class="p">)</span>
				<span class="cm">/* Delete default control endpoint resources */</span>
				<span class="n">xhci_free_device_endpoint_resources</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
						<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">],</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">xhci_free_virt_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_CONFIG_EP</span><span class="p">)</span>:
		<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handle_cmd_in_cmd_wait_list</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Configure endpoint commands can come from the USB core</span>
<span class="cm">		 * configuration or alt setting changes, or because the HW</span>
<span class="cm">		 * needed an extra configure endpoint command after a reset</span>
<span class="cm">		 * endpoint command or streams were being configured.</span>
<span class="cm">		 * If the command was for a halted endpoint, the xHCI driver</span>
<span class="cm">		 * is not waiting on the configure endpoint command.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
		<span class="cm">/* Input ctx add_flags are the endpoint index plus one */</span>
		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_last_valid_endpoint</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* A usb_set_interface() call directly after clearing a halted</span>
<span class="cm">		 * condition may race on this quirky hardware.  Not worth</span>
<span class="cm">		 * worrying about, since this is prototype hardware.  Not sure</span>
<span class="cm">		 * if this will work for streams, but streams support was</span>
<span class="cm">		 * untested on this prototype.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_RESET_EP_QUIRK</span> <span class="o">&amp;&amp;</span>
				<span class="n">ep_index</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span><span class="p">)</span> <span class="o">-</span> <span class="n">SLOT_FLAG</span> <span class="o">==</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ring</span><span class="p">;</span>
			<span class="n">ep_state</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HALTED</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bandwidth_change</span><span class="p">;</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Completed config ep cmd - &quot;</span>
					<span class="s">&quot;last ep index = %d, state = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ep_index</span><span class="p">,</span> <span class="n">ep_state</span><span class="p">);</span>
			<span class="cm">/* Clear internal halted state and restart ring(s) */</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="n">EP_HALTED</span><span class="p">;</span>
			<span class="n">ring_doorbell_for_active_rings</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">bandwidth_change:</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Completed config ep cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span>
			<span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cmd_completion</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_EVAL_CONTEXT</span><span class="p">)</span>:
		<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handle_cmd_in_cmd_wait_list</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cmd_completion</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_ADDR_DEV</span><span class="p">)</span>:
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">addr_dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_STOP_RING</span><span class="p">)</span>:
		<span class="n">handle_stopped_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_SET_DEQ</span><span class="p">)</span>:
		<span class="n">handle_set_deq_completion</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_CMD_NOOP</span><span class="p">)</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_RESET_EP</span><span class="p">)</span>:
		<span class="n">handle_reset_ep_completion</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_RESET_DEV</span><span class="p">)</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Completed reset device command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
		<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="p">)</span>
			<span class="n">handle_cmd_in_cmd_wait_list</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Reset device command completion &quot;</span>
					<span class="s">&quot;for disabled slot %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_NEC_GET_FW</span><span class="p">)</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_NEC_HOST</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;NEC firmware version %2x.%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">NEC_FW_MAJOR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)),</span>
			 <span class="n">NEC_FW_MINOR</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Skip over unknown commands on the event ring */</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_vendor_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">trb_type</span><span class="p">;</span>

	<span class="n">trb_type</span> <span class="o">=</span> <span class="n">TRB_FIELD_TO_TYPE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Vendor specific event TRB type = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trb_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trb_type</span> <span class="o">==</span> <span class="n">TRB_NEC_CMD_COMP</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_NEC_HOST</span><span class="p">))</span>
		<span class="n">handle_cmd_completion</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* @port_id: the one-based port ID from the hardware (indexed from array of all</span>
<span class="cm"> * port registers -- USB 3.0 and USB 2.0).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a zero-based port number, which is suitable for indexing into each of</span>
<span class="cm"> * the split roothubs&#39; port arrays and bus state arrays.</span>
<span class="cm"> * Add one to it in order to call xhci_find_slot_id_by_port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">find_faked_portnum_from_hw_portnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_similar_speed_ports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* port_id from the hardware is 1-based, but port_array[], usb3_ports[],</span>
<span class="cm">	 * and usb2_ports are 0-based indexes.  Count the number of similar</span>
<span class="cm">	 * speed ports, up to 1 port before this port.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">port_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">port_speed</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">port_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Skip ports that don&#39;t have known speeds, or have duplicate</span>
<span class="cm">		 * Extended Capabilities port speed entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port_speed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">port_speed</span> <span class="o">==</span> <span class="n">DUPLICATE_ENTRY</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * USB 3.0 ports are always under a USB 3.0 hub.  USB 2.0 and</span>
<span class="cm">		 * 1.1 ports are under the USB 2.0 hub.  If the port speed</span>
<span class="cm">		 * matches the device speed, it&#39;s a similar speed port.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">port_speed</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">))</span>
			<span class="n">num_similar_speed_ports</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">num_similar_speed_ports</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_device_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Device Notification event for &quot;</span>
				<span class="s">&quot;unused slot %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Device Wake Notification event for slot ID %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">slot_id</span><span class="p">);</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span> <span class="o">&amp;&amp;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">usb_wakeup_notification</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_port_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">port_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">temp1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_ports</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">faked_port_index</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">major_revision</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_bus_state</span> <span class="o">*</span><span class="n">bus_state</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bogus_port_status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Port status change events always have a successful completion code */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">COMP_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: xHC returned failed port status event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">port_id</span> <span class="o">=</span> <span class="n">GET_PORT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Port Status Change Event for port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_id</span><span class="p">);</span>

	<span class="n">max_ports</span> <span class="o">=</span> <span class="n">HCS_MAX_PORTS</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcs_params1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">port_id</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">port_id</span> <span class="o">&gt;</span> <span class="n">max_ports</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Invalid port id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_id</span><span class="p">);</span>
		<span class="n">bogus_port_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Figure out which usb_hcd this port is attached to:</span>
<span class="cm">	 * is it a USB 3.0 port or a USB 2.0/1.1 port?</span>
<span class="cm">	 */</span>
	<span class="n">major_revision</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">port_array</span><span class="p">[</span><span class="n">port_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">major_revision</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Event for port %u not in &quot;</span>
				<span class="s">&quot;Extended Capabilities, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port_id</span><span class="p">);</span>
		<span class="n">bogus_port_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">major_revision</span> <span class="o">==</span> <span class="n">DUPLICATE_ENTRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Event for port %u duplicated in&quot;</span>
				<span class="s">&quot;Extended Capabilities, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port_id</span><span class="p">);</span>
		<span class="n">bogus_port_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hardware port IDs reported by a Port Status Change Event include USB</span>
<span class="cm">	 * 3.0 and USB 2.0 ports.  We want to check if the port has reported a</span>
<span class="cm">	 * resume event, but we first need to translate the hardware port ID</span>
<span class="cm">	 * into the index into the ports on the correct split roothub, and the</span>
<span class="cm">	 * correct bus_state structure.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Find the right roothub. */</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">major_revision</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">))</span>
		<span class="n">hcd</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="p">;</span>
	<span class="n">bus_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">hcd_index</span><span class="p">(</span><span class="n">hcd</span><span class="p">)];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">)</span>
		<span class="n">port_array</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb3_ports</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">port_array</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb2_ports</span><span class="p">;</span>
	<span class="cm">/* Find the faked port hub number */</span>
	<span class="n">faked_port_index</span> <span class="o">=</span> <span class="n">find_faked_portnum_from_hw_portnum</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
			<span class="n">port_id</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">faked_port_index</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;resume root hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">XDEV_RESUME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;port resume event for port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_id</span><span class="p">);</span>

		<span class="n">temp1</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp1</span> <span class="o">&amp;</span> <span class="n">CMD_RUN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHC is not running.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEV_SUPERSPEED</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;remote wake SS port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_id</span><span class="p">);</span>
			<span class="cm">/* Set a flag to say the port signaled remote wakeup,</span>
<span class="cm">			 * so we can tell the difference between the end of</span>
<span class="cm">			 * device and host initiated resume.</span>
<span class="cm">			 */</span>
			<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_remote_wakeup</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">faked_port_index</span><span class="p">;</span>
			<span class="n">xhci_test_and_clear_bit</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span>
					<span class="n">faked_port_index</span><span class="p">,</span> <span class="n">PORT_PLC</span><span class="p">);</span>
			<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">faked_port_index</span><span class="p">,</span>
						<span class="n">XDEV_U0</span><span class="p">);</span>
			<span class="cm">/* Need to wait until the next link state change</span>
<span class="cm">			 * indicates the device is actually in U0.</span>
<span class="cm">			 */</span>
			<span class="n">bogus_port_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;resume HS port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_id</span><span class="p">);</span>
			<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resume_done</span><span class="p">[</span><span class="n">faked_port_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">faked_port_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resuming_ports</span><span class="p">);</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span>
				  <span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resume_done</span><span class="p">[</span><span class="n">faked_port_index</span><span class="p">]);</span>
			<span class="cm">/* Do the rest in GetPortStatus */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">XDEV_U0</span> <span class="o">&amp;&amp;</span>
			<span class="n">DEV_SUPERSPEED</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;resume SS port %d finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_id</span><span class="p">);</span>
		<span class="cm">/* We&#39;ve just brought the device into U0 through either the</span>
<span class="cm">		 * Resume state after a device remote wakeup, or through the</span>
<span class="cm">		 * U3Exit state after a host-initiated resume.  If it&#39;s a device</span>
<span class="cm">		 * initiated remote wake, don&#39;t pass up the link state change,</span>
<span class="cm">		 * so the roothub behavior is consistent with external</span>
<span class="cm">		 * USB 3.0 hub behavior.</span>
<span class="cm">		 */</span>
		<span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
				<span class="n">faked_port_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot_id</span> <span class="o">&amp;&amp;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">])</span>
			<span class="n">xhci_ring_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_remote_wakeup</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">faked_port_index</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_remote_wakeup</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">faked_port_index</span><span class="p">);</span>
			<span class="n">xhci_test_and_clear_bit</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span>
					<span class="n">faked_port_index</span><span class="p">,</span> <span class="n">PORT_PLC</span><span class="p">);</span>
			<span class="n">usb_wakeup_notification</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">,</span>
					<span class="n">faked_port_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">bogus_port_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span>
		<span class="n">xhci_test_and_clear_bit</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">faked_port_index</span><span class="p">,</span>
					<span class="n">PORT_PLC</span><span class="p">);</span>

<span class="nl">cleanup:</span>
	<span class="cm">/* Update event ring dequeue pointer before dropping the lock */</span>
	<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t make the USB core poll the roothub if we got a bad port status</span>
<span class="cm">	 * change event.  Besides, at that point we can&#39;t tell which roothub</span>
<span class="cm">	 * (USB 2.0 or USB 3.0) to kick.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bogus_port_status</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* Pass this up to the core */</span>
	<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This TD is defined by the TRBs starting at start_trb in start_seg and ending</span>
<span class="cm"> * at end_trb, which may be in another segment.  If the suspect DMA address is a</span>
<span class="cm"> * TRB in this TD, this function returns that TRB&#39;s segment.  Otherwise it</span>
<span class="cm"> * returns 0.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="nf">trb_in_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">start_seg</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span>	<span class="o">*</span><span class="n">start_trb</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span>	<span class="o">*</span><span class="n">end_trb</span><span class="p">,</span>
		<span class="n">dma_addr_t</span>	<span class="n">suspect_dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">start_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">end_seg_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">end_trb_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">cur_seg</span><span class="p">;</span>

	<span class="n">start_dma</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">start_seg</span><span class="p">,</span> <span class="n">start_trb</span><span class="p">);</span>
	<span class="n">cur_seg</span> <span class="o">=</span> <span class="n">start_seg</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_dma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* We may get an event for a Link TRB in the middle of a TD */</span>
		<span class="n">end_seg_dma</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">cur_seg</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[</span><span class="n">TRBS_PER_SEGMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="cm">/* If the end TRB isn&#39;t in this segment, this is set to 0 */</span>
		<span class="n">end_trb_dma</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">cur_seg</span><span class="p">,</span> <span class="n">end_trb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end_trb_dma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The end TRB is in this segment, so suspect should be here */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_dma</span> <span class="o">&lt;=</span> <span class="n">end_trb_dma</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">suspect_dma</span> <span class="o">&gt;=</span> <span class="n">start_dma</span> <span class="o">&amp;&amp;</span> <span class="n">suspect_dma</span> <span class="o">&lt;=</span> <span class="n">end_trb_dma</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">cur_seg</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Case for one segment with</span>
<span class="cm">				 * a TD wrapped around to the top</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">suspect_dma</span> <span class="o">&gt;=</span> <span class="n">start_dma</span> <span class="o">&amp;&amp;</span>
							<span class="n">suspect_dma</span> <span class="o">&lt;=</span> <span class="n">end_seg_dma</span><span class="p">)</span> <span class="o">||</span>
						<span class="p">(</span><span class="n">suspect_dma</span> <span class="o">&gt;=</span> <span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">&amp;&amp;</span>
						 <span class="n">suspect_dma</span> <span class="o">&lt;=</span> <span class="n">end_trb_dma</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">cur_seg</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Might still be somewhere in this segment */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">suspect_dma</span> <span class="o">&gt;=</span> <span class="n">start_dma</span> <span class="o">&amp;&amp;</span> <span class="n">suspect_dma</span> <span class="o">&lt;=</span> <span class="n">end_seg_dma</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">cur_seg</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur_seg</span> <span class="o">=</span> <span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">start_dma</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">cur_seg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cur_seg</span> <span class="o">!=</span> <span class="n">start_seg</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_cleanup_halted_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event_trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">|=</span> <span class="n">EP_HALTED</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_trb</span> <span class="o">=</span> <span class="n">event_trb</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_stream</span> <span class="o">=</span> <span class="n">stream_id</span><span class="p">;</span>

	<span class="n">xhci_queue_reset_ep</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">xhci_cleanup_stalled_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_trb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_stream</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check if an error has halted the endpoint ring.  The class driver will</span>
<span class="cm"> * cleanup the halt for a non-default control endpoint if we indicate a stall.</span>
<span class="cm"> * However, a babble and other errors also halt the endpoint ring, and the class</span>
<span class="cm"> * driver won&#39;t clear the halt in that case, so we need to issue a Set Transfer</span>
<span class="cm"> * Ring Dequeue Pointer command manually.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_requires_manual_halt_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trb_comp_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TRB completion codes that may require a manual halt cleanup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_TX_ERR</span> <span class="o">||</span>
			<span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_BABBLE</span> <span class="o">||</span>
			<span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_SPLIT_ERR</span><span class="p">)</span>
		<span class="cm">/* The 0.96 spec says a babbling control endpoint</span>
<span class="cm">		 * is not halted. The 0.96 spec says it is.  Some HW</span>
<span class="cm">		 * claims to be 0.95 compliant, but it halts the control</span>
<span class="cm">		 * endpoint anyway.  Check if a babble halted the</span>
<span class="cm">		 * endpoint.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EP_STATE_MASK</span><span class="p">))</span> <span class="o">==</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EP_STATE_HALTED</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_is_vendor_info_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trb_comp_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">&gt;=</span> <span class="mi">224</span> <span class="o">&amp;&amp;</span> <span class="n">trb_comp_code</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Vendor defined &quot;informational&quot; completion code,</span>
<span class="cm">		 * treat as not-an-error.</span>
<span class="cm">		 */</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Vendor defined info completion code %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">trb_comp_code</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Treating code as success.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finish the td processing, remove the td from td list;</span>
<span class="cm"> * Return 1 if the urb can be given back.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">finish_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event_trb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_transfer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span> <span class="n">bool</span> <span class="n">skip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">xdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span>	<span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trb_comp_code</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="n">xdev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">TRB_TO_EP_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_dma_to_transfer_ring</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skip</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">td_cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_STOP_INVAL</span> <span class="o">||</span>
			<span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The Endpoint Stop Command completion will take care of any</span>
<span class="cm">		 * stopped TDs.  A stopped TD may be restarted, so don&#39;t update</span>
<span class="cm">		 * the ring dequeue pointer or take this TD off any lists yet.</span>
<span class="cm">		 */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_trb</span> <span class="o">=</span> <span class="n">event_trb</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_STALL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The transfer is completed from the driver&#39;s</span>
<span class="cm">			 * perspective, but we need to issue a set dequeue</span>
<span class="cm">			 * command for this stalled endpoint to move the dequeue</span>
<span class="cm">			 * pointer past the TD.  We can&#39;t do that here because</span>
<span class="cm">			 * the halt condition must be cleared first.  Let the</span>
<span class="cm">			 * USB class driver clear the stall later.</span>
<span class="cm">			 */</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_trb</span> <span class="o">=</span> <span class="n">event_trb</span><span class="p">;</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_stream</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">xhci_requires_manual_halt_cleanup</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="n">ep_ctx</span><span class="p">,</span> <span class="n">trb_comp_code</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Other types of errors halt the endpoint, but the</span>
<span class="cm">			 * class driver doesn&#39;t call usb_reset_endpoint() unless</span>
<span class="cm">			 * the error is -EPIPE.  Clear the halted status in the</span>
<span class="cm">			 * xHCI hardware manually.</span>
<span class="cm">			 */</span>
			<span class="n">xhci_cleanup_halted_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
					<span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Update ring dequeue pointer */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">!=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span>
				<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">);</span>
			<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">);</span>
		<span class="p">}</span>

<span class="nl">td_cleanup:</span>
		<span class="cm">/* Clean up the endpoint&#39;s TD list */</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
		<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

		<span class="cm">/* Do one last check of the actual transfer length.</span>
<span class="cm">		 * If the host controller said we transferred more data than</span>
<span class="cm">		 * the buffer length, urb-&gt;actual_length will be a very big</span>
<span class="cm">		 * number (since it&#39;s unsigned).  Play it safe and say we didn&#39;t</span>
<span class="cm">		 * transfer anything.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&gt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;URB transfer length is wrong, &quot;</span>
					<span class="s">&quot;xHC issue? req. len = %u, &quot;</span>
					<span class="s">&quot;act. len = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
				<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
		<span class="cm">/* Was this TD slated to be cancelled but completed anyway? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">))</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">);</span>

		<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Giveback the urb when all the tds are completed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span> <span class="o">==</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="n">PIPE_ISOCHRONOUS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span>
					<span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_AMD_PLL_FIX</span><span class="p">)</span>
						<span class="n">usb_amd_quirk_pll_enable</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process control tds, update urb status and actual_length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_ctrl_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event_trb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_transfer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">xdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trb_comp_code</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="n">xdev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">TRB_TO_EP_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_dma_to_transfer_ring</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">trb_comp_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">event_trb</span> <span class="o">==</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: Success on ctrl setup TRB &quot;</span>
					<span class="s">&quot;without IOC set??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event_trb</span> <span class="o">!=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: Success on ctrl data TRB &quot;</span>
					<span class="s">&quot;without IOC set??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SHORT_TX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_STOP_INVAL</span>:
	<span class="k">case</span> <span class="n">COMP_STOP</span>:
		<span class="k">return</span> <span class="n">finish_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci_requires_manual_halt_cleanup</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="n">ep_ctx</span><span class="p">,</span> <span class="n">trb_comp_code</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;TRB error code %u, &quot;</span>
				<span class="s">&quot;halted endpoint index = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">trb_comp_code</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="cm">/* else fall through */</span>
	<span class="k">case</span> <span class="n">COMP_STALL</span>:
		<span class="cm">/* Did we transfer part of the data (middle) phase? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_trb</span> <span class="o">!=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">&amp;&amp;</span>
				<span class="n">event_trb</span> <span class="o">!=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span>
				<span class="o">-</span> <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">xhci_cleanup_halted_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
			<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">finish_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Did we transfer any data, despite the errors that might have</span>
<span class="cm">	 * happened?  I.e. did we get past the setup stage?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event_trb</span> <span class="o">!=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The event was for the status stage */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_trb</span> <span class="o">==</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Don&#39;t overwrite a previously set error code</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span> <span class="o">||</span> <span class="o">*</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						<span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span>
						 <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">))</span>
					<span class="cm">/* Did we already see a short data</span>
<span class="cm">					 * stage? */</span>
					<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span>
					<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Maybe the event was for the data stage? */</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span>
				<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Waiting for status &quot;</span>
					<span class="s">&quot;stage event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">finish_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process isochronous tds, update urb packet status and actual_length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_isoc_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event_trb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_transfer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">cur_trb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">cur_seg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trb_comp_code</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">skip_td</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_dma_to_transfer_ring</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>
	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span><span class="p">;</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="cm">/* handle completion code */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">trb_comp_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_TRUST_TX_LENGTH</span><span class="p">))</span>
			<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">COMP_SHORT_TX</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SHORT_TX</span>:
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span> <span class="o">?</span>
				<span class="o">-</span><span class="n">EREMOTEIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_BW_OVER</span>:
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">;</span>
		<span class="n">skip_td</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_BUFF_OVER</span>:
	<span class="k">case</span> <span class="n">COMP_BABBLE</span>:
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="n">skip_td</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_DEV_ERR</span>:
	<span class="k">case</span> <span class="n">COMP_STALL</span>:
	<span class="k">case</span> <span class="n">COMP_TX_ERR</span>:
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="n">skip_td</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_STOP</span>:
	<span class="k">case</span> <span class="n">COMP_STOP_INVAL</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_SUCCESS</span> <span class="o">||</span> <span class="n">skip_td</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cur_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">,</span>
		     <span class="n">cur_seg</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">;</span> <span class="n">cur_trb</span> <span class="o">!=</span> <span class="n">event_trb</span><span class="p">;</span>
		     <span class="n">next_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_seg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_trb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TRB_TYPE_NOOP_LE32</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">-</span>
			<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">!=</span> <span class="n">COMP_STOP_INVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">finish_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">skip_isoc_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">xhci_transfer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_dma_to_transfer_ring</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span><span class="p">;</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="cm">/* The transfer is partly done. */</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>

	<span class="cm">/* calc actual length */</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Update ring dequeue pointer */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">!=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span>
		<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">);</span>
	<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">finish_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process bulk and interrupt tds, update urb status and actual_length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_bulk_intr_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event_trb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_transfer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">cur_trb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">cur_seg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trb_comp_code</span><span class="p">;</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_dma_to_transfer_ring</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">trb_comp_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="cm">/* Double check that the HW transferred everything. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_trb</span> <span class="o">!=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span> <span class="o">||</span>
				<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Successful completion &quot;</span>
					<span class="s">&quot;on short TX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
				<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_TRUST_TX_LENGTH</span><span class="p">))</span>
				<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">COMP_SHORT_TX</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SHORT_TX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Others already handled above */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_SHORT_TX</span><span class="p">)</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ep %#x - asked for %d bytes, &quot;</span>
				<span class="s">&quot;%d bytes untransferred</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
				<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">)));</span>
	<span class="cm">/* Fast path - was this the last TRB in the TD for this URB? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event_trb</span> <span class="o">==</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span>
				<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&lt;</span>
					<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;HC gave bad length &quot;</span>
						<span class="s">&quot;of %d bytes left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">)));</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
					<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Don&#39;t overwrite a previously set error code */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
					<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
			<span class="cm">/* Ignore a short packet completion if the</span>
<span class="cm">			 * untransferred length was zero.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">)</span>
				<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Slow path - walk the list, starting from the dequeue</span>
<span class="cm">		 * pointer, to get the actual length transferred.</span>
<span class="cm">		 */</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cur_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">,</span> <span class="n">cur_seg</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">;</span>
				<span class="n">cur_trb</span> <span class="o">!=</span> <span class="n">event_trb</span><span class="p">;</span>
				<span class="n">next_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_seg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_trb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TRB_TYPE_NOOP_LE32</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span>
					<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
		<span class="p">}</span>
		<span class="cm">/* If the ring didn&#39;t stop on a Link or No-op TRB, add</span>
<span class="cm">		 * in the actual bytes transferred from the Normal TRB</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">!=</span> <span class="n">COMP_STOP_INVAL</span><span class="p">)</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span>
				<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cur_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">-</span>
				<span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">finish_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If this function returns an error condition, it means it got a Transfer</span>
<span class="cm"> * event with a corrupted Slot ID, Endpoint ID, or TRB DMA address.</span>
<span class="cm"> * At this point, the host controller is probably hosed and should be reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_tx_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_transfer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">xdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">event_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">event_seg</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event_trb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trb_comp_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">td_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="n">xdev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR Transfer event pointed to bad slot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;@%016llx %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span>
				 <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span>
				 <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">),</span>
			 <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)),</span>
			 <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)),</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">),</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Event ring:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_debug_segment</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Endpoint ID is 1 based, our index is zero based */</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">TRB_TO_EP_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_dma_to_transfer_ring</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EP_STATE_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">EP_STATE_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR Transfer event for disabled endpoint &quot;</span>
				<span class="s">&quot;or incorrect stream ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;@%016llx %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span>
				 <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span>
				 <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">),</span>
			 <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)),</span>
			 <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)),</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">),</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Event ring:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_debug_segment</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Count current td numbers if ep-&gt;skip is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">)</span>
			<span class="n">td_num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event_dma</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">GET_COMP_CODE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">));</span>
	<span class="cm">/* Look for common error cases */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">trb_comp_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* Skip codes that require special handling depending on</span>
<span class="cm">	 * transfer type</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">TRB_LEN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">transfer_len</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_TRUST_TX_LENGTH</span><span class="p">)</span>
			<span class="n">trb_comp_code</span> <span class="o">=</span> <span class="n">COMP_SHORT_TX</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Successful completion on short TX: &quot;</span>
					<span class="s">&quot;needs XHCI_TRUST_TX_LENGTH quirk?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">COMP_SHORT_TX</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_STOP</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Stopped on Transfer TRB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_STOP_INVAL</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Stopped on No-op or Link TRB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_STALL</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Stalled endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">|=</span> <span class="n">EP_HALTED</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_TRB_ERR</span>:
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: TRB error on endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SPLIT_ERR</span>:
	<span class="k">case</span> <span class="n">COMP_TX_ERR</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Transfer error on endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_BABBLE</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Babble error on endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_DB_ERR</span>:
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: HC couldn&#39;t access mem fast enough</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_BW_OVER</span>:
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: bandwidth overrun event on endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_BUFF_OVER</span>:
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: buffer overrun event on endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_UNDERRUN</span>:
		<span class="cm">/*</span>
<span class="cm">		 * When the Isoch ring is empty, the xHC will generate</span>
<span class="cm">		 * a Ring Overrun Event for IN Isoch endpoint or Ring</span>
<span class="cm">		 * Underrun Event for OUT Isoch endpoint.</span>
<span class="cm">		 */</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;underrun event on endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Underrun Event for slot %d ep %d &quot;</span>
					<span class="s">&quot;still with TDs queued?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)),</span>
				 <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_OVERRUN</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;overrun event on endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Overrun Event for slot %d ep %d &quot;</span>
					<span class="s">&quot;still with TDs queued?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)),</span>
				 <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_DEV_ERR</span>:
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: detect an incompatible device&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_MISSED_INT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * When encounter missed service error, one or more isoc tds</span>
<span class="cm">		 * may be missed by xHC.</span>
<span class="cm">		 * Set skip flag of the ep_ring; Complete the missed tds as</span>
<span class="cm">		 * short transfer when process the ep_ring next time.</span>
<span class="cm">		 */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Miss service interval error, set skip flag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_is_vendor_info_code</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">trb_comp_code</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR Unknown event condition, HC probably &quot;</span>
				<span class="s">&quot;busted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* This TRB should be in the TD at the head of this ring&#39;s</span>
<span class="cm">		 * TD list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Event TRB for slot %d ep %d &quot;</span>
					<span class="s">&quot;with no TDs queued?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">TRB_TO_SLOT_ID</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)),</span>
				  <span class="n">ep_index</span><span class="p">);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Event TRB with TRB type ID %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span>
				  <span class="n">TRB_TYPE_BITMASK</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">xhci_print_trb_offsets</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="p">)</span> <span class="n">event</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;td_list is empty while skip &quot;</span>
						<span class="s">&quot;flag set. Clear skip flag.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We&#39;ve skipped all the TDs on the ep ring when ep-&gt;skip set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">&amp;&amp;</span> <span class="n">td_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;All tds on the ep_ring skipped. &quot;</span>
						<span class="s">&quot;Clear skip flag.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_td</span><span class="p">,</span> <span class="n">td_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span>
			<span class="n">td_num</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Is this a TRB in the currently executing TD? */</span>
		<span class="n">event_seg</span> <span class="o">=</span> <span class="n">trb_in_td</span><span class="p">(</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">,</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span><span class="p">,</span> <span class="n">event_dma</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Skip the Force Stopped Event. The event_trb(event_dma) of FSE</span>
<span class="cm">		 * is not in the current TD pointed by ep_ring-&gt;dequeue because</span>
<span class="cm">		 * that the hardware dequeue pointer still at the previous TRB</span>
<span class="cm">		 * of the current TD. The previous TRB maybe a Link TD or the</span>
<span class="cm">		 * last TRB of the previous TD. The command completion handle</span>
<span class="cm">		 * will take care the rest.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_seg</span> <span class="o">&amp;&amp;</span> <span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_STOP_INVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_seg</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Some host controllers give a spurious</span>
<span class="cm">				 * successful event after a short transfer.</span>
<span class="cm">				 * Ignore it.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_SPURIOUS_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
						<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">last_td_was_short</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">last_td_was_short</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* HC is busted, give up! */</span>
				<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="s">&quot;ERROR Transfer event TRB DMA ptr not &quot;</span>
					<span class="s">&quot;part of current TD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">skip_isoc_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_SHORT_TX</span><span class="p">)</span>
			<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">last_td_was_short</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">last_td_was_short</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Found td. Clear skip flag.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">event_trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[(</span><span class="n">event_dma</span> <span class="o">-</span> <span class="n">event_seg</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="o">/</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event_trb</span><span class="p">)];</span>
		<span class="cm">/*</span>
<span class="cm">		 * No-op TRB should not trigger interrupts.</span>
<span class="cm">		 * If event_trb is a no-op TRB, it means the</span>
<span class="cm">		 * corresponding TD has been cancelled. Just ignore</span>
<span class="cm">		 * the TD.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TRB_TYPE_NOOP_LE32</span><span class="p">(</span><span class="n">event_trb</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				 <span class="s">&quot;event_trb is a no-op TRB. Skip it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Now update the urb&#39;s actual_length and give back to</span>
<span class="cm">		 * the core</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">process_ctrl_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">process_isoc_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">process_bulk_intr_td</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">event_trb</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span>
						 <span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

<span class="nl">cleanup:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not update event ring dequeue pointer if ep-&gt;skip is set.</span>
<span class="cm">		 * Will roll back to continue process missed tds.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">==</span> <span class="n">COMP_MISSED_INT</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">urb</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
			<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
			<span class="cm">/* Leave the TD around for the reset endpoint function</span>
<span class="cm">			 * to use(but only if it&#39;s not a control endpoint,</span>
<span class="cm">			 * since we already queued the Set TR dequeue pointer</span>
<span class="cm">			 * command for stalled control endpoints).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">trb_comp_code</span> <span class="o">!=</span> <span class="n">COMP_STALL</span> <span class="o">&amp;&amp;</span>
					<span class="n">trb_comp_code</span> <span class="o">!=</span> <span class="n">COMP_BABBLE</span><span class="p">))</span>
				<span class="n">xhci_urb_free_priv</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="p">);</span>

			<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&amp;&amp;</span>
						<span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span>
						 <span class="n">URB_SHORT_NOT_OK</span><span class="p">))</span> <span class="o">||</span>
					<span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
					 <span class="o">!</span><span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)))</span>
				<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Giveback URB %p, len = %d, &quot;</span>
						<span class="s">&quot;expected = %d, status = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span>
						<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
						<span class="n">status</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="cm">/* EHCI, UHCI, and OHCI always unconditionally set the</span>
<span class="cm">			 * urb-&gt;status of an isochronous endpoint to 0.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="n">PIPE_ISOCHRONOUS</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If ep-&gt;skip is set, it means there are missed tds on the</span>
<span class="cm">	 * endpoint ring need to take care of.</span>
<span class="cm">	 * Process them as short transfer until reach the td pointed by</span>
<span class="cm">	 * the event.</span>
<span class="cm">	 */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">&amp;&amp;</span> <span class="n">trb_comp_code</span> <span class="o">!=</span> <span class="n">COMP_MISSED_INT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function handles all OS-owned events on the event ring.  It may drop</span>
<span class="cm"> * xhci-&gt;lock between event processing (e.g. to pass up port status changes).</span>
<span class="cm"> * Returns &gt;0 for &quot;possibly more events to process&quot; (caller should call again),</span>
<span class="cm"> * otherwise 0 if done.  In future, &lt;0 returns should indicate error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_handle_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_ptrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span> <span class="o">||</span> <span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">;</span>
	<span class="cm">/* Does the HC or OS own the TRB? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_cmd</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TRB_CYCLE</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Barrier between reading the TRB_CYCLE (valid) flag above and any</span>
<span class="cm">	 * speculative reads of the event&#39;s flags/data below.</span>
<span class="cm">	 */</span>
	<span class="n">rmb</span><span class="p">();</span>
	<span class="cm">/* FIXME: Handle more event types. */</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_cmd</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TRB_TYPE_BITMASK</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_COMPLETION</span><span class="p">)</span>:
		<span class="n">handle_cmd_completion</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_PORT_STATUS</span><span class="p">)</span>:
		<span class="n">handle_port_status</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="n">update_ptrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_TRANSFER</span><span class="p">)</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_tx_event</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">trans_event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">update_ptrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_DEV_NOTE</span><span class="p">)</span>:
		<span class="n">handle_device_notification</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_cmd</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TRB_TYPE_BITMASK</span><span class="p">)</span> <span class="o">&gt;=</span>
		    <span class="n">TRB_TYPE</span><span class="p">(</span><span class="mi">48</span><span class="p">))</span>
			<span class="n">handle_vendor_event</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Any of the above functions may drop and re-acquire the lock, so check</span>
<span class="cm">	 * to make sure a watchdog timer didn&#39;t mark the host as non-responsive.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI host dying, returning from &quot;</span>
				<span class="s">&quot;event handler.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">update_ptrs</span><span class="p">)</span>
		<span class="cm">/* Update SW event ring dequeue pointer */</span>
		<span class="n">inc_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">);</span>

	<span class="cm">/* Are there more items on the event ring?  Caller will call us again to</span>
<span class="cm">	 * check.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xHCI spec says we can get an interrupt, and if the HC has an error condition,</span>
<span class="cm"> * we might get bad data out of the event ring.  Section 4.10.2.7 has a list of</span>
<span class="cm"> * indicators of an event TRB error, but we check the status *first* to be safe.</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">xhci_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">temp_64</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">event_ring_deq</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">deq</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">trb</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">;</span>
	<span class="cm">/* Check if the xHC generated the interrupt, or the irq is shared */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">hw_died</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_EINT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_FATAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARNING: Host System Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
<span class="nl">hw_died:</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the op reg interrupt status first,</span>
<span class="cm">	 * so we can receive interrupts from other MSI-X interrupters.</span>
<span class="cm">	 * Write 1 to clear the interrupt status.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">|=</span> <span class="n">STS_EINT</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="cm">/* FIXME when MSI-X is supported and there are multiple vectors */</span>
	<span class="cm">/* Clear the MSI-X event interrupt status */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">irq_pending</span><span class="p">;</span>
		<span class="cm">/* Acknowledge the PCI interrupt */</span>
		<span class="n">irq_pending</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
		<span class="n">irq_pending</span> <span class="o">|=</span> <span class="n">IMAN_IP</span><span class="p">;</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">irq_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI dying, ignoring interrupt. &quot;</span>
				<span class="s">&quot;Shouldn&#39;t IRQs be disabled?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Clear the event handler busy flag (RW1C);</span>
<span class="cm">		 * the event ring should be empty.</span>
<span class="cm">		 */</span>
		<span class="n">temp_64</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>
		<span class="n">xhci_write_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp_64</span> <span class="o">|</span> <span class="n">ERST_EHB</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event_ring_deq</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">;</span>
	<span class="cm">/* FIXME this should be a delayed service routine</span>
<span class="cm">	 * that clears the EHB.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">xhci_handle_event</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

	<span class="n">temp_64</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>
	<span class="cm">/* If necessary, update the HW&#39;s version of the event ring deq ptr. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event_ring_deq</span> <span class="o">!=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">deq</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">deq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN something wrong with SW event &quot;</span>
					<span class="s">&quot;ring dequeue ptr.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Update HC event ring dequeue pointer */</span>
		<span class="n">temp_64</span> <span class="o">&amp;=</span> <span class="n">ERST_PTR_MASK</span><span class="p">;</span>
		<span class="n">temp_64</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">deq</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">~</span><span class="n">ERST_PTR_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear the event handler busy flag (RW1C); event ring is empty. */</span>
	<span class="n">temp_64</span> <span class="o">|=</span> <span class="n">ERST_EHB</span><span class="p">;</span>
	<span class="n">xhci_write_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">xhci_msi_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xhci_irq</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****		Endpoint Ring Operations	****/</span>

<span class="cm">/*</span>
<span class="cm"> * Generic function for queueing a TRB on a ring.</span>
<span class="cm"> * The caller must have checked to make sure there&#39;s room on the ring.</span>
<span class="cm"> *</span>
<span class="cm"> * @more_trbs_coming:	Will you enqueue more TRBs before calling</span>
<span class="cm"> *			prepare_transfer()?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_trb</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">more_trbs_coming</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">field1</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field3</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">trb</span><span class="p">;</span>

	<span class="n">trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">;</span>
	<span class="n">trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">field1</span><span class="p">);</span>
	<span class="n">trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">field2</span><span class="p">);</span>
	<span class="n">trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">field3</span><span class="p">);</span>
	<span class="n">trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">field4</span><span class="p">);</span>
	<span class="n">inc_enq</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">more_trbs_coming</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Does various checks on the endpoint ring, and makes it ready to queue num_trbs.</span>
<span class="cm"> * FIXME allocate segments if the ring is full.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">ep_state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_trbs</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_trbs_needed</span><span class="p">;</span>

	<span class="cm">/* Make sure the endpoint has been added to xHC schedule */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ep_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EP_STATE_DISABLED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * USB core changed config/interfaces without notifying us,</span>
<span class="cm">		 * or hardware is reporting the wrong state.</span>
<span class="cm">		 */</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN urb submitted to disabled ep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EP_STATE_ERROR</span>:
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN waiting for error on ep to be cleared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* FIXME event handling code for error needs to clear it */</span>
		<span class="cm">/* XXX not sure if this should be -ENOENT or not */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EP_STATE_HALTED</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN halted endpoint, queueing URB anyway.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EP_STATE_STOPPED</span>:
	<span class="k">case</span> <span class="n">EP_STATE_RUNNING</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR unknown endpoint state for ep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * FIXME issue Configure Endpoint command to try to get the HC</span>
<span class="cm">		 * back into a known state.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">room_on_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">num_trbs</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ep_ring</span> <span class="o">==</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Do not support expand command ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR no room on ep ring, &quot;</span>
					<span class="s">&quot;try ring expansion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">num_trbs_needed</span> <span class="o">=</span> <span class="n">num_trbs</span> <span class="o">-</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_ring_expansion</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">num_trbs_needed</span><span class="p">,</span>
					<span class="n">mem_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Ring expansion failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enqueue_is_link_trb</span><span class="p">(</span><span class="n">ep_ring</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">last_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If we&#39;re not dealing with 0.95 hardware or isoc rings</span>
<span class="cm">			 * on AMD 0.96 host, clear the chain bit.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci_link_trb_quirk</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_ISOC</span> <span class="o">&amp;&amp;</span>
					 <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_AMD_0x96_HOST</span><span class="p">)))</span>
				<span class="n">next</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">TRB_CHAIN</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">next</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TRB_CHAIN</span><span class="p">);</span>

			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span> <span class="o">^=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TRB_CYCLE</span><span class="p">);</span>

			<span class="cm">/* Toggle the cycle bit after the last ring segment. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_trb_on_last_seg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">xdev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_trbs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">td_index</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span>	<span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_stream_id_to_ring</span><span class="p">(</span><span class="n">xdev</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Can&#39;t prepare ring for bad stream ID %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">stream_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span>
			   <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EP_STATE_MASK</span><span class="p">,</span>
			   <span class="n">num_trbs</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">td_index</span><span class="p">];</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">td_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">td</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="cm">/* Add this TD to the tail of the endpoint ring&#39;s TD list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">start_seg</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="p">;</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">first_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>

	<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">td_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">count_sg_trbs_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_sgs</span><span class="p">,</span> <span class="n">num_trbs</span><span class="p">,</span> <span class="n">running_total</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">num_sgs</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_mapped_sgs</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="n">num_trbs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">num_sgs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="cm">/* Scatter gather list entries may cross 64KB boundaries */</span>
		<span class="n">running_total</span> <span class="o">=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">running_total</span> <span class="o">&amp;=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">num_trbs</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* How many more 64KB chunks to transfer, how many more TRBs? */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">&lt;</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">running_total</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_trbs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">running_total</span> <span class="o">+=</span> <span class="n">TRB_MAX_BUFF_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">num_trbs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_trb_math</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_trbs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">running_total</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_trbs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - ep %#x - Miscalculated number of &quot;</span>
				<span class="s">&quot;TRBs, %d left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">num_trbs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - ep %#x - Miscalculated tx length, &quot;</span>
				<span class="s">&quot;queued %#x (%d), asked for %#x (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
				<span class="n">running_total</span><span class="p">,</span> <span class="n">running_total</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">giveback_first_trb</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_cycle</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">start_trb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pass all the TRBs to the hardware at once and make sure this write</span>
<span class="cm">	 * isn&#39;t reordered.</span>
<span class="cm">	 */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_cycle</span><span class="p">)</span>
		<span class="n">start_trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">start_cycle</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">start_trb</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">TRB_CYCLE</span><span class="p">);</span>
	<span class="n">xhci_ring_ep_doorbell</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xHCI uses normal TRBs for both bulk and interrupt.  When the interrupt</span>
<span class="cm"> * endpoint is to be serviced, the xHC will consume (at most) one TD.  A TD</span>
<span class="cm"> * (comprised of sg list entries) can take several service intervals to</span>
<span class="cm"> * transmit.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_intr_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">xhci_interval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_interval</span><span class="p">;</span>

	<span class="n">xhci_interval</span> <span class="o">=</span> <span class="n">EP_INTERVAL_TO_UFRAMES</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span><span class="p">));</span>
	<span class="n">ep_interval</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
	<span class="cm">/* Convert to microframes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span> <span class="o">||</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
		<span class="n">ep_interval</span> <span class="o">*=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="cm">/* FIXME change this to a warning and a suggestion to use the new API</span>
<span class="cm">	 * to set the polling interval (once the API is added).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_interval</span> <span class="o">!=</span> <span class="n">ep_interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Driver uses different interval&quot;</span>
					<span class="s">&quot; (%d microframe%s) than xHCI &quot;</span>
					<span class="s">&quot;(%d microframe%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ep_interval</span><span class="p">,</span>
					<span class="n">ep_interval</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;s&quot;</span><span class="p">,</span>
					<span class="n">xhci_interval</span><span class="p">,</span>
					<span class="n">xhci_interval</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;s&quot;</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">xhci_interval</span><span class="p">;</span>
		<span class="cm">/* Convert back to frames for LS/FS devices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span> <span class="o">||</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">/=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">xhci_queue_bulk_tx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The TD size is the number of bytes remaining in the TD (including this TRB),</span>
<span class="cm"> * right shifted by 10.</span>
<span class="cm"> * It must fit in bits 21:17, so it can&#39;t be bigger than 31.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">xhci_td_remainder</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remainder</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">21</span> <span class="o">-</span> <span class="mi">17</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">remainder</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">max</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For xHCI 1.0 host controllers, TD size is the number of packets remaining in</span>
<span class="cm"> * the TD (*not* including this TRB).</span>
<span class="cm"> *</span>
<span class="cm"> * Total TD packet count = total_packet_count =</span>
<span class="cm"> *     roundup(TD size in bytes / wMaxPacketSize)</span>
<span class="cm"> *</span>
<span class="cm"> * Packets transferred up to and including this TRB = packets_transferred =</span>
<span class="cm"> *     rounddown(total bytes transferred including this TRB / wMaxPacketSize)</span>
<span class="cm"> *</span>
<span class="cm"> * TD size = total_packet_count - packets_transferred</span>
<span class="cm"> *</span>
<span class="cm"> * It must fit in bits 21:17, so it can&#39;t be bigger than 31.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">xhci_v1_0_td_remainder</span><span class="p">(</span><span class="kt">int</span> <span class="n">running_total</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trb_buff_len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_packet_count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">packets_transferred</span><span class="p">;</span>

	<span class="cm">/* One TRB with a zero-length data packet. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">trb_buff_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* All the TRB queueing functions don&#39;t count the current TRB in</span>
<span class="cm">	 * running_total.</span>
<span class="cm">	 */</span>
	<span class="n">packets_transferred</span> <span class="o">=</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">+</span> <span class="n">trb_buff_len</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">xhci_td_remainder</span><span class="p">(</span><span class="n">total_packet_count</span> <span class="o">-</span> <span class="n">packets_transferred</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_bulk_sg_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_trbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_sgs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trb_buff_len</span><span class="p">,</span> <span class="n">this_sg_len</span><span class="p">,</span> <span class="n">running_total</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_packet_count</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">first_trb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">more_trbs_coming</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">start_trb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_cycle</span><span class="p">;</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_urb_to_transfer_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">num_trbs</span> <span class="o">=</span> <span class="n">count_sg_trbs_needed</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">num_sgs</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_mapped_sgs</span><span class="p">;</span>
	<span class="n">total_packet_count</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
			<span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">));</span>

	<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">prepare_transfer</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">],</span>
			<span class="n">ep_index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
			<span class="n">num_trbs</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trb_buff_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">trb_buff_len</span><span class="p">;</span>

	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t give the first TRB to the hardware (by toggling the cycle bit)</span>
<span class="cm">	 * until we&#39;ve finished creating all the other TRBs.  The ring&#39;s cycle</span>
<span class="cm">	 * state may change as we enqueue the other TRBs, so save it too.</span>
<span class="cm">	 */</span>
	<span class="n">start_trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">;</span>
	<span class="n">start_cycle</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>

	<span class="n">running_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * How much data is in the first TRB?</span>
<span class="cm">	 *</span>
<span class="cm">	 * There are three forces at work for TRB buffer pointers and lengths:</span>
<span class="cm">	 * 1. We don&#39;t want to walk off the end of this sg-list entry buffer.</span>
<span class="cm">	 * 2. The transfer length that the driver requested may be smaller than</span>
<span class="cm">	 *    the amount of memory allocated for this scatter-gather list.</span>
<span class="cm">	 * 3. TRBs buffers can&#39;t cross 64KB boundaries.</span>
<span class="cm">	 */</span>
	<span class="n">sg</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">trb_buff_len</span><span class="p">,</span> <span class="n">this_sg_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trb_buff_len</span> <span class="o">&gt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span>
		<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="n">first_trb</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/* Queue the first TRB, even if it&#39;s zero-length */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">length_field</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">remainder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t change the cycle bit of the first TRB until later */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_trb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">first_trb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>

		<span class="cm">/* Chain all the TRBs together; clear the chain bit in the last</span>
<span class="cm">		 * TRB to indicate it&#39;s the last TRB in the chain.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_trbs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_CHAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* FIXME - add check for ZERO_PACKET flag before this */</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_IOC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Only set interrupt on short packet for IN endpoints */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_ISP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">trb_buff_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: sg dma xfer crosses 64KB boundaries!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Next boundary at %#x, end dma = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">TRB_MAX_BUFF_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">trb_buff_len</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Set the TRB length, TD size, and interrupter fields. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&lt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">remainder</span> <span class="o">=</span> <span class="n">xhci_td_remainder</span><span class="p">(</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span>
					<span class="n">running_total</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">remainder</span> <span class="o">=</span> <span class="n">xhci_v1_0_td_remainder</span><span class="p">(</span><span class="n">running_total</span><span class="p">,</span>
					<span class="n">trb_buff_len</span><span class="p">,</span> <span class="n">total_packet_count</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">length_field</span> <span class="o">=</span> <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">trb_buff_len</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">remainder</span> <span class="o">|</span>
			<span class="n">TRB_INTR_TARGET</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_trbs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">more_trbs_coming</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">more_trbs_coming</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">queue_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">more_trbs_coming</span><span class="p">,</span>
				<span class="n">lower_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">length_field</span><span class="p">,</span>
				<span class="n">field</span> <span class="o">|</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_NORMAL</span><span class="p">));</span>
		<span class="o">--</span><span class="n">num_trbs</span><span class="p">;</span>
		<span class="n">running_total</span> <span class="o">+=</span> <span class="n">trb_buff_len</span><span class="p">;</span>

		<span class="cm">/* Calculate length for next transfer --</span>
<span class="cm">		 * Are we done queueing all the TRBs for this sg entry?</span>
<span class="cm">		 */</span>
		<span class="n">this_sg_len</span> <span class="o">-=</span> <span class="n">trb_buff_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_sg_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">num_sgs</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_sgs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">trb_buff_len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">trb_buff_len</span><span class="p">,</span> <span class="n">this_sg_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">+</span> <span class="n">trb_buff_len</span> <span class="o">&gt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span>
			<span class="n">trb_buff_len</span> <span class="o">=</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span> <span class="n">running_total</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>

	<span class="n">check_trb_math</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">num_trbs</span><span class="p">,</span> <span class="n">running_total</span><span class="p">);</span>
	<span class="n">giveback_first_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
			<span class="n">start_cycle</span><span class="p">,</span> <span class="n">start_trb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is very similar to what ehci-q.c qtd_fill() does */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_bulk_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_trbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">start_trb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">first_trb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">more_trbs_coming</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_cycle</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">length_field</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">running_total</span><span class="p">,</span> <span class="n">trb_buff_len</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_packet_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">queue_bulk_sg_tx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_urb_to_transfer_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">num_trbs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* How much data is (potentially) left before the 64KB boundary? */</span>
	<span class="n">running_total</span> <span class="o">=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">running_total</span> <span class="o">&amp;=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If there&#39;s some data on this 64KB chunk, or we have to send a</span>
<span class="cm">	 * zero-length transfer, we need at least one TRB</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">num_trbs</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* How many more 64KB chunks to transfer, how many more TRBs? */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_trbs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">running_total</span> <span class="o">+=</span> <span class="n">TRB_MAX_BUFF_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME: this doesn&#39;t deal with URB_ZERO_PACKET - need one more */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_transfer</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">],</span>
			<span class="n">ep_index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
			<span class="n">num_trbs</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t give the first TRB to the hardware (by toggling the cycle bit)</span>
<span class="cm">	 * until we&#39;ve finished creating all the other TRBs.  The ring&#39;s cycle</span>
<span class="cm">	 * state may change as we enqueue the other TRBs, so save it too.</span>
<span class="cm">	 */</span>
	<span class="n">start_trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">;</span>
	<span class="n">start_cycle</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>

	<span class="n">running_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">total_packet_count</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
			<span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">));</span>
	<span class="cm">/* How much data is in the first TRB? */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>
	<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trb_buff_len</span> <span class="o">&gt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span>
		<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="n">first_trb</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Queue the first TRB, even if it&#39;s zero-length */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">remainder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">field</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t change the cycle bit of the first TRB until later */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_trb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">first_trb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>

		<span class="cm">/* Chain all the TRBs together; clear the chain bit in the last</span>
<span class="cm">		 * TRB to indicate it&#39;s the last TRB in the chain.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_trbs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_CHAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* FIXME - add check for ZERO_PACKET flag before this */</span>
			<span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_IOC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Only set interrupt on short packet for IN endpoints */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_ISP</span><span class="p">;</span>

		<span class="cm">/* Set the TRB length, TD size, and interrupter fields. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&lt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">remainder</span> <span class="o">=</span> <span class="n">xhci_td_remainder</span><span class="p">(</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span>
					<span class="n">running_total</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">remainder</span> <span class="o">=</span> <span class="n">xhci_v1_0_td_remainder</span><span class="p">(</span><span class="n">running_total</span><span class="p">,</span>
					<span class="n">trb_buff_len</span><span class="p">,</span> <span class="n">total_packet_count</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">length_field</span> <span class="o">=</span> <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">trb_buff_len</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">remainder</span> <span class="o">|</span>
			<span class="n">TRB_INTR_TARGET</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_trbs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">more_trbs_coming</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">more_trbs_coming</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">queue_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">more_trbs_coming</span><span class="p">,</span>
				<span class="n">lower_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">length_field</span><span class="p">,</span>
				<span class="n">field</span> <span class="o">|</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_NORMAL</span><span class="p">));</span>
		<span class="o">--</span><span class="n">num_trbs</span><span class="p">;</span>
		<span class="n">running_total</span> <span class="o">+=</span> <span class="n">trb_buff_len</span><span class="p">;</span>

		<span class="cm">/* Calculate length for next transfer */</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">trb_buff_len</span><span class="p">;</span>
		<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span> <span class="n">running_total</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trb_buff_len</span> <span class="o">&gt;</span> <span class="n">TRB_MAX_BUFF_SIZE</span><span class="p">)</span>
			<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">TRB_MAX_BUFF_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>

	<span class="n">check_trb_math</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">num_trbs</span><span class="p">,</span> <span class="n">running_total</span><span class="p">);</span>
	<span class="n">giveback_first_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
			<span class="n">start_cycle</span><span class="p">,</span> <span class="n">start_trb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must have locked xhci-&gt;lock */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_ctrl_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_trbs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">setup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">start_trb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_cycle</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">length_field</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_urb_to_transfer_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to copy setup packet into setup TRB, so we can&#39;t use the setup</span>
<span class="cm">	 * DMA address.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* 1 TRB for setup, 1 for status */</span>
	<span class="n">num_trbs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t need to check if we need additional event data and normal TRBs,</span>
<span class="cm">	 * since data in control transfers will never get bigger than 16MB</span>
<span class="cm">	 * XXX: can we get a buffer that crosses 64KB boundaries?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">num_trbs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_transfer</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">],</span>
			<span class="n">ep_index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
			<span class="n">num_trbs</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t give the first TRB to the hardware (by toggling the cycle bit)</span>
<span class="cm">	 * until we&#39;ve finished creating all the other TRBs.  The ring&#39;s cycle</span>
<span class="cm">	 * state may change as we enqueue the other TRBs, so save it too.</span>
<span class="cm">	 */</span>
	<span class="n">start_trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">;</span>
	<span class="n">start_cycle</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>

	<span class="cm">/* Queue setup TRB - see section 6.4.1.2.1 */</span>
	<span class="cm">/* FIXME better way to translate setup_packet into two u32 fields? */</span>
	<span class="n">setup</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">;</span>
	<span class="n">field</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_IDT</span> <span class="o">|</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_SETUP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">field</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="cm">/* xHCI 1.0 6.4.1.2.1: Transfer Type field */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">==</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_TX_TYPE</span><span class="p">(</span><span class="n">TRB_DATA_IN</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_TX_TYPE</span><span class="p">(</span><span class="n">TRB_DATA_OUT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">queue_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
		  <span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">|</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wValue</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span>
		  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="p">)</span> <span class="o">|</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span>
		  <span class="n">TRB_LEN</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">TRB_INTR_TARGET</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		  <span class="cm">/* Immediate data in pointer */</span>
		  <span class="n">field</span><span class="p">);</span>

	<span class="cm">/* If there&#39;s data, queue data TRBs */</span>
	<span class="cm">/* Only set interrupt on short packet for IN endpoints */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
		<span class="n">field</span> <span class="o">=</span> <span class="n">TRB_ISP</span> <span class="o">|</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_DATA</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">field</span> <span class="o">=</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_DATA</span><span class="p">);</span>

	<span class="n">length_field</span> <span class="o">=</span> <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">xhci_td_remainder</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">TRB_INTR_TARGET</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
			<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_DIR_IN</span><span class="p">;</span>
		<span class="n">queue_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
				<span class="n">lower_32_bits</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">),</span>
				<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">),</span>
				<span class="n">length_field</span><span class="p">,</span>
				<span class="n">field</span> <span class="o">|</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Save the DMA address of the last TRB in the TD */</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>

	<span class="cm">/* Queue status TRB - see Table 7 and sections 4.11.2.2 and 6.4.1.2.3 */</span>
	<span class="cm">/* If the device sent data, the status stage is an OUT transfer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">setup</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
		<span class="n">field</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">field</span> <span class="o">=</span> <span class="n">TRB_DIR_IN</span><span class="p">;</span>
	<span class="n">queue_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span>
			<span class="n">TRB_INTR_TARGET</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			<span class="cm">/* Event on completion */</span>
			<span class="n">field</span> <span class="o">|</span> <span class="n">TRB_IOC</span> <span class="o">|</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_STATUS</span><span class="p">)</span> <span class="o">|</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">);</span>

	<span class="n">giveback_first_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">start_cycle</span><span class="p">,</span> <span class="n">start_trb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_isoc_trbs_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_trbs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">td_len</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">td_len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>

	<span class="n">num_trbs</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">td_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
			<span class="n">TRB_MAX_BUFF_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_trbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">num_trbs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">num_trbs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The transfer burst count field of the isochronous TRB defines the number of</span>
<span class="cm"> * bursts that are required to move all packets in this TD.  Only SuperSpeed</span>
<span class="cm"> * devices can burst up to bMaxBurst number of packets per service interval.</span>
<span class="cm"> * This field is zero based, meaning a value of zero in the field means one</span>
<span class="cm"> * burst.  Basically, for everything but SuperSpeed devices, this field will be</span>
<span class="cm"> * zero.  Only xHCI 1.0 host controllers support this field.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_burst_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_packet_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_burst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&lt;</span> <span class="mh">0x100</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">max_burst</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ss_ep_comp</span><span class="p">.</span><span class="n">bMaxBurst</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">roundup</span><span class="p">(</span><span class="n">total_packet_count</span><span class="p">,</span> <span class="n">max_burst</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the number of packets in the last &quot;burst&quot; of packets.  This field is</span>
<span class="cm"> * valid for all speeds of devices.  USB 2.0 devices can only do one &quot;burst&quot;, so</span>
<span class="cm"> * the last burst packet count is equal to the total number of packets in the</span>
<span class="cm"> * TD.  SuperSpeed endpoints can have up to 3 bursts.  All but the last burst</span>
<span class="cm"> * must contain (bMaxBurst + 1) number of packets, but the last burst can</span>
<span class="cm"> * contain 1 to (bMaxBurst + 1) packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_last_burst_packet_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_packet_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_burst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">residue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&lt;</span> <span class="mh">0x100</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_SUPER</span>:
		<span class="cm">/* bMaxBurst is zero based: 0 means 1 packet per burst */</span>
		<span class="n">max_burst</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ss_ep_comp</span><span class="p">.</span><span class="n">bMaxBurst</span><span class="p">;</span>
		<span class="n">residue</span> <span class="o">=</span> <span class="n">total_packet_count</span> <span class="o">%</span> <span class="p">(</span><span class="n">max_burst</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* If residue is zero, the last burst contains (max_burst + 1)</span>
<span class="cm">		 * number of packets, but the TLBPC field is zero-based.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">residue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">max_burst</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">residue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_packet_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">total_packet_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This is for isoc transfer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_queue_isoc_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_tds</span><span class="p">,</span> <span class="n">trbs_per_td</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_generic_trb</span> <span class="o">*</span><span class="n">start_trb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">first_trb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_cycle</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">length_field</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">running_total</span><span class="p">,</span> <span class="n">trb_buff_len</span><span class="p">,</span> <span class="n">td_len</span><span class="p">,</span> <span class="n">td_remain_len</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">more_trbs_coming</span><span class="p">;</span>

	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ring</span><span class="p">;</span>

	<span class="n">num_tds</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_tds</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Isoc URB with zero packets?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>
	<span class="n">start_trb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">;</span>
	<span class="n">start_cycle</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>

	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="cm">/* Queue the first TRB, even if it&#39;s zero-length */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_tds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_packet_count</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">burst_count</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">residue</span><span class="p">;</span>

		<span class="n">first_trb</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">running_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">start_addr</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">td_len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
		<span class="n">td_remain_len</span> <span class="o">=</span> <span class="n">td_len</span><span class="p">;</span>
		<span class="n">total_packet_count</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">td_len</span><span class="p">,</span>
				<span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">));</span>
		<span class="cm">/* A zero-length transfer still involves at least one packet. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_packet_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">total_packet_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">burst_count</span> <span class="o">=</span> <span class="n">xhci_get_burst_count</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
				<span class="n">total_packet_count</span><span class="p">);</span>
		<span class="n">residue</span> <span class="o">=</span> <span class="n">xhci_get_last_burst_packet_count</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">total_packet_count</span><span class="p">);</span>

		<span class="n">trbs_per_td</span> <span class="o">=</span> <span class="n">count_isoc_trbs_needed</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_transfer</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">],</span> <span class="n">ep_index</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span> <span class="n">trbs_per_td</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">td</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">trbs_per_td</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">remainder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">field</span> <span class="o">=</span> <span class="n">TRB_TBC</span><span class="p">(</span><span class="n">burst_count</span><span class="p">)</span> <span class="o">|</span> <span class="n">TRB_TLBPC</span><span class="p">(</span><span class="n">residue</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">first_trb</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Queue the isoc TRB */</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_ISOC</span><span class="p">);</span>
				<span class="cm">/* Assume URB_ISO_ASAP is set */</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_SIA</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">start_cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">field</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">field</span> <span class="o">|=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>
				<span class="n">first_trb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Queue other normal TRBs */</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_NORMAL</span><span class="p">);</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Only set interrupt on short packet for IN EPs */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_ISP</span><span class="p">;</span>

			<span class="cm">/* Chain all the TRBs together; clear the chain bit in</span>
<span class="cm">			 * the last TRB to indicate it&#39;s the last TRB in the</span>
<span class="cm">			 * chain.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">trbs_per_td</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_CHAIN</span><span class="p">;</span>
				<span class="n">more_trbs_coming</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">last_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>
				<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_IOC</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">==</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Set BEI bit except for the last td */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_tds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
						<span class="n">field</span> <span class="o">|=</span> <span class="n">TRB_BEI</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">more_trbs_coming</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Calculate TRB length */</span>
			<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">TRB_MAX_BUFF_SIZE</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TRB_MAX_BUFF_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">trb_buff_len</span> <span class="o">&gt;</span> <span class="n">td_remain_len</span><span class="p">)</span>
				<span class="n">trb_buff_len</span> <span class="o">=</span> <span class="n">td_remain_len</span><span class="p">;</span>

			<span class="cm">/* Set the TRB length, TD size, &amp; interrupter fields. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&lt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">remainder</span> <span class="o">=</span> <span class="n">xhci_td_remainder</span><span class="p">(</span>
						<span class="n">td_len</span> <span class="o">-</span> <span class="n">running_total</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">remainder</span> <span class="o">=</span> <span class="n">xhci_v1_0_td_remainder</span><span class="p">(</span>
						<span class="n">running_total</span><span class="p">,</span> <span class="n">trb_buff_len</span><span class="p">,</span>
						<span class="n">total_packet_count</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">length_field</span> <span class="o">=</span> <span class="n">TRB_LEN</span><span class="p">(</span><span class="n">trb_buff_len</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">remainder</span> <span class="o">|</span>
				<span class="n">TRB_INTR_TARGET</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

			<span class="n">queue_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">more_trbs_coming</span><span class="p">,</span>
				<span class="n">lower_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
				<span class="n">length_field</span><span class="p">,</span>
				<span class="n">field</span><span class="p">);</span>
			<span class="n">running_total</span> <span class="o">+=</span> <span class="n">trb_buff_len</span><span class="p">;</span>

			<span class="n">addr</span> <span class="o">+=</span> <span class="n">trb_buff_len</span><span class="p">;</span>
			<span class="n">td_remain_len</span> <span class="o">-=</span> <span class="n">trb_buff_len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check TD length */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">running_total</span> <span class="o">!=</span> <span class="n">td_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ISOC TD length unmatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_AMD_PLL_FIX</span><span class="p">)</span>
			<span class="n">usb_amd_quirk_pll_disable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">giveback_first_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">,</span>
			<span class="n">start_cycle</span><span class="p">,</span> <span class="n">start_trb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">cleanup:</span>
	<span class="cm">/* Clean up a partially enqueued isoc transfer. */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>

	<span class="cm">/* Use the first TD as a temporary variable to turn the TDs we&#39;ve queued</span>
<span class="cm">	 * into No-ops with a software-owned cycle bit. That way the hardware</span>
<span class="cm">	 * won&#39;t accidentally start executing bogus TDs when we partially</span>
<span class="cm">	 * overwrite them.  td-&gt;first_trb and td-&gt;start_seg are already set.</span>
<span class="cm">	 */</span>
	<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">last_trb</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>
	<span class="cm">/* Every TRB except the first &amp; last will have its cycle bit flipped. */</span>
	<span class="n">td_to_noop</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* Reset the ring enqueue back to the first TRB and its cycle bit. */</span>
	<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">first_trb</span><span class="p">;</span>
	<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start_seg</span><span class="p">;</span>
	<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">=</span> <span class="n">start_cycle</span><span class="p">;</span>
	<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free_temp</span><span class="p">;</span>
	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check transfer ring to guarantee there is enough room for the urb.</span>
<span class="cm"> * Update ISO URB start_frame and interval.</span>
<span class="cm"> * Update interval as xhci_queue_intr_tx does. Just use xhci frame_index to</span>
<span class="cm"> * update the urb-&gt;start_frame by now.</span>
<span class="cm"> * Always assume URB_ISO_ASAP set, and NEVER use urb-&gt;start_frame as input.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_isoc_tx_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">xdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_frame</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xhci_interval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_interval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_tds</span><span class="p">,</span> <span class="n">num_trbs</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xdev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ring</span><span class="p">;</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>

	<span class="n">num_trbs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">num_tds</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_tds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">num_trbs</span> <span class="o">+=</span> <span class="n">count_isoc_trbs_needed</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* Check the ring to guarantee there is enough room for the whole urb.</span>
<span class="cm">	 * Do not insert any td of the urb to the ring if the check failed.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ring</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EP_STATE_MASK</span><span class="p">,</span>
			   <span class="n">num_trbs</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">start_frame</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">run_regs</span><span class="o">-&gt;</span><span class="n">microframe_index</span><span class="p">);</span>
	<span class="n">start_frame</span> <span class="o">&amp;=</span> <span class="mh">0x3fff</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">=</span> <span class="n">start_frame</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span> <span class="o">||</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">xhci_interval</span> <span class="o">=</span> <span class="n">EP_INTERVAL_TO_UFRAMES</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span><span class="p">));</span>
	<span class="n">ep_interval</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
	<span class="cm">/* Convert to microframes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span> <span class="o">||</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
		<span class="n">ep_interval</span> <span class="o">*=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="cm">/* FIXME change this to a warning and a suggestion to use the new API</span>
<span class="cm">	 * to set the polling interval (once the API is added).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_interval</span> <span class="o">!=</span> <span class="n">ep_interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Driver uses different interval&quot;</span>
					<span class="s">&quot; (%d microframe%s) than xHCI &quot;</span>
					<span class="s">&quot;(%d microframe%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ep_interval</span><span class="p">,</span>
					<span class="n">ep_interval</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;s&quot;</span><span class="p">,</span>
					<span class="n">xhci_interval</span><span class="p">,</span>
					<span class="n">xhci_interval</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;s&quot;</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">xhci_interval</span><span class="p">;</span>
		<span class="cm">/* Convert back to frames for LS/FS devices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span> <span class="o">||</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">/=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free_temp</span> <span class="o">=</span> <span class="n">ep_ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">xhci_queue_isoc_tx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****		Command Ring Operations		****/</span>

<span class="cm">/* Generic function for queueing a command TRB on the command ring.</span>
<span class="cm"> * Check to make sure there&#39;s room on the command ring for one command TRB.</span>
<span class="cm"> * Also check that there&#39;s room reserved for commands that must not fail.</span>
<span class="cm"> * If this is a command that must not fail, meaning command_must_succeed = TRUE,</span>
<span class="cm"> * then only check for the number of reserved spots.</span>
<span class="cm"> * Don&#39;t decrement xhci-&gt;cmd_ring_reserved_trbs after we&#39;ve queued the TRB</span>
<span class="cm"> * because the command event handler may want to resubmit a failed command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field1</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field2</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">field3</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field4</span><span class="p">,</span> <span class="n">bool</span> <span class="n">command_must_succeed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">reserved_trbs</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring_reserved_trbs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">command_must_succeed</span><span class="p">)</span>
		<span class="n">reserved_trbs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">,</span> <span class="n">EP_STATE_RUNNING</span><span class="p">,</span>
			<span class="n">reserved_trbs</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERR: No room for command on command ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">command_must_succeed</span><span class="p">)</span>
			<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERR: Reserved TRB counting for &quot;</span>
					<span class="s">&quot;unfailable commands failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">queue_trb</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span><span class="p">,</span>
			<span class="n">field4</span> <span class="o">|</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Queue a slot enable or disable request on the command ring */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_slot_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">trb_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">slot_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">trb_type</span><span class="p">)</span> <span class="o">|</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Queue an address device command TRB */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_address_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">in_ctx_ptr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">slot_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">in_ctx_ptr</span><span class="p">),</span>
			<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">in_ctx_ptr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_ADDR_DEV</span><span class="p">)</span> <span class="o">|</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">),</span>
			<span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_queue_vendor_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">field1</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field3</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span><span class="p">,</span> <span class="n">field4</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Queue a reset device command TRB */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">slot_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_RESET_DEV</span><span class="p">)</span> <span class="o">|</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">),</span>
			<span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Queue a configure endpoint command TRB */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_configure_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">in_ctx_ptr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">bool</span> <span class="n">command_must_succeed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">in_ctx_ptr</span><span class="p">),</span>
			<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">in_ctx_ptr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_CONFIG_EP</span><span class="p">)</span> <span class="o">|</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">),</span>
			<span class="n">command_must_succeed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Queue an evaluate context command TRB */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_evaluate_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">in_ctx_ptr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">bool</span> <span class="n">command_must_succeed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">in_ctx_ptr</span><span class="p">),</span>
			<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">in_ctx_ptr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_EVAL_CONTEXT</span><span class="p">)</span> <span class="o">|</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">),</span>
			<span class="n">command_must_succeed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Suspend is set to indicate &quot;Stop Endpoint Command&quot; is being issued to stop</span>
<span class="cm"> * activity on an endpoint that is about to be suspended.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_queue_stop_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">suspend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">trb_slot_id</span> <span class="o">=</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">trb_ep_index</span> <span class="o">=</span> <span class="n">EP_ID_FOR_TRB</span><span class="p">(</span><span class="n">ep_index</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_STOP_RING</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">trb_suspend</span> <span class="o">=</span> <span class="n">SUSPEND_PORT_FOR_TRB</span><span class="p">(</span><span class="n">suspend</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">trb_slot_id</span> <span class="o">|</span> <span class="n">trb_ep_index</span> <span class="o">|</span> <span class="n">type</span> <span class="o">|</span> <span class="n">trb_suspend</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set Transfer Ring Dequeue Pointer command.</span>
<span class="cm"> * This should not be used for endpoints that have streams enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_set_tr_deq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">deq_seg</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">xhci_trb</span> <span class="o">*</span><span class="n">deq_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cycle_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trb_slot_id</span> <span class="o">=</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">trb_ep_index</span> <span class="o">=</span> <span class="n">EP_ID_FOR_TRB</span><span class="p">(</span><span class="n">ep_index</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">trb_stream_id</span> <span class="o">=</span> <span class="n">STREAM_ID_FOR_TRB</span><span class="p">(</span><span class="n">stream_id</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_SET_DEQ</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">deq_seg</span><span class="p">,</span> <span class="n">deq_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Cannot submit Set TR Deq Ptr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN deq seg = %p, deq pt = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">deq_seg</span><span class="p">,</span> <span class="n">deq_ptr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">SET_DEQ_PENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Cannot submit Set TR Deq Ptr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;A Set TR Deq Ptr command is pending.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">queued_deq_seg</span> <span class="o">=</span> <span class="n">deq_seg</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">queued_deq_ptr</span> <span class="o">=</span> <span class="n">deq_ptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">|</span> <span class="n">cycle_state</span><span class="p">,</span>
			<span class="n">upper_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">trb_stream_id</span><span class="p">,</span>
			<span class="n">trb_slot_id</span> <span class="o">|</span> <span class="n">trb_ep_index</span> <span class="o">|</span> <span class="n">type</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_queue_reset_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">trb_slot_id</span> <span class="o">=</span> <span class="n">SLOT_ID_FOR_TRB</span><span class="p">(</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">trb_ep_index</span> <span class="o">=</span> <span class="n">EP_ID_FOR_TRB</span><span class="p">(</span><span class="n">ep_index</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_RESET_EP</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">queue_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trb_slot_id</span> <span class="o">|</span> <span class="n">trb_ep_index</span> <span class="o">|</span> <span class="n">type</span><span class="p">,</span>
			<span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
