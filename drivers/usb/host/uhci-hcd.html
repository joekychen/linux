<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › uhci-hcd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>uhci-hcd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_UHCI_HCD_H</span>
<span class="cp">#define __LINUX_UHCI_HCD_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>

<span class="cp">#define usb_packetid(pipe)	(usb_pipein(pipe) ? USB_PID_IN : USB_PID_OUT)</span>
<span class="cp">#define PIPE_DEVEP_MASK		0x0007ff00</span>


<span class="cm">/*</span>
<span class="cm"> * Universal Host Controller Interface data structures and defines</span>
<span class="cm"> */</span>

<span class="cm">/* Command register */</span>
<span class="cp">#define USBCMD		0</span>
<span class="cp">#define   USBCMD_RS		0x0001	</span><span class="cm">/* Run/Stop */</span><span class="cp"></span>
<span class="cp">#define   USBCMD_HCRESET	0x0002	</span><span class="cm">/* Host reset */</span><span class="cp"></span>
<span class="cp">#define   USBCMD_GRESET		0x0004	</span><span class="cm">/* Global reset */</span><span class="cp"></span>
<span class="cp">#define   USBCMD_EGSM		0x0008	</span><span class="cm">/* Global Suspend Mode */</span><span class="cp"></span>
<span class="cp">#define   USBCMD_FGR		0x0010	</span><span class="cm">/* Force Global Resume */</span><span class="cp"></span>
<span class="cp">#define   USBCMD_SWDBG		0x0020	</span><span class="cm">/* SW Debug mode */</span><span class="cp"></span>
<span class="cp">#define   USBCMD_CF		0x0040	</span><span class="cm">/* Config Flag (sw only) */</span><span class="cp"></span>
<span class="cp">#define   USBCMD_MAXP		0x0080	</span><span class="cm">/* Max Packet (0 = 32, 1 = 64) */</span><span class="cp"></span>

<span class="cm">/* Status register */</span>
<span class="cp">#define USBSTS		2</span>
<span class="cp">#define   USBSTS_USBINT		0x0001	</span><span class="cm">/* Interrupt due to IOC */</span><span class="cp"></span>
<span class="cp">#define   USBSTS_ERROR		0x0002	</span><span class="cm">/* Interrupt due to error */</span><span class="cp"></span>
<span class="cp">#define   USBSTS_RD		0x0004	</span><span class="cm">/* Resume Detect */</span><span class="cp"></span>
<span class="cp">#define   USBSTS_HSE		0x0008	</span><span class="cm">/* Host System Error: PCI problems */</span><span class="cp"></span>
<span class="cp">#define   USBSTS_HCPE		0x0010	</span><span class="cm">/* Host Controller Process Error:</span>
<span class="cm">					 * the schedule is buggy */</span><span class="cp"></span>
<span class="cp">#define   USBSTS_HCH		0x0020	</span><span class="cm">/* HC Halted */</span><span class="cp"></span>

<span class="cm">/* Interrupt enable register */</span>
<span class="cp">#define USBINTR		4</span>
<span class="cp">#define   USBINTR_TIMEOUT	0x0001	</span><span class="cm">/* Timeout/CRC error enable */</span><span class="cp"></span>
<span class="cp">#define   USBINTR_RESUME	0x0002	</span><span class="cm">/* Resume interrupt enable */</span><span class="cp"></span>
<span class="cp">#define   USBINTR_IOC		0x0004	</span><span class="cm">/* Interrupt On Complete enable */</span><span class="cp"></span>
<span class="cp">#define   USBINTR_SP		0x0008	</span><span class="cm">/* Short packet interrupt enable */</span><span class="cp"></span>

<span class="cp">#define USBFRNUM	6</span>
<span class="cp">#define USBFLBASEADD	8</span>
<span class="cp">#define USBSOF		12</span>
<span class="cp">#define   USBSOF_DEFAULT	64	</span><span class="cm">/* Frame length is exactly 1 ms */</span><span class="cp"></span>

<span class="cm">/* USB port status and control registers */</span>
<span class="cp">#define USBPORTSC1	16</span>
<span class="cp">#define USBPORTSC2	18</span>
<span class="cp">#define   USBPORTSC_CCS		0x0001	</span><span class="cm">/* Current Connect Status</span>
<span class="cm">					 * (&quot;device present&quot;) */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_CSC		0x0002	</span><span class="cm">/* Connect Status Change */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_PE		0x0004	</span><span class="cm">/* Port Enable */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_PEC		0x0008	</span><span class="cm">/* Port Enable Change */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_DPLUS	0x0010	</span><span class="cm">/* D+ high (line status) */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_DMINUS	0x0020	</span><span class="cm">/* D- high (line status) */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_RD		0x0040	</span><span class="cm">/* Resume Detect */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_RES1	0x0080	</span><span class="cm">/* reserved, always 1 */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_LSDA	0x0100	</span><span class="cm">/* Low Speed Device Attached */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_PR		0x0200	</span><span class="cm">/* Port Reset */</span><span class="cp"></span>
<span class="cm">/* OC and OCC from Intel 430TX and later (not UHCI 1.1d spec) */</span>
<span class="cp">#define   USBPORTSC_OC		0x0400	</span><span class="cm">/* Over Current condition */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_OCC		0x0800	</span><span class="cm">/* Over Current Change R/WC */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_SUSP	0x1000	</span><span class="cm">/* Suspend */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_RES2	0x2000	</span><span class="cm">/* reserved, write zeroes */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_RES3	0x4000	</span><span class="cm">/* reserved, write zeroes */</span><span class="cp"></span>
<span class="cp">#define   USBPORTSC_RES4	0x8000	</span><span class="cm">/* reserved, write zeroes */</span><span class="cp"></span>

<span class="cm">/* PCI legacy support register */</span>
<span class="cp">#define USBLEGSUP		0xc0</span>
<span class="cp">#define   USBLEGSUP_DEFAULT	0x2000	</span><span class="cm">/* only PIRQ enable set */</span><span class="cp"></span>
<span class="cp">#define   USBLEGSUP_RWC		0x8f00	</span><span class="cm">/* the R/WC bits */</span><span class="cp"></span>
<span class="cp">#define   USBLEGSUP_RO		0x5040	</span><span class="cm">/* R/O and reserved bits */</span><span class="cp"></span>

<span class="cm">/* PCI Intel-specific resume-enable register */</span>
<span class="cp">#define USBRES_INTEL		0xc4</span>
<span class="cp">#define   USBPORT1EN		0x01</span>
<span class="cp">#define   USBPORT2EN		0x02</span>

<span class="cp">#define UHCI_PTR_BITS(uhci)	cpu_to_hc32((uhci), 0x000F)</span>
<span class="cp">#define UHCI_PTR_TERM(uhci)	cpu_to_hc32((uhci), 0x0001)</span>
<span class="cp">#define UHCI_PTR_QH(uhci)	cpu_to_hc32((uhci), 0x0002)</span>
<span class="cp">#define UHCI_PTR_DEPTH(uhci)	cpu_to_hc32((uhci), 0x0004)</span>
<span class="cp">#define UHCI_PTR_BREADTH(uhci)	cpu_to_hc32((uhci), 0x0000)</span>

<span class="cp">#define UHCI_NUMFRAMES		1024	</span><span class="cm">/* in the frame list [array] */</span><span class="cp"></span>
<span class="cp">#define UHCI_MAX_SOF_NUMBER	2047	</span><span class="cm">/* in an SOF packet */</span><span class="cp"></span>
<span class="cp">#define CAN_SCHEDULE_FRAMES	1000	</span><span class="cm">/* how far in the future frames</span>
<span class="cm">					 * can be scheduled */</span><span class="cp"></span>
<span class="cp">#define MAX_PHASE		32	</span><span class="cm">/* Periodic scheduling length */</span><span class="cp"></span>

<span class="cm">/* When no queues need Full-Speed Bandwidth Reclamation,</span>
<span class="cm"> * delay this long before turning FSBR off */</span>
<span class="cp">#define FSBR_OFF_DELAY		msecs_to_jiffies(10)</span>

<span class="cm">/* If a queue hasn&#39;t advanced after this much time, assume it is stuck */</span>
<span class="cp">#define QH_WAIT_TIMEOUT		msecs_to_jiffies(200)</span>


<span class="cm">/*</span>
<span class="cm"> * __hc32 and __hc16 are &quot;Host Controller&quot; types, they may be equivalent to</span>
<span class="cm"> * __leXX (normally) or __beXX (given UHCI_BIG_ENDIAN_DESC), depending on</span>
<span class="cm"> * the host controller implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * To facilitate the strongest possible byte-order checking from &quot;sparse&quot;</span>
<span class="cm"> * and so on, we use __leXX unless that&#39;s not practical.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_DESC</span>
<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">__bitwise</span> <span class="n">__hc32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u16</span> <span class="n">__bitwise</span> <span class="n">__hc16</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define __hc32	__le32</span>
<span class="cp">#define __hc16	__le16</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Queue Headers</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * One role of a QH is to hold a queue of TDs for some endpoint.  One QH goes</span>
<span class="cm"> * with each endpoint, and qh-&gt;element (updated by the HC) is either:</span>
<span class="cm"> *   - the next unprocessed TD in the endpoint&#39;s queue, or</span>
<span class="cm"> *   - UHCI_PTR_TERM (when there&#39;s no more traffic for this endpoint).</span>
<span class="cm"> *</span>
<span class="cm"> * The other role of a QH is to serve as a &quot;skeleton&quot; framelist entry, so we</span>
<span class="cm"> * can easily splice a QH for some endpoint into the schedule at the right</span>
<span class="cm"> * place.  Then qh-&gt;element is UHCI_PTR_TERM.</span>
<span class="cm"> *</span>
<span class="cm"> * In the schedule, qh-&gt;link maintains a list of QHs seen by the HC:</span>
<span class="cm"> *     skel1 --&gt; ep1-qh --&gt; ep2-qh --&gt; ... --&gt; skel2 --&gt; ...</span>
<span class="cm"> *</span>
<span class="cm"> * qh-&gt;node is the software equivalent of qh-&gt;link.  The differences</span>
<span class="cm"> * are that the software list is doubly-linked and QHs in the UNLINKING</span>
<span class="cm"> * state are on the software list but not the hardware schedule.</span>
<span class="cm"> *</span>
<span class="cm"> * For bookkeeping purposes we maintain QHs even for Isochronous endpoints,</span>
<span class="cm"> * but they never get added to the hardware schedule.</span>
<span class="cm"> */</span>
<span class="cp">#define QH_STATE_IDLE		1	</span><span class="cm">/* QH is not being used */</span><span class="cp"></span>
<span class="cp">#define QH_STATE_UNLINKING	2	</span><span class="cm">/* QH has been removed from the</span>
<span class="cm">					 * schedule but the hardware may</span>
<span class="cm">					 * still be using it */</span><span class="cp"></span>
<span class="cp">#define QH_STATE_ACTIVE		3	</span><span class="cm">/* QH is on the schedule */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="p">{</span>
	<span class="cm">/* Hardware fields */</span>
	<span class="n">__hc32</span> <span class="n">link</span><span class="p">;</span>			<span class="cm">/* Next QH in the schedule */</span>
	<span class="n">__hc32</span> <span class="n">element</span><span class="p">;</span>			<span class="cm">/* Queue element (TD) pointer */</span>

	<span class="cm">/* Software fields */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>		<span class="cm">/* Node in the list of QHs */</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">hep</span><span class="p">;</span>	<span class="cm">/* Endpoint information */</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>		<span class="cm">/* Queue of urbps for this QH */</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">dummy_td</span><span class="p">;</span>	<span class="cm">/* Dummy TD to end the queue */</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">post_td</span><span class="p">;</span>	<span class="cm">/* Last TD completed */</span>

	<span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span> <span class="o">*</span><span class="n">iso_packet_desc</span><span class="p">;</span>
					<span class="cm">/* Next urb-&gt;iso_frame_desc entry */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">advance_jiffies</span><span class="p">;</span>	<span class="cm">/* Time of last queue advance */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unlink_frame</span><span class="p">;</span>	<span class="cm">/* When the QH was unlinked */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period</span><span class="p">;</span>		<span class="cm">/* For Interrupt and Isochronous QHs */</span>
	<span class="kt">short</span> <span class="n">phase</span><span class="p">;</span>			<span class="cm">/* Between 0 and period-1 */</span>
	<span class="kt">short</span> <span class="n">load</span><span class="p">;</span>			<span class="cm">/* Periodic time requirement, in us */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iso_frame</span><span class="p">;</span>		<span class="cm">/* Frame # for iso_packet_desc */</span>

	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>			<span class="cm">/* QH_STATE_xxx; see above */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>			<span class="cm">/* Queue type (control, bulk, etc) */</span>
	<span class="kt">int</span> <span class="n">skel</span><span class="p">;</span>			<span class="cm">/* Skeleton queue number */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">initial_toggle</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Endpoint&#39;s current toggle value */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">needs_fixup</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Must fix the TD toggle values */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_stopped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Queue was stopped by error/unlink */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait_expired</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* QH_WAIT_TIMEOUT has expired */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bandwidth_reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Periodic bandwidth has</span>
<span class="cm">						 * been allocated */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * We need a special accessor for the element pointer because it is</span>
<span class="cm"> * subject to asynchronous updates by the controller.</span>
<span class="cm"> */</span>
<span class="cp">#define qh_element(qh)		ACCESS_ONCE((qh)-&gt;element)</span>

<span class="cp">#define LINK_TO_QH(uhci, qh)	(UHCI_PTR_QH((uhci)) | \</span>
<span class="cp">				cpu_to_hc32((uhci), (qh)-&gt;dma_handle))</span>


<span class="cm">/*</span>
<span class="cm"> *	Transfer Descriptors</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * for TD &lt;status&gt;:</span>
<span class="cm"> */</span>
<span class="cp">#define TD_CTRL_SPD		(1 &lt;&lt; 29)	</span><span class="cm">/* Short Packet Detect */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_C_ERR_MASK	(3 &lt;&lt; 27)	</span><span class="cm">/* Error Counter bits */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_C_ERR_SHIFT	27</span>
<span class="cp">#define TD_CTRL_LS		(1 &lt;&lt; 26)	</span><span class="cm">/* Low Speed Device */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_IOS		(1 &lt;&lt; 25)	</span><span class="cm">/* Isochronous Select */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_IOC		(1 &lt;&lt; 24)	</span><span class="cm">/* Interrupt on Complete */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_ACTIVE		(1 &lt;&lt; 23)	</span><span class="cm">/* TD Active */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_STALLED		(1 &lt;&lt; 22)	</span><span class="cm">/* TD Stalled */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_DBUFERR		(1 &lt;&lt; 21)	</span><span class="cm">/* Data Buffer Error */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_BABBLE		(1 &lt;&lt; 20)	</span><span class="cm">/* Babble Detected */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_NAK		(1 &lt;&lt; 19)	</span><span class="cm">/* NAK Received */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_CRCTIMEO	(1 &lt;&lt; 18)	</span><span class="cm">/* CRC/Time Out Error */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_BITSTUFF	(1 &lt;&lt; 17)	</span><span class="cm">/* Bit Stuff Error */</span><span class="cp"></span>
<span class="cp">#define TD_CTRL_ACTLEN_MASK	0x7FF	</span><span class="cm">/* actual length, encoded as n - 1 */</span><span class="cp"></span>

<span class="cp">#define TD_CTRL_ANY_ERROR	(TD_CTRL_STALLED | TD_CTRL_DBUFERR | \</span>
<span class="cp">				 TD_CTRL_BABBLE | TD_CTRL_CRCTIME | \</span>
<span class="cp">				 TD_CTRL_BITSTUFF)</span>

<span class="cp">#define uhci_maxerr(err)		((err) &lt;&lt; TD_CTRL_C_ERR_SHIFT)</span>
<span class="cp">#define uhci_status_bits(ctrl_sts)	((ctrl_sts) &amp; 0xF60000)</span>
<span class="cp">#define uhci_actual_length(ctrl_sts)	(((ctrl_sts) + 1) &amp; \</span>
<span class="cp">			TD_CTRL_ACTLEN_MASK)	</span><span class="cm">/* 1-based */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * for TD &lt;info&gt;: (a.k.a. Token)</span>
<span class="cm"> */</span>
<span class="cp">#define td_token(uhci, td)	hc32_to_cpu((uhci), (td)-&gt;token)</span>
<span class="cp">#define TD_TOKEN_DEVADDR_SHIFT	8</span>
<span class="cp">#define TD_TOKEN_TOGGLE_SHIFT	19</span>
<span class="cp">#define TD_TOKEN_TOGGLE		(1 &lt;&lt; 19)</span>
<span class="cp">#define TD_TOKEN_EXPLEN_SHIFT	21</span>
<span class="cp">#define TD_TOKEN_EXPLEN_MASK	0x7FF	</span><span class="cm">/* expected length, encoded as n-1 */</span><span class="cp"></span>
<span class="cp">#define TD_TOKEN_PID_MASK	0xFF</span>

<span class="cp">#define uhci_explen(len)	((((len) - 1) &amp; TD_TOKEN_EXPLEN_MASK) &lt;&lt; \</span>
<span class="cp">					TD_TOKEN_EXPLEN_SHIFT)</span>

<span class="cp">#define uhci_expected_length(token) ((((token) &gt;&gt; TD_TOKEN_EXPLEN_SHIFT) + \</span>
<span class="cp">					1) &amp; TD_TOKEN_EXPLEN_MASK)</span>
<span class="cp">#define uhci_toggle(token)	(((token) &gt;&gt; TD_TOKEN_TOGGLE_SHIFT) &amp; 1)</span>
<span class="cp">#define uhci_endpoint(token)	(((token) &gt;&gt; 15) &amp; 0xf)</span>
<span class="cp">#define uhci_devaddr(token)	(((token) &gt;&gt; TD_TOKEN_DEVADDR_SHIFT) &amp; 0x7f)</span>
<span class="cp">#define uhci_devep(token)	(((token) &gt;&gt; TD_TOKEN_DEVADDR_SHIFT) &amp; 0x7ff)</span>
<span class="cp">#define uhci_packetid(token)	((token) &amp; TD_TOKEN_PID_MASK)</span>
<span class="cp">#define uhci_packetout(token)	(uhci_packetid(token) != USB_PID_IN)</span>
<span class="cp">#define uhci_packetin(token)	(uhci_packetid(token) == USB_PID_IN)</span>

<span class="cm">/*</span>
<span class="cm"> * The documentation says &quot;4 words for hardware, 4 words for software&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * That&#39;s silly, the hardware doesn&#39;t care. The hardware only cares that</span>
<span class="cm"> * the hardware words are 16-byte aligned, and we can have any amount of</span>
<span class="cm"> * sw space after the TD entry.</span>
<span class="cm"> *</span>
<span class="cm"> * td-&gt;link points to either another TD (not necessarily for the same urb or</span>
<span class="cm"> * even the same endpoint), or nothing (PTR_TERM), or a QH.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uhci_td</span> <span class="p">{</span>
	<span class="cm">/* Hardware fields */</span>
	<span class="n">__hc32</span> <span class="n">link</span><span class="p">;</span>
	<span class="n">__hc32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__hc32</span> <span class="n">token</span><span class="p">;</span>
	<span class="n">__hc32</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="cm">/* Software fields */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">frame</span><span class="p">;</span>			<span class="cm">/* for iso: what frame? */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fl_list</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * We need a special accessor for the control/status word because it is</span>
<span class="cm"> * subject to asynchronous updates by the controller.</span>
<span class="cm"> */</span>
<span class="cp">#define td_status(uhci, td)		hc32_to_cpu((uhci), \</span>
<span class="cp">						ACCESS_ONCE((td)-&gt;status))</span>

<span class="cp">#define LINK_TO_TD(uhci, td)		(cpu_to_hc32((uhci), (td)-&gt;dma_handle))</span>


<span class="cm">/*</span>
<span class="cm"> *	Skeleton Queue Headers</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The UHCI driver uses QHs with Interrupt, Control and Bulk URBs for</span>
<span class="cm"> * automatic queuing. To make it easy to insert entries into the schedule,</span>
<span class="cm"> * we have a skeleton of QHs for each predefined Interrupt latency.</span>
<span class="cm"> * Asynchronous QHs (low-speed control, full-speed control, and bulk)</span>
<span class="cm"> * go onto the period-1 interrupt list, since they all get accessed on</span>
<span class="cm"> * every frame.</span>
<span class="cm"> *</span>
<span class="cm"> * When we want to add a new QH, we add it to the list starting from the</span>
<span class="cm"> * appropriate skeleton QH.  For instance, the schedule can look like this:</span>
<span class="cm"> *</span>
<span class="cm"> * skel int128 QH</span>
<span class="cm"> * dev 1 interrupt QH</span>
<span class="cm"> * dev 5 interrupt QH</span>
<span class="cm"> * skel int64 QH</span>
<span class="cm"> * skel int32 QH</span>
<span class="cm"> * ...</span>
<span class="cm"> * skel int1 + async QH</span>
<span class="cm"> * dev 5 low-speed control QH</span>
<span class="cm"> * dev 1 bulk QH</span>
<span class="cm"> * dev 2 bulk QH</span>
<span class="cm"> *</span>
<span class="cm"> * There is a special terminating QH used to keep full-speed bandwidth</span>
<span class="cm"> * reclamation active when no full-speed control or bulk QHs are linked</span>
<span class="cm"> * into the schedule.  It has an inactive TD (to work around a PIIX bug,</span>
<span class="cm"> * see the Intel errata) and it points back to itself.</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s a special skeleton QH for Isochronous QHs which never appears</span>
<span class="cm"> * on the schedule.  Isochronous TDs go on the schedule before the</span>
<span class="cm"> * the skeleton QHs.  The hardware accesses them directly rather than</span>
<span class="cm"> * through their QH, which is used only for bookkeeping purposes.</span>
<span class="cm"> * While the UHCI spec doesn&#39;t forbid the use of QHs for Isochronous,</span>
<span class="cm"> * it doesn&#39;t use them either.  And the spec says that queues never</span>
<span class="cm"> * advance on an error completion status, which makes them totally</span>
<span class="cm"> * unsuitable for Isochronous transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s also a special skeleton QH used for QHs which are in the process</span>
<span class="cm"> * of unlinking and so may still be in use by the hardware.  It too never</span>
<span class="cm"> * appears on the schedule.</span>
<span class="cm"> */</span>

<span class="cp">#define UHCI_NUM_SKELQH		11</span>
<span class="cp">#define SKEL_UNLINK		0</span>
<span class="cp">#define skel_unlink_qh		skelqh[SKEL_UNLINK]</span>
<span class="cp">#define SKEL_ISO		1</span>
<span class="cp">#define skel_iso_qh		skelqh[SKEL_ISO]</span>
	<span class="cm">/* int128, int64, ..., int1 = 2, 3, ..., 9 */</span>
<span class="cp">#define SKEL_INDEX(exponent)	(9 - exponent)</span>
<span class="cp">#define SKEL_ASYNC		9</span>
<span class="cp">#define skel_async_qh		skelqh[SKEL_ASYNC]</span>
<span class="cp">#define SKEL_TERM		10</span>
<span class="cp">#define skel_term_qh		skelqh[SKEL_TERM]</span>

<span class="cm">/* The following entries refer to sublists of skel_async_qh */</span>
<span class="cp">#define SKEL_LS_CONTROL		20</span>
<span class="cp">#define SKEL_FS_CONTROL		21</span>
<span class="cp">#define SKEL_FSBR		SKEL_FS_CONTROL</span>
<span class="cp">#define SKEL_BULK		22</span>

<span class="cm">/*</span>
<span class="cm"> *	The UHCI controller and root hub</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * States for the root hub:</span>
<span class="cm"> *</span>
<span class="cm"> * To prevent &quot;bouncing&quot; in the presence of electrical noise,</span>
<span class="cm"> * when there are no devices attached we delay for 1 second in the</span>
<span class="cm"> * RUNNING_NODEVS state before switching to the AUTO_STOPPED state.</span>
<span class="cm"> * </span>
<span class="cm"> * (Note that the AUTO_STOPPED state won&#39;t be necessary once the hub</span>
<span class="cm"> * driver learns to autosuspend.)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">uhci_rh_state</span> <span class="p">{</span>
	<span class="cm">/* In the following states the HC must be halted.</span>
<span class="cm">	 * These two must come first. */</span>
	<span class="n">UHCI_RH_RESET</span><span class="p">,</span>
	<span class="n">UHCI_RH_SUSPENDED</span><span class="p">,</span>

	<span class="n">UHCI_RH_AUTO_STOPPED</span><span class="p">,</span>
	<span class="n">UHCI_RH_RESUMING</span><span class="p">,</span>

	<span class="cm">/* In this state the HC changes from running to halted,</span>
<span class="cm">	 * so it can legally appear either way. */</span>
	<span class="n">UHCI_RH_SUSPENDING</span><span class="p">,</span>

	<span class="cm">/* In the following states it&#39;s an error if the HC is halted.</span>
<span class="cm">	 * These two must come last. */</span>
	<span class="n">UHCI_RH_RUNNING</span><span class="p">,</span>		<span class="cm">/* The normal state */</span>
	<span class="n">UHCI_RH_RUNNING_NODEVS</span><span class="p">,</span>		<span class="cm">/* Running with no devices attached */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The full UHCI controller information:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="p">{</span>

	<span class="cm">/* debugfs */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="cm">/* Grabbed from PCI */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_addr</span><span class="p">;</span>

	<span class="cm">/* Used when registers are memory mapped */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dma_pool</span> <span class="o">*</span><span class="n">qh_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span> <span class="o">*</span><span class="n">td_pool</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">term_td</span><span class="p">;</span>	<span class="cm">/* Terminating TD, see UHCI bug */</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">skelqh</span><span class="p">[</span><span class="n">UHCI_NUM_SKELQH</span><span class="p">];</span>	<span class="cm">/* Skeleton QHs */</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">next_qh</span><span class="p">;</span>	<span class="cm">/* Next QH to scan */</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="n">dma_addr_t</span> <span class="n">frame_dma_handle</span><span class="p">;</span>	<span class="cm">/* Hardware frame list */</span>
	<span class="n">__hc32</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">frame_cpu</span><span class="p">;</span>		<span class="cm">/* CPU&#39;s frame list */</span>

	<span class="k">enum</span> <span class="n">uhci_rh_state</span> <span class="n">rh_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">auto_stop_time</span><span class="p">;</span>		<span class="cm">/* When to AUTO_STOP */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frame_number</span><span class="p">;</span>		<span class="cm">/* As of last check */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_stopped</span><span class="p">;</span>
<span class="cp">#define UHCI_IS_STOPPED		9999		</span><span class="cm">/* Larger than a frame # */</span><span class="cp"></span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_iso_frame</span><span class="p">;</span>		<span class="cm">/* Frame of last scan */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_iso_frame</span><span class="p">;</span>		<span class="cm">/* Frame for current scan */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_in_progress</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Schedule scan is running */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">need_rescan</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Redo the schedule scan */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dead</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* Controller has died */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">RD_enable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Suspended root hub with</span>
<span class="cm">						   Resume-Detect interrupts</span>
<span class="cm">						   enabled */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_initialized</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Data structure is usable */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fsbr_is_on</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* FSBR is turned on */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fsbr_is_wanted</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Does any URB want FSBR? */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fsbr_expiring</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* FSBR is timing out */</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">fsbr_timer</span><span class="p">;</span>		<span class="cm">/* For turning off FBSR */</span>

	<span class="cm">/* Silicon quirks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oc_low</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* OverCurrent bit active low */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait_for_hp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Wait for HP port reset */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">big_endian_mmio</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Big endian registers */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">big_endian_desc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Big endian descriptors */</span>

	<span class="cm">/* Support for port suspend/resume/reset */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_c_suspend</span><span class="p">;</span>		<span class="cm">/* Bit-arrays of ports */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resuming_ports</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ports_timeout</span><span class="p">;</span>		<span class="cm">/* Time to stop signalling */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">idle_qh_list</span><span class="p">;</span>		<span class="cm">/* Where the idle QHs live */</span>

	<span class="kt">int</span> <span class="n">rh_numports</span><span class="p">;</span>			<span class="cm">/* Number of root-hub ports */</span>

	<span class="n">wait_queue_head_t</span> <span class="n">waitqh</span><span class="p">;</span>		<span class="cm">/* endpoint_disable waiters */</span>
	<span class="kt">int</span> <span class="n">num_waiting</span><span class="p">;</span>			<span class="cm">/* Number of waiters */</span>

	<span class="kt">int</span> <span class="n">total_load</span><span class="p">;</span>				<span class="cm">/* Sum of array values */</span>
	<span class="kt">short</span> <span class="n">load</span><span class="p">[</span><span class="n">MAX_PHASE</span><span class="p">];</span>			<span class="cm">/* Periodic allocations */</span>

	<span class="cm">/* Reset host controller */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset_hc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">check_and_reset_hc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">);</span>
	<span class="cm">/* configure_hc should perform arch specific settings, if needed */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">configure_hc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">);</span>
	<span class="cm">/* Check for broken resume detect interrupts */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">resume_detect_interrupts_are_broken</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">);</span>
	<span class="cm">/* Check for broken global suspend */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">global_suspend_mode_is_broken</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Convert between a usb_hcd pointer and the corresponding uhci_hcd */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="nf">hcd_to_uhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">uhci_to_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define uhci_dev(u)	(uhci_to_hcd(u)-&gt;self.controller)</span>

<span class="cm">/* Utility macro for comparing frame numbers */</span>
<span class="cp">#define uhci_frame_before_eq(f1, f2)	(0 &lt;= (int) ((f2) - (f1)))</span>


<span class="cm">/*</span>
<span class="cm"> *	Private per-URB data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">urb_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>		<span class="cm">/* Node in the QH&#39;s urbp list */</span>

	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>		<span class="cm">/* QH for this URB */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">td_list</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">fsbr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* URB wants FSBR */</span>
<span class="p">};</span>


<span class="cm">/* Some special IDs */</span>

<span class="cp">#define PCI_VENDOR_ID_GENESYS		0x17a0</span>
<span class="cp">#define PCI_DEVICE_ID_GL880S_UHCI	0x8083</span>

<span class="cm">/*</span>
<span class="cm"> * Functions used to access controller registers. The UCHI spec says that host</span>
<span class="cm"> * controller I/O registers are mapped into PCI I/O space. For non-PCI hosts</span>
<span class="cm"> * we use memory mapped registers.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef CONFIG_USB_UHCI_SUPPORT_NON_PCI_HC</span>
<span class="cm">/* Support PCI only */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">uhci_readl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inl</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_writel</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">uhci_readw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_writew</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">uhci_readb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_writeb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cm">/* Support non-PCI host controllers */</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cm">/* Support PCI and non-PCI host controllers */</span>
<span class="cp">#define uhci_has_pci_registers(u)	((u)-&gt;io_addr != 0)</span>
<span class="cp">#else</span>
<span class="cm">/* Support non-PCI host controllers only */</span>
<span class="cp">#define uhci_has_pci_registers(u)	0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO</span>
<span class="cm">/* Support (non-PCI) big endian host controllers */</span>
<span class="cp">#define uhci_big_endian_mmio(u)		((u)-&gt;big_endian_mmio)</span>
<span class="cp">#else</span>
<span class="cp">#define uhci_big_endian_mmio(u)		0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">uhci_readl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci_has_pci_registers</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inl</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uhci_big_endian_mmio</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_writel</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci_has_pci_registers</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="n">outl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uhci_big_endian_mmio</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="n">writel_be</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">uhci_readw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci_has_pci_registers</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uhci_big_endian_mmio</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">readw_be</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">readw</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_writew</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci_has_pci_registers</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uhci_big_endian_mmio</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="n">writew_be</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">uhci_readb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci_has_pci_registers</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uhci_big_endian_mmio</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">readb_be</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_writeb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci_has_pci_registers</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">io_addr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uhci_big_endian_mmio</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="n">writeb_be</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_UHCI_SUPPORT_NON_PCI_HC */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The GRLIB GRUSBHC controller can use big endian format for its descriptors.</span>
<span class="cm"> *</span>
<span class="cm"> * UHCI controllers accessed through PCI work normally (little-endian</span>
<span class="cm"> * everywhere), so we don&#39;t bother supporting a BE-only mode.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_DESC</span>
<span class="cp">#define uhci_big_endian_desc(u)		((u)-&gt;big_endian_desc)</span>

<span class="cm">/* cpu to uhci */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc32</span> <span class="nf">cpu_to_hc32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uhci_big_endian_desc</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span>
		<span class="o">?</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__hc32</span><span class="p">)</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__hc32</span><span class="p">)</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* uhci to cpu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uhci_big_endian_desc</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">be32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span><span class="p">)</span><span class="n">x</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">le32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cm">/* cpu to uhci */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc32</span> <span class="nf">cpu_to_hc32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* uhci to cpu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
