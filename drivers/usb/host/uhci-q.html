<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › uhci-q.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>uhci-q.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Universal Host Controller Interface driver for USB.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintainer: Alan Stern &lt;stern@rowland.harvard.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 1999 Linus Torvalds</span>
<span class="cm"> * (C) Copyright 1999-2002 Johannes Erdfelt, johannes@erdfelt.com</span>
<span class="cm"> * (C) Copyright 1999 Randy Dunlap</span>
<span class="cm"> * (C) Copyright 1999 Georg Acher, acher@in.tum.de</span>
<span class="cm"> * (C) Copyright 1999 Deti Fliegl, deti@fliegl.de</span>
<span class="cm"> * (C) Copyright 1999 Thomas Sailer, sailer@ife.ee.ethz.ch</span>
<span class="cm"> * (C) Copyright 1999 Roman Weissgaerber, weissg@vienna.at</span>
<span class="cm"> * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface</span>
<span class="cm"> *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).</span>
<span class="cm"> * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)</span>
<span class="cm"> * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Technically, updating td-&gt;status here is a race, but it&#39;s not really a</span>
<span class="cm"> * problem. The worst that can happen is that we set the IOC bit again</span>
<span class="cm"> * generating a spurious interrupt. We could fix this by creating another</span>
<span class="cm"> * QH and leaving the IOC bit always set, but then we would have to play</span>
<span class="cm"> * games with the FSBR code to make sure we get the correct order in all</span>
<span class="cm"> * the cases. I don&#39;t think it&#39;s worth the effort</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_set_next_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">is_stopped</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">term_td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">TD_CTRL_IOC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_clear_next_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">term_td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">TD_CTRL_IOC</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Full-Speed Bandwidth Reclamation (FSBR).</span>
<span class="cm"> * We turn on FSBR whenever a queue that wants it is advancing,</span>
<span class="cm"> * and leave it on for a short time thereafter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_fsbr_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">lqh</span><span class="p">;</span>

	<span class="cm">/* The terminating skeleton QH always points back to the first</span>
<span class="cm">	 * FSBR QH.  Make the last async QH point to the terminating</span>
<span class="cm">	 * skeleton QH. */</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_is_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lqh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_async_qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">lqh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">LINK_TO_QH</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_term_qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_fsbr_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">lqh</span><span class="p">;</span>

	<span class="cm">/* Remove the link from the last async QH to the terminating</span>
<span class="cm">	 * skeleton QH. */</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_is_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lqh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_async_qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">lqh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_add_fsbr</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_FSBR</span><span class="p">))</span>
		<span class="n">urbp</span><span class="o">-&gt;</span><span class="n">fsbr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_urbp_wants_fsbr</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">fsbr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_is_wanted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_is_on</span><span class="p">)</span>
			<span class="n">uhci_fsbr_on</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_expiring</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_expiring</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_timer</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_fsbr_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">_uhci</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_expiring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_expiring</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">uhci_fsbr_off</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="nf">uhci_alloc_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>

	<span class="n">td</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">td_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">td</span><span class="o">-&gt;</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">td</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_free_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="n">dev_WARN</span><span class="p">(</span><span class="n">uhci_dev</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span> <span class="s">&quot;td %p still in list!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">))</span>
		<span class="n">dev_WARN</span><span class="p">(</span><span class="n">uhci_dev</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span> <span class="s">&quot;td %p still in fl_list!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>

	<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">td_pool</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_fill_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">u32</span> <span class="n">token</span><span class="p">,</span> <span class="n">u32</span> <span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">token</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_add_td_to_urbp</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_remove_td_from_urbp</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We insert Isochronous URBs directly into the frame list at the beginning</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_insert_td_in_frame_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">framenum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">framenum</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">UHCI_NUMFRAMES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">framenum</span><span class="p">;</span>

	<span class="cm">/* Is there a TD already mapped there? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">framenum</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">ftd</span><span class="p">,</span> <span class="o">*</span><span class="n">ltd</span><span class="p">;</span>

		<span class="n">ftd</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">framenum</span><span class="p">];</span>
		<span class="n">ltd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ftd</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">fl_list</span><span class="p">);</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftd</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">);</span>

		<span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">ltd</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">ltd</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">framenum</span><span class="p">];</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">framenum</span><span class="p">]</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">framenum</span><span class="p">]</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_remove_td_from_frame_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If it&#39;s not inserted, don&#39;t remove it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">]</span> <span class="o">==</span> <span class="n">td</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">ntd</span><span class="p">;</span>

			<span class="n">ntd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span>
					 <span class="n">fl_list</span><span class="p">);</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">ntd</span><span class="p">);</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">ptd</span><span class="p">;</span>

		<span class="n">ptd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">fl_list</span><span class="p">);</span>
		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">);</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uhci_remove_tds_from_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">framenum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">ftd</span><span class="p">,</span> <span class="o">*</span><span class="n">ltd</span><span class="p">;</span>

	<span class="n">framenum</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">UHCI_NUMFRAMES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ftd</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">framenum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ltd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ftd</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">fl_list</span><span class="p">);</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">framenum</span><span class="p">]</span> <span class="o">=</span> <span class="n">ltd</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_cpu</span><span class="p">[</span><span class="n">framenum</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftd</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">))</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="n">ftd</span><span class="o">-&gt;</span><span class="n">fl_list</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove all the TDs for an Isochronous URB from the frame list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_unlink_isochronous_tds</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">uhci_remove_td_from_frame_list</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="nf">uhci_alloc_qh</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">hep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">qh_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">qh</span><span class="p">));</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">dma_handle</span><span class="p">;</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Normal QH */</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">usb_endpoint_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">qh_pool</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hep</span> <span class="o">=</span> <span class="n">hep</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
		<span class="n">hep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_INT</span> <span class="o">||</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">load</span> <span class="o">=</span> <span class="n">usb_calc_bus_time</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span>
					<span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span>
					<span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">,</span>
					<span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
				<span class="o">/</span> <span class="mi">1000</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* Skeleton QH */</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_free_qh</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">QH_STATE_IDLE</span> <span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">dev_WARN</span><span class="p">(</span><span class="n">uhci_dev</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span> <span class="s">&quot;qh %p list not empty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="p">)</span>
			<span class="n">uhci_free_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">qh_pool</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a queue is stopped and a dequeued URB is given back, adjust</span>
<span class="cm"> * the previous TD link (if the URB isn&#39;t first on the queue) or</span>
<span class="cm"> * save its toggle value (if it is first and is currently executing).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the URB should not yet be given back, 1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_cleanup_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Isochronous pipes don&#39;t use toggles and their TD link pointers</span>
<span class="cm">	 * get adjusted during uhci_urb_dequeue().  But since their queues</span>
<span class="cm">	 * cannot truly be stopped, we have to watch out for dequeues</span>
<span class="cm">	 * occurring after the nominal unlink frame. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span> <span class="o">+</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">is_stopped</span> <span class="o">!=</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">unlink_frame</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the URB isn&#39;t first on its queue, adjust the link pointer</span>
<span class="cm">	 * of the last TD in the previous URB.  The toggle doesn&#39;t need</span>
<span class="cm">	 * to be saved since this URB can&#39;t be executing yet. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">purbp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">ptd</span><span class="p">;</span>

		<span class="n">purbp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">purbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">));</span>
		<span class="n">ptd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">purbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span>
				<span class="n">list</span><span class="p">);</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span>
				<span class="n">list</span><span class="p">);</span>
		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the QH element pointer is UHCI_PTR_TERM then then currently</span>
<span class="cm">	 * executing URB has already been unlinked, so this one isn&#39;t it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh_element</span><span class="p">(</span><span class="n">qh</span><span class="p">)</span> <span class="o">==</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>

	<span class="cm">/* Control pipes don&#39;t have to worry about toggles */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Save the next toggle value */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">));</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_fixup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">initial_toggle</span> <span class="o">=</span> <span class="n">uhci_toggle</span><span class="p">(</span><span class="n">td_token</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">));</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fix up the data toggles for URBs in a queue, when one of them</span>
<span class="cm"> * terminates early (short transfer, error, or dequeued).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_fixup_toggles</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">skip_first</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">toggle</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">initial_toggle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="cm">/* Fixups for a short transfer start with the second URB in the</span>
<span class="cm">	 * queue (the short URB is the first). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skip_first</span><span class="p">)</span>
		<span class="n">urbp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="cm">/* When starting with the first URB, if the QH element pointer is</span>
<span class="cm">	 * still valid then we know the URB&#39;s toggles are okay. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh_element</span><span class="p">(</span><span class="n">qh</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span>
		<span class="n">toggle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Fix up the toggle for the URBs in the queue.  Normally this</span>
<span class="cm">	 * loop won&#39;t run more than once: When an error or short transfer</span>
<span class="cm">	 * occurs, the queue usually gets emptied. */</span>
	<span class="n">urbp</span> <span class="o">=</span> <span class="n">list_prepare_entry</span><span class="p">(</span><span class="n">urbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">urbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* If the first TD has the right toggle value, we don&#39;t</span>
<span class="cm">		 * need to change any toggles in this URB */</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">toggle</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">uhci_toggle</span><span class="p">(</span><span class="n">td_token</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">))</span> <span class="o">==</span> <span class="n">toggle</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span>
					<span class="n">list</span><span class="p">);</span>
			<span class="n">toggle</span> <span class="o">=</span> <span class="n">uhci_toggle</span><span class="p">(</span><span class="n">td_token</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">))</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Otherwise all the toggles in the URB have to be switched */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">td</span><span class="o">-&gt;</span><span class="n">token</span> <span class="o">^=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span>
							<span class="n">TD_TOKEN_TOGGLE</span><span class="p">);</span>
				<span class="n">toggle</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
	<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span>
			<span class="n">usb_pipeout</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span> <span class="n">toggle</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_fixup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link an Isochronous QH into its skeleton&#39;s list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">link_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_iso_qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* Isochronous QHs aren&#39;t linked by the hardware */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link a high-period interrupt QH into the schedule at the end of its</span>
<span class="cm"> * skeleton&#39;s list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">link_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">pqh</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skelqh</span><span class="p">[</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="n">pqh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">pqh</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">pqh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">LINK_TO_QH</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link a period-1 interrupt or async QH into the schedule at the</span>
<span class="cm"> * correct spot in the async skeleton&#39;s list, and update the FSBR link</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">link_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">pqh</span><span class="p">;</span>
	<span class="n">__hc32</span> <span class="n">link_to_new_qh</span><span class="p">;</span>

	<span class="cm">/* Find the predecessor QH for our new one and insert it in the list.</span>
<span class="cm">	 * The list of QHs is expected to be short, so linear search won&#39;t</span>
<span class="cm">	 * take too long. */</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">pqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_async_qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pqh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">&lt;=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pqh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* Link it into the schedule */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">pqh</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">link_to_new_qh</span> <span class="o">=</span> <span class="n">LINK_TO_QH</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="n">pqh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">link_to_new_qh</span><span class="p">;</span>

	<span class="cm">/* If this is now the first FSBR QH, link the terminating skeleton</span>
<span class="cm">	 * QH to it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pqh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">&lt;</span> <span class="n">SKEL_FSBR</span> <span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">&gt;=</span> <span class="n">SKEL_FSBR</span><span class="p">)</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_term_qh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">link_to_new_qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put a QH on the schedule in both hardware and software</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_activate_qh</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>

	<span class="cm">/* Set the element pointer if it isn&#39;t set already.</span>
<span class="cm">	 * This isn&#39;t needed for Isochronous queues, but it doesn&#39;t hurt. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh_element</span><span class="p">(</span><span class="n">qh</span><span class="p">)</span> <span class="o">==</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Treat the queue as if it has just advanced */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">wait_expired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">advance_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">;</span>

	<span class="cm">/* Move the QH from its old list to the correct spot in the appropriate</span>
<span class="cm">	 * skeleton&#39;s list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span><span class="p">)</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span>
				<span class="n">node</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">==</span> <span class="n">SKEL_ISO</span><span class="p">)</span>
		<span class="n">link_iso</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">&lt;</span> <span class="n">SKEL_ASYNC</span><span class="p">)</span>
		<span class="n">link_interrupt</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">link_async</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a high-period interrupt QH from the schedule</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">pqh</span><span class="p">;</span>

	<span class="n">pqh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">pqh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a period-1 interrupt or async QH from the schedule</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">pqh</span><span class="p">;</span>
	<span class="n">__hc32</span> <span class="n">link_to_next_qh</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="n">pqh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">pqh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">link_to_next_qh</span><span class="p">;</span>

	<span class="cm">/* If this was the old first FSBR QH, link the terminating skeleton</span>
<span class="cm">	 * QH to the next (new first FSBR) QH. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pqh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">&lt;</span> <span class="n">SKEL_FSBR</span> <span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">&gt;=</span> <span class="n">SKEL_FSBR</span><span class="p">)</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_term_qh</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">link_to_next_qh</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take a QH off the hardware schedule</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_unlink_qh</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_UNLINKING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">QH_STATE_ACTIVE</span> <span class="o">||</span> <span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">QH_STATE_UNLINKING</span><span class="p">;</span>

	<span class="cm">/* Unlink the QH from the schedule and record when we did it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">==</span> <span class="n">SKEL_ISO</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">&lt;</span> <span class="n">SKEL_ASYNC</span><span class="p">)</span>
		<span class="n">unlink_interrupt</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">unlink_async</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="n">uhci_get_current_frame_number</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">unlink_frame</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span><span class="p">;</span>

	<span class="cm">/* Force an interrupt so we know when the QH is fully unlinked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_unlink_qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="o">||</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">is_stopped</span><span class="p">)</span>
		<span class="n">uhci_set_next_interrupt</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>

	<span class="cm">/* Move the QH from its old list to the end of the unlinking list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span><span class="p">)</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span>
				<span class="n">node</span><span class="p">);</span>
	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_unlink_qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we and the controller are through with a QH, it becomes IDLE.</span>
<span class="cm"> * This happens when a QH has been off the schedule (on the unlinking</span>
<span class="cm"> * list) for more than one frame, or when an error occurs while adding</span>
<span class="cm"> * the first URB onto a new QH.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_make_qh_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span><span class="p">)</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span>
				<span class="n">node</span><span class="p">);</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">idle_qh_list</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>

	<span class="cm">/* Now that the QH is idle, its post_td isn&#39;t being used */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci_free_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If anyone is waiting for a QH to become idle, wake them up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">num_waiting</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">waitqh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the highest existing bandwidth load for a given phase and period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_highest_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">highest_load</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">[</span><span class="n">phase</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">phase</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="n">MAX_PHASE</span><span class="p">;</span> <span class="n">phase</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span>
		<span class="n">highest_load</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">highest_load</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">[</span><span class="n">phase</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">highest_load</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set qh-&gt;phase to the optimal phase for a periodic transfer and</span>
<span class="cm"> * check whether the bandwidth requirement is acceptable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_check_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">minimax_load</span><span class="p">;</span>

	<span class="cm">/* Find the optimal phase (unless it is already set) and get</span>
<span class="cm">	 * its load value. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">minimax_load</span> <span class="o">=</span> <span class="n">uhci_highest_load</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">phase</span><span class="p">,</span> <span class="n">load</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">max_phase</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">MAX_PHASE</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>

		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">minimax_load</span> <span class="o">=</span> <span class="n">uhci_highest_load</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="n">max_phase</span><span class="p">;</span> <span class="o">++</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">load</span> <span class="o">=</span> <span class="n">uhci_highest_load</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">load</span> <span class="o">&lt;</span> <span class="n">minimax_load</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">minimax_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Maximum allowable periodic bandwidth is 90%, or 900 us per frame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">minimax_load</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">load</span> <span class="o">&gt;</span> <span class="mi">900</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">uhci_dev</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span> <span class="s">&quot;bandwidth allocation failed: &quot;</span>
				<span class="s">&quot;period %d, phase %d, %d + %d us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">,</span> <span class="n">minimax_load</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve a periodic QH&#39;s bandwidth in the schedule</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_reserve_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">load</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;??&quot;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PHASE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">load</span><span class="p">;</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">total_load</span> <span class="o">+=</span> <span class="n">load</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span> <span class="o">=</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">total_load</span> <span class="o">/</span> <span class="n">MAX_PHASE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="o">++</span><span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_int_reqs</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;INT&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="o">++</span><span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;ISO&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">bandwidth_reserved</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">uhci_dev</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span>
			<span class="s">&quot;%s dev %d ep%02x-%s, period %d, phase %d, %d us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="s">&quot;reserve&quot;</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">,</span> <span class="n">load</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release a periodic QH&#39;s bandwidth reservation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_release_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">load</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;??&quot;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PHASE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">load</span><span class="p">;</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">total_load</span> <span class="o">-=</span> <span class="n">load</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span> <span class="o">=</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">total_load</span> <span class="o">/</span> <span class="n">MAX_PHASE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="o">--</span><span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_int_reqs</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;INT&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="o">--</span><span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;ISO&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">bandwidth_reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">uhci_dev</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span>
			<span class="s">&quot;%s dev %d ep%02x-%s, period %d, phase %d, %d us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="s">&quot;release&quot;</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">,</span> <span class="n">load</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="nf">uhci_alloc_urb_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span><span class="p">;</span>

	<span class="n">urbp</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">uhci_up_cachep</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urbp</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">urbp</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">urbp</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">urbp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_free_urb_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">))</span>
		<span class="n">dev_WARN</span><span class="p">(</span><span class="n">uhci_dev</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span> <span class="s">&quot;urb %p still on QH&#39;s list!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urbp</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci_remove_td_from_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">);</span>
		<span class="n">uhci_free_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">uhci_up_cachep</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map status to standard result codes</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;status&gt; is (td_status(uhci, td) &amp; 0xF60000), a.k.a.</span>
<span class="cm"> * uhci_status_bits(td_status(uhci, td)).</span>
<span class="cm"> * Note: &lt;status&gt; does not include the TD_CTRL_NAK bit.</span>
<span class="cm"> * &lt;dir_out&gt; is True for output TDs and False for input TDs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_map_status</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_BITSTUFF</span><span class="p">)</span>			<span class="cm">/* Bitstuff error */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_CRCTIMEO</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* CRC/Timeout */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir_out</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_BABBLE</span><span class="p">)</span>			<span class="cm">/* Babble */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_DBUFERR</span><span class="p">)</span>			<span class="cm">/* Buffer error */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_STALLED</span><span class="p">)</span>			<span class="cm">/* Stalled */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Control transfers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_submit_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxsze</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>
	<span class="n">__hc32</span> <span class="o">*</span><span class="n">plink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skel</span><span class="p">;</span>

	<span class="cm">/* The &quot;pipe&quot; thing contains the destination in bits 8--18 */</span>
	<span class="n">destination</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">&amp;</span> <span class="n">PIPE_DEVEP_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">USB_PID_SETUP</span><span class="p">;</span>

	<span class="cm">/* 3 errors, dummy TD remains inactive */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">uhci_maxerr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">TD_CTRL_LS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the TD for the control request setup packet</span>
<span class="cm">	 */</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="p">;</span>
	<span class="n">uhci_add_td_to_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
	<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">destination</span> <span class="o">|</span> <span class="n">uhci_explen</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_dma</span><span class="p">);</span>
	<span class="n">plink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">|=</span> <span class="n">TD_CTRL_ACTIVE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If direction is &quot;send&quot;, change the packet ID from SETUP (0x2D)</span>
<span class="cm">	 * to OUT (0xE1).  Else change it from SETUP to IN (0x69) and</span>
<span class="cm">	 * set Short Packet Detect (SPD) for all data packets.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0-length transfers always get treated as &quot;send&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">||</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">destination</span> <span class="o">^=</span> <span class="p">(</span><span class="n">USB_PID_SETUP</span> <span class="o">^</span> <span class="n">USB_PID_OUT</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">destination</span> <span class="o">^=</span> <span class="p">(</span><span class="n">USB_PID_SETUP</span> <span class="o">^</span> <span class="n">USB_PID_IN</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">TD_CTRL_SPD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the DATA TDs</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pktsze</span> <span class="o">=</span> <span class="n">maxsze</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">pktsze</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* The last data packet */</span>
			<span class="n">pktsze</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TD_CTRL_SPD</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="o">*</span><span class="n">plink</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>

		<span class="cm">/* Alternate Data0/1 (start with Data1) */</span>
		<span class="n">destination</span> <span class="o">^=</span> <span class="n">TD_TOKEN_TOGGLE</span><span class="p">;</span>

		<span class="n">uhci_add_td_to_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
		<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
			<span class="n">destination</span> <span class="o">|</span> <span class="n">uhci_explen</span><span class="p">(</span><span class="n">pktsze</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
		<span class="n">plink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">+=</span> <span class="n">pktsze</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">pktsze</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the final TD for control status</span>
<span class="cm">	 */</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="o">*</span><span class="n">plink</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>

	<span class="cm">/* Change direction for the status transaction */</span>
	<span class="n">destination</span> <span class="o">^=</span> <span class="p">(</span><span class="n">USB_PID_IN</span> <span class="o">^</span> <span class="n">USB_PID_OUT</span><span class="p">);</span>
	<span class="n">destination</span> <span class="o">|=</span> <span class="n">TD_TOKEN_TOGGLE</span><span class="p">;</span>		<span class="cm">/* End in Data1 */</span>

	<span class="n">uhci_add_td_to_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
	<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">status</span> <span class="o">|</span> <span class="n">TD_CTRL_IOC</span><span class="p">,</span>
			<span class="n">destination</span> <span class="o">|</span> <span class="n">uhci_explen</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">plink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the new dummy TD and activate the old one</span>
<span class="cm">	 */</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="o">*</span><span class="n">plink</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>

	<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_PID_OUT</span> <span class="o">|</span> <span class="n">uhci_explen</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">TD_CTRL_ACTIVE</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>

	<span class="cm">/* Low-speed transfers get a different queue, and won&#39;t hog the bus.</span>
<span class="cm">	 * Also, some devices enumerate better without FSBR; the easiest way</span>
<span class="cm">	 * to do that is to put URBs on the low-speed queue while the device</span>
<span class="cm">	 * isn&#39;t in the CONFIGURED state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span> <span class="o">||</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">USB_STATE_CONFIGURED</span><span class="p">)</span>
		<span class="n">skel</span> <span class="o">=</span> <span class="n">SKEL_LS_CONTROL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">skel</span> <span class="o">=</span> <span class="n">SKEL_FS_CONTROL</span><span class="p">;</span>
		<span class="n">uhci_add_fsbr</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">)</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">=</span> <span class="n">skel</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="cm">/* Remove the dummy TD from the td_list so it doesn&#39;t get freed */</span>
	<span class="n">uhci_remove_td_from_urbp</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common submit for bulk and interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_submit_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxsze</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_sg_len</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__hc32</span> <span class="o">*</span><span class="n">plink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">toggle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>  <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* The &quot;pipe&quot; thing contains the destination in bits 8--18 */</span>
	<span class="n">destination</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">&amp;</span> <span class="n">PIPE_DEVEP_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">usb_packetid</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">toggle</span> <span class="o">=</span> <span class="n">usb_gettoggle</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
			 <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">));</span>

	<span class="cm">/* 3 errors, dummy TD remains inactive */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">uhci_maxerr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">TD_CTRL_LS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">TD_CTRL_SPD</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_mapped_sgs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="cm">/* urb-&gt;transfer_buffer_length may be smaller than the</span>
<span class="cm">		 * size of the scatterlist (or vice versa)</span>
<span class="cm">		 */</span>
		<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>
		<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Build the DATA TDs</span>
<span class="cm">	 */</span>
	<span class="n">plink</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>	<span class="cm">/* Allow zero length packets */</span>
		<span class="kt">int</span> <span class="n">pktsze</span> <span class="o">=</span> <span class="n">maxsze</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">pktsze</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* The last packet */</span>
			<span class="n">pktsze</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">))</span>
				<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TD_CTRL_SPD</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">plink</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
			<span class="o">*</span><span class="n">plink</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">uhci_add_td_to_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
		<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
				<span class="n">destination</span> <span class="o">|</span> <span class="n">uhci_explen</span><span class="p">(</span><span class="n">pktsze</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">toggle</span> <span class="o">&lt;&lt;</span> <span class="n">TD_TOKEN_TOGGLE_SHIFT</span><span class="p">),</span>
				<span class="n">data</span><span class="p">);</span>
		<span class="n">plink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">TD_CTRL_ACTIVE</span><span class="p">;</span>

		<span class="n">toggle</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">pktsze</span><span class="p">;</span>
		<span class="n">this_sg_len</span> <span class="o">-=</span> <span class="n">pktsze</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">maxsze</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_sg_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * URB_ZERO_PACKET means adding a 0-length packet, if direction</span>
<span class="cm">	 * is OUT and the transfer_length was an exact multiple of maxsze,</span>
<span class="cm">	 * hence (len = transfer_length - N * maxsze) == 0</span>
<span class="cm">	 * however, if transfer_length == 0, the zero packet was already</span>
<span class="cm">	 * prepared above.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ZERO_PACKET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="o">*</span><span class="n">plink</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>

		<span class="n">uhci_add_td_to_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
		<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
				<span class="n">destination</span> <span class="o">|</span> <span class="n">uhci_explen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">toggle</span> <span class="o">&lt;&lt;</span> <span class="n">TD_TOKEN_TOGGLE_SHIFT</span><span class="p">),</span>
				<span class="n">data</span><span class="p">);</span>
		<span class="n">plink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

		<span class="n">toggle</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the interrupt-on-completion flag on the last packet.</span>
<span class="cm">	 * A more-or-less typical 4 KB URB (= size of one memory page)</span>
<span class="cm">	 * will require about 3 ms to transfer; that&#39;s a little on the</span>
<span class="cm">	 * fast side but not enough to justify delaying an interrupt</span>
<span class="cm">	 * more than 2 or 3 URBs, so we will ignore the URB_NO_INTERRUPT</span>
<span class="cm">	 * flag setting. */</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">TD_CTRL_IOC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the new dummy TD and activate the old one</span>
<span class="cm">	 */</span>
	<span class="n">td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="o">*</span><span class="n">plink</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>

	<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_PID_OUT</span> <span class="o">|</span> <span class="n">uhci_explen</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">TD_CTRL_ACTIVE</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>

	<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
			<span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span> <span class="n">toggle</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="cm">/* Remove the dummy TD from the td_list so it doesn&#39;t get freed */</span>
	<span class="n">uhci_remove_td_from_urbp</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy_td</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_submit_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t have low-speed bulk transfers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">)</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">=</span> <span class="n">SKEL_BULK</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_submit_common</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uhci_add_fsbr</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_submit_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* USB 1.1 interrupt transfers only involve one packet per interval.</span>
<span class="cm">	 * Drivers can submit URBs of any length, but longer ones will need</span>
<span class="cm">	 * multiple intervals to complete.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">bandwidth_reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">exponent</span><span class="p">;</span>

		<span class="cm">/* Figure out which power-of-two queue to use */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">exponent</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* If the slot is full, try a lower period */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">exponent</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">=</span> <span class="n">SKEL_INDEX</span><span class="p">(</span><span class="n">exponent</span><span class="p">);</span>

			<span class="cm">/* For now, interrupt phase is fixed by the layout</span>
<span class="cm">			 * of the QH lists.</span>
<span class="cm">			 */</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAX_PHASE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_check_bandwidth</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>		<span class="cm">/* Can&#39;t decrease the period */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_submit_common</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">bandwidth_reserved</span><span class="p">)</span>
			<span class="n">uhci_reserve_bandwidth</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fix up the data structures following a short transfer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_fixup_short_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* When a control transfer is short, we have to restart</span>
<span class="cm">		 * the queue at the status stage transaction, which is</span>
<span class="cm">		 * the last TD. */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">));</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* When a bulk/interrupt transfer is short, we have to</span>
<span class="cm">		 * fix up the toggles of the following URBs on the queue</span>
<span class="cm">		 * before restarting the queue at the next URB. */</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">initial_toggle</span> <span class="o">=</span>
			<span class="n">uhci_toggle</span><span class="p">(</span><span class="n">td_token</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="p">))</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">uhci_fixup_toggles</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span>
			<span class="n">td</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove all the TDs we skipped over, from tmp back to the start */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

		<span class="n">uhci_remove_td_from_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">);</span>
		<span class="n">uhci_free_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common result for control, bulk, and interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_result_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrlstat</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ctrlstat</span> <span class="o">=</span> <span class="n">td_status</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">uhci_status_bits</span><span class="p">(</span><span class="n">ctrlstat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_ACTIVE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">uhci_actual_length</span><span class="p">(</span><span class="n">ctrlstat</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_map_status</span><span class="p">(</span><span class="n">status</span><span class="p">,</span>
					<span class="n">uhci_packetout</span><span class="p">(</span><span class="n">td_token</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">)));</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="o">||</span> <span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Some debugging code */</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;%s: failed with status %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errbuf</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Print the chain for debugging */</span>
					<span class="n">uhci_show_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">,</span> <span class="n">errbuf</span><span class="p">,</span>
							<span class="n">ERRBUF_LEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">lprintk</span><span class="p">(</span><span class="n">errbuf</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="cm">/* Did we receive a short packet? */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">uhci_expected_length</span><span class="p">(</span><span class="n">td_token</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">)))</span> <span class="p">{</span>

			<span class="cm">/* For control transfers, go to the status TD if</span>
<span class="cm">			 * this isn&#39;t already the last data TD */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">prev</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* For bulk and interrupt, this may be an error */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>

			<span class="cm">/* Fixup needed only if this isn&#39;t the URB&#39;s last TD */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">!=</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">prev</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uhci_remove_td_from_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="p">)</span>
			<span class="n">uhci_free_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span> <span class="o">=</span> <span class="n">td</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Note that the queue has stopped and save</span>
<span class="cm">		 * the next toggle value */</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">UHCI_PTR_TERM</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_fixup</span> <span class="o">=</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">initial_toggle</span> <span class="o">=</span> <span class="n">uhci_toggle</span><span class="p">(</span><span class="n">td_token</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">))</span> <span class="o">^</span>
				<span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span>		<span class="cm">/* Short packet received */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_fixup_short_transfer</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Isochronous transfers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_submit_isochronous</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* Since urb-&gt;number_of_packets &gt; 0 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="cm">/* Values must not be too big (could overflow below) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;=</span> <span class="n">UHCI_NUMFRAMES</span> <span class="o">||</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">&gt;=</span> <span class="n">UHCI_NUMFRAMES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="cm">/* Check the period and figure out the starting frame number */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">bandwidth_reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ISO_ASAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Find the best phase */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">uhci_check_bandwidth</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/* Allow a little time to allocate the TDs */</span>
			<span class="n">uhci_get_current_frame_number</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

			<span class="cm">/* Move forward to the first frame having the</span>
<span class="cm">			 * correct phase */</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">=</span> <span class="n">frame</span> <span class="o">+</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">-</span> <span class="n">frame</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">-</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">last_iso_frame</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">UHCI_NUMFRAMES</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">uhci_check_bandwidth</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>		<span class="cm">/* Can&#39;t change the period */</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Find the next unused frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_frame</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">lurb</span><span class="p">;</span>

			<span class="n">lurb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="n">lurb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">+</span>
					<span class="n">lurb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">*</span>
					<span class="n">lurb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ISO_ASAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Skip some frames if necessary to insure</span>
<span class="cm">			 * the start frame is in the future.</span>
<span class="cm">			 */</span>
			<span class="n">uhci_get_current_frame_number</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uhci_frame_before_eq</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">frame</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">frame</span> <span class="o">+=</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">-</span> <span class="n">frame</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>	<span class="cm">/* Otherwise pick up where the last URB leaves off */</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we won&#39;t have to go too far into the future */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci_frame_before_eq</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">last_iso_frame</span> <span class="o">+</span> <span class="n">UHCI_NUMFRAMES</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">*</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">TD_CTRL_ACTIVE</span> <span class="o">|</span> <span class="n">TD_CTRL_IOS</span><span class="p">;</span>
	<span class="n">destination</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">&amp;</span> <span class="n">PIPE_DEVEP_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">usb_packetid</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">uhci_alloc_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">uhci_add_td_to_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
		<span class="n">uhci_fill_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">destination</span> <span class="o">|</span>
				<span class="n">uhci_explen</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">),</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">+</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the interrupt-on-completion flag on the last packet. */</span>
	<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">TD_CTRL_IOC</span><span class="p">);</span>

	<span class="cm">/* Add the TDs to the frame list */</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci_insert_td_in_frame_list</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
		<span class="n">frame</span> <span class="o">+=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_packet_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_frame</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">skel</span> <span class="o">=</span> <span class="n">SKEL_ISO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">bandwidth_reserved</span><span class="p">)</span>
		<span class="n">uhci_reserve_bandwidth</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_result_isochronous</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrlstat</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">actlength</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">uhci_frame_before_eq</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">cur_iso_frame</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_frame</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

		<span class="n">uhci_remove_tds_from_frame</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_frame</span><span class="p">);</span>

		<span class="n">ctrlstat</span> <span class="o">=</span> <span class="n">td_status</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrlstat</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>	<span class="cm">/* TD was added too late? */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">uhci_map_status</span><span class="p">(</span><span class="n">uhci_status_bits</span><span class="p">(</span><span class="n">ctrlstat</span><span class="p">),</span>
					<span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">));</span>
			<span class="n">actlength</span> <span class="o">=</span> <span class="n">uhci_actual_length</span><span class="p">(</span><span class="n">ctrlstat</span><span class="p">);</span>

			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">actlength</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_packet_desc</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">actlength</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_packet_desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">uhci_remove_td_from_urbp</span><span class="p">(</span><span class="n">td</span><span class="p">);</span>
		<span class="n">uhci_free_td</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_frame</span> <span class="o">+=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
		<span class="o">++</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_packet_desc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span> <span class="o">=</span> <span class="n">hcd_to_uhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done_not_linked</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">urbp</span> <span class="o">=</span> <span class="n">uhci_alloc_urb_priv</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urbp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">)</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="n">uhci_alloc_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_qh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">urbp</span><span class="o">-&gt;</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_submit_control</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_submit_bulk</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_submit_interrupt</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci_submit_isochronous</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_submit_failed</span><span class="p">;</span>

	<span class="cm">/* Add this URB to the QH */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* If the new URB is the first and only one on this QH then either</span>
<span class="cm">	 * the QH is new and idle or else it&#39;s unlinked and waiting to</span>
<span class="cm">	 * become idle, so we can activate it right away.  But only if the</span>
<span class="cm">	 * queue isn&#39;t stopped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci_activate_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="n">uhci_urbp_wants_fsbr</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">err_submit_failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">)</span>
		<span class="n">uhci_make_qh_idle</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>	<span class="cm">/* Reclaim unused QH */</span>
<span class="nl">err_no_qh:</span>
	<span class="n">uhci_free_urb_priv</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
<span class="nl">done_not_linked:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span> <span class="o">=</span> <span class="n">hcd_to_uhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">;</span>

	<span class="cm">/* Remove Isochronous TDs from the frame list ASAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci_unlink_isochronous_tds</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">mb</span><span class="p">();</span>

		<span class="cm">/* If the URB has already started, update the QH unlink time */</span>
		<span class="n">uhci_get_current_frame_number</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uhci_frame_before_eq</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span><span class="p">,</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span><span class="p">))</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">unlink_frame</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uhci_unlink_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finish unlinking an URB and give it back</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_giveback_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Subtract off the length of the SETUP packet from</span>
<span class="cm">		 * urb-&gt;actual_length.</span>
<span class="cm">		 */</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">-=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* When giving back the first URB in an Isochronous queue,</span>
<span class="cm">	 * reinitialize the QH&#39;s iso-related members for the next URB. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span> <span class="o">&amp;&amp;</span>
			<span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">&amp;&amp;</span>
			<span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">nurb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_packet_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nurb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">iso_frame</span> <span class="o">=</span> <span class="n">nurb</span><span class="o">-&gt;</span><span class="n">start_frame</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Take the URB off the QH&#39;s queue.  If the queue is now empty,</span>
<span class="cm">	 * this is a perfect time for a toggle fixup. */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_fixup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
				<span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">initial_toggle</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_fixup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uhci_free_urb_priv</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">uhci_to_hcd</span><span class="p">(</span><span class="n">uhci</span><span class="p">),</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* If the queue is now empty, we can unlink the QH and give up its</span>
<span class="cm">	 * reserved bandwidth. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">uhci_unlink_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">bandwidth_reserved</span><span class="p">)</span>
			<span class="n">uhci_release_bandwidth</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan the URBs in a QH&#39;s queue</span>
<span class="cm"> */</span>
<span class="cp">#define QH_FINISHED_UNLINKING(qh)			\</span>
<span class="cp">		(qh-&gt;state == QH_STATE_UNLINKING &amp;&amp;	\</span>
<span class="cp">		uhci-&gt;frame_number + uhci-&gt;is_stopped != qh-&gt;unlink_frame)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_scan_qh</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">urbp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">uhci_result_isochronous</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">uhci_result_common</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Dequeued but completed URBs can&#39;t be given back unless</span>
<span class="cm">		 * the QH is stopped or has finished unlinking. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">QH_FINISHED_UNLINKING</span><span class="p">(</span><span class="n">qh</span><span class="p">))</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uhci_giveback_urb</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the QH is neither stopped nor finished unlinking (normal case),</span>
<span class="cm">	 * our work here is done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">QH_FINISHED_UNLINKING</span><span class="p">(</span><span class="n">qh</span><span class="p">))</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Otherwise give back each of the dequeued URBs */</span>
<span class="nl">restart:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">urbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Fix up the TD links and save the toggles for</span>
<span class="cm">			 * non-Isochronous queues.  For Isochronous queues,</span>
<span class="cm">			 * test for too-recent dequeues. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uhci_cleanup_queue</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">urb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">uhci_giveback_urb</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* There are no more dequeued URBs.  If there are still URBs on the</span>
<span class="cm">	 * queue, the QH can now be re-activated. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_fixup</span><span class="p">)</span>
			<span class="n">uhci_fixup_toggles</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* If the first URB on the queue wants FSBR but its time</span>
<span class="cm">		 * limit has expired, set the next TD to interrupt on</span>
<span class="cm">		 * completion before reactivating the QH. */</span>
		<span class="n">urbp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">fsbr</span> <span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">wait_expired</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

			<span class="n">td</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">TD_CTRL_IOC</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">uhci_activate_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The queue is empty.  The QH can become idle if it is fully</span>
<span class="cm">	 * unlinked. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">QH_FINISHED_UNLINKING</span><span class="p">(</span><span class="n">qh</span><span class="p">))</span>
		<span class="n">uhci_make_qh_idle</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for queues that have made some forward progress.</span>
<span class="cm"> * Returns 0 if the queue is not Isochronous, is ACTIVE, and</span>
<span class="cm"> * has not advanced since last examined; 1 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Early Intel controllers have a bug which causes qh-&gt;element sometimes</span>
<span class="cm"> * not to advance when a TD completes successfully.  The queue remains</span>
<span class="cm"> * stuck on the inactive completed TD.  We detect such cases and advance</span>
<span class="cm"> * the element pointer by hand.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uhci_advance_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Treat an UNLINKING queue as though it hasn&#39;t advanced.</span>
<span class="cm">	 * This is okay because reactivation will treat it as though</span>
<span class="cm">	 * it has advanced, and if it is going to become IDLE then</span>
<span class="cm">	 * this doesn&#39;t matter anyway.  Furthermore it&#39;s possible</span>
<span class="cm">	 * for an UNLINKING queue not to have any URBs at all, or</span>
<span class="cm">	 * for its first URB not to have any TDs (if it was dequeued</span>
<span class="cm">	 * just as it completed).  So it&#39;s not easy in any case to</span>
<span class="cm">	 * test whether such queues have advanced. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">urbp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">urbp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uhci_td</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">td_status</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_ACTIVE</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* We&#39;re okay, the queue has advanced */</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">wait_expired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">advance_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">is_stopped</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The queue hasn&#39;t advanced; check for timeout */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">wait_expired</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">advance_jiffies</span> <span class="o">+</span> <span class="n">QH_WAIT_TIMEOUT</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Detect the Intel bug and work around it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span> <span class="o">&amp;&amp;</span> <span class="n">qh_element</span><span class="p">(</span><span class="n">qh</span><span class="p">)</span> <span class="o">==</span>
			<span class="n">LINK_TO_TD</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">post_td</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">advance_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">wait_expired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* If the current URB wants FSBR, unlink it temporarily</span>
<span class="cm">		 * so that we can safely set the next TD to interrupt on</span>
<span class="cm">		 * completion.  That way we&#39;ll know as soon as the queue</span>
<span class="cm">		 * starts moving again. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urbp</span> <span class="o">&amp;&amp;</span> <span class="n">urbp</span><span class="o">-&gt;</span><span class="n">fsbr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TD_CTRL_IOC</span><span class="p">))</span>
			<span class="n">uhci_unlink_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Unmoving but not-yet-expired queues keep FSBR alive */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urbp</span><span class="p">)</span>
			<span class="n">uhci_urbp_wants_fsbr</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">urbp</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process events in the schedule, but only in one thread at a time</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uhci_scan_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">uhci_hcd</span> <span class="o">*</span><span class="n">uhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uhci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allow re-entrant calls */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">scan_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">need_rescan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">scan_in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">rescan:</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">need_rescan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_is_wanted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">uhci_clear_next_interrupt</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="n">uhci_get_current_frame_number</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">cur_iso_frame</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">frame_number</span><span class="p">;</span>

	<span class="cm">/* Go through all the QH queues and process the URBs in each one */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UHCI_NUM_SKELQH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skelqh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">qh</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skelqh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">next_qh</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">uhci_qh</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">uhci_advance_check</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">uhci_scan_qh</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">uhci_urbp_wants_fsbr</span><span class="p">(</span><span class="n">uhci</span><span class="p">,</span>
	<span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_priv</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">last_iso_frame</span> <span class="o">=</span> <span class="n">uhci</span><span class="o">-&gt;</span><span class="n">cur_iso_frame</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">need_rescan</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
	<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">scan_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_is_on</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_is_wanted</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_expiring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_expiring</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">fsbr_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">FSBR_OFF_DELAY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uhci</span><span class="o">-&gt;</span><span class="n">skel_unlink_qh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">))</span>
		<span class="n">uhci_clear_next_interrupt</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">uhci_set_next_interrupt</span><span class="p">(</span><span class="n">uhci</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
