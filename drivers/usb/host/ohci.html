<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › ohci.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ohci.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * OHCI HCD (Host Controller Driver) for USB.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 1999 Roman Weissgaerber &lt;weissg@vienna.at&gt;</span>
<span class="cm"> * (C) Copyright 2000-2002 David Brownell &lt;dbrownell@users.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licenced under the GPL.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * __hc32 and __hc16 are &quot;Host Controller&quot; types, they may be equivalent to</span>
<span class="cm"> * __leXX (normally) or __beXX (given OHCI_BIG_ENDIAN), depending on the</span>
<span class="cm"> * host controller implementation.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">__bitwise</span> <span class="n">__hc32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u16</span> <span class="n">__bitwise</span> <span class="n">__hc16</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * OHCI Endpoint Descriptor (ED) ... holds TD queue</span>
<span class="cm"> * See OHCI spec, section 4.2</span>
<span class="cm"> *</span>
<span class="cm"> * This is a &quot;Queue Head&quot; for those transfers, which is why</span>
<span class="cm"> * both EHCI and UHCI call similar structures a &quot;QH&quot;.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ed</span> <span class="p">{</span>
	<span class="cm">/* first fields are hardware-specified */</span>
	<span class="n">__hc32</span>			<span class="n">hwINFO</span><span class="p">;</span>      <span class="cm">/* endpoint config bitmap */</span>
	<span class="cm">/* info bits defined by hcd */</span>
<span class="cp">#define ED_DEQUEUE	(1 &lt;&lt; 27)</span>
	<span class="cm">/* info bits defined by the hardware */</span>
<span class="cp">#define ED_ISO		(1 &lt;&lt; 15)</span>
<span class="cp">#define ED_SKIP		(1 &lt;&lt; 14)</span>
<span class="cp">#define ED_LOWSPEED	(1 &lt;&lt; 13)</span>
<span class="cp">#define ED_OUT		(0x01 &lt;&lt; 11)</span>
<span class="cp">#define ED_IN		(0x02 &lt;&lt; 11)</span>
	<span class="n">__hc32</span>			<span class="n">hwTailP</span><span class="p">;</span>	<span class="cm">/* tail of TD list */</span>
	<span class="n">__hc32</span>			<span class="n">hwHeadP</span><span class="p">;</span>	<span class="cm">/* head of TD list (hc r/w) */</span>
<span class="cp">#define ED_C		(0x02)			</span><span class="cm">/* toggle carry */</span><span class="cp"></span>
<span class="cp">#define ED_H		(0x01)			</span><span class="cm">/* halted */</span><span class="cp"></span>
	<span class="n">__hc32</span>			<span class="n">hwNextED</span><span class="p">;</span>	<span class="cm">/* next ED in list */</span>

	<span class="cm">/* rest are purely for the driver&#39;s use */</span>
	<span class="n">dma_addr_t</span>		<span class="n">dma</span><span class="p">;</span>		<span class="cm">/* addr of ED */</span>
	<span class="k">struct</span> <span class="n">td</span>		<span class="o">*</span><span class="n">dummy</span><span class="p">;</span>		<span class="cm">/* next TD to activate */</span>

	<span class="cm">/* host&#39;s view of schedule */</span>
	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed_next</span><span class="p">;</span>	<span class="cm">/* on schedule or rm_list */</span>
	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed_prev</span><span class="p">;</span>	<span class="cm">/* for non-interrupt EDs */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">td_list</span><span class="p">;</span>	<span class="cm">/* &quot;shadow list&quot; of our TDs */</span>

	<span class="cm">/* create --&gt; IDLE --&gt; OPER --&gt; ... --&gt; IDLE --&gt; destroy</span>
<span class="cm">	 * usually:  OPER --&gt; UNLINK --&gt; (IDLE | OPER) --&gt; ...</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>			<span class="n">state</span><span class="p">;</span>		<span class="cm">/* ED_{IDLE,UNLINK,OPER} */</span>
<span class="cp">#define ED_IDLE		0x00		</span><span class="cm">/* NOT linked to HC */</span><span class="cp"></span>
<span class="cp">#define ED_UNLINK	0x01		</span><span class="cm">/* being unlinked from hc */</span><span class="cp"></span>
<span class="cp">#define ED_OPER		0x02		</span><span class="cm">/* IS linked to hc */</span><span class="cp"></span>

	<span class="n">u8</span>			<span class="n">type</span><span class="p">;</span>		<span class="cm">/* PIPE_{BULK,...} */</span>

	<span class="cm">/* periodic scheduling params (for intr and iso) */</span>
	<span class="n">u8</span>			<span class="n">branch</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">interval</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">load</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">last_iso</span><span class="p">;</span>	<span class="cm">/* iso only */</span>

	<span class="cm">/* HC may see EDs on rm_list until next frame (frame_no == tick) */</span>
	<span class="n">u16</span>			<span class="n">tick</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

<span class="cp">#define ED_MASK	((u32)~0x0f)		</span><span class="cm">/* strip hw status in low addr bits */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * OHCI Transfer Descriptor (TD) ... one per transfer segment</span>
<span class="cm"> * See OHCI spec, sections 4.3.1 (general = control/bulk/interrupt)</span>
<span class="cm"> * and 4.3.2 (iso)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">td</span> <span class="p">{</span>
	<span class="cm">/* first fields are hardware-specified */</span>
	<span class="n">__hc32</span>		<span class="n">hwINFO</span><span class="p">;</span>		<span class="cm">/* transfer info bitmask */</span>

	<span class="cm">/* hwINFO bits for both general and iso tds: */</span>
<span class="cp">#define TD_CC       0xf0000000			</span><span class="cm">/* condition code */</span><span class="cp"></span>
<span class="cp">#define TD_CC_GET(td_p) ((td_p &gt;&gt;28) &amp; 0x0f)</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><h1>define TD<em>CC</em>SET(td<em>p, cc) (td</em>p) = ((td_p) &amp; 0x0fffffff) | (((cc) &amp; 0x0f) &lt;&lt; 28)</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#define TD_DI       0x00E00000			</span><span class="cm">/* frames before interrupt */</span><span class="cp"></span>
<span class="cp">#define TD_DI_SET(X) (((X) &amp; 0x07)&lt;&lt; 21)</span>
	<span class="cm">/* these two bits are available for definition/use by HCDs in both</span>
<span class="cm">	 * general and iso tds ... others are available for only one type</span>
<span class="cm">	 */</span>
<span class="cp">#define TD_DONE     0x00020000			</span><span class="cm">/* retired to donelist */</span><span class="cp"></span>
<span class="cp">#define TD_ISO      0x00010000			</span><span class="cm">/* copy of ED_ISO */</span><span class="cp"></span>

	<span class="cm">/* hwINFO bits for general tds: */</span>
<span class="cp">#define TD_EC       0x0C000000			</span><span class="cm">/* error count */</span><span class="cp"></span>
<span class="cp">#define TD_T        0x03000000			</span><span class="cm">/* data toggle state */</span><span class="cp"></span>
<span class="cp">#define TD_T_DATA0  0x02000000				</span><span class="cm">/* DATA0 */</span><span class="cp"></span>
<span class="cp">#define TD_T_DATA1  0x03000000				</span><span class="cm">/* DATA1 */</span><span class="cp"></span>
<span class="cp">#define TD_T_TOGGLE 0x00000000				</span><span class="cm">/* uses ED_C */</span><span class="cp"></span>
<span class="cp">#define TD_DP       0x00180000			</span><span class="cm">/* direction/pid */</span><span class="cp"></span>
<span class="cp">#define TD_DP_SETUP 0x00000000			</span><span class="cm">/* SETUP pid */</span><span class="cp"></span>
<span class="cp">#define TD_DP_IN    0x00100000				</span><span class="cm">/* IN pid */</span><span class="cp"></span>
<span class="cp">#define TD_DP_OUT   0x00080000				</span><span class="cm">/* OUT pid */</span><span class="cp"></span>
							<span class="cm">/* 0x00180000 rsvd */</span>
<span class="cp">#define TD_R        0x00040000			</span><span class="cm">/* round: short packets OK? */</span><span class="cp"></span>

	<span class="cm">/* (no hwINFO #defines yet for iso tds) */</span>

	<span class="n">__hc32</span>		<span class="n">hwCBP</span><span class="p">;</span>		<span class="cm">/* Current Buffer Pointer (or 0) */</span>
	<span class="n">__hc32</span>		<span class="n">hwNextTD</span><span class="p">;</span>	<span class="cm">/* Next TD Pointer */</span>
	<span class="n">__hc32</span>		<span class="n">hwBE</span><span class="p">;</span>		<span class="cm">/* Memory Buffer End Pointer */</span>

	<span class="cm">/* PSW is only for ISO.  Only 1 PSW entry is used, but on</span>
<span class="cm">	 * big-endian PPC hardware that&#39;s the second entry.</span>
<span class="cm">	 */</span>
<span class="cp">#define MAXPSW	2</span>
	<span class="n">__hc16</span>		<span class="n">hwPSW</span> <span class="p">[</span><span class="n">MAXPSW</span><span class="p">];</span>

	<span class="cm">/* rest are purely for the driver&#39;s use */</span>
	<span class="n">__u8</span>		<span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ed</span>	<span class="o">*</span><span class="n">ed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">td</span>	<span class="o">*</span><span class="n">td_hash</span><span class="p">;</span>	<span class="cm">/* dma--&gt;td hashtable */</span>
	<span class="k">struct</span> <span class="n">td</span>	<span class="o">*</span><span class="n">next_dl_td</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="n">dma_addr_t</span>	<span class="n">td_dma</span><span class="p">;</span>		<span class="cm">/* addr of this TD */</span>
	<span class="n">dma_addr_t</span>	<span class="n">data_dma</span><span class="p">;</span>	<span class="cm">/* addr of data it points to */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">td_list</span><span class="p">;</span>	<span class="cm">/* &quot;shadow list&quot;, TDs on same ED */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>	<span class="cm">/* c/b/i need 16; only iso needs 32 */</span>

<span class="cp">#define TD_MASK	((u32)~0x1f)		</span><span class="cm">/* strip hw status in low addr bits */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Hardware transfer status codes -- CC from td-&gt;hwINFO or td-&gt;hwPSW</span>
<span class="cm"> */</span>
<span class="cp">#define TD_CC_NOERROR      0x00</span>
<span class="cp">#define TD_CC_CRC          0x01</span>
<span class="cp">#define TD_CC_BITSTUFFING  0x02</span>
<span class="cp">#define TD_CC_DATATOGGLEM  0x03</span>
<span class="cp">#define TD_CC_STALL        0x04</span>
<span class="cp">#define TD_DEVNOTRESP      0x05</span>
<span class="cp">#define TD_PIDCHECKFAIL    0x06</span>
<span class="cp">#define TD_UNEXPECTEDPID   0x07</span>
<span class="cp">#define TD_DATAOVERRUN     0x08</span>
<span class="cp">#define TD_DATAUNDERRUN    0x09</span>
    <span class="cm">/* 0x0A, 0x0B reserved for hardware */</span>
<span class="cp">#define TD_BUFFEROVERRUN   0x0C</span>
<span class="cp">#define TD_BUFFERUNDERRUN  0x0D</span>
    <span class="cm">/* 0x0E, 0x0F reserved for HCD */</span>
<span class="cp">#define TD_NOTACCESSED     0x0F</span>


<span class="cm">/* map OHCI TD status codes (CC) to errno values */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cc_to_error</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* No  Error  */</span>               <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* CRC Error  */</span>               <span class="o">-</span><span class="n">EILSEQ</span><span class="p">,</span>
	<span class="cm">/* Bit Stuff  */</span>               <span class="o">-</span><span class="n">EPROTO</span><span class="p">,</span>
	<span class="cm">/* Data Togg  */</span>               <span class="o">-</span><span class="n">EILSEQ</span><span class="p">,</span>
	<span class="cm">/* Stall      */</span>               <span class="o">-</span><span class="n">EPIPE</span><span class="p">,</span>
	<span class="cm">/* DevNotResp */</span>               <span class="o">-</span><span class="n">ETIME</span><span class="p">,</span>
	<span class="cm">/* PIDCheck   */</span>               <span class="o">-</span><span class="n">EPROTO</span><span class="p">,</span>
	<span class="cm">/* UnExpPID   */</span>               <span class="o">-</span><span class="n">EPROTO</span><span class="p">,</span>
	<span class="cm">/* DataOver   */</span>               <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">,</span>
	<span class="cm">/* DataUnder  */</span>               <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">,</span>
	<span class="cm">/* (for hw)   */</span>               <span class="o">-</span><span class="n">EIO</span><span class="p">,</span>
	<span class="cm">/* (for hw)   */</span>               <span class="o">-</span><span class="n">EIO</span><span class="p">,</span>
	<span class="cm">/* BufferOver */</span>               <span class="o">-</span><span class="n">ECOMM</span><span class="p">,</span>
	<span class="cm">/* BuffUnder  */</span>               <span class="o">-</span><span class="n">ENOSR</span><span class="p">,</span>
	<span class="cm">/* (for HCD)  */</span>               <span class="o">-</span><span class="n">EALREADY</span><span class="p">,</span>
	<span class="cm">/* (for HCD)  */</span>               <span class="o">-</span><span class="n">EALREADY</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * The HCCA (Host Controller Communications Area) is a 256 byte</span>
<span class="cm"> * structure defined section 4.4.1 of the OHCI spec. The HC is</span>
<span class="cm"> * told the base address of it.  It must be 256-byte aligned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ohci_hcca</span> <span class="p">{</span>
<span class="cp">#define NUM_INTS 32</span>
	<span class="n">__hc32</span>	<span class="n">int_table</span> <span class="p">[</span><span class="n">NUM_INTS</span><span class="p">];</span>	<span class="cm">/* periodic schedule */</span>

	<span class="cm">/*</span>
<span class="cm">	 * OHCI defines u16 frame_no, followed by u16 zero pad.</span>
<span class="cm">	 * Since some processors can&#39;t do 16 bit bus accesses,</span>
<span class="cm">	 * portable access must be a 32 bits wide.</span>
<span class="cm">	 */</span>
	<span class="n">__hc32</span>	<span class="n">frame_no</span><span class="p">;</span>		<span class="cm">/* current frame number */</span>
	<span class="n">__hc32</span>	<span class="n">done_head</span><span class="p">;</span>		<span class="cm">/* info returned for an interrupt */</span>
	<span class="n">u8</span>	<span class="n">reserved_for_hc</span> <span class="p">[</span><span class="mi">116</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">what</span> <span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* spec only identifies 252 bytes :) */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">256</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * This is the structure of the OHCI controller&#39;s memory mapped I/O region.</span>
<span class="cm"> * You must use readl() and writel() (in &lt;asm/io.h&gt;) to access these fields!!</span>
<span class="cm"> * Layout is in section 7 (and appendix B) of the spec.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ohci_regs</span> <span class="p">{</span>
	<span class="cm">/* control and status registers (section 7.1) */</span>
	<span class="n">__hc32</span>	<span class="n">revision</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">control</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">cmdstatus</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">intrstatus</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">intrenable</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">intrdisable</span><span class="p">;</span>

	<span class="cm">/* memory pointers (section 7.2) */</span>
	<span class="n">__hc32</span>	<span class="n">hcca</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">ed_periodcurrent</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">ed_controlhead</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">ed_controlcurrent</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">ed_bulkhead</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">ed_bulkcurrent</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">donehead</span><span class="p">;</span>

	<span class="cm">/* frame counters (section 7.3) */</span>
	<span class="n">__hc32</span>	<span class="n">fminterval</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">fmremaining</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">fmnumber</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">periodicstart</span><span class="p">;</span>
	<span class="n">__hc32</span>	<span class="n">lsthresh</span><span class="p">;</span>

	<span class="cm">/* Root hub ports (section 7.4) */</span>
	<span class="k">struct</span>	<span class="n">ohci_roothub_regs</span> <span class="p">{</span>
		<span class="n">__hc32</span>	<span class="n">a</span><span class="p">;</span>
		<span class="n">__hc32</span>	<span class="n">b</span><span class="p">;</span>
		<span class="n">__hc32</span>	<span class="n">status</span><span class="p">;</span>
<span class="cp">#define MAX_ROOT_PORTS	15	</span><span class="cm">/* maximum OHCI root hub ports (RH_A_NDP) */</span><span class="cp"></span>
		<span class="n">__hc32</span>	<span class="n">portstatus</span> <span class="p">[</span><span class="n">MAX_ROOT_PORTS</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">roothub</span><span class="p">;</span>

	<span class="cm">/* and optional &quot;legacy support&quot; registers (appendix B) at 0x0100 */</span>

<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>


<span class="cm">/* OHCI CONTROL AND STATUS REGISTER MASKS */</span>

<span class="cm">/*</span>
<span class="cm"> * HcControl (control) register masks</span>
<span class="cm"> */</span>
<span class="cp">#define OHCI_CTRL_CBSR	(3 &lt;&lt; 0)	</span><span class="cm">/* control/bulk service ratio */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_PLE	(1 &lt;&lt; 2)	</span><span class="cm">/* periodic list enable */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_IE	(1 &lt;&lt; 3)	</span><span class="cm">/* isochronous enable */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_CLE	(1 &lt;&lt; 4)	</span><span class="cm">/* control list enable */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_BLE	(1 &lt;&lt; 5)	</span><span class="cm">/* bulk list enable */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_HCFS	(3 &lt;&lt; 6)	</span><span class="cm">/* host controller functional state */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_IR	(1 &lt;&lt; 8)	</span><span class="cm">/* interrupt routing */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_RWC	(1 &lt;&lt; 9)	</span><span class="cm">/* remote wakeup connected */</span><span class="cp"></span>
<span class="cp">#define OHCI_CTRL_RWE	(1 &lt;&lt; 10)	</span><span class="cm">/* remote wakeup enable */</span><span class="cp"></span>

<span class="cm">/* pre-shifted values for HCFS */</span>
<span class="cp">#	define OHCI_USB_RESET	(0 &lt;&lt; 6)</span>
<span class="cp">#	define OHCI_USB_RESUME	(1 &lt;&lt; 6)</span>
<span class="cp">#	define OHCI_USB_OPER	(2 &lt;&lt; 6)</span>
<span class="cp">#	define OHCI_USB_SUSPEND	(3 &lt;&lt; 6)</span>

<span class="cm">/*</span>
<span class="cm"> * HcCommandStatus (cmdstatus) register masks</span>
<span class="cm"> */</span>
<span class="cp">#define OHCI_HCR	(1 &lt;&lt; 0)	</span><span class="cm">/* host controller reset */</span><span class="cp"></span>
<span class="cp">#define OHCI_CLF	(1 &lt;&lt; 1)	</span><span class="cm">/* control list filled */</span><span class="cp"></span>
<span class="cp">#define OHCI_BLF	(1 &lt;&lt; 2)	</span><span class="cm">/* bulk list filled */</span><span class="cp"></span>
<span class="cp">#define OHCI_OCR	(1 &lt;&lt; 3)	</span><span class="cm">/* ownership change request */</span><span class="cp"></span>
<span class="cp">#define OHCI_SOC	(3 &lt;&lt; 16)	</span><span class="cm">/* scheduling overrun count */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * masks used with interrupt registers:</span>
<span class="cm"> * HcInterruptStatus (intrstatus)</span>
<span class="cm"> * HcInterruptEnable (intrenable)</span>
<span class="cm"> * HcInterruptDisable (intrdisable)</span>
<span class="cm"> */</span>
<span class="cp">#define OHCI_INTR_SO	(1 &lt;&lt; 0)	</span><span class="cm">/* scheduling overrun */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_WDH	(1 &lt;&lt; 1)	</span><span class="cm">/* writeback of done_head */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_SF	(1 &lt;&lt; 2)	</span><span class="cm">/* start frame */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_RD	(1 &lt;&lt; 3)	</span><span class="cm">/* resume detect */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_UE	(1 &lt;&lt; 4)	</span><span class="cm">/* unrecoverable error */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_FNO	(1 &lt;&lt; 5)	</span><span class="cm">/* frame number overflow */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_RHSC	(1 &lt;&lt; 6)	</span><span class="cm">/* root hub status change */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_OC	(1 &lt;&lt; 30)	</span><span class="cm">/* ownership change */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_MIE	(1 &lt;&lt; 31)	</span><span class="cm">/* master interrupt enable */</span><span class="cp"></span>


<span class="cm">/* OHCI ROOT HUB REGISTER MASKS */</span>

<span class="cm">/* roothub.portstatus [i] bits */</span>
<span class="cp">#define RH_PS_CCS            0x00000001		</span><span class="cm">/* current connect status */</span><span class="cp"></span>
<span class="cp">#define RH_PS_PES            0x00000002		</span><span class="cm">/* port enable status*/</span><span class="cp"></span>
<span class="cp">#define RH_PS_PSS            0x00000004		</span><span class="cm">/* port suspend status */</span><span class="cp"></span>
<span class="cp">#define RH_PS_POCI           0x00000008		</span><span class="cm">/* port over current indicator */</span><span class="cp"></span>
<span class="cp">#define RH_PS_PRS            0x00000010		</span><span class="cm">/* port reset status */</span><span class="cp"></span>
<span class="cp">#define RH_PS_PPS            0x00000100		</span><span class="cm">/* port power status */</span><span class="cp"></span>
<span class="cp">#define RH_PS_LSDA           0x00000200		</span><span class="cm">/* low speed device attached */</span><span class="cp"></span>
<span class="cp">#define RH_PS_CSC            0x00010000		</span><span class="cm">/* connect status change */</span><span class="cp"></span>
<span class="cp">#define RH_PS_PESC           0x00020000		</span><span class="cm">/* port enable status change */</span><span class="cp"></span>
<span class="cp">#define RH_PS_PSSC           0x00040000		</span><span class="cm">/* port suspend status change */</span><span class="cp"></span>
<span class="cp">#define RH_PS_OCIC           0x00080000		</span><span class="cm">/* over current indicator change */</span><span class="cp"></span>
<span class="cp">#define RH_PS_PRSC           0x00100000		</span><span class="cm">/* port reset status change */</span><span class="cp"></span>

<span class="cm">/* roothub.status bits */</span>
<span class="cp">#define RH_HS_LPS	     0x00000001		</span><span class="cm">/* local power status */</span><span class="cp"></span>
<span class="cp">#define RH_HS_OCI	     0x00000002		</span><span class="cm">/* over current indicator */</span><span class="cp"></span>
<span class="cp">#define RH_HS_DRWE	     0x00008000		</span><span class="cm">/* device remote wakeup enable */</span><span class="cp"></span>
<span class="cp">#define RH_HS_LPSC	     0x00010000		</span><span class="cm">/* local power status change */</span><span class="cp"></span>
<span class="cp">#define RH_HS_OCIC	     0x00020000		</span><span class="cm">/* over current indicator change */</span><span class="cp"></span>
<span class="cp">#define RH_HS_CRWE	     0x80000000		</span><span class="cm">/* clear remote wakeup enable */</span><span class="cp"></span>

<span class="cm">/* roothub.b masks */</span>
<span class="cp">#define RH_B_DR		0x0000ffff		</span><span class="cm">/* device removable flags */</span><span class="cp"></span>
<span class="cp">#define RH_B_PPCM	0xffff0000		</span><span class="cm">/* port power control mask */</span><span class="cp"></span>

<span class="cm">/* roothub.a masks */</span>
<span class="cp">#define	RH_A_NDP	(0xff &lt;&lt; 0)		</span><span class="cm">/* number of downstream ports */</span><span class="cp"></span>
<span class="cp">#define	RH_A_PSM	(1 &lt;&lt; 8)		</span><span class="cm">/* power switching mode */</span><span class="cp"></span>
<span class="cp">#define	RH_A_NPS	(1 &lt;&lt; 9)		</span><span class="cm">/* no power switching */</span><span class="cp"></span>
<span class="cp">#define	RH_A_DT		(1 &lt;&lt; 10)		</span><span class="cm">/* device type (mbz) */</span><span class="cp"></span>
<span class="cp">#define	RH_A_OCPM	(1 &lt;&lt; 11)		</span><span class="cm">/* over current protection mode */</span><span class="cp"></span>
<span class="cp">#define	RH_A_NOCP	(1 &lt;&lt; 12)		</span><span class="cm">/* no over current protection */</span><span class="cp"></span>
<span class="cp">#define	RH_A_POTPGT	(0xff &lt;&lt; 24)		</span><span class="cm">/* power on to power good time */</span><span class="cp"></span>


<span class="cm">/* hcd-private per-urb state */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">urb_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">length</span><span class="p">;</span>		<span class="c1">// # tds in this request</span>
	<span class="n">u16</span>			<span class="n">td_cnt</span><span class="p">;</span>		<span class="c1">// tds already serviced</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">td</span>		<span class="o">*</span><span class="n">td</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// all TDs in this request</span>

<span class="p">}</span> <span class="n">urb_priv_t</span><span class="p">;</span>

<span class="cp">#define TD_HASH_SIZE    64    </span><span class="cm">/* power&#39;o&#39;two */</span><span class="cp"></span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>sizeof (struct td) ~= 64 == 2^6 ...</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define TD_HASH_FUNC(td_dma) ((td_dma ^ (td_dma &gt;&gt; 6)) % TD_HASH_SIZE)</span>


<span class="cm">/*</span>
<span class="cm"> * This is the full ohci controller description</span>
<span class="cm"> *</span>
<span class="cm"> * Note how the &quot;proper&quot; USB information is just</span>
<span class="cm"> * a subset of what the full implementation needs. (Linus)</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">ohci_rh_state</span> <span class="p">{</span>
	<span class="n">OHCI_RH_HALTED</span><span class="p">,</span>
	<span class="n">OHCI_RH_SUSPENDED</span><span class="p">,</span>
	<span class="n">OHCI_RH_RUNNING</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * I/O memory used to communicate with the HC (dma-consistent)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ohci_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * main memory used to communicate with the HC (dma-consistent).</span>
<span class="cm">	 * hcd adds to schedule for a live hc any time, but removals finish</span>
<span class="cm">	 * only at the start of the next frame.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ohci_hcca</span>	<span class="o">*</span><span class="n">hcca</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">hcca_dma</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed_rm_list</span><span class="p">;</span>		<span class="cm">/* to be removed */</span>

	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed_bulktail</span><span class="p">;</span>		<span class="cm">/* last in bulk list */</span>
	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed_controltail</span><span class="p">;</span>	<span class="cm">/* last in ctrl list */</span>
	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">periodic</span> <span class="p">[</span><span class="n">NUM_INTS</span><span class="p">];</span>	<span class="cm">/* shadow int_table */</span>

	<span class="cm">/*</span>
<span class="cm">	 * OTG controllers and transceivers need software interaction;</span>
<span class="cm">	 * other external transceivers should be software-transparent</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">usb_phy</span>	<span class="o">*</span><span class="n">transceiver</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">start_hnp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * memory management for queue data structures</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">td_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">ed_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">td</span>		<span class="o">*</span><span class="n">td_hash</span> <span class="p">[</span><span class="n">TD_HASH_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pending</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * driver state</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">ohci_rh_state</span>	<span class="n">rh_state</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_ports</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">load</span> <span class="p">[</span><span class="n">NUM_INTS</span><span class="p">];</span>
	<span class="n">u32</span>			<span class="n">hc_control</span><span class="p">;</span>	<span class="cm">/* copy of hc control reg */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">next_statechange</span><span class="p">;</span>	<span class="cm">/* suspend/resume */</span>
	<span class="n">u32</span>			<span class="n">fminterval</span><span class="p">;</span>		<span class="cm">/* saved register */</span>
	<span class="kt">unsigned</span>		<span class="n">autostop</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* rh auto stopping/stopped */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* for HC bugs */</span>
<span class="cp">#define	OHCI_QUIRK_AMD756	0x01			</span><span class="cm">/* erratum #4 */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_SUPERIO	0x02			</span><span class="cm">/* natsemi */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_INITRESET	0x04			</span><span class="cm">/* SiS, OPTi, ... */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_BE_DESC	0x08			</span><span class="cm">/* BE descriptors */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_BE_MMIO	0x10			</span><span class="cm">/* BE registers */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_ZFMICRO	0x20			</span><span class="cm">/* Compaq ZFMicro chipset*/</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_NEC		0x40			</span><span class="cm">/* lost interrupts */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_FRAME_NO	0x80			</span><span class="cm">/* no big endian frame_no shift */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_HUB_POWER	0x100			</span><span class="cm">/* distrust firmware power/oc setup */</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_AMD_PLL	0x200			</span><span class="cm">/* AMD PLL quirk*/</span><span class="cp"></span>
<span class="cp">#define	OHCI_QUIRK_AMD_PREFETCH	0x400			</span><span class="cm">/* pre-fetch for ISO transfer */</span><span class="cp"></span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>there are also chip quirks/bugs in init logic</p></td><td class="code"><div class="highlight"><pre>	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">nec_work</span><span class="p">;</span>	<span class="cm">/* Worker for NEC quirk */</span>

	<span class="cm">/* Needed for ZF Micro quirk */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">unlink_watchdog</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">eds_scheduled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed_to_check</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">zf_delay</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">debug_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">debug_async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">debug_periodic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">debug_registers</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_nec</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_NEC</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_zfmicro</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_ZFMICRO</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_amdiso</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_AMD_PLL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_amdprefetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_AMD_PREFETCH</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_nec</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_zfmicro</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_amdiso</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">quirk_amdprefetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* convert between an hcd pointer and the corresponding ohci_hcd */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="nf">hcd_to_ohci</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">ohci_to_hcd</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ohci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifndef DEBUG</span>
<span class="cp">#define STUB_DEBUG_FILES</span>
<span class="cp">#endif	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cp">#define ohci_dbg(ohci, fmt, args...) \</span>
<span class="cp">	dev_dbg (ohci_to_hcd(ohci)-&gt;self.controller , fmt , ## args )</span>
<span class="cp">#define ohci_err(ohci, fmt, args...) \</span>
<span class="cp">	dev_err (ohci_to_hcd(ohci)-&gt;self.controller , fmt , ## args )</span>
<span class="cp">#define ohci_info(ohci, fmt, args...) \</span>
<span class="cp">	dev_info (ohci_to_hcd(ohci)-&gt;self.controller , fmt , ## args )</span>
<span class="cp">#define ohci_warn(ohci, fmt, args...) \</span>
<span class="cp">	dev_warn (ohci_to_hcd(ohci)-&gt;self.controller , fmt , ## args )</span>

<span class="cp">#ifdef OHCI_VERBOSE_DEBUG</span>
<span class="cp">#	define ohci_vdbg ohci_dbg</span>
<span class="cp">#else</span>
<span class="cp">#	define ohci_vdbg(ohci, fmt, args...) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * While most USB host controllers implement their registers and</span>
<span class="cm"> * in-memory communication descriptors in little-endian format,</span>
<span class="cm"> * a minority (notably the IBM STB04XXX and the Motorola MPC5200</span>
<span class="cm"> * processors) implement them in big endian format.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition some more exotic implementations like the Toshiba</span>
<span class="cm"> * Spider (aka SCC) cell southbridge are &quot;mixed&quot; endian, that is,</span>
<span class="cm"> * they have a different endianness for registers vs. in-memory</span>
<span class="cm"> * descriptors.</span>
<span class="cm"> *</span>
<span class="cm"> * This attempts to support either format at compile time without a</span>
<span class="cm"> * runtime penalty, or both formats with the additional overhead</span>
<span class="cm"> * of checking a flag bit.</span>
<span class="cm"> *</span>
<span class="cm"> * That leads to some tricky Kconfig rules howevber. There are</span>
<span class="cm"> * different defaults based on some arch/ppc platforms, though</span>
<span class="cm"> * the basic rules are:</span>
<span class="cm"> *</span>
<span class="cm"> * Controller type              Kconfig options needed</span>
<span class="cm"> * ---------------              ----------------------</span>
<span class="cm"> * little endian                CONFIG_USB_OHCI_LITTLE_ENDIAN</span>
<span class="cm"> *</span>
<span class="cm"> * fully big endian             CONFIG_USB_OHCI_BIG_ENDIAN_DESC _and_</span>
<span class="cm"> *                              CONFIG_USB_OHCI_BIG_ENDIAN_MMIO</span>
<span class="cm"> *</span>
<span class="cm"> * mixed endian                 CONFIG_USB_OHCI_LITTLE_ENDIAN _and_</span>
<span class="cm"> *                              CONFIG_USB_OHCI_BIG_ENDIAN_{MMIO,DESC}</span>
<span class="cm"> *</span>
<span class="cm"> * (If you have a mixed endian controller, you -must- also define</span>
<span class="cm"> * CONFIG_USB_OHCI_LITTLE_ENDIAN or things will not work when building</span>
<span class="cm"> * both your mixed endian and a fully big endian controller support in</span>
<span class="cm"> * the same kernel image).</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_DESC</span>
<span class="cp">#ifdef CONFIG_USB_OHCI_LITTLE_ENDIAN</span>
<span class="cp">#define big_endian_desc(ohci)	(ohci-&gt;flags &amp; OHCI_QUIRK_BE_DESC)</span>
<span class="cp">#else</span>
<span class="cp">#define big_endian_desc(ohci)	1		</span><span class="cm">/* only big endian */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cp">#define big_endian_desc(ohci)	0		</span><span class="cm">/* only little endian */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO</span>
<span class="cp">#ifdef CONFIG_USB_OHCI_LITTLE_ENDIAN</span>
<span class="cp">#define big_endian_mmio(ohci)	(ohci-&gt;flags &amp; OHCI_QUIRK_BE_MMIO)</span>
<span class="cp">#else</span>
<span class="cp">#define big_endian_mmio(ohci)	1		</span><span class="cm">/* only big endian */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cp">#define big_endian_mmio(ohci)	0		</span><span class="cm">/* only little endian */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Big-endian read/write functions are arch-specific.</span>
<span class="cm"> * Other arches can be added if/when they&#39;re needed.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">_ohci_readl</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
					<span class="n">__hc32</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">return</span> <span class="n">big_endian_mmio</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">readl_be</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">readl</span> <span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">readl</span> <span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_ohci_writel</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">__hc32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO</span>
	<span class="n">big_endian_mmio</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">writel_be</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">writel</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">writel</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define ohci_readl(o,r)		_ohci_readl(o,r)</span>
<span class="cp">#define ohci_writel(o,v,r)	_ohci_writel(o,v,r)</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* cpu to ohci */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc16</span> <span class="nf">cpu_to_hc16</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">__force</span> <span class="n">__hc16</span><span class="p">)</span><span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">__force</span> <span class="n">__hc16</span><span class="p">)</span><span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc16</span> <span class="nf">cpu_to_hc16p</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">cpu_to_be16p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">cpu_to_le16p</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc32</span> <span class="nf">cpu_to_hc32</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">__force</span> <span class="n">__hc32</span><span class="p">)</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">__force</span> <span class="n">__hc32</span><span class="p">)</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc32</span> <span class="nf">cpu_to_hc32p</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">cpu_to_be32p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">cpu_to_le32p</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ohci to cpu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">hc16_to_cpu</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc16</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">be16_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be16</span><span class="p">)</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">le16_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le16</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">hc16_to_cpup</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc16</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">be16_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpu</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">be32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span><span class="p">)</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">le32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpup</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">be32_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">le32_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* HCCA frame number is 16 bits, but is accessed as 32 bits since not all</span>
<span class="cm"> * hardware handles 16 bit reads.  That creates a different confusion on</span>
<span class="cm"> * some big-endian SOC implementations.  Same thing happens with PSW access.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PPC_MPC52xx</span>
<span class="cp">#define big_endian_frame_no_quirk(ohci)	(ohci-&gt;flags &amp; OHCI_QUIRK_FRAME_NO)</span>
<span class="cp">#else</span>
<span class="cp">#define big_endian_frame_no_quirk(ohci)	0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ohci_frame_no</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="o">-&gt;</span><span class="n">frame_no</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">big_endian_frame_no_quirk</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span>
			<span class="n">tmp</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">le32_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="o">-&gt;</span><span class="n">frame_no</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc16</span> <span class="o">*</span><span class="nf">ohci_hwPSWp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__hc16</span> <span class="o">*</span><span class="p">)(</span><span class="n">big_endian_desc</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">hwPSW</span><span class="p">[</span><span class="n">index</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">hwPSW</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ohci_hwPSW</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
                               <span class="k">const</span> <span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">td</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hc16_to_cpup</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ohci_hwPSWp</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">index</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define	FI			0x2edf		</span><span class="cm">/* 12000 bits per frame (-1) */</span><span class="cp"></span>
<span class="cp">#define	FSMP(fi)		(0x7fff &amp; ((6 * ((fi) - 210)) / 7))</span>
<span class="cp">#define	FIT			(1 &lt;&lt; 31)</span>
<span class="cp">#define LSTHRESH		0x628		</span><span class="cm">/* lowspeed bit threshold */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">periodic_reinit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">fi</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span> <span class="o">&amp;</span> <span class="mh">0x03fff</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">fit</span> <span class="o">=</span> <span class="n">ohci_readl</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FIT</span><span class="p">;</span>

	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="p">(</span><span class="n">fit</span> <span class="o">^</span> <span class="n">FIT</span><span class="p">)</span> <span class="o">|</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">);</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="p">((</span><span class="mi">9</span> <span class="o">*</span> <span class="n">fi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">periodicstart</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* AMD-756 (D2 rev) reports corrupt register contents in some cases.</span>
<span class="cm"> * The erratum (#4) description is incorrect.  AMD&#39;s workaround waits</span>
<span class="cm"> * till some bits (mostly reserved) are clear; ok for all revs.</span>
<span class="cm"> */</span>
<span class="cp">#define read_roothub(hc, register, mask) ({ \</span>
<span class="cp">	u32 temp = ohci_readl (hc, &amp;hc-&gt;regs-&gt;roothub.register); \</span>
<span class="cp">	if (temp == -1) \</span>
<span class="cp">		hc-&gt;rh_state = OHCI_RH_HALTED; \</span>
<span class="cp">	else if (hc-&gt;flags &amp; OHCI_QUIRK_AMD756) \</span>
<span class="cp">		while (temp &amp; mask) \</span>
<span class="cp">			temp = ohci_readl (hc, &amp;hc-&gt;regs-&gt;roothub.register); \</span>
<span class="cp">	temp; })</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">roothub_a</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">hc</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">return</span> <span class="n">read_roothub</span> <span class="p">(</span><span class="n">hc</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mh">0xfc0fe000</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">roothub_b</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">hc</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">return</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">hc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hc</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">roothub</span><span class="p">.</span><span class="n">b</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">roothub_status</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">hc</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">return</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">hc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hc</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">roothub</span><span class="p">.</span><span class="n">status</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">roothub_portstatus</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">hc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">return</span> <span class="n">read_roothub</span> <span class="p">(</span><span class="n">hc</span><span class="p">,</span> <span class="n">portstatus</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mh">0xffe0fce0</span><span class="p">);</span> <span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
