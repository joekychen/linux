<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › ehci-hcd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ehci-hcd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Enhanced Host Controller Interface (EHCI) driver for USB.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintainer: Alan Stern &lt;stern@rowland.harvard.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2004 by David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#if defined(CONFIG_PPC_PS3)</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI hc_driver implementation ... experimental, incomplete.</span>
<span class="cm"> * Based on the final 1.0 register interface specification.</span>
<span class="cm"> *</span>
<span class="cm"> * USB 2.0 shows up in upcoming www.pcmcia.org technology.</span>
<span class="cm"> * First was PCMCIA, like ISA; then CardBus, which is PCI.</span>
<span class="cm"> * Next comes &quot;CardBay&quot;, using USB 2.0 signals.</span>
<span class="cm"> *</span>
<span class="cm"> * Contains additional contributions by Brad Hards, Rory Bolt, and others.</span>
<span class="cm"> * Special thanks to Intel and VIA for providing host controllers to</span>
<span class="cm"> * test this driver on, and Cypress (including In-System Design) for</span>
<span class="cm"> * providing early devices for those host controllers to talk to!</span>
<span class="cm"> */</span>

<span class="cp">#define DRIVER_AUTHOR &quot;David Brownell&quot;</span>
<span class="cp">#define DRIVER_DESC &quot;USB 2.0 &#39;Enhanced&#39; Host Controller (EHCI) Driver&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span>	<span class="n">hcd_name</span> <span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ehci_hcd&quot;</span><span class="p">;</span>


<span class="cp">#undef VERBOSE_DEBUG</span>
<span class="cp">#undef EHCI_URB_TRACE</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define EHCI_STATS</span>
<span class="cp">#endif</span>

<span class="cm">/* magic numbers that can affect system performance */</span>
<span class="cp">#define	EHCI_TUNE_CERR		3	</span><span class="cm">/* 0-3 qtd retries; 0 == don&#39;t stop */</span><span class="cp"></span>
<span class="cp">#define	EHCI_TUNE_RL_HS		4	</span><span class="cm">/* nak throttle; see 4.9 */</span><span class="cp"></span>
<span class="cp">#define	EHCI_TUNE_RL_TT		0</span>
<span class="cp">#define	EHCI_TUNE_MULT_HS	1	</span><span class="cm">/* 1-3 transactions/uframe; 4.10.3 */</span><span class="cp"></span>
<span class="cp">#define	EHCI_TUNE_MULT_TT	1</span>
<span class="cm">/*</span>
<span class="cm"> * Some drivers think it&#39;s safe to schedule isochronous transfers more than</span>
<span class="cm"> * 256 ms into the future (partly as a result of an old bug in the scheduling</span>
<span class="cm"> * code).  In an attempt to avoid trouble, we will use a minimum scheduling</span>
<span class="cm"> * length of 512 frames instead of 256.</span>
<span class="cm"> */</span>
<span class="cp">#define	EHCI_TUNE_FLS		1	</span><span class="cm">/* (medium) 512-frame schedule */</span><span class="cp"></span>

<span class="cp">#define EHCI_IAA_MSECS		10		</span><span class="cm">/* arbitrary */</span><span class="cp"></span>
<span class="cp">#define EHCI_IO_JIFFIES		(HZ/10)		</span><span class="cm">/* io watchdog &gt; irq_thresh */</span><span class="cp"></span>
<span class="cp">#define EHCI_ASYNC_JIFFIES	(HZ/20)		</span><span class="cm">/* async idle timeout */</span><span class="cp"></span>
<span class="cp">#define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)</span>
						<span class="cm">/* 5-ms async qh unlink delay */</span>

<span class="cm">/* Initial IRQ latency:  faster than hw default */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">log2_irq_thresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="c1">// 0 to 6</span>
<span class="n">module_param</span> <span class="p">(</span><span class="n">log2_irq_thresh</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span> <span class="p">(</span><span class="n">log2_irq_thresh</span><span class="p">,</span> <span class="s">&quot;log2 IRQ latency, 1-64 microframes&quot;</span><span class="p">);</span>

<span class="cm">/* initial park setting:  slower than hw default */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">park</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span> <span class="p">(</span><span class="n">park</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span> <span class="p">(</span><span class="n">park</span><span class="p">,</span> <span class="s">&quot;park setting; 1-3 back-to-back async packets&quot;</span><span class="p">);</span>

<span class="cm">/* for flakey hardware, ignore overcurrent indicators */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">ignore_oc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span> <span class="p">(</span><span class="n">ignore_oc</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span> <span class="p">(</span><span class="n">ignore_oc</span><span class="p">,</span> <span class="s">&quot;ignore bogus hardware overcurrent indications&quot;</span><span class="p">);</span>

<span class="cm">/* for link power management(LPM) feature */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hird</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hird</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hird</span><span class="p">,</span> <span class="s">&quot;host initiated resume duration, +1 for each 75us&quot;</span><span class="p">);</span>

<span class="cp">#define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#include &quot;ehci.h&quot;</span>
<span class="cp">#include &quot;ehci-dbg.c&quot;</span>
<span class="cp">#include &quot;pci-quirks.h&quot;</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">timer_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ehci_timer_action</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t override timeouts which shrink or (later) disable</span>
<span class="cm">	 * the async ring; just the I/O watchdog.  Note that if a</span>
<span class="cm">	 * SHRINK were pending, OFF would never be requested.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">BIT</span><span class="p">(</span><span class="n">TIMER_ASYNC_SHRINK</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="n">TIMER_ASYNC_OFF</span><span class="p">))</span>
				<span class="o">&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">actions</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">actions</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TIMER_IO_WATCHDOG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">need_io_watchdog</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">EHCI_IO_JIFFIES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TIMER_ASYNC_OFF</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">EHCI_ASYNC_JIFFIES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* case TIMER_ASYNC_SHRINK: */</span>
		<span class="nl">default:</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">EHCI_SHRINK_JIFFIES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * handshake - spin reading hc until handshake completes or fails</span>
<span class="cm"> * @ptr: address of hc register to be read</span>
<span class="cm"> * @mask: bits to look at in result of read</span>
<span class="cm"> * @done: value of those bits when handshake succeeds</span>
<span class="cm"> * @usec: timeout in microseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative errno, or zero on success</span>
<span class="cm"> *</span>
<span class="cm"> * Success happens when the &quot;mask&quot; bits have the specified value (hardware</span>
<span class="cm"> * handshake done).  There are two failure modes:  &quot;usec&quot; have passed (major</span>
<span class="cm"> * hardware flakeout), or the register reads as all-ones (hardware removed).</span>
<span class="cm"> *</span>
<span class="cm"> * That last failure should_only happen in cases like physical cardbus eject</span>
<span class="cm"> * before driver shutdown. But it also seems to be caused by bugs in cardbus</span>
<span class="cm"> * bridge shutdown:  shutting down the bridge before the devices using it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">result</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>		<span class="cm">/* card removed */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">usec</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">usec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check TDI/ARC silicon is in host mode */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tdi_in_host_mode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">reg_ptr</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">tmp</span><span class="p">;</span>

	<span class="n">reg_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(((</span><span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="o">+</span> <span class="n">USBMODE</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">reg_ptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">USBMODE_CM_HC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* force HC to halt state from unknown (EHCI spec section 2.3) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_halt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* disable any irqs left enabled by previous code */</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_is_TDI</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tdi_in_host_mode</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">STS_HALT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This routine gets called during probe before ehci-&gt;command</span>
<span class="cm">	 * has been initialized, so we can&#39;t rely on its value.</span>
<span class="cm">	 */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_RUN</span> <span class="o">|</span> <span class="n">CMD_IAAD</span><span class="p">);</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">handshake</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
			  <span class="n">STS_HALT</span><span class="p">,</span> <span class="n">STS_HALT</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_USB_SUSPEND) &amp;&amp; defined(CONFIG_PPC_PS3)</span>

<span class="cm">/*</span>
<span class="cm"> * The EHCI controller of the Cell Super Companion Chip used in the</span>
<span class="cm"> * PS3 will stop the root hub after all root hub ports are suspended.</span>
<span class="cm"> * When in this condition handshake will return -ETIMEDOUT.  The</span>
<span class="cm"> * STS_HLT bit will not be set, so inspection of the frame index is</span>
<span class="cm"> * used here to test for the condition.  If the condition is found</span>
<span class="cm"> * return success to allow the USB suspend to complete.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake_for_broken_root_hub</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_PS3_LV1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="n">old_index</span> <span class="o">=</span> <span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">usec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span> <span class="o">&amp;&amp;</span> <span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake_for_broken_root_hub</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake_on_error_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">usec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">handshake_for_broken_root_hub</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span>
						      <span class="n">usec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">EHCI_RH_HALTED</span><span class="p">;</span>
		<span class="n">ehci_err</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;force halt; handshake %p %08x %08x -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* put TDI/ARC silicon into EHCI mode */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tdi_reset</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">reg_ptr</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">tmp</span><span class="p">;</span>

	<span class="n">reg_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(((</span><span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="o">+</span> <span class="n">USBMODE</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">reg_ptr</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USBMODE_CM_HC</span><span class="p">;</span>
	<span class="cm">/* The default byte access to MMR space is LE after</span>
<span class="cm">	 * controller reset. Set the required endian mode</span>
<span class="cm">	 * for transfer buffers to match the host microprocessor</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_big_endian_mmio</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">USBMODE_BE</span><span class="p">;</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">reg_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* reset a non-running (STS_HALT == 1) controller */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_reset</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">command</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/* If the EHCI debug controller is active, special care must be</span>
<span class="cm">	 * taken before and after a host controller reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">debug</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dbgp_reset_prep</span><span class="p">())</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">debug</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RESET</span><span class="p">;</span>
	<span class="n">dbg_cmd</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">EHCI_RH_HALTED</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span>
			    <span class="n">CMD_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">has_hostpc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">USBMODE_EX_HC</span> <span class="o">|</span> <span class="n">USBMODE_EX_VBPS</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="o">+</span> <span class="n">USBMODE_EX</span><span class="p">));</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TXFIFO_DEFAULT</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="o">+</span> <span class="n">TXFILLTUNING</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_is_TDI</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span>
		<span class="n">tdi_reset</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">dbgp_external_startup</span><span class="p">();</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">port_c_suspend</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">suspended_ports</span> <span class="o">=</span>
			<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">resuming_ports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* idle the controller (from running) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_quiesce</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">temp</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span>
		<span class="n">BUG</span> <span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* wait for any schedule enables/disables to take effect */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STS_ASS</span> <span class="o">|</span> <span class="n">STS_PSS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handshake_on_error_set_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
					<span class="n">STS_ASS</span> <span class="o">|</span> <span class="n">STS_PSS</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">125</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* then disable anything that&#39;s still active */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_ASE</span> <span class="o">|</span> <span class="n">CMD_PSE</span><span class="p">);</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/* hardware can take 16 microframes to turn off ... */</span>
	<span class="n">handshake_on_error_set_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
				    <span class="n">STS_ASS</span> <span class="o">|</span> <span class="n">STS_PSS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">end_unlink_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ehci_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">);</span>

<span class="cp">#include &quot;ehci-hub.c&quot;</span>
<span class="cp">#include &quot;ehci-lpm.c&quot;</span>
<span class="cp">#include &quot;ehci-mem.c&quot;</span>
<span class="cp">#include &quot;ehci-q.c&quot;</span>
<span class="cp">#include &quot;ehci-sched.c&quot;</span>
<span class="cp">#include &quot;ehci-sysfs.c&quot;</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_iaa_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Lost IAA irqs wedge things badly; seen first with a vt8235.</span>
<span class="cm">	 * So we need this watchdog, but must protect it against both</span>
<span class="cm">	 * (a) SMP races against real IAA firing and retriggering, and</span>
<span class="cm">	 * (b) clean HC shutdown, when IAA watchdog was pending.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

		<span class="cm">/* If we get here, IAA is *REALLY* late.  It&#39;s barely</span>
<span class="cm">		 * conceivable that the system is so busy that CMD_IAAD</span>
<span class="cm">		 * is still legitimately set, so let&#39;s be sure it&#39;s</span>
<span class="cm">		 * clear before we read STS_IAA.  (The HC should clear</span>
<span class="cm">		 * CMD_IAAD when it sets STS_IAA.)</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

		<span class="cm">/* If IAA is set here it either legitimately triggered</span>
<span class="cm">		 * before we cleared IAAD above (but _way_ late, so we&#39;ll</span>
<span class="cm">		 * still count it as lost) ... or a silicon erratum:</span>
<span class="cm">		 * - VIA seems to set IAA without triggering the IRQ;</span>
<span class="cm">		 * - IAAD potentially cleared without setting IAA.</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_IAA</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">CMD_IAAD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">COUNT</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lost_iaa</span><span class="p">);</span>
			<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">STS_IAA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ehci_vdbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;IAA watchdog: status %x cmd %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">end_unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* stop async processing after it&#39;s idled a bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">TIMER_ASYNC_OFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">actions</span><span class="p">))</span>
		<span class="n">start_unlink_async</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">);</span>

	<span class="cm">/* ehci could run by timer, without IRQs ... */</span>
	<span class="n">ehci_work</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* On some systems, leaving remote wakeup enabled prevents system shutdown.</span>
<span class="cm"> * The firmware seems to think that powering off is a wakeup event!</span>
<span class="cm"> * This routine turns off remote wakeup and everything else, on all ports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_turn_off_all_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">port</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">port</span><span class="o">--</span><span class="p">)</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">PORT_RWC_BITS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Halt HC, turn off all ports, and let the BIOS use the companion controllers.</span>
<span class="cm"> * Should be called with ehci-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_silence_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ehci_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">ehci_turn_off_all_ports</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="cm">/* make BIOS/etc use companion controller during reboot */</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>

	<span class="cm">/* unblock posted writes */</span>
	<span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).</span>
<span class="cm"> * This forcibly disables dma and IRQs, helping kexec and other cases</span>
<span class="cm"> * where the next system software may expect clean state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>	<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ehci_silence_controller</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_port_power</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCS_PPC</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;...power%s ports...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">is_on</span> <span class="o">?</span> <span class="s">&quot;up&quot;</span> <span class="o">:</span> <span class="s">&quot;down&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span> <span class="n">port</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ehci_hub_control</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span>
				<span class="n">is_on</span> <span class="o">?</span> <span class="n">SetPortFeature</span> <span class="o">:</span> <span class="n">ClearPortFeature</span><span class="p">,</span>
				<span class="n">USB_PORT_FEAT_POWER</span><span class="p">,</span>
				<span class="n">port</span><span class="o">--</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Flush those writes */</span>
	<span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * ehci_work is called from some interrupts, timers, and so on.</span>
<span class="cm"> * it calls driver completion functions, after dropping ehci-&gt;lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_work</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer_action_done</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">);</span>

	<span class="cm">/* another CPU may drop ehci-&gt;lock during a schedule scan while</span>
<span class="cm">	 * it reports urb completions.  this flag guards against bogus</span>
<span class="cm">	 * attempts at re-entrant schedule scanning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">scanning</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">scanning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scan_async</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">scan_periodic</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">scanning</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the IO watchdog guards against hardware or driver bugs that</span>
<span class="cm">	 * misplace IRQs, and should let us run completely without IRQs.</span>
<span class="cm">	 * such lossage has been observed on both VT6202 and VT8235.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
			 <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_sched</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">timer_action</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when the ehci_hcd module is removed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_stop</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;stop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* no more interrupts ... */</span>
	<span class="n">del_timer_sync</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span>
		<span class="n">ehci_quiesce</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="n">ehci_silence_controller</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">ehci_reset</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">remove_sysfs_files</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">remove_debug_files</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="cm">/* root hub is shut down separately (first, when possible) */</span>
	<span class="n">spin_lock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">)</span>
		<span class="n">ehci_work</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ehci_mem_cleanup</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">amd_pll_fix</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">usb_amd_dev_put</span><span class="p">();</span>

<span class="cp">#ifdef	EHCI_STATS</span>
	<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;irq normal %ld err %ld reclaim %ld (lost %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">error</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">reclaim</span><span class="p">,</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lost_iaa</span><span class="p">);</span>
	<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;complete %ld unlink %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">complete</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unlink</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">dbg_status</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;ehci_stop completed&quot;</span><span class="p">,</span>
		    <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* one-time init, only for memory state */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">hcc_params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * keep io watchdog by default, those good HCDs could turn off it later</span>
<span class="cm">	 */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">need_io_watchdog</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ehci_watchdog</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ehci</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ehci_iaa_watchdog</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ehci</span><span class="p">;</span>

	<span class="n">hcc_params</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * by default set standard 80% (== 100 usec/uframe) max periodic</span>
<span class="cm">	 * bandwidth as required by USB 2.0</span>
<span class="cm">	 */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">uframe_periodic_max</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * hw default: 1K periodic list heads, one per frame.</span>
<span class="cm">	 * periodic_size can shrink by USBCMD update if hcc_params allows.</span>
<span class="cm">	 */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">=</span> <span class="n">DEFAULT_I_TDPS</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">cached_itd_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">cached_sitd_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_PGM_FRAMELISTLEN</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* periodic schedule size can be smaller than default */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">EHCI_TUNE_FLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>: <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>	<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">ehci_mem_init</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* controllers may cache some of the periodic schedule ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_ISOC_CACHE</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span>		<span class="c1">// full frame cache</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">i_thresh</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span>					<span class="c1">// N microframes cached</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">i_thresh</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">HCC_ISOC_THRES</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">);</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">clock_frame</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * dedicate a qh for the async ring head, since we couldn&#39;t unlink</span>
<span class="cm">	 * a &#39;real&#39; qh without stopping the async schedule [4.8].  use it</span>
<span class="cm">	 * as the &#39;reclamation list head&#39; too.</span>
<span class="cm">	 * its dummy is used in hw_alt_next of many tds, to prevent the qh</span>
<span class="cm">	 * from automatically advancing to the next td after short reads.</span>
<span class="cm">	 */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hw</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QH_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QH_HEAD</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_PPC_PS3)</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">));</span>	<span class="cm">/* I = 1 */</span>
<span class="cp">#endif</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QTD_STS_HALT</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_qtd_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_LINKED</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>

	<span class="cm">/* clear interrupt enables, set irq latency */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log2_irq_thresh</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">log2_irq_thresh</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">log2_irq_thresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">log2_irq_thresh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_PER_PORT_CHANGE_EVENT</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">has_ppcd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;enable per-port change event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">CMD_PPCEE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_CANPARK</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* HW default park == 3, on hardware that supports it (like</span>
<span class="cm">		 * NVidia and ALI silicon), maximizes throughput on the async</span>
<span class="cm">		 * schedule by avoiding QH fetches between transfers.</span>
<span class="cm">		 *</span>
<span class="cm">		 * With fast usb storage devices and NForce2, &quot;park&quot; seems to</span>
<span class="cm">		 * make problems:  throughput reduction (!), data errors...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">park</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">park</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">park</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">CMD_PARK</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">park</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;park %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">park</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_PGM_FRAMELISTLEN</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* periodic schedule size can be smaller than default */</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_FLS</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_LPM</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* support link power management EHCI 1.1 addendum */</span>
		<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;support lpm</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">has_lpm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hird</span> <span class="o">&gt;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;hird %d invalid, use default 0&quot;</span><span class="p">,</span>
			<span class="n">hird</span><span class="p">);</span>
			<span class="n">hird</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">hird</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* Accept arbitrarily long scatter-gather lists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HCD_LOCAL_MEM</span><span class="p">))</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* start HC running; it&#39;s halted, ehci_init() has been run (once) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_run</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">temp</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">hcc_params</span><span class="p">;</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* EHCI spec section 4.1 */</span>

	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_list</span><span class="p">);</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">async_next</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * hcc_params controls whether ehci-&gt;regs-&gt;segment must (!!!)</span>
<span class="cm">	 * be used; it constrains QH/ITD/SITD and QTD locations.</span>
<span class="cm">	 * pci_pool consistent memory always uses segment zero.</span>
<span class="cm">	 * streaming mappings for I/O buffers, like pci_map_single(),</span>
<span class="cm">	 * can return segments above 4GB, if the device allows.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  the dma mask is visible through dma_supported(), so</span>
<span class="cm">	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,</span>
<span class="cm">	 * Scsi_Host.highmem_io, and so forth.  It&#39;s readonly to all</span>
<span class="cm">	 * host side drivers though.</span>
<span class="cm">	 */</span>
	<span class="n">hcc_params</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_64BIT_ADDR</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>this is deeply broken on almost all architectures</p></td><td class="code"><div class="highlight"><pre><span class="c">		if (!dma_set_mask(hcd-&gt;self.controller, DMA_BIT_MASK(64)))</span>
<span class="c">			ehci_info(ehci, &quot;enabled 64bit DMA\n&quot;);</span>
<span class="cp">#endif</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Philips, Intel, and maybe others need CMD_RUN before the
root hub will detect new devices (why?); NEC doesn't</p></td><td class="code"><div class="highlight"><pre>	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_LRESET</span><span class="o">|</span><span class="n">CMD_IAAD</span><span class="o">|</span><span class="n">CMD_PSE</span><span class="o">|</span><span class="n">CMD_ASE</span><span class="o">|</span><span class="n">CMD_RESET</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">dbg_cmd</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;init&quot;</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices</span>
<span class="cm">	 * are explicitly handed to companion controller(s), so no TT is</span>
<span class="cm">	 * involved with the root hub.  (Except where one is integrated,</span>
<span class="cm">	 * and there&#39;s no companion controller unless maybe for USB OTG.)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Turning on the CF flag will transfer ownership of all ports</span>
<span class="cm">	 * from the companions to the EHCI controller.  If any of the</span>
<span class="cm">	 * companions are in the middle of a port reset at the time, it</span>
<span class="cm">	 * could cause trouble.  Write-locking ehci_cf_port_reset_rwsem</span>
<span class="cm">	 * guarantees that no resets are in progress.  After we set CF,</span>
<span class="cm">	 * a short delay lets the hardware catch up; new resets shouldn&#39;t</span>
<span class="cm">	 * be started before the port switching actions could complete.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">;</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">FLAG_CF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>
	<span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>	<span class="cm">/* unblock posted writes */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">last_periodic_enable</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">HC_VERSION</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">));</span>
	<span class="n">ehci_info</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
		<span class="s">&quot;USB %x.%x started, EHCI %x.%02x%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">((</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">sbrn</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">sbrn</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">),</span>
		<span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>
		<span class="n">ignore_oc</span> <span class="o">?</span> <span class="s">&quot;, overcurrent ignored&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">INTR_MASK</span><span class="p">,</span>
		    <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span> <span class="cm">/* Turn On Interrupts */</span>

	<span class="cm">/* GRR this is run-once init(), being done every time the HC starts.</span>
<span class="cm">	 * So long as they&#39;re part of class devices, we can&#39;t do it init()</span>
<span class="cm">	 * since the class device isn&#39;t created that early.</span>
<span class="cm">	 */</span>
	<span class="n">create_debug_files</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">create_sysfs_files</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="nf">ehci_setup</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">+</span>
	    <span class="n">HC_LENGTH</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">));</span>
	<span class="n">dbg_hcs_params</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">);</span>
	<span class="n">dbg_hcc_params</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">);</span>

	<span class="cm">/* cache this readonly data; minimize chip reads */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">hcs_params</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">sbrn</span> <span class="o">=</span> <span class="n">HCD_USB2</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">ehci_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* data structure init */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ehci_init</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">ehci_reset</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ehci_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">status</span><span class="p">,</span> <span class="n">masked_status</span><span class="p">,</span> <span class="n">pcd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bh</span><span class="p">;</span>

	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* e.g. cardbus physical eject */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;device removed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dead</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t use STS_FLR, but some controllers don&#39;t like it to</span>
<span class="cm">	 * remain on, so mask it out along with the other status bits.</span>
<span class="cm">	 */</span>
	<span class="n">masked_status</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_MASK</span> <span class="o">|</span> <span class="n">STS_FLR</span><span class="p">);</span>

	<span class="cm">/* Shared IRQ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">masked_status</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_HALTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear (just) interrupts */</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">masked_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef	VERBOSE_DEBUG</span>
	<span class="cm">/* unrequested/ignored: Frame List Rollover */</span>
	<span class="n">dbg_status</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;irq&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* INT, ERR, and IAA interrupt rates can be throttled */</span>

	<span class="cm">/* normal [4.15.1.2] or error [4.15.1.1] completion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STS_INT</span><span class="o">|</span><span class="n">STS_ERR</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_ERR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">COUNT</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">COUNT</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">error</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* complete the unlinking of some qh [4.15.2.3] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_IAA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* guard against (alleged) silicon errata */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">CMD_IAAD</span><span class="p">)</span>
			<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;IAA with IAAD still set?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">COUNT</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">reclaim</span><span class="p">);</span>
			<span class="n">end_unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;IAA with nothing to reclaim?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remote wakeup [4.3.1] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_PCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">i</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
		<span class="n">u32</span>		<span class="n">ppcd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* kick root hub later */</span>
		<span class="n">pcd_status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

		<span class="cm">/* resume root hub? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_SUSPENDED</span><span class="p">)</span>
			<span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

		<span class="cm">/* get per-port change detect bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">has_ppcd</span><span class="p">)</span>
			<span class="n">ppcd</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">pstatus</span><span class="p">;</span>

			<span class="cm">/* leverage per-port change bits feature */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">has_ppcd</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ppcd</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">pstatus</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pstatus</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">suspended_ports</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">((</span><span class="n">pstatus</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span> <span class="o">||</span>
						<span class="o">!</span><span class="p">(</span><span class="n">pstatus</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">pstatus</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* start 20 msec resume signaling from this port,</span>
<span class="cm">			 * and make khubd collect PORT_STAT_C_SUSPEND to</span>
<span class="cm">			 * stop that signaling.  Use 5 ms extra for safety,</span>
<span class="cm">			 * like usb_port_resume() does.</span>
<span class="cm">			 */</span>
			<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">resuming_ports</span><span class="p">);</span>
			<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;port %d remote wakeup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* PCI errors [4.15.2.4] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_FATAL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_err</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;fatal error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dbg_cmd</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;fatal&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">dbg_status</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;fatal&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">ehci_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
<span class="nl">dead:</span>
		<span class="n">ehci_reset</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>
		<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="cm">/* generic layer kills/unlinks all urbs, then</span>
<span class="cm">		 * uses ehci_stop to clean up the rest</span>
<span class="cm">		 */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">ehci_work</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcd_status</span><span class="p">)</span>
		<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * non-error returns are a promise to giveback() the urb later</span>
<span class="cm"> * we drop ownership so next owner (or urb unlink) can get it</span>
<span class="cm"> *</span>
<span class="cm"> * urb + dev is in hcd.self.controller.urb_list</span>
<span class="cm"> * we&#39;re queueing TDs onto software and hardware lists</span>
<span class="cm"> *</span>
<span class="cm"> * hcd-specific init for hcpriv hasn&#39;t been done yet</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  control, bulk, and interrupt share the same code to append TDs</span>
<span class="cm"> * to a (possibly active) QH, and the same QH scanning code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_urb_enqueue</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>	<span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span>		<span class="n">mem_flags</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">qtd_list</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">usb_pipetype</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PIPE_CONTROL</span>:
		<span class="cm">/* qh_completions() code doesn&#39;t handle all the fault cases</span>
<span class="cm">		 * in multi-TD control transfers.  Even 1KB is rare anyway.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="cm">/* case PIPE_BULK: */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh_urb_transaction</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">submit_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PIPE_INTERRUPT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh_urb_transaction</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">intr_submit</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PIPE_ISOCHRONOUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">itd_submit</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">sitd_submit</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_async</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* failfast */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span>
		<span class="n">end_unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="cm">/* If the QH isn&#39;t linked then there&#39;s nothing we can do</span>
<span class="cm">	 * unless we were called during a giveback, in which case</span>
<span class="cm">	 * qh_completions() has to deal with it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_LINKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_COMPLETING</span><span class="p">)</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* defer till later if busy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">last</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">last</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
				<span class="n">last</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
				<span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_UNLINK_WAIT</span><span class="p">;</span>
		<span class="n">last</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>

	<span class="cm">/* start IAA cycle */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">start_unlink_async</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* remove from hardware lists</span>
<span class="cm"> * completions normally happen asynchronously</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">usb_pipetype</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>case PIPE<em>CONTROL:
case PIPE</em>BULK:</p></td><td class="code"><div class="highlight"><pre>	<span class="nl">default:</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">QH_STATE_LINKED</span>:
		<span class="k">case</span> <span class="n">QH_STATE_COMPLETING</span>:
			<span class="n">unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">QH_STATE_UNLINK</span>:
		<span class="k">case</span> <span class="n">QH_STATE_UNLINK_WAIT</span>:
			<span class="cm">/* already started */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">QH_STATE_IDLE</span>:
			<span class="cm">/* QH might be waiting for a Clear-TT-Buffer */</span>
			<span class="n">qh_completions</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PIPE_INTERRUPT</span>:
		<span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">QH_STATE_LINKED</span>:
		<span class="k">case</span> <span class="n">QH_STATE_COMPLETING</span>:
			<span class="n">intr_deschedule</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">QH_STATE_IDLE</span>:
			<span class="n">qh_completions</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;bogus qh %p state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PIPE_ISOCHRONOUS</span>:</pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>itd or sitd ...</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>wait till next completion, do it then.
completion irqs can wait up to 1024 msec,</p></td><td class="code"><div class="highlight"><pre>		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>bulk qh holds the data toggle</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">ehci_endpoint_disable</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* ASSERT:  any requests/urbs are being unlinked */</span>
	<span class="cm">/* ASSERT:  nobody can be submitting urbs for this any more */</span>

<span class="nl">rescan:</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* endpoints can be iso streams.  for now, we don&#39;t</span>
<span class="cm">	 * accelerate iso completions ... so spin a while.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_vdbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;iso delay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">idle_timeout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">QH_STATE_LINKED</span>:
	<span class="k">case</span> <span class="n">QH_STATE_COMPLETING</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">qh</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* periodic qh self-unlinks on empty, and a COMPLETING qh</span>
<span class="cm">		 * may already be unlinked.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="n">unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="cm">/* FALL THROUGH */</span>
	<span class="k">case</span> <span class="n">QH_STATE_UNLINK</span>:		<span class="cm">/* wait for hw to finish? */</span>
	<span class="k">case</span> <span class="n">QH_STATE_UNLINK_WAIT</span>:
<span class="nl">idle_timeout:</span>
		<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">QH_STATE_IDLE</span>:		<span class="cm">/* fully unlinked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">clearing_tt</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">idle_timeout</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qh_put</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* else FALL THROUGH */</span>
	<span class="nl">default:</span>
		<span class="cm">/* caller was supposed to have unlinked any requests;</span>
<span class="cm">		 * that&#39;s not our job.  just leak this memory.</span>
<span class="cm">		 */</span>
		<span class="n">ehci_err</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;qh %p (#%02x) state %d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">qh</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">,</span>
			<span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;(has tds)&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ehci_endpoint_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">eptype</span> <span class="o">=</span> <span class="n">usb_endpoint_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">epnum</span> <span class="o">=</span> <span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">is_out</span> <span class="o">=</span> <span class="n">usb_endpoint_dir_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eptype</span> <span class="o">!=</span> <span class="n">USB_ENDPOINT_XFER_BULK</span> <span class="o">&amp;&amp;</span> <span class="n">eptype</span> <span class="o">!=</span> <span class="n">USB_ENDPOINT_XFER_INT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="cm">/* For Bulk and Interrupt endpoints we maintain the toggle state</span>
<span class="cm">	 * in the hardware; the toggle bits in udev aren&#39;t used at all.</span>
<span class="cm">	 * When an endpoint is reset by usb_clear_halt() we must reset</span>
<span class="cm">	 * the toggle bit in the QH.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">is_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clear_halt for a busy endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_LINKED</span> <span class="o">||</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_COMPLETING</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* The toggle value in the QH can&#39;t be updated</span>
<span class="cm">			 * while the QH is active.  Unlink it now;</span>
<span class="cm">			 * re-linking will call qh_refresh().</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eptype</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_BULK</span><span class="p">)</span>
				<span class="n">unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">intr_deschedule</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_get_frame</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * The EHCI in ChipIdea HDRC cannot be a separate module or device,</span>
<span class="cm"> * because its registers (and irq) are shared between host/gadget/otg</span>
<span class="cm"> * functions  and in order to facilitate role switching we cannot</span>
<span class="cm"> * give the ehci driver exclusive access to those.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CHIPIDEA_EHCI</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span> <span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span> <span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cp">#include &quot;ehci-pci.c&quot;</span>
<span class="cp">#define	PCI_DRIVER		ehci_pci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_FSL</span>
<span class="cp">#include &quot;ehci-fsl.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ehci_fsl_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_MXC</span>
<span class="cp">#include &quot;ehci-mxc.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_mxc_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_SH</span>
<span class="cp">#include &quot;ehci-sh.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_hcd_sh_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MIPS_ALCHEMY</span>
<span class="cp">#include &quot;ehci-au1xxx.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_HCD_OMAP</span>
<span class="cp">#include &quot;ehci-omap.c&quot;</span>
<span class="cp">#define        PLATFORM_DRIVER         ehci_hcd_omap_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC_PS3</span>
<span class="cp">#include &quot;ehci-ps3.c&quot;</span>
<span class="cp">#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_HCD_PPC_OF</span>
<span class="cp">#include &quot;ehci-ppc-of.c&quot;</span>
<span class="cp">#define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_XPS_USB_HCD_XILINX</span>
<span class="cp">#include &quot;ehci-xilinx-of.c&quot;</span>
<span class="cp">#define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PLAT_ORION</span>
<span class="cp">#include &quot;ehci-orion.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ehci_orion_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_IXP4XX</span>
<span class="cp">#include &quot;ehci-ixp4xx.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ixp4xx_ehci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_W90X900_EHCI</span>
<span class="cp">#include &quot;ehci-w90x900.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_AT91</span>
<span class="cp">#include &quot;ehci-atmel.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ehci_atmel_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OCTEON_EHCI</span>
<span class="cp">#include &quot;ehci-octeon.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_octeon_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_CNS3XXX_EHCI</span>
<span class="cp">#include &quot;ehci-cns3xxx.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		cns3xxx_ehci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_VT8500</span>
<span class="cp">#include &quot;ehci-vt8500.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		vt8500_ehci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PLAT_SPEAR</span>
<span class="cp">#include &quot;ehci-spear.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		spear_ehci_hcd_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_MSM</span>
<span class="cp">#include &quot;ehci-msm.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_msm_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_HCD_PMC_MSP</span>
<span class="cp">#include &quot;ehci-pmcmsp.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ehci_hcd_msp_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_TEGRA</span>
<span class="cp">#include &quot;ehci-tegra.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		tegra_ehci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_S5P</span>
<span class="cp">#include &quot;ehci-s5p.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		s5p_ehci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SPARC_LEON</span>
<span class="cp">#include &quot;ehci-grlib.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_grlib_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CPU_XLR</span>
<span class="cp">#include &quot;ehci-xls.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_xls_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_MV</span>
<span class="cp">#include &quot;ehci-mv.c&quot;</span>
<span class="cp">#define        PLATFORM_DRIVER         ehci_mv_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MACH_LOONGSON1</span>
<span class="cp">#include &quot;ehci-ls1x.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_ls1x_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MIPS_SEAD3</span>
<span class="cp">#include &quot;ehci-sead3.c&quot;</span>
<span class="cp">#define	PLATFORM_DRIVER		ehci_hcd_sead3_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_HCD_PLATFORM</span>
<span class="cp">#include &quot;ehci-platform.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ehci_platform_driver</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(PCI_DRIVER) &amp;&amp; !defined(PLATFORM_DRIVER) &amp;&amp; \</span>
<span class="cp">    !defined(PS3_SYSTEM_BUS_DRIVER) &amp;&amp; !defined(OF_PLATFORM_DRIVER) &amp;&amp; \</span>
<span class="cp">    !defined(XILINX_OF_PLATFORM_DRIVER)</span>
<span class="cp">#error &quot;missing bus glue for ehci-hcd&quot;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ehci_hcd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: &quot;</span> <span class="n">DRIVER_DESC</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hcd_name</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">USB_EHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">USB_UHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">USB_OHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Warning! ehci_hcd should always be loaded&quot;</span>
				<span class="s">&quot; before uhci_hcd and ohci_hcd, not after</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">hcd_name</span><span class="p">,</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">),</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_itd</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_sitd</span><span class="p">));</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">ehci_debug_root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;ehci&quot;</span><span class="p">,</span> <span class="n">usb_debug_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci_debug_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_debug</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PLATFORM_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PLATFORM_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clean0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PCI_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PCI_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clean1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PS3_SYSTEM_BUS_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ps3_ehci_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PS3_SYSTEM_BUS_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clean2</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef OF_PLATFORM_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OF_PLATFORM_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clean3</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef XILINX_OF_PLATFORM_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">XILINX_OF_PLATFORM_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clean4</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="cp">#ifdef XILINX_OF_PLATFORM_DRIVER</span>
	<span class="cm">/* platform_driver_unregister(&amp;XILINX_OF_PLATFORM_DRIVER); */</span>
<span class="nl">clean4:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef OF_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OF_PLATFORM_DRIVER</span><span class="p">);</span>
<span class="nl">clean3:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PS3_SYSTEM_BUS_DRIVER</span>
	<span class="n">ps3_ehci_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PS3_SYSTEM_BUS_DRIVER</span><span class="p">);</span>
<span class="nl">clean2:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PCI_DRIVER</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PCI_DRIVER</span><span class="p">);</span>
<span class="nl">clean1:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PLATFORM_DRIVER</span><span class="p">);</span>
<span class="nl">clean0:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">ehci_debug_root</span><span class="p">);</span>
	<span class="n">ehci_debug_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err_debug:</span>
<span class="cp">#endif</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">USB_EHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ehci_hcd_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ehci_hcd_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef XILINX_OF_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">XILINX_OF_PLATFORM_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef OF_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OF_PLATFORM_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PLATFORM_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PCI_DRIVER</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PCI_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PS3_SYSTEM_BUS_DRIVER</span>
	<span class="n">ps3_ehci_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PS3_SYSTEM_BUS_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">ehci_debug_root</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">USB_EHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ehci_hcd_cleanup</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CHIPIDEA_EHCI */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
