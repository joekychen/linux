<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › xhci.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xhci.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * xHCI host controller driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Sarah Sharp</span>
<span class="cm"> * Some code borrowed from the Linux EHCI driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;xhci.h&quot;</span>

<span class="cp">#define DRIVER_AUTHOR &quot;Sarah Sharp&quot;</span>
<span class="cp">#define DRIVER_DESC &quot;&#39;eXtensible&#39; Host Controller (xHC) Driver&quot;</span>

<span class="cm">/* Some 0.95 hardware can&#39;t handle the chain bit on a Link TRB being cleared */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">link_quirk</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">link_quirk</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">link_quirk</span><span class="p">,</span> <span class="s">&quot;Don&#39;t clear the chain bit on a link TRB&quot;</span><span class="p">);</span>

<span class="cm">/* TODO: copied from ehci-hcd.c - can this be refactored? */</span>
<span class="cm">/*</span>
<span class="cm"> * handshake - spin reading hc until handshake completes or fails</span>
<span class="cm"> * @ptr: address of hc register to be read</span>
<span class="cm"> * @mask: bits to look at in result of read</span>
<span class="cm"> * @done: value of those bits when handshake succeeds</span>
<span class="cm"> * @usec: timeout in microseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative errno, or zero on success</span>
<span class="cm"> *</span>
<span class="cm"> * Success happens when the &quot;mask&quot; bits have the specified value (hardware</span>
<span class="cm"> * handshake done).  There are two failure modes:  &quot;usec&quot; have passed (major</span>
<span class="cm"> * hardware flakeout), or the register reads as all-ones (hardware removed).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">result</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>		<span class="cm">/* card removed */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">usec</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">usec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable interrupts and begin the xHCI halting process.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">halted</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">XHCI_IRQS</span><span class="p">);</span>
	<span class="n">halted</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">STS_HALT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">halted</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_RUN</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force HC into halt state.</span>
<span class="cm"> *</span>
<span class="cm"> * Disable any IRQs and clear the run/stop bit.</span>
<span class="cm"> * HC will complete any current and actively pipelined transactions, and</span>
<span class="cm"> * should halt within 16 ms of the run/stop bit being cleared.</span>
<span class="cm"> * Read HC Halted bit in the status register to see when the HC is finished.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Halt the HC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_quiesce</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
			<span class="n">STS_HALT</span><span class="p">,</span> <span class="n">STS_HALT</span><span class="p">,</span> <span class="n">XHCI_MAX_HALT_USEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">|=</span> <span class="n">XHCI_STATE_HALTED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Host not halted after %u microseconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">XHCI_MAX_HALT_USEC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the run bit and wait for the host to be running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CMD_RUN</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Turn on HC, cmd = 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">temp</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for the HCHalted Status bit to be 0 to indicate the host is</span>
<span class="cm">	 * running.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
			<span class="n">STS_HALT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XHCI_MAX_HALT_USEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Host took too long to start, &quot;</span>
				<span class="s">&quot;waited %u microseconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">XHCI_MAX_HALT_USEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XHCI_STATE_HALTED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset a halted HC.</span>
<span class="cm"> *</span>
<span class="cm"> * This resets pipelines, timers, counters, state machines, etc.</span>
<span class="cm"> * Transactions will be terminated immediately, and operational registers</span>
<span class="cm"> * will be set to their defaults.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">STS_HALT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Host controller not halted, aborting reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Reset the HC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RESET</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span>
			<span class="n">CMD_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Wait for controller to be ready for doorbell rings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * xHCI cannot write to any doorbells or operational registers other</span>
<span class="cm">	 * than status until the &quot;Controller Not Ready&quot; flag is cleared.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">STS_CNR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port_c_suspend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">suspended_ports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resuming_ports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_free_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					<span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up MSI</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_setup_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>  <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;failed to allocate MSI entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="n">irq_handler_t</span><span class="p">)</span><span class="n">xhci_msi_irq</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;xhci_hcd&quot;</span><span class="p">,</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;disable MSI interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free IRQs</span>
<span class="cm"> * free all IRQs request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* return if using legacy interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_free_msi</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">));</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up MSI-X</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_setup_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * calculate number of msi-x vectors supported.</span>
<span class="cm">	 * - HCS_MAX_INTRS: the max number of interrupts the host can handle,</span>
<span class="cm">	 *   with max number of interrupters based on the xhci HCSPARAMS1.</span>
<span class="cm">	 * - num_online_cpus: maximum msi-x vectors per CPUs core.</span>
<span class="cm">	 *   Add additional 1 vector to ensure always available interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">HCS_MAX_INTRS</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcs_params1</span><span class="p">));</span>

	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span>
		<span class="n">kmalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msix_entry</span><span class="p">))</span><span class="o">*</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_count</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Failed to allocate MSI-X entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Failed to enable MSI-X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_entries</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				<span class="p">(</span><span class="n">irq_handler_t</span><span class="p">)</span><span class="n">xhci_msi_irq</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;xhci_hcd&quot;</span><span class="p">,</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">disable_msix</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">msix_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">disable_msix:</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;disable MSI-X interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_free_irq</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">free_entries:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free any IRQs and disable MSI-X */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_cleanup_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>

	<span class="n">xhci_free_irq</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">msix_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_msix_sync_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_try_enable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>  <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some Fresco Logic host controllers advertise MSI, but fail to</span>
<span class="cm">	 * generate interrupts.  Don&#39;t even try to enable MSI.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_BROKEN_MSI</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* unregister the legacy interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">hcd</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_setup_msix</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="cm">/* fall back to msi*/</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_setup_msi</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="cm">/* hcd-&gt;irq is 0, we have MSI */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;No msi-x/msi found and no IRQ in BIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fall back to legacy interrupt*/</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcd_irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq_descr</span><span class="p">,</span> <span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;request interrupt %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_try_enable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_cleanup_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_msix_sync_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize memory for HCD and xHC (one-time init).</span>
<span class="cm"> *</span>
<span class="cm"> * Program the PAGESIZE register, initialize the device context array, create</span>
<span class="cm"> * device contexts (?), set up a command ring segment (or two?), create event</span>
<span class="cm"> * ring (one for now).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xhci_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">==</span> <span class="mh">0x95</span> <span class="o">&amp;&amp;</span> <span class="n">link_quirk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;QUIRK: Not clearing Link TRB chain bits.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">|=</span> <span class="n">XHCI_LINK_TRB_QUIRK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI doesn&#39;t need link TRB QUIRK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_mem_init</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Finished xhci_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>


<span class="cp">#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_event_ring_work</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">temp_64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Poll event ring: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;op reg status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mh">0xffffffff</span> <span class="o">||</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_HALTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;HW died, polling stopped.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ir_set 0 pending = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;HC error bitmask = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">error_bitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Event ring:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_debug_segment</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">);</span>
	<span class="n">xhci_dbg_ring_ptrs</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">);</span>
	<span class="n">temp_64</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>
	<span class="n">temp_64</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ERST_PTR_MASK</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERST deq = 64&#39;h%0lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">temp_64</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Command ring:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_debug_segment</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">);</span>
	<span class="n">xhci_dbg_ring_ptrs</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">);</span>
	<span class="n">xhci_dbg_cmd_ptrs</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_HC_SLOTS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_dbg_ep_rings</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">zombie</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">POLL_TIMEOUT</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Quit polling the event ring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_run_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_start</span><span class="p">(</span><span class="n">xhci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_NEC_HOST</span><span class="p">)</span>
		<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Finished xhci_run for USB3 roothub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the HC after it was halted.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the USB core when the HC driver is added.</span>
<span class="cm"> * Its opposite is xhci_stop().</span>
<span class="cm"> *</span>
<span class="cm"> * xhci_init() must be called once before this function can be called.</span>
<span class="cm"> * Reset the HC, enable device slot contexts, program DCBAAP, and</span>
<span class="cm"> * set command ring pointer and event ring pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Setup MSI-X vectors and enable interrupts.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">temp_64</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/* Start the xHCI host controller running only after the USB 2.0 roothub</span>
<span class="cm">	 * is setup.</span>
<span class="cm">	 */</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xhci_run_finished</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xhci_run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_try_enable_msi</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xhci</span><span class="p">;</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">xhci_event_ring_work</span><span class="p">;</span>
	<span class="cm">/* Poll the event ring */</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">POLL_TIMEOUT</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">zombie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Setting event ring polling timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Command ring memory map follows:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_debug_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">);</span>
	<span class="n">xhci_dbg_ring_ptrs</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">);</span>
	<span class="n">xhci_dbg_cmd_ptrs</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERST memory map follows:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_dbg_erst</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">erst</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Event ring:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_debug_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">);</span>
	<span class="n">xhci_dbg_ring_ptrs</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring</span><span class="p">);</span>
	<span class="n">temp_64</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>
	<span class="n">temp_64</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ERST_PTR_MASK</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERST deq = 64&#39;h%0lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">temp_64</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Set the interrupt modulation register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_control</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ER_IRQ_INTERVAL_MASK</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="mi">160</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_control</span><span class="p">);</span>

	<span class="cm">/* Set the HCD state before we enable the irqs */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CMD_EIE</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Enable interrupts, cmd = 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">temp</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Enabling event ring interrupter %p by writing 0x%x to irq_pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">ER_IRQ_ENABLE</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ER_IRQ_ENABLE</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="n">xhci_print_ir_set</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_NEC_HOST</span><span class="p">)</span>
		<span class="n">xhci_queue_vendor_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">TRB_TYPE</span><span class="p">(</span><span class="n">TRB_NEC_GET_FW</span><span class="p">));</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Finished xhci_run for USB2 roothub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_only_stop_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="cm">/* The shared_hcd is going to be deallocated shortly (the USB core only</span>
<span class="cm">	 * calls this function when allocation fails in usb_add_hcd(), or</span>
<span class="cm">	 * usb_remove_hcd() is called).  So we need to unset xHCI&#39;s pointer.</span>
<span class="cm">	 */</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop xHCI driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the USB core when the HC driver is removed.</span>
<span class="cm"> * Its opposite is xhci_run().</span>
<span class="cm"> *</span>
<span class="cm"> * Disable device contexts, disable IRQs, and quiesce the HC.</span>
<span class="cm"> * Reset the HC, finish any completed transactions, and cleanup memory.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_only_stop_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* Make sure the xHC is halted for a USB3 roothub</span>
<span class="cm">	 * (xhci_stop() could be called as part of failed init).</span>
<span class="cm">	 */</span>
	<span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">xhci_reset</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">xhci_cleanup_msix</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING</span>
	<span class="cm">/* Tell the event ring poll function not to reschedule */</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">zombie</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_AMD_PLL_FIX</span><span class="p">)</span>
		<span class="n">usb_amd_dev_put</span><span class="p">();</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Disabling event ring interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">STS_EINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ER_IRQ_DISABLE</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="n">xhci_print_ir_set</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;cleaning up memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_mem_cleanup</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xhci_stop completed - status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Shutdown HC (not bus-specific)</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when the machine is rebooting or halting.  We assume that the</span>
<span class="cm"> * machine will be powered off, and the HC&#39;s internal state will be reset.</span>
<span class="cm"> * Don&#39;t bother to free memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This will only ever be called with the main usb_hcd (the USB3 roothub).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">xhci_cleanup_msix</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xhci_shutdown completed - status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_save_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">dev_nt</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">dev_notification</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">dcbaa_ptr</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">dcbaa_ptr</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">config_reg</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">config_reg</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">erst_size</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_size</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">erst_base</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_base</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">erst_dequeue</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">irq_pending</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">irq_control</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_restore_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">dev_nt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">dev_notification</span><span class="p">);</span>
	<span class="n">xhci_write_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">dcbaa_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">dcbaa_ptr</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">config_reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">config_reg</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">erst_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_size</span><span class="p">);</span>
	<span class="n">xhci_write_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">erst_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_base</span><span class="p">);</span>
	<span class="n">xhci_write_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">erst_dequeue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">erst_dequeue</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">irq_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">s3</span><span class="p">.</span><span class="n">irq_control</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_set_cmd_ring_deq</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span>	<span class="n">val_64</span><span class="p">;</span>

	<span class="cm">/* step 2: initialize command ring buffer */</span>
	<span class="n">val_64</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">);</span>
	<span class="n">val_64</span> <span class="o">=</span> <span class="p">(</span><span class="n">val_64</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">CMD_RING_RSVD_BITS</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">,</span>
				      <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">)</span> <span class="o">&amp;</span>
		 <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">~</span><span class="n">CMD_RING_RSVD_BITS</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Setting command ring address to 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">val_64</span><span class="p">);</span>
	<span class="n">xhci_write_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">val_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The whole command ring must be cleared to zero when we suspend the host.</span>
<span class="cm"> *</span>
<span class="cm"> * The host doesn&#39;t save the command ring pointer in the suspend well, so we</span>
<span class="cm"> * need to re-program it on resume.  Unfortunately, the pointer must be 64-byte</span>
<span class="cm"> * aligned, because of the reserved bits in the command ring dequeue pointer</span>
<span class="cm"> * register.  Therefore, we can&#39;t just set the dequeue pointer back in the</span>
<span class="cm"> * middle of the ring (TRBs are 16-byte aligned).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_clear_command_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_segment</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>

	<span class="n">ring</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="p">;</span>
	<span class="n">seg</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">xhci_trb</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">TRBS_PER_SEGMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">[</span><span class="n">TRBS_PER_SEGMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">link</span><span class="p">.</span><span class="n">control</span> <span class="o">&amp;=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">TRB_CYCLE</span><span class="p">);</span>
		<span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">seg</span> <span class="o">!=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">);</span>

	<span class="cm">/* Reset the software enqueue and dequeue pointers */</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">first_seg</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">first_seg</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">deq_seg</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">enqueue</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">;</span>

	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">num_trbs_free</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">num_segs</span> <span class="o">*</span> <span class="p">(</span><span class="n">TRBS_PER_SEGMENT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ring is now zeroed, so the HW should look for change of ownership</span>
<span class="cm">	 * when the cycle bit is set to 1.</span>
<span class="cm">	 */</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">cycle_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the hardware dequeue pointer.</span>
<span class="cm">	 * Yes, this will need to be re-written after resume, but we&#39;re paranoid</span>
<span class="cm">	 * and want to make sure the hardware doesn&#39;t access bogus memory</span>
<span class="cm">	 * because, say, the BIOS or an SMI started the host without changing</span>
<span class="cm">	 * the command ring pointers.</span>
<span class="cm">	 */</span>
	<span class="n">xhci_set_cmd_ring_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop HC (not bus-specific)</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when the machine transition into S3/S4 mode.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">command</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* step 1: stop endpoint */</span>
	<span class="cm">/* skipped assuming that port suspend has done */</span>

	<span class="cm">/* step 2: clear Run/Stop bit */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
		      <span class="n">STS_HALT</span><span class="p">,</span> <span class="n">STS_HALT</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: xHC CMD_RUN timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci_clear_command_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="cm">/* step 3: save registers */</span>
	<span class="n">xhci_save_registers</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="cm">/* step 4: set CSS flag */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_CSS</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">STS_SAVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: xHC save state timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* step 5: remove core well power */</span>
	<span class="cm">/* synchronize irq when using MSI-X */</span>
	<span class="n">xhci_msix_sync_irqs</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * start xHC (not bus-specific)</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when the machine transition from S3/S4 mode.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">bool</span> <span class="n">hibernated</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">command</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">secondary_hcd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait a bit if either of the roothubs need to settle from the</span>
<span class="cm">	 * transition into bus suspend.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next_statechange</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">next_statechange</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_RESET_ON_RESUME</span><span class="p">)</span>
		<span class="n">hibernated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hibernated</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* step 1: restore register */</span>
		<span class="n">xhci_restore_registers</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
		<span class="cm">/* step 2: initialize command ring buffer */</span>
		<span class="n">xhci_set_cmd_ring_deq</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
		<span class="cm">/* step 3: restore state and start state*/</span>
		<span class="cm">/* step 3: set CRS flag */</span>
		<span class="n">command</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
		<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_CRS</span><span class="p">;</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
			      <span class="n">STS_RESTORE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: xHC restore state timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If restore operation fails, re-initialize the HC during resume */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">STS_SRE</span><span class="p">)</span> <span class="o">||</span> <span class="n">hibernated</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Let the USB core know _both_ roothubs lost power. */</span>
		<span class="n">usb_root_hub_lost_power</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">main_hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">);</span>
		<span class="n">usb_root_hub_lost_power</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">);</span>

		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Stop HCD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
		<span class="n">xhci_reset</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">xhci_cleanup_msix</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING</span>
		<span class="cm">/* Tell the event ring poll function not to reschedule */</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">zombie</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">event_ring_timer</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;// Disabling event ring interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">STS_EINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ER_IRQ_DISABLE</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">ir_set</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
		<span class="n">xhci_print_ir_set</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;cleaning up memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_mem_cleanup</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xhci_stop completed - status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>

		<span class="cm">/* USB core calls the PCI reinit and start functions twice:</span>
<span class="cm">		 * first with the primary HCD, and then with the secondary HCD.</span>
<span class="cm">		 * If we don&#39;t do the same, the host will never be started.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
			<span class="n">secondary_hcd</span> <span class="o">=</span> <span class="n">hcd</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">secondary_hcd</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="p">;</span>

		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Initialize the xhci_hcd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_init</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">primary_hcd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Start the primary HCD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_run</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">primary_hcd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Start the secondary HCD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_run</span><span class="p">(</span><span class="n">secondary_hcd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">;</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* step 4: set Run/Stop bit */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">STS_HALT</span><span class="p">,</span>
		  <span class="mi">0</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/* step 5: walk topology and initialize portsc,</span>
<span class="cm">	 * portpmsc and portli</span>
<span class="cm">	 */</span>
	<span class="cm">/* this is done in bus_resume */</span>

	<span class="cm">/* step 6: restart each of the previously</span>
<span class="cm">	 * Running endpoints by ringing their doorbells</span>
<span class="cm">	 */</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">shared_hcd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * xhci_get_endpoint_index - Used for passing endpoint bitmasks between the core and</span>
<span class="cm"> * HCDs.  Find the index for an endpoint given its descriptor.  Use the return</span>
<span class="cm"> * value to right shift 1 for the bitmask.</span>
<span class="cm"> *</span>
<span class="cm"> * Index  = (epnum * 2) + direction - 1,</span>
<span class="cm"> * where direction = 0 for OUT, 1 for IN.</span>
<span class="cm"> * For control endpoints, the IN index is used (OUT index is unused), so</span>
<span class="cm"> * index = (epnum * 2) + direction - 1 = (epnum * 2) + 1 - 1 = (epnum * 2)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_endpoint_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find the flag for this endpoint (for use in the control context).  Use the</span>
<span class="cm"> * endpoint index to create a bitmask.  The slot context is bit 0, endpoint 0 is</span>
<span class="cm"> * bit 1, etc.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_endpoint_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find the flag for this endpoint (for use in the control context).  Use the</span>
<span class="cm"> * endpoint index to create a bitmask.  The slot context is bit 0, endpoint 0 is</span>
<span class="cm"> * bit 1, etc.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_endpoint_flag_from_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ep_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compute the last valid endpoint context index.  Basically, this is the</span>
<span class="cm"> * endpoint index plus one.  For slot contexts with more than valid endpoint,</span>
<span class="cm"> * we find the most significant bit set in the added contexts flags.</span>
<span class="cm"> * e.g. ep 1 IN (with epnum 0x81) =&gt; added_ctxs = 0b1000</span>
<span class="cm"> * fls(0b1000) = 4, but the endpoint context index is 3, so subtract one.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_last_valid_endpoint</span><span class="p">(</span><span class="n">u32</span> <span class="n">added_ctxs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fls</span><span class="p">(</span><span class="n">added_ctxs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns 1 if the arguments are OK;</span>
<span class="cm"> * returns 0 this is a root hub; returns -EINVAL for NULL pointers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check_ep</span><span class="p">,</span> <span class="n">bool</span> <span class="n">check_virt_dev</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span>	<span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span> <span class="o">||</span> <span class="p">(</span><span class="n">check_ep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;xHCI %s called with invalid args</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">func</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;xHCI %s called for root hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">func</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_HALTED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_virt_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span> <span class="o">||</span> <span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;xHCI %s called with unaddressed &quot;</span>
						<span class="s">&quot;device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">!=</span> <span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;xHCI %s called with udev and &quot;</span>
					  <span class="s">&quot;virt_dev does not match</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">ctx_change</span><span class="p">,</span> <span class="n">bool</span> <span class="n">must_succeed</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Full speed devices may have a max packet size greater than 8 bytes, but the</span>
<span class="cm"> * USB core doesn&#39;t know that until it reads the first 8 bytes of the</span>
<span class="cm"> * descriptor.  If the usb_device&#39;s max packet size changes after that point,</span>
<span class="cm"> * we need to issue an evaluate context command and wait on it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_maxpacket</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">out_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_packet_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hw_max_packet_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">out_ctx</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">;</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">hw_max_packet_size</span> <span class="o">=</span> <span class="n">MAX_PACKET_DECODED</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info2</span><span class="p">));</span>
	<span class="n">max_packet_size</span> <span class="o">=</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_max_packet_size</span> <span class="o">!=</span> <span class="n">max_packet_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Max Packet Size for ep 0 changed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Max packet size in usb_device = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">max_packet_size</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Max packet size in xHCI HW = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hw_max_packet_size</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Issuing evaluate context command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Set up the modified control endpoint 0 */</span>
		<span class="n">xhci_endpoint_copy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">in_ctx</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">;</span>
		<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info2</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">MAX_PACKET_MASK</span><span class="p">);</span>
		<span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info2</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">MAX_PACKET</span><span class="p">(</span><span class="n">max_packet_size</span><span class="p">));</span>

		<span class="cm">/* Set up the input context flags for the command */</span>
		<span class="cm">/* FIXME: This won&#39;t work if a non-default control endpoint</span>
<span class="cm">		 * changes max packet sizes.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
		<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EP0_FLAG</span><span class="p">);</span>
		<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot %d input context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot %d output context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

		<span class="cm">/* Clean up the input context for later use by bandwidth</span>
<span class="cm">		 * functions.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SLOT_FLAG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * non-error returns are a promise to giveback() the urb later</span>
<span class="cm"> * we drop ownership so next owner (or urb unlink) can get it</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span>	<span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span> <span class="o">||</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span>
					<span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">__func__</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">;</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">())</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;urb submitted during PCI suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb_priv</span><span class="p">)</span> <span class="o">+</span>
				  <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="p">),</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb_priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_td</span><span class="p">),</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">urb_priv</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="n">buffer</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Check to see if the max packet size for the default control</span>
<span class="cm">		 * endpoint changed during FS device enumeration</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_maxpacket</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span>
					<span class="n">ep_index</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xhci_urb_free_priv</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* We have a spinlock and interrupts disabled, so we must pass</span>
<span class="cm">		 * atomic context to this function, which may allocate memory.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dying</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_ctrl_tx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_priv</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_bulk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dying</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;</span>
				<span class="n">EP_GETTING_STREAMS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: Can&#39;t enqueue URB while bulk ep &quot;</span>
					<span class="s">&quot;is transitioning to using streams.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;</span>
				<span class="n">EP_GETTING_NO_STREAMS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: Can&#39;t enqueue URB while bulk ep &quot;</span>
					<span class="s">&quot;is transitioning to &quot;</span>
					<span class="s">&quot;not having streams.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_bulk_tx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
					<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_priv</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dying</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_intr_tx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_priv</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dying</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_isoc_tx_prepare</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_priv</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">dying:</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Ep 0x%x: URB %p submitted for &quot;</span>
			<span class="s">&quot;non-responsive xHCI host.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
<span class="nl">free_priv:</span>
	<span class="n">xhci_urb_free_priv</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the right ring for the given URB.</span>
<span class="cm"> * If the endpoint supports streams, boundary check the URB&#39;s stream ID.</span>
<span class="cm"> * If the endpoint doesn&#39;t support streams, return the singular endpoint ring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="nf">xhci_urb_to_transfer_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">;</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">stream_id</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="cm">/* Common case: no streams */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HAS_STREAMS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="s">&quot;WARN: Slot ID %u, ep index %u has streams, &quot;</span>
				<span class="s">&quot;but URB has no stream ID.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream_id</span> <span class="o">&lt;</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">stream_rings</span><span class="p">[</span><span class="n">stream_id</span><span class="p">];</span>

	<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
			<span class="s">&quot;WARN: Slot ID %u, ep index %u has &quot;</span>
			<span class="s">&quot;stream IDs 1 to %u allocated, &quot;</span>
			<span class="s">&quot;but stream ID %u is requested.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">num_streams</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">stream_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the URB&#39;s TD from the endpoint ring.  This may cause the HC to stop</span>
<span class="cm"> * USB transfers, potentially stopping in the middle of a TRB buffer.  The HC</span>
<span class="cm"> * should pick up where it left off in the TD, unless a Set Transfer Ring</span>
<span class="cm"> * Dequeue Pointer is issued.</span>
<span class="cm"> *</span>
<span class="cm"> * The TRBs that make up the buffers for the canceled URB will be &quot;removed&quot; from</span>
<span class="cm"> * the ring.  Since the ring is a contiguous structure, they can&#39;t be physically</span>
<span class="cm"> * removed.  Instead, there are two options:</span>
<span class="cm"> *</span>
<span class="cm"> *  1) If the HC is in the middle of processing the URB to be canceled, we</span>
<span class="cm"> *     simply move the ring&#39;s dequeue pointer past those TRBs using the Set</span>
<span class="cm"> *     Transfer Ring Dequeue Pointer command.  This will be the common case,</span>
<span class="cm"> *     when drivers timeout on the last submitted URB and attempt to cancel.</span>
<span class="cm"> *</span>
<span class="cm"> *  2) If the HC is in the middle of a different TD, we turn the TRBs into a</span>
<span class="cm"> *     series of 1-TRB transfer no-op TDs.  (No-ops shouldn&#39;t be chained.)  The</span>
<span class="cm"> *     HC will need to invalidate the any TRBs it has cached after the stop</span>
<span class="cm"> *     endpoint command, as noted in the xHCI 0.95 errata.</span>
<span class="cm"> *</span>
<span class="cm"> *  3) The TD may have completed by the time the Stop Endpoint Command</span>
<span class="cm"> *     completes, so software needs to handle that case too.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should protect against the TD enqueueing code ringing the</span>
<span class="cm"> * doorbell while this code is waiting for a Stop Endpoint command to complete.</span>
<span class="cm"> * It also needs to account for multiple cancellations on happening at the same</span>
<span class="cm"> * time for the same endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function can be called in any context, or so says</span>
<span class="cm"> * usb_hcd_unlink_urb()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span>	<span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_td</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ring</span> <span class="o">*</span><span class="n">ep_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Make sure the URB hasn&#39;t completed or been unlinked already */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mh">0xffffffff</span> <span class="o">||</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_HALTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;HW died, freeing TD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">td</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">))</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
		<span class="n">xhci_urb_free_priv</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_HALTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Ep 0x%x: URB %p to be canceled on &quot;</span>
				<span class="s">&quot;non-responsive xHCI host.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="cm">/* Let the stop endpoint command watchdog timer (which set this</span>
<span class="cm">		 * state) finish cleaning up the endpoint TD lists.  We must</span>
<span class="cm">		 * have caught it in the middle of dropping a lock and giving</span>
<span class="cm">		 * back an URB.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="n">ep_ring</span> <span class="o">=</span> <span class="n">xhci_urb_to_transfer_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td_cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Cancel URB %p, dev %s, ep 0x%x, &quot;</span>
				<span class="s">&quot;starting at offset 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span>
					<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start_seg</span><span class="p">,</span>
					<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">first_trb</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">td</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">cancelled_td_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Queue a stop endpoint command, but only if this is</span>
<span class="cm">	 * the first cancellation to be handled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HALT_PENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">|=</span> <span class="n">EP_HALT_PENDING</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stop_cmds_pending</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stop_cmd_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
			<span class="n">XHCI_STOP_EP_CMD_TIMEOUT</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">stop_cmd_timer</span><span class="p">);</span>
		<span class="n">xhci_queue_stop_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Drop an endpoint from a new bandwidth configuration for this device.</span>
<span class="cm"> * Only one call to this function is allowed per endpoint before</span>
<span class="cm"> * check_bandwidth() or reset_bandwidth() must be called.</span>
<span class="cm"> * A call to xhci_drop_endpoint() followed by a call to xhci_add_endpoint() will</span>
<span class="cm"> * add the endpoint to the schedule with possibly new parameters denoted by a</span>
<span class="cm"> * different endpoint descriptor in usb_host_endpoint.</span>
<span class="cm"> * A call to xhci_add_endpoint() followed by a call to xhci_drop_endpoint() is</span>
<span class="cm"> * not allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * The USB core will not allow URBs to be queued to an endpoint that is being</span>
<span class="cm"> * disabled, so there&#39;s no need for mutual exclusion to protect</span>
<span class="cm"> * the xhci-&gt;devs[slot_id] structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_drop_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">out_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">drop_flag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_add_flags</span><span class="p">,</span> <span class="n">new_drop_flags</span><span class="p">,</span> <span class="n">new_slot_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s called for udev %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="n">drop_flag</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_flag</span> <span class="o">==</span> <span class="n">SLOT_FLAG</span> <span class="o">||</span> <span class="n">drop_flag</span> <span class="o">==</span> <span class="n">EP0_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI %s - can&#39;t drop slot or ep 0 %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">drop_flag</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">in_ctx</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">;</span>
	<span class="n">out_ctx</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">;</span>
	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="cm">/* If the HC already knows the endpoint is disabled,</span>
<span class="cm">	 * or the HCD has noted it is disabled, ignore this request</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EP_STATE_MASK</span><span class="p">))</span> <span class="o">==</span>
	     <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EP_STATE_DISABLED</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span><span class="p">)</span> <span class="o">&amp;</span>
	    <span class="n">xhci_get_endpoint_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI %s called with disabled ep %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">drop_flag</span><span class="p">);</span>
	<span class="n">new_drop_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span><span class="p">);</span>

	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">drop_flag</span><span class="p">);</span>
	<span class="n">new_add_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span><span class="p">);</span>

	<span class="n">last_ctx</span> <span class="o">=</span> <span class="n">xhci_last_valid_endpoint</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span><span class="p">));</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="cm">/* Update the last valid endpoint context, if we deleted the last one */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LAST_CTX_MASK</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">LAST_CTX</span><span class="p">(</span><span class="n">last_ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">LAST_CTX_MASK</span><span class="p">);</span>
		<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LAST_CTX</span><span class="p">(</span><span class="n">last_ctx</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">new_slot_info</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">);</span>

	<span class="n">xhci_endpoint_zero</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">],</span> <span class="n">ep</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;drop ep 0x%x, slot id %d, new drop flags = %#x, new add flags = %#x, new slot info = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">new_drop_flags</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">new_add_flags</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">new_slot_info</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add an endpoint to a new possible bandwidth configuration for this device.</span>
<span class="cm"> * Only one call to this function is allowed per endpoint before</span>
<span class="cm"> * check_bandwidth() or reset_bandwidth() must be called.</span>
<span class="cm"> * A call to xhci_drop_endpoint() followed by a call to xhci_add_endpoint() will</span>
<span class="cm"> * add the endpoint to the schedule with possibly new parameters denoted by a</span>
<span class="cm"> * different endpoint descriptor in usb_host_endpoint.</span>
<span class="cm"> * A call to xhci_add_endpoint() followed by a call to xhci_drop_endpoint() is</span>
<span class="cm"> * not allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * The USB core will not allow URBs to be queued to an endpoint until the</span>
<span class="cm"> * configuration or alt setting is installed in the device, so there&#39;s no need</span>
<span class="cm"> * for mutual exclusion to protect the xhci-&gt;devs[slot_id] structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_add_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">out_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">added_ctxs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_add_flags</span><span class="p">,</span> <span class="n">new_drop_flags</span><span class="p">,</span> <span class="n">new_slot_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* So we won&#39;t queue a reset ep command for a root hub */</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">added_ctxs</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">last_ctx</span> <span class="o">=</span> <span class="n">xhci_last_valid_endpoint</span><span class="p">(</span><span class="n">added_ctxs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">added_ctxs</span> <span class="o">==</span> <span class="n">SLOT_FLAG</span> <span class="o">||</span> <span class="n">added_ctxs</span> <span class="o">==</span> <span class="n">EP0_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME when we have to issue an evaluate endpoint command to</span>
<span class="cm">		 * deal with ep0 max packet size changing once we get the</span>
<span class="cm">		 * descriptors</span>
<span class="cm">		 */</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI %s - can&#39;t add slot or ep 0 %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">added_ctxs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="n">in_ctx</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">;</span>
	<span class="n">out_ctx</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">;</span>
	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>

	<span class="cm">/* If this endpoint is already in use, and the upper layers are trying</span>
<span class="cm">	 * to add it again without dropping it, reject the addition.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ring</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">xhci_get_endpoint_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Trying to add endpoint 0x%x &quot;</span>
				<span class="s">&quot;without dropping it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the HCD has already noted the endpoint is enabled,</span>
<span class="cm">	 * ignore this request.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span><span class="p">)</span> <span class="o">&amp;</span>
	    <span class="n">xhci_get_endpoint_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI %s called with enabled ep %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configuration and alternate setting changes must be done in</span>
<span class="cm">	 * process context, not interrupt context (or so documenation</span>
<span class="cm">	 * for usb_set_interface() and usb_set_configuration() claim).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_endpoint_init</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - could not initialize ep %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">added_ctxs</span><span class="p">);</span>
	<span class="n">new_add_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span><span class="p">);</span>

	<span class="cm">/* If xhci_endpoint_disable() was called for this endpoint, but the</span>
<span class="cm">	 * xHC hasn&#39;t been notified yet through the check_bandwidth() call,</span>
<span class="cm">	 * this re-adds a new state for the endpoint from the new endpoint</span>
<span class="cm">	 * descriptors.  We must drop and re-add this endpoint, so we leave the</span>
<span class="cm">	 * drop flags alone.</span>
<span class="cm">	 */</span>
	<span class="n">new_drop_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span><span class="p">);</span>

	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="cm">/* Update the last valid endpoint context, if we just added one past */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LAST_CTX_MASK</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">LAST_CTX</span><span class="p">(</span><span class="n">last_ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">LAST_CTX_MASK</span><span class="p">);</span>
		<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LAST_CTX</span><span class="p">(</span><span class="n">last_ctx</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">new_slot_info</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">);</span>

	<span class="cm">/* Store the usb_device pointer for later use */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;add ep 0x%x, slot id %d, new drop flags = %#x, new add flags = %#x, new slot info = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">new_drop_flags</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">new_add_flags</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">new_slot_info</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_zero_in_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* When a device&#39;s add flag and drop flag are zero, any subsequent</span>
<span class="cm">	 * configure endpoint command will leave that endpoint&#39;s state</span>
<span class="cm">	 * untouched.  Make sure we don&#39;t leave any old state in the input</span>
<span class="cm">	 * endpoint contexts.</span>
<span class="cm">	 */</span>
	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">LAST_CTX_MASK</span><span class="p">);</span>
	<span class="cm">/* Endpoint 0 is always valid */</span>
	<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LAST_CTX</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">ep_info2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">deq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">tx_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_configure_endpoint_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cmd_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMP_ENOMEM</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not enough host controller resources &quot;</span>
				<span class="s">&quot;for new device state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="cm">/* FIXME: can we allocate more resources for the HC? */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_BW_ERR</span>:
	<span class="k">case</span> <span class="n">COMP_2ND_BW_ERR</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not enough bandwidth &quot;</span>
				<span class="s">&quot;for new device state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="cm">/* FIXME: can we go back to the old state? */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_TRB_ERR</span>:
		<span class="cm">/* the HCD set up something wrong */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ERROR: Endpoint drop flag = 0, &quot;</span>
				<span class="s">&quot;add flag = 1, &quot;</span>
				<span class="s">&quot;and endpoint is not disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_DEV_ERR</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ERROR: Incompatible device for endpoint &quot;</span>
				<span class="s">&quot;configure command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Successful Endpoint Configure command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR: unexpected command completion &quot;</span>
				<span class="s">&quot;code 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">cmd_status</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_evaluate_context_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cmd_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMP_EINVAL</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARN: xHCI driver setup invalid evaluate &quot;</span>
				<span class="s">&quot;context command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_EBADSLT</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARN: slot not enabled for&quot;</span>
				<span class="s">&quot;evaluate context command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">COMP_CTX_STATE</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARN: invalid context state for &quot;</span>
				<span class="s">&quot;evaluate context command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_DEV_ERR</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ERROR: Incompatible device for evaluate &quot;</span>
				<span class="s">&quot;context command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_MEL_ERR</span>:
		<span class="cm">/* Max Exit Latency too large error */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARN: Max Exit Latency too large</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Successful evaluate context command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR: unexpected command completion &quot;</span>
				<span class="s">&quot;code 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">cmd_status</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">xhci_count_num_new_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">valid_add_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">valid_drop_flags</span><span class="p">;</span>

	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="cm">/* Ignore the slot flag (bit 0), and the default control endpoint flag</span>
<span class="cm">	 * (bit 1).  The default control endpoint is added during the Address</span>
<span class="cm">	 * Device command and is never removed until the slot is disabled.</span>
<span class="cm">	 */</span>
	<span class="n">valid_add_flags</span> <span class="o">=</span> <span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">valid_drop_flags</span> <span class="o">=</span> <span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Use hweight32 to count the number of ones in the add flags, or</span>
<span class="cm">	 * number of endpoints added.  Don&#39;t count endpoints that are changed</span>
<span class="cm">	 * (both added and dropped).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">hweight32</span><span class="p">(</span><span class="n">valid_add_flags</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">hweight32</span><span class="p">(</span><span class="n">valid_add_flags</span> <span class="o">&amp;</span> <span class="n">valid_drop_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_count_num_dropped_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">valid_add_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">valid_drop_flags</span><span class="p">;</span>

	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">valid_add_flags</span> <span class="o">=</span> <span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">valid_drop_flags</span> <span class="o">=</span> <span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hweight32</span><span class="p">(</span><span class="n">valid_drop_flags</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">hweight32</span><span class="p">(</span><span class="n">valid_add_flags</span> <span class="o">&amp;</span> <span class="n">valid_drop_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to reserve the new number of endpoints before the configure endpoint</span>
<span class="cm"> * command completes.  We can&#39;t subtract the dropped endpoints from the number</span>
<span class="cm"> * of active endpoints until the command completes because we can oversubscribe</span>
<span class="cm"> * the host in this case:</span>
<span class="cm"> *</span>
<span class="cm"> *  - the first configure endpoint command drops more endpoints than it adds</span>
<span class="cm"> *  - a second configure endpoint command that adds more endpoints is queued</span>
<span class="cm"> *  - the first configure endpoint command fails, so the config is unchanged</span>
<span class="cm"> *  - the second command may succeed, even though there isn&#39;t enough resources</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with xhci-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_reserve_host_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">added_eps</span><span class="p">;</span>

	<span class="n">added_eps</span> <span class="o">=</span> <span class="n">xhci_count_num_new_endpoints</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span> <span class="o">+</span> <span class="n">added_eps</span> <span class="o">&gt;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">limit_active_eps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough ep ctxs: &quot;</span>
				<span class="s">&quot;%u active, need to add %u, limit is %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">,</span> <span class="n">added_eps</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">limit_active_eps</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span> <span class="o">+=</span> <span class="n">added_eps</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Adding %u ep ctxs, %u now active.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">added_eps</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The configure endpoint was failed by the xHC for some other reason, so we</span>
<span class="cm"> * need to revert the resources that failed configuration would have used.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with xhci-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_free_host_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">num_failed_eps</span><span class="p">;</span>

	<span class="n">num_failed_eps</span> <span class="o">=</span> <span class="n">xhci_count_num_new_endpoints</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span> <span class="o">-=</span> <span class="n">num_failed_eps</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Removing %u failed ep ctxs, %u now active.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">num_failed_eps</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Now that the command has completed, clean up the active endpoint count by</span>
<span class="cm"> * subtracting out the endpoints that were dropped (but not changed).</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with xhci-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_finish_resource_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">num_dropped_eps</span><span class="p">;</span>

	<span class="n">num_dropped_eps</span> <span class="o">=</span> <span class="n">xhci_count_num_dropped_endpoints</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span> <span class="o">-=</span> <span class="n">num_dropped_eps</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_dropped_eps</span><span class="p">)</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Removing %u dropped ep ctxs, %u now active.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">num_dropped_eps</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
	<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:
		<span class="k">return</span> <span class="n">FS_BLOCK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:
		<span class="k">return</span> <span class="n">HS_BLOCK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_SUPER</span>:
		<span class="k">return</span> <span class="n">SS_BLOCK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_UNKNOWN</span>:
	<span class="k">case</span> <span class="n">USB_SPEED_WIRELESS</span>:
	<span class="nl">default:</span>
		<span class="cm">/* Should never happen */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_largest_overhead</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_interval_bw</span> <span class="o">*</span><span class="n">interval_bw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">LS_OVERHEAD_TYPE</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">LS_OVERHEAD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">FS_OVERHEAD_TYPE</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">FS_OVERHEAD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">HS_OVERHEAD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If we are changing a LS/FS device under a HS hub,</span>
<span class="cm"> * make sure (if we are activating a new TT) that the HS bus has enough</span>
<span class="cm"> * bandwidth for this new TT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_tt_bw_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">old_active_eps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_interval_bw_table</span> <span class="o">*</span><span class="n">bw_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_tt_bw_info</span> <span class="o">*</span><span class="n">tt_info</span><span class="p">;</span>

	<span class="cm">/* Find the bandwidth table for the root port this TT is attached to. */</span>
	<span class="n">bw_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">rh_bw</span><span class="p">[</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">real_port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">bw_table</span><span class="p">;</span>
	<span class="n">tt_info</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">;</span>
	<span class="cm">/* If this TT already had active endpoints, the bandwidth for this TT</span>
<span class="cm">	 * has already been added.  Removing all periodic endpoints (and thus</span>
<span class="cm">	 * making the TT enactive) will only decrease the bandwidth used.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_active_eps</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_active_eps</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">active_eps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">bw_used</span> <span class="o">+</span> <span class="n">TT_HS_OVERHEAD</span> <span class="o">&gt;</span> <span class="n">HS_BW_LIMIT</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Not sure why we would have no new active endpoints...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Maybe because of an Evaluate Context change for a hub update or a</span>
<span class="cm">	 * control endpoint 0 max packet size change?</span>
<span class="cm">	 * FIXME: skip the bandwidth calculation in that case.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_ss_bw</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bw_reserved</span><span class="p">;</span>

	<span class="n">bw_reserved</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">SS_BW_RESERVED</span><span class="o">*</span><span class="n">SS_BW_LIMIT_IN</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">ss_bw_in</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">SS_BW_LIMIT_IN</span> <span class="o">-</span> <span class="n">bw_reserved</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">bw_reserved</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">SS_BW_RESERVED</span><span class="o">*</span><span class="n">SS_BW_LIMIT_OUT</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">ss_bw_out</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">SS_BW_LIMIT_OUT</span> <span class="o">-</span> <span class="n">bw_reserved</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This algorithm is a very conservative estimate of the worst-case scheduling</span>
<span class="cm"> * scenario for any one interval.  The hardware dynamically schedules the</span>
<span class="cm"> * packets, so we can&#39;t tell which microframe could be the limiting factor in</span>
<span class="cm"> * the bandwidth scheduling.  This only takes into account periodic endpoints.</span>
<span class="cm"> *</span>
<span class="cm"> * Obviously, we can&#39;t solve an NP complete problem to find the minimum worst</span>
<span class="cm"> * case scenario.  Instead, we come up with an estimate that is no less than</span>
<span class="cm"> * the worst case bandwidth used for any one microframe, but may be an</span>
<span class="cm"> * over-estimate.</span>
<span class="cm"> *</span>
<span class="cm"> * We walk the requirements for each endpoint by interval, starting with the</span>
<span class="cm"> * smallest interval, and place packets in the schedule where there is only one</span>
<span class="cm"> * possible way to schedule packets for that interval.  In order to simplify</span>
<span class="cm"> * this algorithm, we record the largest max packet size for each interval, and</span>
<span class="cm"> * assume all packets will be that size.</span>
<span class="cm"> *</span>
<span class="cm"> * For interval 0, we obviously must schedule all packets for each interval.</span>
<span class="cm"> * The bandwidth for interval 0 is just the amount of data to be transmitted</span>
<span class="cm"> * (the sum of all max ESIT payload sizes, plus any overhead per packet times</span>
<span class="cm"> * the number of packets).</span>
<span class="cm"> *</span>
<span class="cm"> * For interval 1, we have two possible microframes to schedule those packets</span>
<span class="cm"> * in.  For this algorithm, if we can schedule the same number of packets for</span>
<span class="cm"> * each possible scheduling opportunity (each microframe), we will do so.  The</span>
<span class="cm"> * remaining number of packets will be saved to be transmitted in the gaps in</span>
<span class="cm"> * the next interval&#39;s scheduling sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * As we move those remaining packets to be scheduled with interval 2 packets,</span>
<span class="cm"> * we have to double the number of remaining packets to transmit.  This is</span>
<span class="cm"> * because the intervals are actually powers of 2, and we would be transmitting</span>
<span class="cm"> * the previous interval&#39;s packets twice in this interval.  We also have to be</span>
<span class="cm"> * sure that when we look at the largest max packet size for this interval, we</span>
<span class="cm"> * also look at the largest max packet size for the remaining packets and take</span>
<span class="cm"> * the greater of the two.</span>
<span class="cm"> *</span>
<span class="cm"> * The algorithm continues to evenly distribute packets in each scheduling</span>
<span class="cm"> * opportunity, and push the remaining packets out, until we get to the last</span>
<span class="cm"> * interval.  Then those packets and their associated overhead are just added</span>
<span class="cm"> * to the bandwidth used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_bw_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">old_active_eps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bw_reserved</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_bandwidth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bw_used</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_interval_bw_table</span> <span class="o">*</span><span class="n">bw_table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packet_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">overhead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packets_transmitted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packets_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xhci_check_ss_bw</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_bandwidth</span> <span class="o">=</span> <span class="n">HS_BW_LIMIT</span><span class="p">;</span>
		<span class="cm">/* Convert percent of bus BW reserved to blocks reserved */</span>
		<span class="n">bw_reserved</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HS_BW_RESERVED</span> <span class="o">*</span> <span class="n">max_bandwidth</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">max_bandwidth</span> <span class="o">=</span> <span class="n">FS_BW_LIMIT</span><span class="p">;</span>
		<span class="n">bw_reserved</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">FS_BW_RESERVED</span> <span class="o">*</span> <span class="n">max_bandwidth</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bw_table</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">;</span>
	<span class="cm">/* We need to translate the max packet size and max ESIT payloads into</span>
<span class="cm">	 * the units the hardware uses.</span>
<span class="cm">	 */</span>
	<span class="n">block_size</span> <span class="o">=</span> <span class="n">xhci_get_block_size</span><span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>

	<span class="cm">/* If we are manipulating a LS/FS device under a HS hub, double check</span>
<span class="cm">	 * that the HS bus has enough bandwidth if we are activing a new TT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Recalculating BW for rootport %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">real_port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_check_tt_bw_table</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">old_active_eps</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough bandwidth on HS bus for &quot;</span>
					<span class="s">&quot;newly activated TT.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Recalculating BW for TT slot %u port %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
				<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">ttport</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Recalculating BW for rootport %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">real_port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Add in how much bandwidth will be used for interval zero, or the</span>
<span class="cm">	 * rounded max ESIT payload + number of packets * largest overhead.</span>
<span class="cm">	 */</span>
	<span class="n">bw_used</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval0_esit_payload</span><span class="p">,</span> <span class="n">block_size</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">num_packets</span> <span class="o">*</span>
		<span class="n">xhci_get_largest_overhead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XHCI_MAX_INTERVAL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bw_added</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">largest_mps</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interval_overhead</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * How many packets could we transmit in this interval?</span>
<span class="cm">		 * If packets didn&#39;t fit in the previous interval, we will need</span>
<span class="cm">		 * to transmit that many packets twice within this interval.</span>
<span class="cm">		 */</span>
		<span class="n">packets_remaining</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">packets_remaining</span> <span class="o">+</span>
			<span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num_packets</span><span class="p">;</span>

		<span class="cm">/* Find the largest max packet size of this or the previous</span>
<span class="cm">		 * interval.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">endpoints</span><span class="p">))</span>
			<span class="n">largest_mps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">virt_ep</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ep_entry</span><span class="p">;</span>

			<span class="n">ep_entry</span> <span class="o">=</span> <span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">endpoints</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="n">virt_ep</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep_entry</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xhci_virt_ep</span><span class="p">,</span> <span class="n">bw_endpoint_list</span><span class="p">);</span>
			<span class="cm">/* Convert to blocks, rounding up */</span>
			<span class="n">largest_mps</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span>
					<span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">bw_info</span><span class="p">.</span><span class="n">max_packet_size</span><span class="p">,</span>
					<span class="n">block_size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">largest_mps</span> <span class="o">&gt;</span> <span class="n">packet_size</span><span class="p">)</span>
			<span class="n">packet_size</span> <span class="o">=</span> <span class="n">largest_mps</span><span class="p">;</span>

		<span class="cm">/* Use the larger overhead of this or the previous interval. */</span>
		<span class="n">interval_overhead</span> <span class="o">=</span> <span class="n">xhci_get_largest_overhead</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">interval_overhead</span> <span class="o">&gt;</span> <span class="n">overhead</span><span class="p">)</span>
			<span class="n">overhead</span> <span class="o">=</span> <span class="n">interval_overhead</span><span class="p">;</span>

		<span class="cm">/* How many packets can we evenly distribute across</span>
<span class="cm">		 * (1 &lt;&lt; (i + 1)) possible scheduling opportunities?</span>
<span class="cm">		 */</span>
		<span class="n">packets_transmitted</span> <span class="o">=</span> <span class="n">packets_remaining</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Add in the bandwidth used for those scheduled packets */</span>
		<span class="n">bw_added</span> <span class="o">=</span> <span class="n">packets_transmitted</span> <span class="o">*</span> <span class="p">(</span><span class="n">overhead</span> <span class="o">+</span> <span class="n">packet_size</span><span class="p">);</span>

		<span class="cm">/* How many packets do we have remaining to transmit? */</span>
		<span class="n">packets_remaining</span> <span class="o">=</span> <span class="n">packets_remaining</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

		<span class="cm">/* What largest max packet size should those packets have? */</span>
		<span class="cm">/* If we&#39;ve transmitted all packets, don&#39;t carry over the</span>
<span class="cm">		 * largest packet size.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packets_remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">packet_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">overhead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">packets_transmitted</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Otherwise if we do have remaining packets, and we&#39;ve</span>
<span class="cm">			 * scheduled some packets in this interval, take the</span>
<span class="cm">			 * largest max packet size from endpoints with this</span>
<span class="cm">			 * interval.</span>
<span class="cm">			 */</span>
			<span class="n">packet_size</span> <span class="o">=</span> <span class="n">largest_mps</span><span class="p">;</span>
			<span class="n">overhead</span> <span class="o">=</span> <span class="n">interval_overhead</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Otherwise carry over packet_size and overhead from the last</span>
<span class="cm">		 * time we had a remainder.</span>
<span class="cm">		 */</span>
		<span class="n">bw_used</span> <span class="o">+=</span> <span class="n">bw_added</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bw_used</span> <span class="o">&gt;</span> <span class="n">max_bandwidth</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough bandwidth. &quot;</span>
					<span class="s">&quot;Proposed: %u, Max: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bw_used</span><span class="p">,</span> <span class="n">max_bandwidth</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ok, we know we have some packets left over after even-handedly</span>
<span class="cm">	 * scheduling interval 15.  We don&#39;t know which microframes they will</span>
<span class="cm">	 * fit into, so we over-schedule and say they will be scheduled every</span>
<span class="cm">	 * microframe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packets_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bw_used</span> <span class="o">+=</span> <span class="n">overhead</span> <span class="o">+</span> <span class="n">packet_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span> <span class="o">&amp;&amp;</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_index</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">real_port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* OK, we&#39;re manipulating a HS device attached to a</span>
<span class="cm">		 * root port bandwidth domain.  Include the number of active TTs</span>
<span class="cm">		 * in the bandwidth used.</span>
<span class="cm">		 */</span>
		<span class="n">bw_used</span> <span class="o">+=</span> <span class="n">TT_HS_OVERHEAD</span> <span class="o">*</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">rh_bw</span><span class="p">[</span><span class="n">port_index</span><span class="p">].</span><span class="n">num_active_tts</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Final bandwidth: %u, Limit: %u, Reserved: %u, &quot;</span>
		<span class="s">&quot;Available: %u &quot;</span> <span class="s">&quot;percent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bw_used</span><span class="p">,</span> <span class="n">max_bandwidth</span><span class="p">,</span> <span class="n">bw_reserved</span><span class="p">,</span>
		<span class="p">(</span><span class="n">max_bandwidth</span> <span class="o">-</span> <span class="n">bw_used</span> <span class="o">-</span> <span class="n">bw_reserved</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span>
		<span class="n">max_bandwidth</span><span class="p">);</span>

	<span class="n">bw_used</span> <span class="o">+=</span> <span class="n">bw_reserved</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bw_used</span> <span class="o">&gt;</span> <span class="n">max_bandwidth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough bandwidth. Proposed: %u, Max: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bw_used</span><span class="p">,</span> <span class="n">max_bandwidth</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">bw_used</span> <span class="o">=</span> <span class="n">bw_used</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">xhci_is_async_ep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ep_type</span> <span class="o">!=</span> <span class="n">ISOC_OUT_EP</span> <span class="o">&amp;&amp;</span> <span class="n">ep_type</span> <span class="o">!=</span> <span class="n">INT_OUT_EP</span> <span class="o">&amp;&amp;</span>
					<span class="n">ep_type</span> <span class="o">!=</span> <span class="n">ISOC_IN_EP</span> <span class="o">&amp;&amp;</span>
					<span class="n">ep_type</span> <span class="o">!=</span> <span class="n">INT_IN_EP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">xhci_is_sync_in_ep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ep_type</span> <span class="o">==</span> <span class="n">ISOC_IN_EP</span> <span class="o">||</span> <span class="n">ep_type</span> <span class="o">!=</span> <span class="n">INT_IN_EP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_get_ss_bw_consumed</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_bw_info</span> <span class="o">*</span><span class="n">ep_bw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mps</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">max_packet_size</span><span class="p">,</span> <span class="n">SS_BLOCK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">ep_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SS_OVERHEAD_BURST</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">*</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">num_packets</span> <span class="o">*</span>
					<span class="p">(</span><span class="n">SS_OVERHEAD</span> <span class="o">+</span> <span class="n">mps</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">*</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">num_packets</span> <span class="o">*</span>
				<span class="p">(</span><span class="n">SS_OVERHEAD</span> <span class="o">+</span> <span class="n">mps</span> <span class="o">+</span> <span class="n">SS_OVERHEAD_BURST</span><span class="p">),</span>
				<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">ep_interval</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xhci_drop_ep_from_interval_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_bw_info</span> <span class="o">*</span><span class="n">ep_bw</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_interval_bw_table</span> <span class="o">*</span><span class="n">bw_table</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">virt_ep</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_tt_bw_info</span> <span class="o">*</span><span class="n">tt_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_interval_bw</span>	<span class="o">*</span><span class="n">interval_bw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">normalized_interval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_is_async_ep</span><span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_is_sync_in_ep</span><span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">ss_bw_in</span> <span class="o">-=</span>
				<span class="n">xhci_get_ss_bw_consumed</span><span class="p">(</span><span class="n">ep_bw</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">ss_bw_out</span> <span class="o">-=</span>
				<span class="n">xhci_get_ss_bw_consumed</span><span class="p">(</span><span class="n">ep_bw</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* SuperSpeed endpoints never get added to intervals in the table, so</span>
<span class="cm">	 * this check is only valid for HS/FS/LS devices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">bw_endpoint_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* For LS/FS devices, we need to translate the interval expressed in</span>
<span class="cm">	 * microframes to frames.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
		<span class="n">normalized_interval</span> <span class="o">=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">ep_interval</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">normalized_interval</span> <span class="o">=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">ep_interval</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">normalized_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval0_esit_payload</span> <span class="o">-=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">max_esit_payload</span><span class="p">;</span>
	<span class="n">interval_bw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="n">normalized_interval</span><span class="p">];</span>
	<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">num_packets</span> <span class="o">-=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">num_packets</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
		<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">LS_OVERHEAD_TYPE</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:
		<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">FS_OVERHEAD_TYPE</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:
		<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">HS_OVERHEAD_TYPE</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_SUPER</span>:
	<span class="k">case</span> <span class="n">USB_SPEED_UNKNOWN</span>:
	<span class="k">case</span> <span class="n">USB_SPEED_WIRELESS</span>:
		<span class="cm">/* Should never happen because only LS/FS/HS endpoints will get</span>
<span class="cm">		 * added to the endpoint list.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tt_info</span><span class="p">)</span>
		<span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">active_eps</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">bw_endpoint_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_add_ep_to_interval_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_bw_info</span> <span class="o">*</span><span class="n">ep_bw</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_interval_bw_table</span> <span class="o">*</span><span class="n">bw_table</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">virt_ep</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_tt_bw_info</span> <span class="o">*</span><span class="n">tt_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_interval_bw</span>	<span class="o">*</span><span class="n">interval_bw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">smaller_ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">normalized_interval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_is_async_ep</span><span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_is_sync_in_ep</span><span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">ss_bw_in</span> <span class="o">+=</span>
				<span class="n">xhci_get_ss_bw_consumed</span><span class="p">(</span><span class="n">ep_bw</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">ss_bw_out</span> <span class="o">+=</span>
				<span class="n">xhci_get_ss_bw_consumed</span><span class="p">(</span><span class="n">ep_bw</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For LS/FS devices, we need to translate the interval expressed in</span>
<span class="cm">	 * microframes to frames.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
		<span class="n">normalized_interval</span> <span class="o">=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">ep_interval</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">normalized_interval</span> <span class="o">=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">ep_interval</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">normalized_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval0_esit_payload</span> <span class="o">+=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">max_esit_payload</span><span class="p">;</span>
	<span class="n">interval_bw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bw_table</span><span class="o">-&gt;</span><span class="n">interval_bw</span><span class="p">[</span><span class="n">normalized_interval</span><span class="p">];</span>
	<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">num_packets</span> <span class="o">+=</span> <span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">num_packets</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
		<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">LS_OVERHEAD_TYPE</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:
		<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">FS_OVERHEAD_TYPE</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:
		<span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">[</span><span class="n">HS_OVERHEAD_TYPE</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_SPEED_SUPER</span>:
	<span class="k">case</span> <span class="n">USB_SPEED_UNKNOWN</span>:
	<span class="k">case</span> <span class="n">USB_SPEED_WIRELESS</span>:
		<span class="cm">/* Should never happen because only LS/FS/HS endpoints will get</span>
<span class="cm">		 * added to the endpoint list.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tt_info</span><span class="p">)</span>
		<span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">active_eps</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Insert the endpoint into the list, largest max packet size first. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">smaller_ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">,</span>
			<span class="n">bw_endpoint_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_bw</span><span class="o">-&gt;</span><span class="n">max_packet_size</span> <span class="o">&gt;=</span>
				<span class="n">smaller_ep</span><span class="o">-&gt;</span><span class="n">bw_info</span><span class="p">.</span><span class="n">max_packet_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Add the new ep before the smaller endpoint */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">bw_endpoint_list</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">smaller_ep</span><span class="o">-&gt;</span><span class="n">bw_endpoint_list</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Add the new endpoint at the end of the list. */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">bw_endpoint_list</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">interval_bw</span><span class="o">-&gt;</span><span class="n">endpoints</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xhci_update_tt_active_eps</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">old_active_eps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_root_port_bw_info</span> <span class="o">*</span><span class="n">rh_bw_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rh_bw_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">rh_bw</span><span class="p">[</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">real_port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_active_eps</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">active_eps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rh_bw_info</span><span class="o">-&gt;</span><span class="n">num_active_tts</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rh_bw_info</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">.</span><span class="n">bw_used</span> <span class="o">+=</span> <span class="n">TT_HS_OVERHEAD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_active_eps</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">active_eps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rh_bw_info</span><span class="o">-&gt;</span><span class="n">num_active_tts</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rh_bw_info</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">.</span><span class="n">bw_used</span> <span class="o">-=</span> <span class="n">TT_HS_OVERHEAD</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_reserve_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_bw_info</span> <span class="n">ep_bw_info</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_active_eps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">)</span>
		<span class="n">old_active_eps</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="o">-&gt;</span><span class="n">active_eps</span><span class="p">;</span>

	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EP_IS_ADDED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">EP_IS_DROPPED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Make a copy of the BW info in case we need to revert this */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep_bw_info</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ep_bw_info</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="cm">/* Drop the endpoint from the interval table if the endpoint is</span>
<span class="cm">		 * being dropped or changed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EP_IS_DROPPED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">xhci_drop_ep_from_interval_table</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Overwrite the information stored in the endpoints&#39; bw_info */</span>
	<span class="n">xhci_update_bw_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add any changed or added endpoints to the interval table */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EP_IS_ADDED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">xhci_add_ep_to_interval_table</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci_check_bw_table</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">old_active_eps</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Ok, this fits in the bandwidth we have.</span>
<span class="cm">		 * Update the number of active TTs.</span>
<span class="cm">		 */</span>
		<span class="n">xhci_update_tt_active_eps</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">old_active_eps</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We don&#39;t have enough bandwidth for this, revert the stored info. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EP_IS_ADDED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">EP_IS_DROPPED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Drop the new copies of any added or changed endpoints from</span>
<span class="cm">		 * the interval table.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EP_IS_ADDED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_drop_ep_from_interval_table</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Revert the endpoint back to its old information */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep_bw_info</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ep_bw_info</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="cm">/* Add any changed or dropped endpoints back into the table */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EP_IS_DROPPED</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">xhci_add_ep_to_interval_table</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Issue a configure endpoint command or evaluate context command</span>
<span class="cm"> * and wait for it to finish.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_configure_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">ctx_change</span><span class="p">,</span> <span class="n">bool</span> <span class="n">must_succeed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeleft</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">cmd_completion</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">cmd_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span>
		<span class="n">in_ctx</span> <span class="o">=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">in_ctx</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_EP_LIMIT_QUIRK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">xhci_reserve_host_resources</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough host resources, &quot;</span>
				<span class="s">&quot;active endpoint contexts = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_SW_BW_CHECKING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">xhci_reserve_bandwidth</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_EP_LIMIT_QUIRK</span><span class="p">))</span>
			<span class="n">xhci_free_host_resources</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough bandwidth</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd_completion</span> <span class="o">=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">;</span>
		<span class="n">cmd_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">command_trb</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>

		<span class="cm">/* Enqueue pointer can be left pointing to the link TRB,</span>
<span class="cm">		 * we must handle that</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">command_trb</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span><span class="p">))</span>
			<span class="n">command</span><span class="o">-&gt;</span><span class="n">command_trb</span> <span class="o">=</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd_completion</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_completion</span><span class="p">;</span>
		<span class="n">cmd_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="n">cmd_completion</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx_change</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span> <span class="n">must_succeed</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_evaluate_context</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span> <span class="n">must_succeed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_EP_LIMIT_QUIRK</span><span class="p">))</span>
			<span class="n">xhci_free_host_resources</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;FIXME allocate a new ring segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Wait for the configure endpoint command to complete */</span>
	<span class="n">timeleft</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span>
			<span class="n">cmd_completion</span><span class="p">,</span>
			<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s while waiting for %s command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">timeleft</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Timeout&quot;</span> <span class="o">:</span> <span class="s">&quot;Signal&quot;</span><span class="p">,</span>
				<span class="n">ctx_change</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span>
					<span class="s">&quot;configure endpoint&quot;</span> <span class="o">:</span>
					<span class="s">&quot;evaluate context&quot;</span><span class="p">);</span>
		<span class="cm">/* FIXME cancel the configure endpoint command */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx_change</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint_result</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">cmd_status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_evaluate_context_result</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">cmd_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_EP_LIMIT_QUIRK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* If the command failed, remove the reserved resources.</span>
<span class="cm">		 * Otherwise, clean up the estimate to include dropped eps.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">xhci_free_host_resources</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xhci_finish_resource_reservation</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called after one or more calls to xhci_add_endpoint() or</span>
<span class="cm"> * xhci_drop_endpoint().  If this call fails, the USB core is expected</span>
<span class="cm"> * to call xhci_reset_bandwidth().</span>
<span class="cm"> *</span>
<span class="cm"> * Since we are in the middle of changing either configuration or</span>
<span class="cm"> * installing a new alt setting, the USB core won&#39;t allow URBs to be</span>
<span class="cm"> * enqueued for any endpoint on the old config or interface.  Nothing</span>
<span class="cm"> * else should be touching the xhci-&gt;devs[slot_id] structure, so we</span>
<span class="cm"> * don&#39;t need to take the xhci-&gt;lock for manipulating that.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_check_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span>	<span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s called for udev %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>

	<span class="cm">/* See section 4.6.6 - A0 = 1; A1 = D0 = D1 = 0 */</span>
	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SLOT_FLAG</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">EP0_FLAG</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">SLOT_FLAG</span> <span class="o">|</span> <span class="n">EP0_FLAG</span><span class="p">));</span>

	<span class="cm">/* Don&#39;t issue the command if there&#39;s no endpoints to update. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SLOT_FLAG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;New Input Control Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
		     <span class="n">LAST_CTX_TO_EP_NUM</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">)));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Callee should call reset_bandwidth() */</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Output context after successful config ep cmd:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span>
		     <span class="n">LAST_CTX_TO_EP_NUM</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">)));</span>

	<span class="cm">/* Free any rings that were dropped, but not changed. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))))</span>
			<span class="n">xhci_free_or_cache_endpoint_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xhci_zero_in_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Install any rings for completely new endpoints or changed endpoints,</span>
<span class="cm">	 * and free or cache any old rings from changed endpoints.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">new_ring</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* Only cache or free the old ring if it exists.</span>
<span class="cm">		 * It may not if this is the first add of an endpoint.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_free_or_cache_endpoint_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ring</span> <span class="o">=</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">new_ring</span><span class="p">;</span>
		<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">new_ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xhci_reset_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span>	<span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s called for udev %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="cm">/* Free any rings allocated for added endpoints */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">new_ring</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_ring_free</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">new_ring</span><span class="p">);</span>
			<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">new_ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xhci_zero_in_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_setup_input_ctx_for_config_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">out_ctx</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">add_flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">drop_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">add_flags</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">drop_flags</span><span class="p">);</span>
	<span class="n">xhci_slot_copy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">,</span> <span class="n">out_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SLOT_FLAG</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Input Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">,</span> <span class="n">xhci_last_valid_endpoint</span><span class="p">(</span><span class="n">add_flags</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_setup_input_ctx_for_quirk</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xhci_dequeue_state</span> <span class="o">*</span><span class="n">deq_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_container_ctx</span> <span class="o">*</span><span class="n">in_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">added_ctxs</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">xhci_endpoint_copy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">in_ctx</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">;</span>
	<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">in_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">xhci_trb_virt_to_dma</span><span class="p">(</span><span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span>
			<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Cannot submit config ep after &quot;</span>
				<span class="s">&quot;reset ep command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN deq seg = %p, deq ptr = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_seg</span><span class="p">,</span>
				<span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_deq_ptr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep_ctx</span><span class="o">-&gt;</span><span class="n">deq</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="n">deq_state</span><span class="o">-&gt;</span><span class="n">new_cycle_state</span><span class="p">);</span>

	<span class="n">added_ctxs</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_flag_from_index</span><span class="p">(</span><span class="n">ep_index</span><span class="p">);</span>
	<span class="n">xhci_setup_input_ctx_for_config_ep</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">added_ctxs</span><span class="p">,</span> <span class="n">added_ctxs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xhci_cleanup_stalled_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_dequeue_state</span> <span class="n">deq_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Cleaning up stalled endpoint ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="cm">/* We need to move the HW&#39;s dequeue pointer past this TD,</span>
<span class="cm">	 * or it will attempt to resend it on the next doorbell ring.</span>
<span class="cm">	 */</span>
	<span class="n">xhci_find_new_dequeue_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
			<span class="n">ep_index</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_stream</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">deq_state</span><span class="p">);</span>

	<span class="cm">/* HW with the reset endpoint quirk will use the saved dequeue state to</span>
<span class="cm">	 * issue a configure endpoint command later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_RESET_EP_QUIRK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Queueing new dequeue state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_queue_new_dequeue_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
				<span class="n">ep_index</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stopped_stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deq_state</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Better hope no one uses the input context between now and the</span>
<span class="cm">		 * reset endpoint completion!</span>
<span class="cm">		 * XXX: No idea how this hardware will react when stream rings</span>
<span class="cm">		 * are enabled.</span>
<span class="cm">		 */</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Setting up input context for &quot;</span>
				<span class="s">&quot;configure endpoint command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_setup_input_ctx_for_quirk</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
				<span class="n">ep_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deq_state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Deal with stalled endpoints.  The core should have sent the control message</span>
<span class="cm"> * to clear the halt condition.  However, we need to make the xHCI hardware</span>
<span class="cm"> * reset its sequence number, since a device will expect a sequence number of</span>
<span class="cm"> * zero after the halt condition is cleared.</span>
<span class="cm"> * Context: in_interrupt</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_endpoint_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">virt_ep</span><span class="p">;</span>

	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">udev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="cm">/* Called with a root hub endpoint (or an endpoint that wasn&#39;t added</span>
<span class="cm">	 * with xhci_add_endpoint()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">virt_ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Endpoint 0x%x not halted, refusing to reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Control endpoint stall already handled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Queueing reset endpoint command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_reset_ep</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t change the ring dequeue pointer until it&#39;s transitioned to the</span>
<span class="cm">	 * stopped state, which is only upon a successful reset endpoint</span>
<span class="cm">	 * command.  Better hope that last command worked!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_cleanup_stalled_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span><span class="p">);</span>
		<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">stopped_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">stopped_trb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">virt_ep</span><span class="o">-&gt;</span><span class="n">stopped_stream</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;FIXME allocate a new ring segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_streams_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">xhci_to_hcd</span><span class="p">(</span><span class="n">xhci</span><span class="p">),</span> <span class="n">udev</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ss_ep_comp</span><span class="p">.</span><span class="n">bmAttributes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: SuperSpeed Endpoint Companion&quot;</span>
				<span class="s">&quot; descriptor for ep 0x%x does not support streams</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">ep_state</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HAS_STREAMS</span> <span class="o">||</span>
			<span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_GETTING_STREAMS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: SuperSpeed bulk endpoint 0x%x &quot;</span>
				<span class="s">&quot;already has streams set up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Send email to xHCI maintainer and ask for &quot;</span>
				<span class="s">&quot;dynamic stream context array reallocation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Cannot setup streams for SuperSpeed bulk &quot;</span>
				<span class="s">&quot;endpoint 0x%x; URBs are pending.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_calculate_streams_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_streams</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_stream_ctxs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_streams</span><span class="p">;</span>

	<span class="cm">/* The stream context array size must be a power of two */</span>
	<span class="o">*</span><span class="n">num_stream_ctxs</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="o">*</span><span class="n">num_streams</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find out how many primary stream array entries the host controller</span>
<span class="cm">	 * supports.  Later we may use secondary stream arrays (similar to 2nd</span>
<span class="cm">	 * level page entries), but that&#39;s an optional feature for xHCI host</span>
<span class="cm">	 * controllers. xHCs must support at least 4 stream IDs.</span>
<span class="cm">	 */</span>
	<span class="n">max_streams</span> <span class="o">=</span> <span class="n">HCC_MAX_PSA</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">num_stream_ctxs</span> <span class="o">&gt;</span> <span class="n">max_streams</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI HW only supports %u stream ctx entries.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">max_streams</span><span class="p">);</span>
		<span class="o">*</span><span class="n">num_stream_ctxs</span> <span class="o">=</span> <span class="n">max_streams</span><span class="p">;</span>
		<span class="o">*</span><span class="n">num_streams</span> <span class="o">=</span> <span class="n">max_streams</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Returns an error code if one of the endpoint already has streams.</span>
<span class="cm"> * This does not change any data structures, it only checks and gathers</span>
<span class="cm"> * information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_calculate_streams_and_bitmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_streams</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">changed_ep_bitmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_streams</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">endpoint_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_streams_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span>
				<span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">max_streams</span> <span class="o">=</span> <span class="n">usb_ss_max_streams</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ss_ep_comp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_streams</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">num_streams</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Ep 0x%x only supports %u stream IDs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span>
					<span class="n">max_streams</span><span class="p">);</span>
			<span class="o">*</span><span class="n">num_streams</span> <span class="o">=</span> <span class="n">max_streams</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">endpoint_flag</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">changed_ep_bitmask</span> <span class="o">&amp;</span> <span class="n">endpoint_flag</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">changed_ep_bitmask</span> <span class="o">|=</span> <span class="n">endpoint_flag</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">xhci_calculate_no_streams_bitmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">changed_ep_bitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">ep_state</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span><span class="p">;</span>
		<span class="cm">/* Are streams already being freed for the endpoint? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_GETTING_NO_STREAMS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Can&#39;t disable streams for &quot;</span>
					<span class="s">&quot;endpoint 0x%x</span><span class="se">\n</span><span class="s">, &quot;</span>
					<span class="s">&quot;streams are being disabled already.&quot;</span><span class="p">,</span>
					<span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Are there actually any streams to free? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HAS_STREAMS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_GETTING_STREAMS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN Can&#39;t disable streams for &quot;</span>
					<span class="s">&quot;endpoint 0x%x</span><span class="se">\n</span><span class="s">, &quot;</span>
					<span class="s">&quot;streams are already disabled!&quot;</span><span class="p">,</span>
					<span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN xhci_free_streams() called &quot;</span>
					<span class="s">&quot;with non-streams endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">changed_ep_bitmask</span> <span class="o">|=</span> <span class="n">xhci_get_endpoint_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">changed_ep_bitmask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The USB device drivers use this function (though the HCD interface in USB</span>
<span class="cm"> * core) to prepare a set of bulk endpoints to use streams.  Streams are used to</span>
<span class="cm"> * coordinate mass storage command queueing across multiple endpoints (basically</span>
<span class="cm"> * a stream ID == a task ID).</span>
<span class="cm"> *</span>
<span class="cm"> * Setting up streams involves allocating the same size stream context array</span>
<span class="cm"> * for each endpoint and issuing a configure endpoint command for all endpoints.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t allow the call to succeed if one endpoint only supports one stream</span>
<span class="cm"> * (which means it doesn&#39;t support streams at all).</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers may get less stream IDs than they asked for, if the host controller</span>
<span class="cm"> * hardware or endpoints claim they can&#39;t support the number of requested</span>
<span class="cm"> * stream IDs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_alloc_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_streams</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">config_cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_stream_ctxs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">changed_ep_bitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eps</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Add one to the number of streams requested to account for</span>
<span class="cm">	 * stream 0 that is reserved for xHCI usage.</span>
<span class="cm">	 */</span>
	<span class="n">num_streams</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Driver wants %u stream IDs (including stream 0).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">num_streams</span><span class="p">);</span>

	<span class="n">config_cmd</span> <span class="o">=</span> <span class="n">xhci_alloc_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">config_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Could not allocate xHCI command structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to make sure all endpoints are not already configured for</span>
<span class="cm">	 * streams.  While we&#39;re at it, find the maximum number of streams that</span>
<span class="cm">	 * all the endpoints will support and check for duplicate endpoints.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_calculate_streams_and_bitmask</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span>
			<span class="n">num_eps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_streams</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">changed_ep_bitmask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_streams</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;WARN: endpoints can&#39;t handle &quot;</span>
				<span class="s">&quot;more than one stream.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vdev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="cm">/* Mark each endpoint as being in transition, so</span>
<span class="cm">	 * xhci_urb_enqueue() will reject all URBs.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">|=</span> <span class="n">EP_GETTING_STREAMS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Setup internal data structures and allocate HW data structures for</span>
<span class="cm">	 * streams (but don&#39;t install the HW structures in the input context</span>
<span class="cm">	 * until we&#39;re sure all memory allocation succeeded).</span>
<span class="cm">	 */</span>
	<span class="n">xhci_calculate_streams_entries</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_streams</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_stream_ctxs</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Need %u stream ctx entries for %u stream IDs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">num_stream_ctxs</span><span class="p">,</span> <span class="n">num_streams</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span> <span class="o">=</span> <span class="n">xhci_alloc_stream_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
				<span class="n">num_stream_ctxs</span><span class="p">,</span>
				<span class="n">num_streams</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="cm">/* Set maxPstreams in endpoint context and update deq ptr to</span>
<span class="cm">		 * point to stream context array. FIXME</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/* Set up the input context for a configure endpoint command. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>

		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>

		<span class="n">xhci_endpoint_copy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
				<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">xhci_setup_streams_ep_input_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ctx</span><span class="p">,</span>
				<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Tell the HW to drop its old copy of the endpoint context info</span>
<span class="cm">	 * and add the updated copy from the input context.</span>
<span class="cm">	 */</span>
	<span class="n">xhci_setup_input_ctx_for_config_ep</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
			<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">changed_ep_bitmask</span><span class="p">,</span> <span class="n">changed_ep_bitmask</span><span class="p">);</span>

	<span class="cm">/* Issue and wait for the configure endpoint command */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">,</span>
			<span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* xHC rejected the configure endpoint command for some reason, so we</span>
<span class="cm">	 * leave the old ring intact and free our internal streams data</span>
<span class="cm">	 * structure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_GETTING_STREAMS</span><span class="p">;</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot %u ep ctx %u now has streams.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">|=</span> <span class="n">EP_HAS_STREAMS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Subtract 1 for stream 0, which drivers can&#39;t use */</span>
	<span class="k">return</span> <span class="n">num_streams</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="cm">/* If it didn&#39;t work, free the streams! */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">xhci_free_stream_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* FIXME Unset maxPstreams in endpoint context and</span>
<span class="cm">		 * update deq ptr to point to normal string ring.</span>
<span class="cm">		 */</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_GETTING_STREAMS</span><span class="p">;</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_HAS_STREAMS</span><span class="p">;</span>
		<span class="n">xhci_endpoint_zero</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">vdev</span><span class="p">,</span> <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Transition the endpoint from using streams to being a &quot;normal&quot; endpoint</span>
<span class="cm"> * without streams.</span>
<span class="cm"> *</span>
<span class="cm"> * Modify the endpoint context state, submit a configure endpoint command,</span>
<span class="cm"> * and free all endpoint rings for streams if that completes successfully.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_free_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">changed_ep_bitmask</span><span class="p">;</span>

	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">vdev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>

	<span class="cm">/* Set up a configure endpoint command to remove the streams rings */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">changed_ep_bitmask</span> <span class="o">=</span> <span class="n">xhci_calculate_no_streams_bitmask</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
			<span class="n">udev</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">changed_ep_bitmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Use the xhci_command structure from the first endpoint.  We may have</span>
<span class="cm">	 * allocated too many, but the driver may call xhci_free_streams() for</span>
<span class="cm">	 * each endpoint it grouped into one call to xhci_alloc_streams().</span>
<span class="cm">	 */</span>
	<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">=</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span><span class="o">-&gt;</span><span class="n">free_streams_command</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xhci_ep_ctx</span> <span class="o">*</span><span class="n">ep_ctx</span><span class="p">;</span>

		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">ep_ctx</span> <span class="o">=</span> <span class="n">xhci_get_ep_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">|=</span>
			<span class="n">EP_GETTING_NO_STREAMS</span><span class="p">;</span>

		<span class="n">xhci_endpoint_copy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
				<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">ep_index</span><span class="p">);</span>
		<span class="n">xhci_setup_no_streams_ep_input_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep_ctx</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">xhci_setup_input_ctx_for_config_ep</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span>
			<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">changed_ep_bitmask</span><span class="p">,</span> <span class="n">changed_ep_bitmask</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Issue and wait for the configure endpoint command,</span>
<span class="cm">	 * which must succeed.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
			<span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* xHC rejected the configure endpoint command for some reason, so we</span>
<span class="cm">	 * leave the streams rings intact.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_eps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_index</span> <span class="o">=</span> <span class="n">xhci_get_endpoint_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">xhci_free_stream_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span><span class="p">);</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">stream_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* FIXME Unset maxPstreams in endpoint context and</span>
<span class="cm">		 * update deq ptr to point to normal string ring.</span>
<span class="cm">		 */</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_GETTING_NO_STREAMS</span><span class="p">;</span>
		<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_HAS_STREAMS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Deletes endpoint resources for endpoints that were active before a Reset</span>
<span class="cm"> * Device command, or a Disable Slot command.  The Reset Device command leaves</span>
<span class="cm"> * the control endpoint intact, whereas the Disable Slot command deletes it.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with xhci-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_free_device_endpoint_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop_control_ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_dropped_eps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drop_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">drop_control_ep</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drop_flags</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">num_dropped_eps</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span> <span class="o">-=</span> <span class="n">num_dropped_eps</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_dropped_eps</span><span class="p">)</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Dropped %u ep ctxs, flags = 0x%x, &quot;</span>
				<span class="s">&quot;%u now active.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">num_dropped_eps</span><span class="p">,</span> <span class="n">drop_flags</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This submits a Reset Device Command, which will set the device state to 0,</span>
<span class="cm"> * set the device address to 0, and disable all the endpoints except the default</span>
<span class="cm"> * control endpoint.  The USB core should come back and call</span>
<span class="cm"> * xhci_address_device(), and then re-set up the configuration.  If this is</span>
<span class="cm"> * called because of a usb_reset_and_verify_device(), then the old alternate</span>
<span class="cm"> * settings will be re-installed through the normal bandwidth allocation</span>
<span class="cm"> * functions.</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for the Reset Device command to finish.  Remove all structures</span>
<span class="cm"> * associated with the endpoints that were disabled.  Clear the input device</span>
<span class="cm"> * structure?  Cache the rings?  Reset the control endpoint 0 max packet size?</span>
<span class="cm"> *</span>
<span class="cm"> * If the virt_dev to be reset does not exist or does not match the udev,</span>
<span class="cm"> * it means the device is lost, possibly due to the xHC restore error and</span>
<span class="cm"> * re-initialization during S3/S4. In this case, call xhci_alloc_dev() to</span>
<span class="cm"> * re-allocate the device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_discover_or_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">reset_device_cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeleft</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_freed_endpoint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_active_eps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">slot_id</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">;</span>
	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;The device to be reset with slot ID %u does &quot;</span>
				<span class="s">&quot;not exist. Re-allocate the device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_alloc_dev</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">!=</span> <span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the virt_dev and the udev does not match, this virt_dev</span>
<span class="cm">		 * may belong to another udev.</span>
<span class="cm">		 * Re-allocate the device.</span>
<span class="cm">		 */</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;The device to be reset with slot ID %u does &quot;</span>
				<span class="s">&quot;not match the udev. Re-allocate the device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_alloc_dev</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If device is not setup, there is no point in resetting it */</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GET_SLOT_STATE</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="p">))</span> <span class="o">==</span>
						<span class="n">SLOT_STATE_DISABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Resetting device with slot ID %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
	<span class="cm">/* Allocate the command structure that holds the struct completion.</span>
<span class="cm">	 * Assume we&#39;re in process context, since the normal device reset</span>
<span class="cm">	 * process has to wait for the device anyway.  Storage devices are</span>
<span class="cm">	 * reset as part of error handling, so use GFP_NOIO instead of</span>
<span class="cm">	 * GFP_KERNEL.</span>
<span class="cm">	 */</span>
	<span class="n">reset_device_cmd</span> <span class="o">=</span> <span class="n">xhci_alloc_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reset_device_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t allocate command structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Attempt to submit the Reset Device command to the command ring */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">command_trb</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>

	<span class="cm">/* Enqueue pointer can be left pointing to the link TRB,</span>
<span class="cm">	 * we must handle that</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TRB_TYPE_LINK_LE32</span><span class="p">(</span><span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">command_trb</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">control</span><span class="p">))</span>
		<span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">command_trb</span> <span class="o">=</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">enq_seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">trbs</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_reset_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;FIXME: allocate a command ring segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">command_cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Wait for the Reset Device command to finish */</span>
	<span class="n">timeleft</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span>
			<span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">,</span>
			<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s while waiting for reset device command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">timeleft</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Timeout&quot;</span> <span class="o">:</span> <span class="s">&quot;Signal&quot;</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* The timeout might have raced with the event ring handler, so</span>
<span class="cm">		 * only delete from the list if the item isn&#39;t poisoned.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">LIST_POISON1</span><span class="p">)</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">command_cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The Reset Device command can&#39;t fail, according to the 0.95/0.96 spec,</span>
<span class="cm">	 * unless we tried to reset a slot ID that wasn&#39;t enabled,</span>
<span class="cm">	 * or the device wasn&#39;t in the addressed or configured state.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">reset_device_cmd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMP_EBADSLT</span>: <span class="cm">/* 0.95 completion code for bad slot ID */</span>
	<span class="k">case</span> <span class="n">COMP_CTX_STATE</span>: <span class="cm">/* 0.96 completion code for same thing */</span>
		<span class="n">xhci_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Can&#39;t reset device (slot ID %u) in %s state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">slot_id</span><span class="p">,</span>
				<span class="n">xhci_get_slot_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">));</span>
		<span class="n">xhci_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not freeing device rings.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Don&#39;t treat this as an error.  May change my mind later. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">command_cleanup</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Successful reset device command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_is_vendor_info_code</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Unknown completion code %u for &quot;</span>
				<span class="s">&quot;reset device command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">command_cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free up host controller endpoint resources */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_EP_LIMIT_QUIRK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Don&#39;t delete the default control endpoint resources */</span>
		<span class="n">xhci_free_device_endpoint_resources</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Everything but endpoint 0 is disabled, so free or cache the rings. */</span>
	<span class="n">last_freed_endpoint</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xhci_virt_ep</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;</span> <span class="n">EP_HAS_STREAMS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_free_stream_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span><span class="p">);</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">stream_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_HAS_STREAMS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_free_or_cache_endpoint_ring</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">last_freed_endpoint</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_endpoint_list</span><span class="p">))</span>
			<span class="n">xhci_drop_ep_from_interval_table</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">,</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">bw_table</span><span class="p">,</span>
					<span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">tt_info</span><span class="p">);</span>
		<span class="n">xhci_clear_endpoint_bw_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bw_info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* If necessary, update the number of active TTs on this root port */</span>
	<span class="n">xhci_update_tt_active_eps</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="p">,</span> <span class="n">old_active_eps</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Output context after successful reset device cmd:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="n">last_freed_endpoint</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">command_cleanup:</span>
	<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">reset_device_cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * At this point, the struct usb_device is about to go away, the device has</span>
<span class="cm"> * disconnected, and all traffic has been stopped and the endpoints have been</span>
<span class="cm"> * disabled.  Free any HC data structures associated with that device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_free_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_check_args</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="cm">/* If the host is halted due to driver unload, we still need to free the</span>
<span class="cm">	 * device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>

	<span class="cm">/* Stop any wayward timer functions (which may grab the lock) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ep_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EP_HALT_PENDING</span><span class="p">;</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stop_cmd_timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_set_usb2_hardware_lpm</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t disable the slot if the host controller is dead. */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mh">0xffffffff</span> <span class="o">||</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_DYING</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">xhc_state</span> <span class="o">&amp;</span> <span class="n">XHCI_STATE_HALTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_free_virt_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_queue_slot_control</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">TRB_DISABLE_SLOT</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;FIXME: allocate a command ring segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Event command completion handler will free any data structures</span>
<span class="cm">	 * associated with the slot.  XXX Can free sleep?</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Checks if we have enough host controller resources for the default control</span>
<span class="cm"> * endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with xhci-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_reserve_host_control_ep_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">limit_active_eps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough ep ctxs: &quot;</span>
				<span class="s">&quot;%u active, need to add 1, limit is %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">limit_active_eps</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Adding 1 ep ctx, %u now active.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Returns 0 if the xHC ran out of device slots, the Enable Slot command</span>
<span class="cm"> * timed out, or allocating memory failed.  Returns 1 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_alloc_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeleft</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_slot_control</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">TRB_ENABLE_SLOT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;FIXME: allocate a command ring segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* XXX: how much time for xHC slot assignment? */</span>
	<span class="n">timeleft</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">addr_dev</span><span class="p">,</span>
			<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s while waiting for a slot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">timeleft</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Timeout&quot;</span> <span class="o">:</span> <span class="s">&quot;Signal&quot;</span><span class="p">);</span>
		<span class="cm">/* FIXME cancel the enable slot request */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Error while assigning device slot ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_EP_LIMIT_QUIRK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_reserve_host_control_ep_resources</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Not enough host resources, &quot;</span>
					<span class="s">&quot;active endpoint contexts = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_active_eps</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">disable_slot</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Use GFP_NOIO, since this function can be called from</span>
<span class="cm">	 * xhci_discover_or_reset_device(), which may be called as part of</span>
<span class="cm">	 * mass storage driver error handling.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci_alloc_virt_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Could not allocate xHCI USB device data structures</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">disable_slot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">;</span>
	<span class="cm">/* Is this a LS or FS device under a HS hub? */</span>
	<span class="cm">/* Hub or peripherial? */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">disable_slot:</span>
	<span class="cm">/* Disable slot, if we can do it without mem alloc */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci_queue_slot_control</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">TRB_DISABLE_SLOT</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">))</span>
		<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue an Address Device command (which will issue a SetAddress request to</span>
<span class="cm"> * the device).</span>
<span class="cm"> * We should be protected by the usb_address0_mutex in khubd&#39;s hub_port_init, so</span>
<span class="cm"> * we should only issue and wait on one address command at the same time.</span>
<span class="cm"> *</span>
<span class="cm"> * We add one to the device address issued by the hardware because the USB core</span>
<span class="cm"> * uses address 1 for the root hubs (even though they&#39;re not really devices).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_address_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeleft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">temp_64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Bad Slot ID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">virt_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In plug/unplug torture test with an NEC controller,</span>
<span class="cm">		 * a zero-dereference was observed once due to virt_dev = 0.</span>
<span class="cm">		 * Print useful debug rather than crash if it is observed again!</span>
<span class="cm">		 */</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Virt dev invalid for slot_id 0x%x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is the first Set Address since device plug-in or</span>
<span class="cm">	 * virt_device realloaction after a resume with an xHCI power loss,</span>
<span class="cm">	 * then set up the slot context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span><span class="p">)</span>
		<span class="n">xhci_setup_addressable_virt_dev</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="cm">/* Otherwise, update the control endpoint ring enqueue pointer. */</span>
	<span class="k">else</span>
		<span class="n">xhci_copy_ep0_dequeue_into_input_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SLOT_FLAG</span> <span class="o">|</span> <span class="n">EP0_FLAG</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot ID %d Input Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_queue_address_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;FIXME: allocate a command ring segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* ctrl tx can take up to 5 sec; XXX: need more time for xHC? */</span>
	<span class="n">timeleft</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">addr_dev</span><span class="p">,</span>
			<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="cm">/* FIXME: From section 4.3.4: &quot;Software shall be responsible for timing</span>
<span class="cm">	 * the SetAddress() &quot;recovery interval&quot; required by USB and aborting the</span>
<span class="cm">	 * command on a timeout.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s while waiting for address device command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">timeleft</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Timeout&quot;</span> <span class="o">:</span> <span class="s">&quot;Signal&quot;</span><span class="p">);</span>
		<span class="cm">/* FIXME cancel the address device command */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMP_CTX_STATE</span>:
	<span class="k">case</span> <span class="n">COMP_EBADSLT</span>:
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Setup ERROR: address device command for slot %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_TX_ERR</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device not responding to set address.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_DEV_ERR</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ERROR: Incompatible device for address &quot;</span>
				<span class="s">&quot;device command.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMP_SUCCESS</span>:
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Successful Address Device command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">xhci_err</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;ERROR: unexpected command completion &quot;</span>
				<span class="s">&quot;code 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot ID %d Output Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
		<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">temp_64</span> <span class="o">=</span> <span class="n">xhci_read_64</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">dcbaa_ptr</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Op regs DCBAA ptr = %#016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp_64</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot ID %d dcbaa entry @%p = %#016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">,</span>
		 <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">dcbaa</span><span class="o">-&gt;</span><span class="n">dev_context_ptrs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">],</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
		 <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">dcbaa</span><span class="o">-&gt;</span><span class="n">dev_context_ptrs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]));</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Output Context DMA address = %#08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot ID %d Input Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot ID %d Output Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * USB core uses address 1 for the roothubs, so we add one to the</span>
<span class="cm">	 * address given back to us by the HC.</span>
<span class="cm">	 */</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">);</span>
	<span class="cm">/* Use kernel assigned address for devices; store xHC assigned</span>
<span class="cm">	 * address locally. */</span>
	<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DEV_ADDR_MASK</span><span class="p">)</span>
		<span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Zero the input context control for later use */</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">drop_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Internal device address = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>

<span class="cm">/* BESL to HIRD Encoding array for USB2 LPM */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xhci_besl_encoding</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">125</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span>
	<span class="mi">3000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">6000</span><span class="p">,</span> <span class="mi">7000</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="mi">9000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">};</span>

<span class="cm">/* Calculate HIRD/BESL for USB2 PORTPMSC*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_calculate_hird_besl</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">u2del</span><span class="p">,</span> <span class="n">besl</span><span class="p">,</span> <span class="n">besl_host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">besl_device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">field</span><span class="p">;</span>

	<span class="n">u2del</span> <span class="o">=</span> <span class="n">HCS_U2_LATENCY</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcs_params3</span><span class="p">);</span>
	<span class="n">field</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ext_cap</span><span class="o">-&gt;</span><span class="n">bmAttributes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">field</span> <span class="o">&amp;</span> <span class="n">USB_BESL_SUPPORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">besl_host</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">besl_host</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">besl_host</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xhci_besl_encoding</span><span class="p">[</span><span class="n">besl_host</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">u2del</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Use baseline BESL value as default */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">field</span> <span class="o">&amp;</span> <span class="n">USB_BESL_BASELINE_VALID</span><span class="p">)</span>
			<span class="n">besl_device</span> <span class="o">=</span> <span class="n">USB_GET_BESL_BASELINE</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">field</span> <span class="o">&amp;</span> <span class="n">USB_BESL_DEEP_VALID</span><span class="p">)</span>
			<span class="n">besl_device</span> <span class="o">=</span> <span class="n">USB_GET_BESL_DEEP</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">u2del</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">)</span>
			<span class="n">besl_host</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">besl_host</span> <span class="o">=</span> <span class="p">(</span><span class="n">u2del</span> <span class="o">-</span> <span class="mi">51</span><span class="p">)</span> <span class="o">/</span> <span class="mi">75</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">besl</span> <span class="o">=</span> <span class="n">besl_host</span> <span class="o">+</span> <span class="n">besl_device</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">besl</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span>
		<span class="n">besl</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">besl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_usb2_software_lpm_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dev_info</span>	<span class="o">*</span><span class="n">dev_info</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span>	<span class="o">**</span><span class="n">port_array</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">pm_addr</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">temp</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">port_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">hird</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span> <span class="o">||</span> <span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">sw_lpm_support</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_capable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* we only support lpm for non-hub device connected to root hub yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">==</span> <span class="n">USB_CLASS_HUB</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Look for devices in lpm_failed_devs list */</span>
	<span class="n">dev_id</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lpm_failed_devs</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_info</span><span class="o">-&gt;</span><span class="n">dev_id</span> <span class="o">==</span> <span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">port_array</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb2_ports</span><span class="p">;</span>
	<span class="n">port_num</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port_num</span> <span class="o">&gt;</span> <span class="n">HCS_MAX_PORTS</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcs_params1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;invalid port number %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Test USB 2.0 software LPM.</span>
<span class="cm">	 * FIXME: some xHCI 1.0 hosts may implement a new register to set up</span>
<span class="cm">	 * hardware-controlled USB 2.0 LPM. See section 5.4.11 and 4.23.5.1.1.1</span>
<span class="cm">	 * in the June 2011 errata release.</span>
<span class="cm">	 */</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;test port %d software LPM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_num</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set L1 Device Slot and HIRD/BESL.</span>
<span class="cm">	 * Check device&#39;s USB 2.0 extension descriptor to determine whether</span>
<span class="cm">	 * HIRD or BESL shoule be used. See USB2.0 LPM errata.</span>
<span class="cm">	 */</span>
	<span class="n">pm_addr</span> <span class="o">=</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_num</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hird</span> <span class="o">=</span> <span class="n">xhci_calculate_hird_besl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">PORT_L1DS</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">)</span> <span class="o">|</span> <span class="n">PORT_HIRD</span><span class="p">(</span><span class="n">hird</span><span class="p">);</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">);</span>

	<span class="cm">/* Set port link state to U2(L1) */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_num</span><span class="p">];</span>
	<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">XDEV_U2</span><span class="p">);</span>

	<span class="cm">/* wait for ACK */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Check L1 Status */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">,</span> <span class="n">PORT_L1S_MASK</span><span class="p">,</span> <span class="n">PORT_L1S_SUCCESS</span><span class="p">,</span> <span class="mi">125</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enter L1 successfully */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;port %d entered L1 state, port status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port_num</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;port %d software lpm failed, L1 status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port_num</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_L1S_MASK</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Resume the port */</span>
	<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">XDEV_U0</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Clear PLC */</span>
	<span class="n">xhci_test_and_clear_bit</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">PORT_PLC</span><span class="p">);</span>

	<span class="cm">/* Check PORTSC to make sure the device is in the right state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;resumed port %d status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>	<span class="n">port_num</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">XDEV_U0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;port L1 resume fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Insert dev to lpm_failed_devs list */</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;device LPM test failed, may disconnect and &quot;</span>
				<span class="s">&quot;re-enumerate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_info</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_info</span><span class="o">-&gt;</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lpm_failed_devs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xhci_ring_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">finish:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_set_usb2_hardware_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="n">__iomem</span>	<span class="o">**</span><span class="n">port_array</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pm_addr</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">port_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">hird</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span> <span class="o">||</span> <span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hw_lpm_support</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">lpm_capable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">==</span> <span class="n">USB_CLASS_HUB</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_capable</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">port_array</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb2_ports</span><span class="p">;</span>
	<span class="n">port_num</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">portnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm_addr</span> <span class="o">=</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_num</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s port %d USB2 hardware LPM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;enable&quot;</span> <span class="o">:</span> <span class="s">&quot;disable&quot;</span><span class="p">,</span> <span class="n">port_num</span><span class="p">);</span>

	<span class="n">hird</span> <span class="o">=</span> <span class="n">xhci_calculate_hird_besl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_HIRD_MASK</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_HIRD</span><span class="p">(</span><span class="n">hird</span><span class="p">)</span> <span class="o">|</span> <span class="n">PORT_RWE</span><span class="p">;</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_HLE</span><span class="p">;</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_HLE</span> <span class="o">|</span> <span class="n">PORT_RWE</span> <span class="o">|</span> <span class="n">PORT_HIRD_MASK</span><span class="p">);</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">pm_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_update_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_usb2_software_lpm_test</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;software LPM test succeed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hw_lpm_support</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_set_usb2_hardware_lpm</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">udev</span><span class="o">-&gt;</span><span class="n">usb2_hw_lpm_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="kt">int</span> <span class="nf">xhci_set_usb2_hardware_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_update_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_SUSPEND */</span><span class="cp"></span>

<span class="cm">/*---------------------- USB 3.0 Link PM functions ------------------------*/</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/* Service interval in nanoseconds = 2^(bInterval - 1) * 125us * 1000ns / 1us */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">xhci_service_interval_to_ns</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bInterval</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">125</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">xhci_get_timeout_no_hub_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">pel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sel_pel</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">state_name</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U1</span>:
		<span class="cm">/* Convert SEL and PEL stored in nanoseconds to microseconds */</span>
		<span class="n">sel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">sel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="n">pel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">pel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="n">max_sel_pel</span> <span class="o">=</span> <span class="n">USB3_LPM_MAX_U1_SEL_PEL</span><span class="p">;</span>
		<span class="n">state_name</span> <span class="o">=</span> <span class="s">&quot;U1&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB3_LPM_U2</span>:
		<span class="n">sel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">sel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="n">pel</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">pel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="n">max_sel_pel</span> <span class="o">=</span> <span class="n">USB3_LPM_MAX_U2_SEL_PEL</span><span class="p">;</span>
		<span class="n">state_name</span> <span class="o">=</span> <span class="s">&quot;U2&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t get timeout for non-U1 or U2 state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sel</span> <span class="o">&lt;=</span> <span class="n">max_sel_pel</span> <span class="o">&amp;&amp;</span> <span class="n">pel</span> <span class="o">&lt;=</span> <span class="n">max_sel_pel</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB3_LPM_DEVICE_INITIATED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sel</span> <span class="o">&gt;</span> <span class="n">max_sel_pel</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device-initiated %s disabled &quot;</span>
				<span class="s">&quot;due to long SEL %llu ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">state_name</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device-initiated %s disabled &quot;</span>
				<span class="s">&quot;due to long PEL %llu</span><span class="se">\n</span><span class="s"> ms&quot;</span><span class="p">,</span>
				<span class="n">state_name</span><span class="p">,</span> <span class="n">pel</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns the hub-encoded U1 timeout value.</span>
<span class="cm"> * The U1 timeout should be the maximum of the following values:</span>
<span class="cm"> *  - For control endpoints, U1 system exit latency (SEL) * 3</span>
<span class="cm"> *  - For bulk endpoints, U1 SEL * 5</span>
<span class="cm"> *  - For interrupt endpoints:</span>
<span class="cm"> *    - Notification EPs, U1 SEL * 3</span>
<span class="cm"> *    - Periodic EPs, max(105% of bInterval, U1 SEL * 2)</span>
<span class="cm"> *  - For isochronous endpoints, max(105% of bInterval, U1 SEL * 2)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">xhci_calculate_intel_u1_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timeout_ns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ep_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">intr_type</span><span class="p">;</span>

	<span class="n">ep_type</span> <span class="o">=</span> <span class="n">usb_endpoint_type</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ep_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_CONTROL</span>:
		<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">sel</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_BULK</span>:
		<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">sel</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_INT</span>:
		<span class="n">intr_type</span> <span class="o">=</span> <span class="n">usb_endpoint_interrupt_type</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_INTR_NOTIFICATION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">sel</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Otherwise the calculation is the same as isoc eps */</span>
	<span class="k">case</span> <span class="n">USB_ENDPOINT_XFER_ISOC</span>:
		<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">xhci_service_interval_to_ns</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP_ULL</span><span class="p">(</span><span class="n">timeout_ns</span> <span class="o">*</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout_ns</span> <span class="o">&lt;</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">sel</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">sel</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The U1 timeout is encoded in 1us intervals. */</span>
	<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP_ULL</span><span class="p">(</span><span class="n">timeout_ns</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t return a timeout of zero, because that&#39;s USB3_LPM_DISABLED. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_ns</span> <span class="o">==</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">)</span>
		<span class="n">timeout_ns</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If the necessary timeout value is bigger than what we can set in the</span>
<span class="cm">	 * USB 3.0 hub, we have to disable hub-initiated U1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_ns</span> <span class="o">&lt;=</span> <span class="n">USB3_LPM_U1_MAX_TIMEOUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">timeout_ns</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Hub-initiated U1 disabled &quot;</span>
			<span class="s">&quot;due to long timeout %llu ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout_ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xhci_get_timeout_no_hub_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB3_LPM_U1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns the hub-encoded U2 timeout value.</span>
<span class="cm"> * The U2 timeout should be the maximum of:</span>
<span class="cm"> *  - 10 ms (to avoid the bandwidth impact on the scheduler)</span>
<span class="cm"> *  - largest bInterval of any active periodic endpoint (to avoid going</span>
<span class="cm"> *    into lower power link states between intervals).</span>
<span class="cm"> *  - the U2 Exit Latency of the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">xhci_calculate_intel_u2_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timeout_ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u2_del_ns</span><span class="p">;</span>

	<span class="n">timeout_ns</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">usb_endpoint_xfer_int</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span> <span class="n">usb_endpoint_xfer_isoc</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">xhci_service_interval_to_ns</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout_ns</span><span class="p">))</span>
		<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">xhci_service_interval_to_ns</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="n">u2_del_ns</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">bos</span><span class="o">-&gt;</span><span class="n">ss_cap</span><span class="o">-&gt;</span><span class="n">bU2DevExitLat</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u2_del_ns</span> <span class="o">&gt;</span> <span class="n">timeout_ns</span><span class="p">)</span>
		<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">u2_del_ns</span><span class="p">;</span>

	<span class="cm">/* The U2 timeout is encoded in 256us intervals */</span>
	<span class="n">timeout_ns</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP_ULL</span><span class="p">(</span><span class="n">timeout_ns</span><span class="p">,</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="cm">/* If the necessary timeout value is bigger than what we can set in the</span>
<span class="cm">	 * USB 3.0 hub, we have to disable hub-initiated U2.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_ns</span> <span class="o">&lt;=</span> <span class="n">USB3_LPM_U2_MAX_TIMEOUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">timeout_ns</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Hub-initiated U2 disabled &quot;</span>
			<span class="s">&quot;due to long timeout %llu ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout_ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xhci_get_timeout_no_hub_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB3_LPM_U2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">xhci_call_host_update_timeout_for_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_INTEL_HOST</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">xhci_calculate_intel_u1_timeout</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_INTEL_HOST</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">xhci_calculate_intel_u2_timeout</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_update_timeout_for_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">alt_timeout</span><span class="p">;</span>

	<span class="n">alt_timeout</span> <span class="o">=</span> <span class="n">xhci_call_host_update_timeout_for_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span>
		<span class="n">desc</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="cm">/* If we found we can&#39;t enable hub-initiated LPM, or</span>
<span class="cm">	 * the U1 or U2 exit latency was too high to allow</span>
<span class="cm">	 * device-initiated LPM as well, just stop searching.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alt_timeout</span> <span class="o">==</span> <span class="n">USB3_LPM_DISABLED</span> <span class="o">||</span>
			<span class="n">alt_timeout</span> <span class="o">==</span> <span class="n">USB3_LPM_DEVICE_INITIATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">alt_timeout</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alt_timeout</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">alt_timeout</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_update_timeout_for_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_update_timeout_for_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">alt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_intel_tier_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_hubs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t enable U1 if the device is on a 2nd tier hub or lower. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">parent</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">num_hubs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">num_hubs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_hubs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Disabling U1 link state for device&quot;</span>
			<span class="s">&quot; below second-tier hub.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Plug device into first-tier hub &quot;</span>
			<span class="s">&quot;to decrease power consumption.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_check_tier_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_INTEL_HOST</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xhci_check_intel_tier_policy</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns the U1 or U2 timeout that should be enabled.</span>
<span class="cm"> * If the tier check or timeout setting functions return with a non-zero exit</span>
<span class="cm"> * code, that means the timeout value has been finalized and we shouldn&#39;t look</span>
<span class="cm"> * at any more endpoints.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">xhci_calculate_lpm_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">state_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U1</span><span class="p">)</span>
		<span class="n">state_name</span> <span class="o">=</span> <span class="s">&quot;U1&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB3_LPM_U2</span><span class="p">)</span>
		<span class="n">state_name</span> <span class="o">=</span> <span class="s">&quot;U2&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t enable unknown link state %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">state</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_check_tier_policy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* Gather some information about the currently installed configuration</span>
<span class="cm">	 * and alternate interface settings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci_update_timeout_for_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep0</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span>
			<span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">config</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">config</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">USB_MAXINTERFACES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check if any currently bound drivers want hub-initiated LPM</span>
<span class="cm">		 * disabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">driver</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_hub_initiated_lpm</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Hub-initiated %s disabled &quot;</span>
						<span class="s">&quot;at request of driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">state_name</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">xhci_get_timeout_no_hub_lpm</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Not sure how this could happen... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xhci_update_timeout_for_interface</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span>
					<span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">,</span>
					<span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue an Evaluate Context command to change the Maximum Exit Latency in the</span>
<span class="cm"> * slot context.  If that succeeds, store the new MEL in the xhci_virt_device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_change_max_exit_latency</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">max_exit_latency</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_exit_latency</span> <span class="o">==</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">current_mel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Attempt to issue an Evaluate Context command to change the MEL. */</span>
	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="n">command</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lpm_command</span><span class="p">;</span>
	<span class="n">xhci_slot_copy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SLOT_FLAG</span><span class="p">);</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info2</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">MAX_EXIT</span><span class="p">));</span>
	<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info2</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">max_exit_latency</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Set up evaluate context for LPM MEL change.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot %u Input Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Issue and wait for the evaluate context command. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
			<span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot %u Output Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">current_mel</span> <span class="o">=</span> <span class="n">max_exit_latency</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">calculate_max_exit_latency</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state_changed</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">hub_encoded_timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u1_mel_us</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u2_mel_us</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">mel_us</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disabling_u1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disabling_u2</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enabling_u1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enabling_u2</span><span class="p">;</span>

	<span class="n">disabling_u1</span> <span class="o">=</span> <span class="p">(</span><span class="n">state_changed</span> <span class="o">==</span> <span class="n">USB3_LPM_U1</span> <span class="o">&amp;&amp;</span>
			<span class="n">hub_encoded_timeout</span> <span class="o">==</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">);</span>
	<span class="n">disabling_u2</span> <span class="o">=</span> <span class="p">(</span><span class="n">state_changed</span> <span class="o">==</span> <span class="n">USB3_LPM_U2</span> <span class="o">&amp;&amp;</span>
			<span class="n">hub_encoded_timeout</span> <span class="o">==</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">);</span>

	<span class="n">enabling_u1</span> <span class="o">=</span> <span class="p">(</span><span class="n">state_changed</span> <span class="o">==</span> <span class="n">USB3_LPM_U1</span> <span class="o">&amp;&amp;</span>
			<span class="n">hub_encoded_timeout</span> <span class="o">!=</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">);</span>
	<span class="n">enabling_u2</span> <span class="o">=</span> <span class="p">(</span><span class="n">state_changed</span> <span class="o">==</span> <span class="n">USB3_LPM_U2</span> <span class="o">&amp;&amp;</span>
			<span class="n">hub_encoded_timeout</span> <span class="o">!=</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">);</span>

	<span class="cm">/* If U1 was already enabled and we&#39;re not disabling it,</span>
<span class="cm">	 * or we&#39;re going to enable U1, account for the U1 max exit latency.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">timeout</span> <span class="o">!=</span> <span class="n">USB3_LPM_DISABLED</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">disabling_u1</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">enabling_u1</span><span class="p">)</span>
		<span class="n">u1_mel_us</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u1_params</span><span class="p">.</span><span class="n">mel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">timeout</span> <span class="o">!=</span> <span class="n">USB3_LPM_DISABLED</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">disabling_u2</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">enabling_u2</span><span class="p">)</span>
		<span class="n">u2_mel_us</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">u2_params</span><span class="p">.</span><span class="n">mel</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u1_mel_us</span> <span class="o">&gt;</span> <span class="n">u2_mel_us</span><span class="p">)</span>
		<span class="n">mel_us</span> <span class="o">=</span> <span class="n">u1_mel_us</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mel_us</span> <span class="o">=</span> <span class="n">u2_mel_us</span><span class="p">;</span>
	<span class="cm">/* xHCI host controller max exit latency field is only 16 bits wide. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mel_us</span> <span class="o">&gt;</span> <span class="n">MAX_EXIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Link PM max exit latency of %lluus &quot;</span>
				<span class="s">&quot;is too big.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mel_us</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mel_us</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns the USB3 hub-encoded value for the U1/U2 timeout. */</span>
<span class="kt">int</span> <span class="nf">xhci_enable_usb3_lpm_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hub_encoded_timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="cm">/* The LPM timeout values are pretty host-controller specific, so don&#39;t</span>
<span class="cm">	 * enable hub-initiated timeouts unless the vendor has provided</span>
<span class="cm">	 * information about their timeout algorithm.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_LPM_SUPPORT</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">;</span>

	<span class="n">hub_encoded_timeout</span> <span class="o">=</span> <span class="n">xhci_calculate_lpm_timeout</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">mel</span> <span class="o">=</span> <span class="n">calculate_max_exit_latency</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">hub_encoded_timeout</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Max Exit Latency is too big, disable LPM. */</span>
		<span class="n">hub_encoded_timeout</span> <span class="o">=</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">;</span>
		<span class="n">mel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_change_max_exit_latency</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">mel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hub_encoded_timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_disable_usb3_lpm_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">XHCI_LPM_SUPPORT</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mel</span> <span class="o">=</span> <span class="n">calculate_max_exit_latency</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_change_max_exit_latency</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">mel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">xhci_enable_usb3_lpm_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">USB3_LPM_DISABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_disable_usb3_lpm_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Once a hub descriptor is fetched for a device, we need to update the xHC&#39;s</span>
<span class="cm"> * internal data structures for the device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_update_hub_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_tt</span> <span class="o">*</span><span class="n">tt</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">config_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_input_control_ctx</span> <span class="o">*</span><span class="n">ctrl_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_slot_ctx</span> <span class="o">*</span><span class="n">slot_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">think_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Ignore root hubs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vdev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Cannot update hub desc for unknown device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">config_cmd</span> <span class="o">=</span> <span class="n">xhci_alloc_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">config_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Could not allocate xHCI command structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span> <span class="o">&amp;&amp;</span>
			<span class="n">xhci_alloc_tt_info</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">vdev</span><span class="p">,</span> <span class="n">hdev</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Could not allocate xHCI TT structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci_slot_copy</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span> <span class="o">=</span> <span class="n">xhci_get_input_control_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">ctrl_ctx</span><span class="o">-&gt;</span><span class="n">add_flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SLOT_FLAG</span><span class="p">);</span>
	<span class="n">slot_ctx</span> <span class="o">=</span> <span class="n">xhci_get_slot_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">);</span>
	<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DEV_HUB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">multi</span><span class="p">)</span>
		<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DEV_MTT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&gt;</span> <span class="mh">0x95</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI version %x needs hub &quot;</span>
				<span class="s">&quot;TT think time and number of ports</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span><span class="p">);</span>
		<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_info2</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">XHCI_MAX_PORTS</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">maxchild</span><span class="p">));</span>
		<span class="cm">/* Set TT think time - convert from ns to FS bit times.</span>
<span class="cm">		 * 0 = 8 FS bit times, 1 = 16 FS bit times,</span>
<span class="cm">		 * 2 = 24 FS bit times, 3 = 32 FS bit times.</span>
<span class="cm">		 *</span>
<span class="cm">		 * xHCI 1.0: this field shall be 0 if the device is not a</span>
<span class="cm">		 * High-spped hub.</span>
<span class="cm">		 */</span>
		<span class="n">think_time</span> <span class="o">=</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">think_time</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">think_time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">think_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">think_time</span> <span class="o">/</span> <span class="mi">666</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&lt;</span> <span class="mh">0x100</span> <span class="o">||</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
			<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">tt_info</span> <span class="o">|=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">TT_THINK_TIME</span><span class="p">(</span><span class="n">think_time</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;xHCI version %x doesn&#39;t need hub &quot;</span>
				<span class="s">&quot;TT think time or number of ports</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">slot_ctx</span><span class="o">-&gt;</span><span class="n">dev_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Set up %s for hub device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&gt;</span> <span class="mh">0x95</span><span class="p">)</span> <span class="o">?</span>
			<span class="s">&quot;configure endpoint&quot;</span> <span class="o">:</span> <span class="s">&quot;evaluate context&quot;</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot %u Input Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="o">-&gt;</span><span class="n">in_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Issue and wait for the configure endpoint or</span>
<span class="cm">	 * evaluate context command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">&gt;</span> <span class="mh">0x95</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">hdev</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">,</span>
				<span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xhci_configure_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">hdev</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">,</span>
				<span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Slot %u Output Context:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">slot_id</span><span class="p">);</span>
	<span class="n">xhci_dbg_ctx</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">out_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">config_cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="cm">/* EHCI mods by the periodic size.  Why? */</span>
	<span class="k">return</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">run_regs</span><span class="o">-&gt;</span><span class="n">microframe_index</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_gen_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci_get_quirks_t</span> <span class="n">get_quirks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>		<span class="o">*</span><span class="n">xhci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* Accept arbitrarily long scatter-gather lists */</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="o">*</span><span class="p">((</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">**</span><span class="p">)</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">)</span> <span class="o">=</span> <span class="n">xhci</span><span class="p">;</span>
		<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">main_hcd</span> <span class="o">=</span> <span class="n">hcd</span><span class="p">;</span>
		<span class="cm">/* Mark the first roothub as being USB 2.0.</span>
<span class="cm">		 * The xHCI driver will register the USB 3.0 roothub.</span>
<span class="cm">		 */</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">HCD_USB2</span><span class="p">;</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * USB 2.0 roothub under xHCI has an integrated TT,</span>
<span class="cm">		 * (rate matching hub) as opposed to having an OHCI/UHCI</span>
<span class="cm">		 * companion controller.</span>
<span class="cm">		 */</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">has_tt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* xHCI private pointer was set in xhci_pci_probe for the second</span>
<span class="cm">		 * registered roothub.</span>
<span class="cm">		 */</span>
		<span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HCC_64BIT_ADDR</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Enabling 64-bit DMA addresses.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dma_set_mask</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dma_set_mask</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
		<span class="n">HC_LENGTH</span><span class="p">(</span><span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">));</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">run_regs</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">run_regs_off</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTSOFF_MASK</span><span class="p">);</span>
	<span class="cm">/* Cache read-only capability registers */</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcs_params1</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcs_params1</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcs_params2</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcs_params2</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcs_params3</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcs_params3</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcc_params</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hci_version</span> <span class="o">=</span> <span class="n">HC_VERSION</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
	<span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcc_params</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
	<span class="n">xhci_print_registers</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>

	<span class="n">get_quirks</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">xhci</span><span class="p">);</span>

	<span class="cm">/* Make sure the HC is halted. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_halt</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Resetting HCD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Reset the internal HC memory state and registers. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_reset</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Reset complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_64BIT_ADDR</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Enabling 64-bit DMA addresses.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dma_set_mask</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dma_set_mask</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Calling HCD init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Initialize HCD and host controller data structures. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_init</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Called HCD init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xhci_hcd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_register_pci</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Problem registering PCI driver.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xhci_register_plat</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Problem registering platform driver.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unreg_pci</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check the compiler generated sizes of structures that must be laid</span>
<span class="cm">	 * out in specific ways for hardware access.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_doorbell_array</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">256</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_slot_ctx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_ep_ctx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* xhci_device_control has eight fields, and also</span>
<span class="cm">	 * embeds one xhci_slot_ctx and 31 xhci_ep_ctx</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_stream_ctx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">xhci_trb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_erst_entry</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_cap_regs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">7</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_intr_reg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* xhci_run_regs has eight fields and embeds 128 xhci_intr_regs */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_run_regs</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">8</span><span class="o">+</span><span class="mi">8</span><span class="o">*</span><span class="mi">128</span><span class="p">)</span><span class="o">*</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unreg_pci:</span>
	<span class="n">xhci_unregister_pci</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">xhci_hcd_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">xhci_hcd_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xhci_unregister_pci</span><span class="p">();</span>
	<span class="n">xhci_unregister_plat</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">xhci_hcd_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
