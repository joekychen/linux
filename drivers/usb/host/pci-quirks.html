<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › pci-quirks.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pci-quirks.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_USB_PCI_QUIRKS_H</span>
<span class="cp">#define __LINUX_USB_PCI_QUIRKS_H</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="kt">void</span> <span class="n">uhci_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uhci_check_and_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usb_amd_find_chipset_info</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_amd_dev_put</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_amd_quirk_pll_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_amd_quirk_pll_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">usb_is_intel_switchable_xhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_enable_xhci_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">xhci_pdev</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_amd_quirk_pll_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_amd_quirk_pll_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_amd_dev_put</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cp">#endif  </span><span class="cm">/*  __LINUX_USB_PCI_QUIRKS_H  */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
CI_CTRL_IR		(1 &lt;&lt; 8)	</span><span class="cm">/* interrupt routing */</span><span class="cp"></span>
<span class="cp">#define OHCI_INTR_OC		(1 &lt;&lt; 30)	</span><span class="cm">/* ownership change */</span><span class="cp"></span>

<span class="cp">#define EHCI_HCC_PARAMS		0x08		</span><span class="cm">/* extended capabilities */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBCMD		0		</span><span class="cm">/* command register */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBCMD_RUN		(1 &lt;&lt; 0)	</span><span class="cm">/* RUN/STOP bit */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBSTS		4		</span><span class="cm">/* status register */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBSTS_HALTED	(1 &lt;&lt; 12)	</span><span class="cm">/* HCHalted bit */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBINTR		8		</span><span class="cm">/* interrupt register */</span><span class="cp"></span>
<span class="cp">#define EHCI_CONFIGFLAG		0x40		</span><span class="cm">/* configured flag register */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBLEGSUP		0		</span><span class="cm">/* legacy support register */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBLEGSUP_BIOS	(1 &lt;&lt; 16)	</span><span class="cm">/* BIOS semaphore */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBLEGSUP_OS	(1 &lt;&lt; 24)	</span><span class="cm">/* OS semaphore */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBLEGCTLSTS	4		</span><span class="cm">/* legacy control/status */</span><span class="cp"></span>
<span class="cp">#define EHCI_USBLEGCTLSTS_SOOE	(1 &lt;&lt; 13)	</span><span class="cm">/* SMI on ownership change */</span><span class="cp"></span>

<span class="cm">/* AMD quirk use */</span>
<span class="cp">#define	AB_REG_BAR_LOW		0xe0</span>
<span class="cp">#define	AB_REG_BAR_HIGH		0xe1</span>
<span class="cp">#define	AB_REG_BAR_SB700	0xf0</span>
<span class="cp">#define	AB_INDX(addr)		((addr) + 0x00)</span>
<span class="cp">#define	AB_DATA(addr)		((addr) + 0x04)</span>
<span class="cp">#define	AX_INDXC		0x30</span>
<span class="cp">#define	AX_DATAC		0x34</span>

<span class="cp">#define	NB_PCIE_INDX_ADDR	0xe0</span>
<span class="cp">#define	NB_PCIE_INDX_DATA	0xe4</span>
<span class="cp">#define	PCIE_P_CNTL		0x10040</span>
<span class="cp">#define	BIF_NB			0x10002</span>
<span class="cp">#define	NB_PIF0_PWRDOWN_0	0x01100012</span>
<span class="cp">#define	NB_PIF0_PWRDOWN_1	0x01100013</span>

<span class="cp">#define USB_INTEL_XUSB2PR      0xD0</span>
<span class="cp">#define USB_INTEL_USB3_PSSEN   0xD8</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">amd_chipset_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">nb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">smbus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nb_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sb_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">isoc_reqs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe_result</span><span class="p">;</span>
<span class="p">}</span> <span class="n">amd_chipset</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">amd_lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usb_amd_find_chipset_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">rev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">amd_chipset_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* probe only once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_result</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4385</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rev</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">&gt;=</span> <span class="mh">0x40</span><span class="p">)</span>
			<span class="n">info</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">&gt;=</span> <span class="mh">0x30</span> <span class="o">&amp;&amp;</span> <span class="n">rev</span> <span class="o">&lt;=</span> <span class="mh">0x3b</span><span class="p">)</span>
			<span class="n">info</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>
						<span class="mh">0x780b</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">commit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rev</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">&gt;=</span> <span class="mh">0x11</span> <span class="o">&amp;&amp;</span> <span class="n">rev</span> <span class="o">&lt;=</span> <span class="mh">0x18</span><span class="p">)</span>
			<span class="n">info</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">);</span>
			<span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">commit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="mh">0x9601</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="p">.</span><span class="n">nb_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="mh">0x1510</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="p">.</span><span class="n">nb_type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>
						     <span class="mh">0x9600</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">)</span>
				<span class="n">info</span><span class="p">.</span><span class="n">nb_type</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">probe_result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;QUIRK: Enable AMD PLL fix</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">commit:</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* race - someone else was faster - drop devices */</span>

		<span class="cm">/* Mark that we where here */</span>
		<span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_result</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">)</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">)</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* no race - commit the result */</span>
		<span class="n">info</span><span class="p">.</span><span class="n">probe_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">amd_chipset</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_amd_find_chipset_info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The hardware normally enables the A-link power management feature, which</span>
<span class="cm"> * lets the system lower the power consumption in idle states.</span>
<span class="cm"> *</span>
<span class="cm"> * This USB quirk prevents the link going into that lower power state</span>
<span class="cm"> * during isochronous transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * Without this quirk, isochronous stream on OHCI/EHCI/xHCI controllers of</span>
<span class="cm"> * some AMD platforms may stutter or have breaks occasionally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_amd_quirk_pll</span><span class="p">(</span><span class="kt">int</span> <span class="n">disable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr_low</span><span class="p">,</span> <span class="n">addr_high</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">disable</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amd_chipset</span><span class="p">.</span><span class="n">isoc_reqs</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">isoc_reqs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">amd_chipset</span><span class="p">.</span><span class="n">isoc_reqs</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">isoc_reqs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">amd_chipset</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">AB_REG_BAR_LOW</span><span class="p">,</span> <span class="mh">0xcd6</span><span class="p">);</span>
		<span class="n">addr_low</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="mh">0xcd7</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">AB_REG_BAR_HIGH</span><span class="p">,</span> <span class="mh">0xcd6</span><span class="p">);</span>
		<span class="n">addr_high</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="mh">0xcd7</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">addr_high</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">addr_low</span><span class="p">;</span>

		<span class="n">outl_p</span><span class="p">(</span><span class="mh">0x30</span><span class="p">,</span> <span class="n">AB_INDX</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">outl_p</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">AB_DATA</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">outl_p</span><span class="p">(</span><span class="mh">0x34</span><span class="p">,</span> <span class="n">AB_INDX</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">inl_p</span><span class="p">(</span><span class="n">AB_DATA</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">,</span>
					<span class="n">AB_REG_BAR_SB700</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">outl</span><span class="p">(</span><span class="n">AX_INDXC</span><span class="p">,</span> <span class="n">AB_INDX</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">outl</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">AB_DATA</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">outl</span><span class="p">(</span><span class="n">AX_DATAC</span><span class="p">,</span> <span class="n">AB_INDX</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">inl</span><span class="p">(</span><span class="n">AB_DATA</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x08</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x08</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">outl_p</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">AB_DATA</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">PCIE_P_CNTL</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_ADDR</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">));</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">bit</span> <span class="o">|</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="p">((</span><span class="o">!</span><span class="n">bit</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="o">!</span><span class="n">bit</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">BIF_NB</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_ADDR</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">NB_PIF0_PWRDOWN_0</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_ADDR</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3f</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x3f</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>

		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">NB_PIF0_PWRDOWN_1</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_ADDR</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3f</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x3f</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>

		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">,</span>
					<span class="n">NB_PCIE_INDX_DATA</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_amd_quirk_pll_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_amd_quirk_pll</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_amd_quirk_pll_disable</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usb_amd_quirk_pll_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_amd_quirk_pll</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_amd_quirk_pll_enable</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">usb_amd_dev_put</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="o">*</span><span class="n">smbus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_count</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save them to pci_dev_put outside of spinlock */</span>
	<span class="n">nb</span>    <span class="o">=</span> <span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span><span class="p">;</span>
	<span class="n">smbus</span> <span class="o">=</span> <span class="n">amd_chipset</span><span class="p">.</span><span class="n">smbus_dev</span><span class="p">;</span>

	<span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">amd_chipset</span><span class="p">.</span><span class="n">smbus_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">amd_chipset</span><span class="p">.</span><span class="n">nb_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">amd_chipset</span><span class="p">.</span><span class="n">sb_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">amd_chipset</span><span class="p">.</span><span class="n">isoc_reqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">amd_chipset</span><span class="p">.</span><span class="n">probe_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smbus</span><span class="p">)</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">smbus</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_amd_dev_put</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Make sure the controller is completely inactive, unable to</span>
<span class="cm"> * generate interrupts or do DMA.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uhci_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Turn off PIRQ enable and SMI enable.  (This also turns off the</span>
<span class="cm">	 * BIOS&#39;s USB Legacy Support.)  Turn off all the R/WC bits too.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">UHCI_USBLEGSUP</span><span class="p">,</span> <span class="n">UHCI_USBLEGSUP_RWC</span><span class="p">);</span>

	<span class="cm">/* Reset the HC - this will force us to get a</span>
<span class="cm">	 * new notification of any already connected</span>
<span class="cm">	 * ports due to the virtual disconnect that it</span>
<span class="cm">	 * implies.</span>
<span class="cm">	 */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">UHCI_USBCMD_HCRESET</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">UHCI_USBCMD</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">UHCI_USBCMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UHCI_USBCMD_HCRESET</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HCRESET not completed yet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Just to be safe, disable interrupt requests and</span>
<span class="cm">	 * make sure the controller is stopped.</span>
<span class="cm">	 */</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">UHCI_USBINTR</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">UHCI_USBCMD</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uhci_reset_hc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize a controller that was newly discovered or has just been</span>
<span class="cm"> * resumed.  In either case we can&#39;t be sure of its previous state.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 1 if the controller was reset, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uhci_check_and_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">legsup</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">intr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When restarting a suspended controller, we expect all the</span>
<span class="cm">	 * settings to be the same as we left them:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	PIRQ and SMI disabled, no R/W bits set in USBLEGSUP;</span>
<span class="cm">	 *	Controller is stopped and configured with EGSM set;</span>
<span class="cm">	 *	No interrupts enabled except possibly Resume Detect.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If any of these conditions are violated we do a complete reset.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">UHCI_USBLEGSUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">legsup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">legsup</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">UHCI_USBLEGSUP_RO</span> <span class="o">|</span> <span class="n">UHCI_USBLEGSUP_RWC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: legsup = 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">legsup</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reset_needed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">UHCI_USBCMD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">UHCI_USBCMD_RUN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">UHCI_USBCMD_CONFIGURE</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">UHCI_USBCMD_EGSM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cmd = 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reset_needed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">intr</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">UHCI_USBINTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">UHCI_USBINTR_RESUME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: intr = 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">intr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reset_needed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">reset_needed:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Performing full reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">uhci_reset_hc</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uhci_check_and_reset_hc</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">io_type_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define pio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_IO)</span>
<span class="cp">#define mmio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_MEMORY)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_usb_handoff_uhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio_enabled</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_ROM_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span>
		<span class="n">uhci_check_and_reset_hc</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">mmio_resource_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mmio_enabled</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_usb_handoff_ohci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">control</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fminterval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmio_resource_enabled</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">control</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CONTROL</span><span class="p">);</span>

<span class="cm">/* On PA-RISC, PDC can leave IR set incorrectly; ignore it there. */</span>
<span class="cp">#ifdef __hppa__</span>
<span class="cp">#define	OHCI_CTRL_MASK		(OHCI_CTRL_RWC | OHCI_CTRL_IR)</span>
<span class="cp">#else</span>
<span class="cp">#define	OHCI_CTRL_MASK		OHCI_CTRL_RWC</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_IR</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">wait_time</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span> <span class="cm">/* arbitrary; 5 seconds */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">OHCI_INTR_OC</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_INTRENABLE</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">OHCI_OCR</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CMDSTATUS</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">wait_time</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_IR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_time</span> <span class="o">-=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_time</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OHCI: BIOS handoff failed&quot;</span>
					<span class="s">&quot; (BIOS bug?) %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CONTROL</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* disable interrupts */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_INTRDISABLE</span><span class="p">);</span>

	<span class="cm">/* Reset the USB bus, if the controller isn&#39;t already in RESET */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">OHCI_HCFS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Go into RESET, preserving RWC (and possibly IR) */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_MASK</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CONTROL</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CONTROL</span><span class="p">);</span>

		<span class="cm">/* drive bus reset for at least 50 ms (7.1.7.5) */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* software reset of the controller, preserving HcFmInterval */</span>
	<span class="n">fminterval</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_FMINTERVAL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">OHCI_HCR</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CMDSTATUS</span><span class="p">);</span>

	<span class="cm">/* reset requires max 10 us delay */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* ... allow extra time */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_CMDSTATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OHCI_HCR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">fminterval</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">OHCI_FMINTERVAL</span><span class="p">);</span>

	<span class="cm">/* Now the controller is safely in SUSPEND and nothing can wake it up */</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">__devinitconst</span> <span class="n">ehci_dmi_nohandoff_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="cm">/*  Pegatron Lucid (ExoPC) */</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BOARD_NAME</span><span class="p">,</span> <span class="s">&quot;EXOPG06411&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;Lucid-CE-133&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="cm">/*  Pegatron Lucid (Ordissimo AIRIS) */</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BOARD_NAME</span><span class="p">,</span> <span class="s">&quot;M11JB&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;Lucid-GE-133&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">ehci_bios_handoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">op_reg_base</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">cap</span><span class="p">,</span> <span class="n">u8</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">try_handoff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tried_handoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The Pegatron Lucid tablet sporadically waits for 98 seconds trying</span>
<span class="cm">	 * the handoff on its unused controller.  Skip it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="mh">0x8086</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x283a</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dmi_check_system</span><span class="p">(</span><span class="n">ehci_dmi_nohandoff_table</span><span class="p">))</span>
			<span class="n">try_handoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">try_handoff</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">EHCI_USBLEGSUP_BIOS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;EHCI: BIOS handoff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* aleksey_gorelov@phoenix.com reports that some systems need SMI forced on,</span>
<span class="c"> * but that seems dubious in general (the BIOS left it off intentionally)</span>
<span class="c"> * and is known to prevent some systems from booting.  so we won&#39;t do this</span>
<span class="c"> * unless maybe we can determine when we&#39;re on a system that needs SMI forced.</span>
<span class="c"> */</span>
<span class="c">		/* BIOS workaround (?): be sure the pre-Linux code</span>
<span class="c">		 * receives the SMI</span>
<span class="c">		 */</span>
<span class="c">		pci_read_config_dword(pdev, offset + EHCI_USBLEGCTLSTS, &amp;val);</span>
<span class="c">		pci_write_config_dword(pdev, offset + EHCI_USBLEGCTLSTS,</span>
<span class="c">				       val | EHCI_USBLEGCTLSTS_SOOE);</span>
<span class="cp">#endif</span>

		<span class="cm">/* some systems get upset if this semaphore is</span>
<span class="cm">		 * set for any other reason than forcing a BIOS</span>
<span class="cm">		 * handoff..</span>
<span class="cm">		 */</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if boot firmware now owns EHCI, spin till it hands it over. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">try_handoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">msec</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">EHCI_USBLEGSUP_BIOS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tried_handoff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">msec</span> <span class="o">-=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">EHCI_USBLEGSUP_BIOS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* well, possibly buggy BIOS... try to shut it down,</span>
<span class="cm">		 * and hope nothing goes too wrong</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">try_handoff</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;EHCI: BIOS handoff failed&quot;</span>
				 <span class="s">&quot; (BIOS bug?) %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* just in case, always disable EHCI SMIs */</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">EHCI_USBLEGCTLSTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* If the BIOS ever owned the controller then we can&#39;t expect</span>
<span class="cm">	 * any power sessions to remain intact.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tried_handoff</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_CONFIGFLAG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_usb_disable_ehci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">op_reg_base</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">hcc_params</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">offset</span><span class="p">,</span> <span class="n">cap_length</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">wait_time</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">256</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmio_resource_enabled</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cap_length</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="n">op_reg_base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">cap_length</span><span class="p">;</span>

	<span class="cm">/* EHCI 0.96 and later may have &quot;extended capabilities&quot;</span>
<span class="cm">	 * spec section 5.1 explains the bios handoff, e.g. for</span>
<span class="cm">	 * booting from USB disk or using a usb keyboard</span>
<span class="cm">	 */</span>
	<span class="n">hcc_params</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EHCI_HCC_PARAMS</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcc_params</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">ehci_bios_handoff</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">op_reg_base</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* Illegal reserved cap, set cap=0 so we exit */</span>
			<span class="n">cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* then fallthrough... */</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;EHCI: unrecognized capability &quot;</span>
				 <span class="s">&quot;%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cap</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;EHCI: capability loop?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * halt EHCI &amp; disable its interrupts in any case</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_USBSTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">EHCI_USBSTS_HALTED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_USBCMD</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EHCI_USBCMD_RUN</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_USBCMD</span><span class="p">);</span>

		<span class="n">wait_time</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x3f</span><span class="p">,</span> <span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_USBSTS</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="n">wait_time</span> <span class="o">-=</span> <span class="mi">100</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_USBSTS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">EHCI_USBSTS_HALTED</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wait_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_USBINTR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x3f</span><span class="p">,</span> <span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">EHCI_USBSTS</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handshake - spin reading a register until handshake completes</span>
<span class="cm"> * @ptr: address of hc register to be read</span>
<span class="cm"> * @mask: bits to look at in result of read</span>
<span class="cm"> * @done: value of those bits when handshake succeeds</span>
<span class="cm"> * @wait_usec: timeout in microseconds</span>
<span class="cm"> * @delay_usec: delay in microseconds to wait between polling</span>
<span class="cm"> *</span>
<span class="cm"> * Polls a register every delay_usec microseconds.</span>
<span class="cm"> * Returns 0 when the mask bits have the value done.</span>
<span class="cm"> * Returns -ETIMEDOUT if this condition is not true after</span>
<span class="cm"> * wait_usec microseconds have passed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">wait_usec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay_usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">result</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">delay_usec</span><span class="p">);</span>
		<span class="n">wait_usec</span> <span class="o">-=</span> <span class="n">delay_usec</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wait_usec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PCI_DEVICE_ID_INTEL_LYNX_POINT_XHCI	0x8C31</span>

<span class="n">bool</span> <span class="nf">usb_is_intel_ppt_switchable_xhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_SERIAL_USB_XHCI</span> <span class="o">&amp;&amp;</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_INTEL</span> <span class="o">&amp;&amp;</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The Intel Lynx Point chipset also has switchable ports. */</span>
<span class="n">bool</span> <span class="nf">usb_is_intel_lpt_switchable_xhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_SERIAL_USB_XHCI</span> <span class="o">&amp;&amp;</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_INTEL</span> <span class="o">&amp;&amp;</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_LYNX_POINT_XHCI</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">usb_is_intel_switchable_xhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_is_intel_ppt_switchable_xhci</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">usb_is_intel_lpt_switchable_xhci</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_is_intel_switchable_xhci</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Intel&#39;s Panther Point chipset has two host controllers (EHCI and xHCI) that</span>
<span class="cm"> * share some number of ports.  These ports can be switched between either</span>
<span class="cm"> * controller.  Not all of the ports under the EHCI host controller may be</span>
<span class="cm"> * switchable.</span>
<span class="cm"> *</span>
<span class="cm"> * The ports should be switched over to xHCI before PCI probes for any device</span>
<span class="cm"> * start.  This avoids active devices under EHCI being disconnected during the</span>
<span class="cm"> * port switchover, which could cause loss of data on USB storage devices, or</span>
<span class="cm"> * failed boot when the root file system is on a USB mass storage device and is</span>
<span class="cm"> * enumerated under EHCI first.</span>
<span class="cm"> *</span>
<span class="cm"> * We write into the xHC&#39;s PCI configuration space in some Intel-specific</span>
<span class="cm"> * registers to switch the ports over.  The USB 3.0 terminations and the USB</span>
<span class="cm"> * 2.0 data wires are switched separately.  We want to enable the SuperSpeed</span>
<span class="cm"> * terminations before switching the USB 2.0 wires over, so that USB 3.0</span>
<span class="cm"> * devices connect at SuperSpeed, rather than at USB 2.0 speeds.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_enable_xhci_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">xhci_pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">ports_available</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t switchover the ports if the user hasn&#39;t compiled the xHCI</span>
<span class="cm">	 * driver.  Otherwise they will see &quot;dead&quot; USB ports that don&#39;t power</span>
<span class="cm">	 * the devices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_USB_XHCI_HCD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci_pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;CONFIG_USB_XHCI_HCD is turned off, &quot;</span>
				<span class="s">&quot;defaulting to EHCI.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci_pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;USB 3.0 devices will work at USB 2.0 speeds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ports_available</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="cm">/* Write USB3_PSSEN, the USB 3.0 Port SuperSpeed Enable</span>
<span class="cm">	 * Register, to turn on SuperSpeed terminations for all</span>
<span class="cm">	 * available ports.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">xhci_pdev</span><span class="p">,</span> <span class="n">USB_INTEL_USB3_PSSEN</span><span class="p">,</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ports_available</span><span class="p">));</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">xhci_pdev</span><span class="p">,</span> <span class="n">USB_INTEL_USB3_PSSEN</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ports_available</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci_pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB 3.0 ports that are now enabled &quot;</span>
			<span class="s">&quot;under xHCI: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ports_available</span><span class="p">);</span>

	<span class="n">ports_available</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="cm">/* Write XUSB2PR, the xHC USB 2.0 Port Routing Register, to</span>
<span class="cm">	 * switch the USB 2.0 power and data lines over to the xHCI</span>
<span class="cm">	 * host.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">xhci_pdev</span><span class="p">,</span> <span class="n">USB_INTEL_XUSB2PR</span><span class="p">,</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ports_available</span><span class="p">));</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">xhci_pdev</span><span class="p">,</span> <span class="n">USB_INTEL_XUSB2PR</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ports_available</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci_pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;USB 2.0 ports that are now switched over &quot;</span>
			<span class="s">&quot;to xHCI: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ports_available</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_enable_xhci_ports</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * PCI Quirks for xHCI.</span>
<span class="cm"> *</span>
<span class="cm"> * Takes care of the handoff between the Pre-OS (i.e. BIOS) and the OS.</span>
<span class="cm"> * It signals to the BIOS that the OS wants control of the host controller,</span>
<span class="cm"> * and then waits 5 seconds for the BIOS to hand over control.</span>
<span class="cm"> * If we timeout, assume the BIOS is broken and take control anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_usb_handoff_xhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ext_cap_offset</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">op_reg_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmio_resource_enabled</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the Legacy Support Capability register -</span>
<span class="cm">	 * this is optional for xHCI host controllers.</span>
<span class="cm">	 */</span>
	<span class="n">ext_cap_offset</span> <span class="o">=</span> <span class="n">xhci_find_next_cap_offset</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">XHCI_HCC_PARAMS_OFFSET</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext_cap_offset</span><span class="p">)</span>
			<span class="cm">/* We&#39;ve reached the end of the extended capabilities */</span>
			<span class="k">goto</span> <span class="n">hc_init</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">ext_cap_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XHCI_EXT_CAPS_ID</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">XHCI_EXT_CAPS_LEGACY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ext_cap_offset</span> <span class="o">=</span> <span class="n">xhci_find_next_cap_offset</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ext_cap_offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* If the BIOS owns the HC, signal that the OS wants it, and wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">XHCI_HC_BIOS_OWNED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">|</span> <span class="n">XHCI_HC_OS_OWNED</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">ext_cap_offset</span><span class="p">);</span>

		<span class="cm">/* Wait for 5 seconds with 10 microsecond polling interval */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">ext_cap_offset</span><span class="p">,</span> <span class="n">XHCI_HC_BIOS_OWNED</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

		<span class="cm">/* Assume a buggy BIOS and take HC ownership anyway */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xHCI BIOS handoff failed&quot;</span>
					<span class="s">&quot; (BIOS bug ?) %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">XHCI_HC_BIOS_OWNED</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">ext_cap_offset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">ext_cap_offset</span> <span class="o">+</span> <span class="n">XHCI_LEGACY_CONTROL_OFFSET</span><span class="p">);</span>
	<span class="cm">/* Mask off (turn off) any enabled SMIs */</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">XHCI_LEGACY_DISABLE_SMI</span><span class="p">;</span>
	<span class="cm">/* Mask all SMI events bits, RW1C */</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">XHCI_LEGACY_SMI_EVENTS</span><span class="p">;</span>
	<span class="cm">/* Disable any BIOS SMIs and clear all SMI events*/</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">ext_cap_offset</span> <span class="o">+</span> <span class="n">XHCI_LEGACY_CONTROL_OFFSET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_is_intel_switchable_xhci</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">usb_enable_xhci_ports</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">hc_init:</span>
	<span class="n">op_reg_base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">XHCI_HC_LENGTH</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span><span class="p">));</span>

	<span class="cm">/* Wait for the host controller to be ready before writing any</span>
<span class="cm">	 * operational or runtime registers.  Wait 5 seconds and no more.</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">XHCI_STS_OFFSET</span><span class="p">,</span> <span class="n">XHCI_STS_CNR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="mi">5000</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="cm">/* Assume a buggy HC and start HC initialization anyway */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">XHCI_STS_OFFSET</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;xHCI HW not ready after 5 sec (HC bug?) &quot;</span>
				<span class="s">&quot;status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Send the halt and disable interrupts command */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">XHCI_CMD_OFFSET</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XHCI_CMD_RUN</span> <span class="o">|</span> <span class="n">XHCI_IRQS</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">XHCI_CMD_OFFSET</span><span class="p">);</span>

	<span class="cm">/* Wait for the HC to halt - poll every 125 usec (one microframe). */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">XHCI_STS_OFFSET</span><span class="p">,</span> <span class="n">XHCI_STS_HALT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">XHCI_MAX_HALT_USEC</span><span class="p">,</span> <span class="mi">125</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">op_reg_base</span> <span class="o">+</span> <span class="n">XHCI_STS_OFFSET</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;xHCI HW did not halt within %d usec &quot;</span>
				<span class="s">&quot;status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">XHCI_MAX_HALT_USEC</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_usb_early_handoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Skip Netlogic mips SoC&#39;s internal PCI USB controller.</span>
<span class="cm">	 * This device does not need/support EHCI/OHCI handoff</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="mh">0x184e</span><span class="p">)</span>	<span class="cm">/* vendor Netlogic */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">PCI_CLASS_SERIAL_USB_UHCI</span> <span class="o">&amp;&amp;</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">PCI_CLASS_SERIAL_USB_OHCI</span> <span class="o">&amp;&amp;</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">PCI_CLASS_SERIAL_USB_EHCI</span> <span class="o">&amp;&amp;</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">PCI_CLASS_SERIAL_USB_XHCI</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t enable PCI device, &quot;</span>
				<span class="s">&quot;BIOS handoff failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_SERIAL_USB_UHCI</span><span class="p">)</span>
		<span class="n">quirk_usb_handoff_uhci</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_SERIAL_USB_OHCI</span><span class="p">)</span>
		<span class="n">quirk_usb_handoff_ohci</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_SERIAL_USB_EHCI</span><span class="p">)</span>
		<span class="n">quirk_usb_disable_ehci</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_SERIAL_USB_XHCI</span><span class="p">)</span>
		<span class="n">quirk_usb_handoff_xhci</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_FINAL</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
			<span class="n">PCI_CLASS_SERIAL_USB</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_usb_early_handoff</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
