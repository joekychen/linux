<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › isp1760-hcd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>isp1760-hcd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for the NXP ISP1760 chip</span>
<span class="cm"> *</span>
<span class="cm"> * However, the code might contain some bugs. What doesn&#39;t work for sure is:</span>
<span class="cm"> * - ISO</span>
<span class="cm"> * - OTG</span>
<span class="cm"> e The interrupt line is configured as active low, level.</span>
<span class="cm"> *</span>
<span class="cm"> * (c) 2007 Sebastian Siewior &lt;bigeasy@linutronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * (c) 2011 Arvid Brodin &lt;arvid.brodin@enea.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>

<span class="cp">#include &quot;isp1760-hcd.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">qtd_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">qh_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">urb_listitem_cachep</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">queue_head_types</span> <span class="p">{</span>
	<span class="n">QH_CONTROL</span><span class="p">,</span>
	<span class="n">QH_BULK</span><span class="p">,</span>
	<span class="n">QH_INTERRUPT</span><span class="p">,</span>
	<span class="n">QH_END</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">hcs_params</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slotinfo</span>		<span class="n">atl_slots</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">atl_done_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slotinfo</span>		<span class="n">int_slots</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">int_done_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memory_chunk</span> <span class="n">memory_pool</span><span class="p">[</span><span class="n">BLOCKS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">qh_list</span><span class="p">[</span><span class="n">QH_END</span><span class="p">];</span>

	<span class="cm">/* periodic schedule support */</span>
<span class="cp">#define	DEFAULT_I_TDPS		1024</span>
	<span class="kt">unsigned</span>		<span class="n">periodic_size</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">reset_done</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">next_statechange</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">devflags</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">rst_gpio</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="nf">hcd_to_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Section 2.2 Host Controller Capability Registers */</span>
<span class="cp">#define HC_LENGTH(p)		(((p)&gt;&gt;00)&amp;0x00ff)	</span><span class="cm">/* bits 7:0 */</span><span class="cp"></span>
<span class="cp">#define HC_VERSION(p)		(((p)&gt;&gt;16)&amp;0xffff)	</span><span class="cm">/* bits 31:16 */</span><span class="cp"></span>
<span class="cp">#define HCS_INDICATOR(p)	((p)&amp;(1 &lt;&lt; 16))	</span><span class="cm">/* true: has port indicators */</span><span class="cp"></span>
<span class="cp">#define HCS_PPC(p)		((p)&amp;(1 &lt;&lt; 4))	</span><span class="cm">/* true: port power control */</span><span class="cp"></span>
<span class="cp">#define HCS_N_PORTS(p)		(((p)&gt;&gt;0)&amp;0xf)	</span><span class="cm">/* bits 3:0, ports on HC */</span><span class="cp"></span>
<span class="cp">#define HCC_ISOC_CACHE(p)       ((p)&amp;(1 &lt;&lt; 7))  </span><span class="cm">/* true: can cache isoc frame */</span><span class="cp"></span>
<span class="cp">#define HCC_ISOC_THRES(p)       (((p)&gt;&gt;4)&amp;0x7)  </span><span class="cm">/* bits 6:4, uframes cached */</span><span class="cp"></span>

<span class="cm">/* Section 2.3 Host Controller Operational Registers */</span>
<span class="cp">#define CMD_LRESET	(1&lt;&lt;7)		</span><span class="cm">/* partial reset (no ports, etc) */</span><span class="cp"></span>
<span class="cp">#define CMD_RESET	(1&lt;&lt;1)		</span><span class="cm">/* reset HC not bus */</span><span class="cp"></span>
<span class="cp">#define CMD_RUN		(1&lt;&lt;0)		</span><span class="cm">/* start/stop HC */</span><span class="cp"></span>
<span class="cp">#define STS_PCD		(1&lt;&lt;2)		</span><span class="cm">/* port change detect */</span><span class="cp"></span>
<span class="cp">#define FLAG_CF		(1&lt;&lt;0)		</span><span class="cm">/* true: we&#39;ll support &quot;high speed&quot; */</span><span class="cp"></span>

<span class="cp">#define PORT_OWNER	(1&lt;&lt;13)		</span><span class="cm">/* true: companion hc owns this port */</span><span class="cp"></span>
<span class="cp">#define PORT_POWER	(1&lt;&lt;12)		</span><span class="cm">/* true: has power (see PPC) */</span><span class="cp"></span>
<span class="cp">#define PORT_USB11(x) (((x) &amp; (3 &lt;&lt; 10)) == (1 &lt;&lt; 10))	</span><span class="cm">/* USB 1.1 device */</span><span class="cp"></span>
<span class="cp">#define PORT_RESET	(1&lt;&lt;8)		</span><span class="cm">/* reset port */</span><span class="cp"></span>
<span class="cp">#define PORT_SUSPEND	(1&lt;&lt;7)		</span><span class="cm">/* suspend port */</span><span class="cp"></span>
<span class="cp">#define PORT_RESUME	(1&lt;&lt;6)		</span><span class="cm">/* resume it */</span><span class="cp"></span>
<span class="cp">#define PORT_PE		(1&lt;&lt;2)		</span><span class="cm">/* port enable */</span><span class="cp"></span>
<span class="cp">#define PORT_CSC	(1&lt;&lt;1)		</span><span class="cm">/* connect status change */</span><span class="cp"></span>
<span class="cp">#define PORT_CONNECT	(1&lt;&lt;0)		</span><span class="cm">/* device connected */</span><span class="cp"></span>
<span class="cp">#define PORT_RWC_BITS   (PORT_CSC)</span>

<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">packet_type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data_buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">payload_addr</span><span class="p">;</span>

	<span class="cm">/* the rest is HCD-private */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">qtd_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">actual_length</span><span class="p">;</span>

	<span class="cm">/* QTD_ENQUEUED:	waiting for transfer (inactive) */</span>
	<span class="cm">/* QTD_PAYLOAD_ALLOC:	chip mem has been allocated for payload */</span>
	<span class="cm">/* QTD_XFER_STARTED:	valid ptd has been written to isp176x - only</span>
<span class="cm">				interrupt handler may touch this qtd! */</span>
	<span class="cm">/* QTD_XFER_COMPLETE:	payload has been transferred successfully */</span>
	<span class="cm">/* QTD_RETIRE:		transfer error/abort qtd */</span>
<span class="cp">#define QTD_ENQUEUED		0</span>
<span class="cp">#define QTD_PAYLOAD_ALLOC	1</span>
<span class="cp">#define QTD_XFER_STARTED	2</span>
<span class="cp">#define QTD_XFER_COMPLETE	3</span>
<span class="cp">#define QTD_RETIRE		4</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Queue head, one for each active endpoint */</span>
<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">qh_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">qtd_list</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">toggle</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tt_buffer_dirty</span><span class="p">;</span>	<span class="cm">/* See USB2.0 spec section 11.17.5 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">urb_listitem</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">urb_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Access functions for isp176x registers (addresses 0..0x03FF).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">reg_read32</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_write32</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access functions for isp176x memory (offset &gt;= 0x0400).</span>
<span class="cm"> *</span>
<span class="cm"> * bank_reads8() reads memory locations prefetched by an earlier write to</span>
<span class="cm"> * HC_MEMORY_REG (see isp176x datasheet). Unless you want to do fancy multi-</span>
<span class="cm"> * bank optimizations, you should use the more generic mem_reads8() below.</span>
<span class="cm"> *</span>
<span class="cm"> * For access to ptd memory, use the specialized ptd_read() and ptd_write()</span>
<span class="cm"> * below.</span>
<span class="cm"> *</span>
<span class="cm"> * These functions copy via MMIO data to/from the device. memcpy_{to|from}io()</span>
<span class="cm"> * doesn&#39;t quite work because some people have to enforce 32-bit access</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bank_reads8</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">src_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">src_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bank_addr</span><span class="p">,</span>
							<span class="n">__u32</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">src_byteptr</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">dst_byteptr</span><span class="p">;</span>

	<span class="n">src</span> <span class="o">=</span> <span class="n">src_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">bank_addr</span> <span class="o">|</span> <span class="n">src_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">src_offset</span> <span class="o">&lt;</span> <span class="n">PAYLOAD_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">src</span><span class="p">));</span>
			<span class="n">bytes</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">src</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
			<span class="n">bytes</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">src</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* in case we have 3, 2 or 1 by left. The dst buffer may not be fully</span>
<span class="cm">	 * allocated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">src_offset</span> <span class="o">&lt;</span> <span class="n">PAYLOAD_OFFSET</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">src</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>

	<span class="n">dst_byteptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">src_byteptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dst_byteptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">src_byteptr</span><span class="p">;</span>
		<span class="n">dst_byteptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">src_byteptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bytes</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_reads8</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">src_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">src_offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
								<span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">src_base</span><span class="p">,</span> <span class="n">HC_MEMORY_REG</span><span class="p">,</span> <span class="n">src_offset</span> <span class="o">+</span> <span class="n">ISP_BANK</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">ndelay</span><span class="p">(</span><span class="mi">90</span><span class="p">);</span>
	<span class="n">bank_reads8</span><span class="p">(</span><span class="n">src_base</span><span class="p">,</span> <span class="n">src_offset</span><span class="p">,</span> <span class="n">ISP_BANK</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dst</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_writes8</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dst_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dst_offset</span><span class="p">,</span>
						<span class="n">__u32</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>

	<span class="n">dst</span> <span class="o">=</span> <span class="n">dst_base</span> <span class="o">+</span> <span class="n">dst_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst_offset</span> <span class="o">&lt;</span> <span class="n">PAYLOAD_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">),</span> <span class="n">dst</span><span class="p">);</span>
			<span class="n">bytes</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">src</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__raw_writel</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
			<span class="n">bytes</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">src</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dst</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* in case we have 3, 2 or 1 bytes left. The buffer is allocated and the</span>
<span class="cm">	 * extra bytes should not be read by the HW.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst_offset</span> <span class="o">&lt;</span> <span class="n">PAYLOAD_OFFSET</span><span class="p">)</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">),</span> <span class="n">dst</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read and write ptds. &#39;ptd_offset&#39; should be one of ISO_PTD_OFFSET,</span>
<span class="cm"> * INT_PTD_OFFSET, and ATL_PTD_OFFSET. &#39;slot&#39; should be less than 32.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ptd_read</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ptd_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">slot</span><span class="p">,</span>
								<span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">HC_MEMORY_REG</span><span class="p">,</span>
				<span class="n">ISP_BANK</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">ptd_offset</span> <span class="o">+</span> <span class="n">slot</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptd</span><span class="p">));</span>
	<span class="n">ndelay</span><span class="p">(</span><span class="mi">90</span><span class="p">);</span>
	<span class="n">bank_reads8</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ptd_offset</span> <span class="o">+</span> <span class="n">slot</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptd</span><span class="p">),</span> <span class="n">ISP_BANK</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
						<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ptd_write</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ptd_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">slot</span><span class="p">,</span>
								<span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mem_writes8</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ptd_offset</span> <span class="o">+</span> <span class="n">slot</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptd</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span><span class="p">,</span> <span class="mi">7</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span><span class="p">));</span>
	<span class="cm">/* Make sure dw0 gets written last (after other dw&#39;s and after payload)</span>
<span class="cm">	   since it contains the enable bit */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">mem_writes8</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ptd_offset</span> <span class="o">+</span> <span class="n">slot</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span><span class="p">,</span>
							<span class="k">sizeof</span><span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/* memory management of the 60kb on the chip from 0x1000 to 0xffff */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">curr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">payload_addr</span><span class="p">;</span>

	<span class="n">payload_addr</span> <span class="o">=</span> <span class="n">PAYLOAD_OFFSET</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLOCK_1_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">payload_addr</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">BLOCK_1_SIZE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">payload_addr</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLOCK_2_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">payload_addr</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">BLOCK_2_SIZE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">payload_addr</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLOCK_3_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">payload_addr</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">BLOCK_3_SIZE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">payload_addr</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">payload_addr</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">PAYLOAD_AREA_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alloc_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLOCKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&amp;&amp;</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLOCKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">==</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">memory_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s: Invalid pointer: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">usec</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">usec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* reset a non-running (STS_HALT == 1) controller */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">u32</span> <span class="n">command</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">);</span>

	<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RESET</span><span class="p">;</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">,</span>
			    <span class="n">CMD_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="nf">qh_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">qh_cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qh_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">qh_cachep</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* one-time init, only for memory state */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">priv_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span>		<span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">hcc_params</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QH_END</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * hw default: 1K periodic list heads, one per frame.</span>
<span class="cm">	 * periodic_size can shrink by USBCMD update if hcc_params allows.</span>
<span class="cm">	 */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">=</span> <span class="n">DEFAULT_I_TDPS</span><span class="p">;</span>

	<span class="cm">/* controllers may cache some of the periodic schedule ... */</span>
	<span class="n">hcc_params</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HCCPARAMS</span><span class="p">);</span>
	<span class="cm">/* full frame cache */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_ISOC_CACHE</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">i_thresh</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* N microframes cached */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">i_thresh</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">HCC_ISOC_THRES</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">isp1760_hc_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">hwmode</span><span class="p">;</span>

	<span class="cm">/* low-level chip reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rst_gpio</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rst_lvl</span><span class="p">;</span>

		<span class="n">rst_lvl</span> <span class="o">=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span>
			   <span class="n">ISP1760_FLAG_RESET_ACTIVE_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rst_gpio</span><span class="p">,</span> <span class="n">rst_lvl</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rst_gpio</span><span class="p">,</span> <span class="o">!</span><span class="n">rst_lvl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup HW Mode Control: This assumes a level active-low interrupt */</span>
	<span class="n">hwmode</span> <span class="o">=</span> <span class="n">HW_DATA_BUS_32BIT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_BUS_WIDTH_16</span><span class="p">)</span>
		<span class="n">hwmode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HW_DATA_BUS_32BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_ANALOG_OC</span><span class="p">)</span>
		<span class="n">hwmode</span> <span class="o">|=</span> <span class="n">HW_ANA_DIGI_OC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_DACK_POL_HIGH</span><span class="p">)</span>
		<span class="n">hwmode</span> <span class="o">|=</span> <span class="n">HW_DACK_POL_HIGH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_DREQ_POL_HIGH</span><span class="p">)</span>
		<span class="n">hwmode</span> <span class="o">|=</span> <span class="n">HW_DREQ_POL_HIGH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_INTR_POL_HIGH</span><span class="p">)</span>
		<span class="n">hwmode</span> <span class="o">|=</span> <span class="n">HW_INTR_HIGH_ACT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_INTR_EDGE_TRIG</span><span class="p">)</span>
		<span class="n">hwmode</span> <span class="o">|=</span> <span class="n">HW_INTR_EDGE_TRIG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to set this first in case we&#39;re in 16-bit mode.</span>
<span class="cm">	 * Write it twice to ensure correct upper bits if switching</span>
<span class="cm">	 * to 16-bit mode.</span>
<span class="cm">	 */</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">,</span> <span class="n">hwmode</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">,</span> <span class="n">hwmode</span><span class="p">);</span>

	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_SCRATCH_REG</span><span class="p">,</span> <span class="mh">0xdeadbabe</span><span class="p">);</span>
	<span class="cm">/* Change bus pattern */</span>
	<span class="n">scratch</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_CHIP_ID_REG</span><span class="p">);</span>
	<span class="n">scratch</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_SCRATCH_REG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scratch</span> <span class="o">!=</span> <span class="mh">0xdeadbabe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;Scratch test failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pre reset */</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_BUFFER_STATUS_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="n">NO_TRANSFER_ACTIVE</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="n">NO_TRANSFER_ACTIVE</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ISO_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="n">NO_TRANSFER_ACTIVE</span><span class="p">);</span>

	<span class="cm">/* reset */</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_RESET_REG</span><span class="p">,</span> <span class="n">SW_RESET_RESET_ALL</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_RESET_REG</span><span class="p">,</span> <span class="n">SW_RESET_RESET_HC</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ehci_reset</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Step 11 passed */</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;bus width: %d, oc: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_BUS_WIDTH_16</span><span class="p">)</span> <span class="o">?</span>
			   <span class="mi">16</span> <span class="o">:</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">&amp;</span> <span class="n">ISP1760_FLAG_ANALOG_OC</span><span class="p">)</span> <span class="o">?</span>
			   <span class="s">&quot;analog&quot;</span> <span class="o">:</span> <span class="s">&quot;digital&quot;</span><span class="p">);</span>

	<span class="cm">/* ATL reset */</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">,</span> <span class="n">hwmode</span> <span class="o">|</span> <span class="n">ALL_ATX_RESET</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">,</span> <span class="n">hwmode</span><span class="p">);</span>

	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INTERRUPT_ENABLE</span><span class="p">,</span> <span class="n">INTERRUPT_ENABLE_MASK</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * PORT 1 Control register of the ISP1760 is the OTG control</span>
<span class="cm">	 * register on ISP1761. Since there is no OTG or device controller</span>
<span class="cm">	 * support in this driver, we use port 1 as a &quot;normal&quot; USB host port on</span>
<span class="cm">	 * both chips.</span>
<span class="cm">	 */</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORT1_CTRL</span><span class="p">,</span> <span class="n">PORT1_POWER</span> <span class="o">|</span> <span class="n">PORT1_INIT2</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hcs_params</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HCSPARAMS</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">priv_init</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">base_to_chip</span><span class="p">(</span><span class="n">u32</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">base</span> <span class="o">-</span> <span class="mh">0x400</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">last_qtd_of_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">qtd</span><span class="p">),</span> <span class="n">qtd_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">!=</span> <span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* magic numbers that can affect system performance */</span>
<span class="cp">#define	EHCI_TUNE_CERR		3	</span><span class="cm">/* 0-3 qtd retries; 0 == don&#39;t stop */</span><span class="cp"></span>
<span class="cp">#define	EHCI_TUNE_RL_HS		4	</span><span class="cm">/* nak throttle; see 4.9 */</span><span class="cp"></span>
<span class="cp">#define	EHCI_TUNE_RL_TT		0</span>
<span class="cp">#define	EHCI_TUNE_MULT_HS	1	</span><span class="cm">/* 1-3 transactions/uframe; 4.10.3 */</span><span class="cp"></span>
<span class="cp">#define	EHCI_TUNE_MULT_TT	1</span>
<span class="cp">#define	EHCI_TUNE_FLS		2	</span><span class="cm">/* (small) 256 frame schedule */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_ptd_atl</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">multi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rl</span> <span class="o">=</span> <span class="n">RL_COUNTER</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nak</span> <span class="o">=</span> <span class="n">NAK_COUNTER</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ptd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptd</span><span class="p">));</span>

	<span class="cm">/* according to 3.6.2, max packet len can not be &gt; 0x400 */</span>
	<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span>
						<span class="n">usb_pipeout</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">));</span>
	<span class="n">multi</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">maxpacket</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">);</span>
	<span class="n">maxpacket</span> <span class="o">&amp;=</span> <span class="mh">0x7ff</span><span class="p">;</span>

	<span class="cm">/* DW0 */</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span> <span class="o">=</span> <span class="n">DW0_VALID_BIT</span><span class="p">;</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span> <span class="o">|=</span> <span class="n">TO_DW0_LENGTH</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span> <span class="o">|=</span> <span class="n">TO_DW0_MAXPACKET</span><span class="p">(</span><span class="n">maxpacket</span><span class="p">);</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span> <span class="o">|=</span> <span class="n">TO_DW0_ENDPOINT</span><span class="p">(</span><span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">));</span>

	<span class="cm">/* DW1 */</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">TO_DW1_DEVICE_ADDR</span><span class="p">(</span><span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">));</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">TO_DW1_PID_TOKEN</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">packet_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipebulk</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">DW1_TRANS_BULK</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>  <span class="p">(</span><span class="n">usb_pipeint</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">DW1_TRANS_INT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* split transaction */</span>

		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">DW1_TRANS_SPLIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span><span class="p">)</span>
			<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">DW1_SE_USB_LOSPEED</span><span class="p">;</span>

		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">TO_DW1_PORT_NUM</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ttport</span><span class="p">);</span>
		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="n">TO_DW1_HUB_NUM</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>

		<span class="cm">/* SE bit for Split INT transfers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeint</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_LOW</span><span class="p">))</span>
			<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw1</span> <span class="o">|=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="n">rl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw0</span> <span class="o">|=</span> <span class="n">TO_DW0_MULTI</span><span class="p">(</span><span class="n">multi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">||</span>
						<span class="n">usb_pipebulk</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
			<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">TO_DW3_PING</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">ping</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* DW2 */</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw2</span> <span class="o">|=</span> <span class="n">TO_DW2_DATA_START_ADDR</span><span class="p">(</span><span class="n">base_to_chip</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">));</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw2</span> <span class="o">|=</span> <span class="n">TO_DW2_RL</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>

	<span class="cm">/* DW3 */</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">TO_DW3_NAKCOUNT</span><span class="p">(</span><span class="n">nak</span><span class="p">);</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">TO_DW3_DATA_TOGGLE</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">toggle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">data_buffer</span> <span class="o">==</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">)</span>
			<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TO_DW3_DATA_TOGGLE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">last_qtd_of_urb</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">qh</span><span class="p">))</span>
			<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">TO_DW3_DATA_TOGGLE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">DW3_ACTIVE_BIT</span><span class="p">;</span>
	<span class="cm">/* Cerr */</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">TO_DW3_CERR</span><span class="p">(</span><span class="n">ERR_COUNTER</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transform_add_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">usof</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">period</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Most of this is guessing. ISP1761 datasheet is quite unclear, and</span>
<span class="cm">	 * the algorithm from the original Philips driver code, which was</span>
<span class="cm">	 * pretty much used in this driver before as well, is quite horrendous</span>
<span class="cm">	 * and, i believe, incorrect. The code below follows the datasheet and</span>
<span class="cm">	 * USB2.0 spec as far as I can tell, and plug/unplug seems to be much</span>
<span class="cm">	 * more reliable this way (fingers crossed...).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* urb-&gt;interval is in units of microframes (1/8 ms) */</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">usof</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* One bit set =&gt;</span>
<span class="cm">						interval 1 ms * uFrame-match */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">usof</span> <span class="o">=</span> <span class="mh">0x22</span><span class="p">;</span> <span class="cm">/* Two bits set =&gt; interval 1/2 ms */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">usof</span> <span class="o">=</span> <span class="mh">0x55</span><span class="p">;</span> <span class="cm">/* Four bits set =&gt; interval 1/4 ms */</span>
		<span class="k">else</span>
			<span class="n">usof</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span> <span class="cm">/* All bits set =&gt; interval 1/8 ms */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* urb-&gt;interval is in units of frames (1 ms) */</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
		<span class="n">usof</span> <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span>		<span class="cm">/* Execute Start Split on any of the</span>
<span class="cm">					   four first uFrames */</span>

		<span class="cm">/*</span>
<span class="cm">		 * First 8 bits in dw5 is uSCS and &quot;specifies which uSOF the</span>
<span class="cm">		 * complete split needs to be sent. Valid only for IN.&quot; Also,</span>
<span class="cm">		 * &quot;All bits can be set to one for every transfer.&quot; (p 82,</span>
<span class="cm">		 * ISP1761 data sheet.) 0x1c is from Philips driver. Where did</span>
<span class="cm">		 * that number come from? 0xff seems to work fine...</span>
<span class="cm">		 */</span>
		<span class="cm">/* ptd-&gt;dw5 = 0x1c; */</span>
		<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw5</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span> <span class="cm">/* Execute Complete Split on any uFrame */</span>
	<span class="p">}</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">period</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span><span class="cm">/* Ensure equal or shorter period than requested */</span>
	<span class="n">period</span> <span class="o">&amp;=</span> <span class="mh">0xf8</span><span class="p">;</span> <span class="cm">/* Mask off too large values and lowest unused 3 bits */</span>

	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw2</span> <span class="o">|=</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw4</span> <span class="o">=</span> <span class="n">usof</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_ptd_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">create_ptd_atl</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">ptd</span><span class="p">);</span>
	<span class="n">transform_add_int</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">ptd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1760_urb_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PIPE_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
		     <span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
		     <span class="n">ptr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* complete() can reenter this HCD */</span>
	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="nf">qtd_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
								<span class="n">u8</span> <span class="n">packet_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

	<span class="n">qtd</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">qtd_cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">packet_type</span> <span class="o">=</span> <span class="n">packet_type</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_ENQUEUED</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">qtd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qtd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">qtd_cachep</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_bus_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ptd_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">slotinfo</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">skip_map</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">QTD_PAYLOAD_ALLOC</span><span class="p">);</span>

	<span class="cm">/* Make sure done map has not triggered from some unlinked transfer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptd_offset</span> <span class="o">==</span> <span class="n">ATL_PTD_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span> <span class="o">|=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span>
						<span class="n">HC_ATL_PTD_DONEMAP_REG</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">slot</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span> <span class="o">|=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span>
						<span class="n">HC_INT_PTD_DONEMAP_REG</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">slot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_XFER_STARTED</span><span class="p">;</span>
	<span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
	<span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
	<span class="n">ptd_write</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">ptd_offset</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">ptd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ptd_offset</span> <span class="o">==</span> <span class="n">ATL_PTD_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skip_map</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_SKIPMAP_REG</span><span class="p">);</span>
		<span class="n">skip_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
		<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="n">skip_map</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skip_map</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_SKIPMAP_REG</span><span class="p">);</span>
		<span class="n">skip_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
		<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="n">skip_map</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_short_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">usb_pipebulk</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&lt;</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">collect_qtds</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">urb_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">last_qtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="o">*</span><span class="n">qtd_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_listitem</span> <span class="o">*</span><span class="n">urb_listitem</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">qtd_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">QTD_XFER_COMPLETE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">last_qtd</span> <span class="o">=</span> <span class="n">last_qtd_of_urb</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">last_qtd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">QTD_RETIRE</span><span class="p">))</span>
			<span class="n">qtd_next</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_RETIRE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">QTD_XFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">packet_type</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">IN_PID</span>:
					<span class="n">mem_reads8</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">,</span>
							<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">,</span>
							<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
					<span class="cm">/* Fall through (?) */</span>
				<span class="k">case</span> <span class="n">OUT_PID</span>:
					<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span>
							<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
					<span class="cm">/* Fall through ... */</span>
				<span class="k">case</span> <span class="n">SETUP_PID</span>:
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">is_short_bulk</span><span class="p">(</span><span class="n">qtd</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
					<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_qtd</span><span class="p">)</span>
					<span class="n">qtd_next</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_RETIRE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">)</span>
			<span class="n">free_mem</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">last_qtd</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">QTD_RETIRE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
				<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="cm">/* Defer calling of urb_done() since it releases lock */</span>
			<span class="n">urb_listitem</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">urb_listitem_cachep</span><span class="p">,</span>
								<span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">urb_listitem</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* Try again on next call */</span>
			<span class="n">urb_listitem</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb_listitem</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">,</span> <span class="n">urb_list</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">qtd_free</span><span class="p">(</span><span class="n">qtd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define ENQUEUE_DEPTH	2</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_qtds</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ptd_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slotinfo</span> <span class="o">*</span><span class="n">slots</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curr_slot</span><span class="p">,</span> <span class="n">free_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptd</span> <span class="n">ptd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure this endpoint&#39;s TT buffer is clean before queueing ptds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_buffer_dirty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeint</span><span class="p">(</span><span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qtd</span><span class="p">,</span>
							<span class="n">qtd_list</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ptd_offset</span> <span class="o">=</span> <span class="n">INT_PTD_OFFSET</span><span class="p">;</span>
		<span class="n">slots</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_slots</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ptd_offset</span> <span class="o">=</span> <span class="n">ATL_PTD_OFFSET</span><span class="p">;</span>
		<span class="n">slots</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_slots</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_slot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">curr_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">curr_slot</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">curr_slot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">free_slot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">curr_slot</span><span class="p">].</span><span class="n">qtd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">free_slot</span> <span class="o">=</span> <span class="n">curr_slot</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">curr_slot</span><span class="p">].</span><span class="n">qh</span> <span class="o">==</span> <span class="n">qh</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">QTD_ENQUEUED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">);</span>
			<span class="n">alloc_mem</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">packet_type</span> <span class="o">==</span> <span class="n">SETUP_PID</span><span class="p">)</span> <span class="o">||</span>
			     <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">packet_type</span> <span class="o">==</span> <span class="n">OUT_PID</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">mem_writes8</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">payload_addr</span><span class="p">,</span>
						<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_PAYLOAD_ALLOC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">QTD_PAYLOAD_ALLOC</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm">			if ((curr_slot &gt; 31) &amp;&amp; (free_slot == -1))</span>
<span class="cm">				dev_dbg(hcd-&gt;self.controller, &quot;%s: No slot &quot;</span>
<span class="cm">					&quot;available for transfer\n&quot;, __func__);</span>
<span class="cm">*/</span>
			<span class="cm">/* Start xfer for this endpoint if not already done */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">curr_slot</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">free_slot</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeint</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
					<span class="n">create_ptd_int</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">create_ptd_atl</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>

				<span class="n">start_bus_transfer</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">ptd_offset</span><span class="p">,</span> <span class="n">free_slot</span><span class="p">,</span>
							<span class="n">slots</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
				<span class="n">curr_slot</span> <span class="o">=</span> <span class="n">free_slot</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">n</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">ENQUEUE_DEPTH</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">schedule_ptds</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="o">*</span><span class="n">qh_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ep_queue</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">urb_listitem</span> <span class="o">*</span><span class="n">urb_listitem</span><span class="p">,</span> <span class="o">*</span><span class="n">urb_listitem_next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check finished/retired xfers, transfer payloads, call urb_done()</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QH_END</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qh_next</span><span class="p">,</span> <span class="n">ep_queue</span><span class="p">,</span> <span class="n">qh_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">collect_qtds</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb_list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">urb_listitem</span><span class="p">,</span> <span class="n">urb_listitem_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb_list</span><span class="p">,</span>
								<span class="n">urb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isp1760_urb_done</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb_listitem</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">urb_listitem_cachep</span><span class="p">,</span> <span class="n">urb_listitem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Schedule packets for transfer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * According to USB2.0 specification:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1st prio: interrupt xfers, up to 80 % of bandwidth</span>
<span class="cm">	 * 2nd prio: control xfers</span>
<span class="cm">	 * 3rd prio: bulk xfers</span>
<span class="cm">	 *</span>
<span class="cm">	 * ... but let&#39;s use a simpler scheme here (mostly because ISP1761 doc</span>
<span class="cm">	 * is very unclear on how to prioritize traffic):</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) Enqueue any queued control transfers, as long as payload chip mem</span>
<span class="cm">	 *    and PTD ATL slots are available.</span>
<span class="cm">	 * 2) Enqueue any queued INT transfers, as long as payload chip mem</span>
<span class="cm">	 *    and PTD INT slots are available.</span>
<span class="cm">	 * 3) Enqueue any queued bulk transfers, as long as payload chip mem</span>
<span class="cm">	 *    and PTD ATL slots are available.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Use double buffering (ENQUEUE_DEPTH==2) as a compromise between</span>
<span class="cm">	 * conservation of chip mem and performance.</span>
<span class="cm">	 *</span>
<span class="cm">	 * I&#39;m sure this scheme could be improved upon!</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QH_END</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qh_next</span><span class="p">,</span> <span class="n">ep_queue</span><span class="p">,</span> <span class="n">qh_list</span><span class="p">)</span>
			<span class="n">enqueue_qtds</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define PTD_STATE_QTD_DONE	1</span>
<span class="cp">#define PTD_STATE_QTD_RELOAD	2</span>
<span class="cp">#define PTD_STATE_URB_RETIRE	3</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_int_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">,</span>
								<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dw</span> <span class="n">dw4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dw4</span> <span class="o">=</span> <span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw4</span><span class="p">;</span>
	<span class="n">dw4</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/* FIXME: ISP1761 datasheet does not say what to do with these. Do we</span>
<span class="cm">	   need to handle these errors? Is it done in hardware? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;</span> <span class="n">DW3_HALT_BIT</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span> <span class="cm">/* Default unknown error */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dw4</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">INT_UNDERRUN</span>:
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s: underrun &quot;</span>
						<span class="s">&quot;during uFrame %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">;</span> <span class="cm">/* Could not write data */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">INT_EXACT</span>:
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s: transaction &quot;</span>
						<span class="s">&quot;error during uFrame %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span> <span class="cm">/* timeout, bad CRC, PID</span>
<span class="cm">							  error etc. */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">INT_BABBLE</span>:
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s: babble &quot;</span>
						<span class="s">&quot;error during uFrame %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dw4</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">PTD_STATE_URB_RETIRE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PTD_STATE_QTD_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_atl_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">,</span>
								<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ptd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;</span> <span class="n">DW3_HALT_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;</span> <span class="n">DW3_BABBLE_BIT</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">FROM_DW3_CERR</span><span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span><span class="p">))</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>  <span class="cm">/* Stall */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;</span> <span class="n">DW3_ERROR_BIT</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span> <span class="cm">/* XactErr */</span>
		<span class="k">else</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span> <span class="cm">/* Unknown */</span>
<span class="cm">/*</span>
<span class="cm">		dev_dbg(hcd-&gt;self.controller, &quot;%s: ptd error:\n&quot;</span>
<span class="cm">			&quot;        dw0: %08x dw1: %08x dw2: %08x dw3: %08x\n&quot;</span>
<span class="cm">			&quot;        dw4: %08x dw5: %08x dw6: %08x dw7: %08x\n&quot;,</span>
<span class="cm">			__func__,</span>
<span class="cm">			ptd-&gt;dw0, ptd-&gt;dw1, ptd-&gt;dw2, ptd-&gt;dw3,</span>
<span class="cm">			ptd-&gt;dw4, ptd-&gt;dw5, ptd-&gt;dw6, ptd-&gt;dw7);</span>
<span class="cm">*/</span>
		<span class="k">return</span> <span class="n">PTD_STATE_URB_RETIRE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;</span> <span class="n">DW3_ERROR_BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;</span> <span class="n">DW3_ACTIVE_BIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Transfer Error, *but* active and no HALT -&gt; reload */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;PID error; reloading ptd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTD_STATE_QTD_RELOAD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FROM_DW3_NAKCOUNT</span><span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ptd</span><span class="o">-&gt;</span><span class="n">dw3</span> <span class="o">&amp;</span> <span class="n">DW3_ACTIVE_BIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * NAKs are handled in HW by the chip. Usually if the</span>
<span class="cm">		 * device is not able to send data fast enough.</span>
<span class="cm">		 * This happens mostly on slower hardware.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">PTD_STATE_QTD_RELOAD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PTD_STATE_QTD_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_done_ptds</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ptd</span> <span class="n">ptd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slotinfo</span> <span class="o">*</span><span class="n">slots</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ptd_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">modified</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip_map</span><span class="p">;</span>

	<span class="n">skip_map</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_SKIPMAP_REG</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">skip_map</span><span class="p">;</span>
	<span class="n">skip_map</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_SKIPMAP_REG</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">skip_map</span><span class="p">;</span>

	<span class="n">modified</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span> <span class="o">||</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span> <span class="o">||</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* INT ptd */</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">slot</span><span class="p">);</span>
			<span class="n">slots</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_slots</span><span class="p">;</span>
			<span class="cm">/* This should not trigger, and could be removed if</span>
<span class="cm">			   noone have any problems with it triggering: */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ptd_offset</span> <span class="o">=</span> <span class="n">INT_PTD_OFFSET</span><span class="p">;</span>
			<span class="n">ptd_read</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">INT_PTD_OFFSET</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">check_int_transfer</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">,</span>
							<span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ATL ptd */</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">slot</span><span class="p">);</span>
			<span class="n">slots</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_slots</span><span class="p">;</span>
			<span class="cm">/* This should not trigger, and could be removed if</span>
<span class="cm">			   noone have any problems with it triggering: */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ptd_offset</span> <span class="o">=</span> <span class="n">ATL_PTD_OFFSET</span><span class="p">;</span>
			<span class="n">ptd_read</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">ATL_PTD_OFFSET</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">check_atl_transfer</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">,</span>
							<span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">qtd</span> <span class="o">=</span> <span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span><span class="p">;</span>
		<span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span><span class="p">;</span>
		<span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">QTD_XFER_STARTED</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PTD_STATE_QTD_DONE</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">usb_pipeint</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				       <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">))</span>
				<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span>
				       <span class="n">FROM_DW3_SCS_NRBYTESTRANSFERRED</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span>
					<span class="n">FROM_DW3_NRBYTESTRANSFERRED</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span><span class="p">);</span>

			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_XFER_COMPLETE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="o">||</span>
							<span class="n">is_short_bulk</span><span class="p">(</span><span class="n">qtd</span><span class="p">))</span>
				<span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
							<span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">qtd</span><span class="p">),</span> <span class="n">qtd_list</span><span class="p">);</span>

			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">toggle</span> <span class="o">=</span> <span class="n">FROM_DW3_DATA_TOGGLE</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span><span class="p">);</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">ping</span> <span class="o">=</span> <span class="n">FROM_DW3_PING</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PTD_STATE_QTD_RELOAD</span>: <span class="cm">/* QTD_RETRY, for atls only */</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_PAYLOAD_ALLOC</span><span class="p">;</span>
			<span class="n">ptd</span><span class="p">.</span><span class="n">dw0</span> <span class="o">|=</span> <span class="n">DW0_VALID_BIT</span><span class="p">;</span>
			<span class="cm">/* RL counter = ERR counter */</span>
			<span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TO_DW3_NAKCOUNT</span><span class="p">(</span><span class="mh">0xf</span><span class="p">);</span>
			<span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">TO_DW3_NAKCOUNT</span><span class="p">(</span><span class="n">FROM_DW2_RL</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw2</span><span class="p">));</span>
			<span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TO_DW3_CERR</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
			<span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span> <span class="o">|=</span> <span class="n">TO_DW3_CERR</span><span class="p">(</span><span class="n">ERR_COUNTER</span><span class="p">);</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">toggle</span> <span class="o">=</span> <span class="n">FROM_DW3_DATA_TOGGLE</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span><span class="p">);</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">ping</span> <span class="o">=</span> <span class="n">FROM_DW3_PING</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PTD_STATE_URB_RETIRE</span>:
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_RETIRE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_buffer_dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">usb_hub_clear_tt_buffer</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">))</span>
					<span class="cm">/* Clear failed; let&#39;s hope things work</span>
<span class="cm">					   anyway */</span>
					<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_buffer_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">toggle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">ping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">QTD_PAYLOAD_ALLOC</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slots</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_slots</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PTD_STATE_QTD_RELOAD</span><span class="p">)</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="s">&quot;%s: PTD_STATE_QTD_RELOAD on &quot;</span>
						<span class="s">&quot;interrupt packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PTD_STATE_QTD_RELOAD</span><span class="p">)</span>
					<span class="n">create_ptd_int</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PTD_STATE_QTD_RELOAD</span><span class="p">)</span>
					<span class="n">create_ptd_atl</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">start_bus_transfer</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">ptd_offset</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">slots</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span>
				<span class="n">qh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">modified</span><span class="p">)</span>
		<span class="n">schedule_ptds</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">isp1760_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">imask</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">irqret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">HC_STATE_RUNNING</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

	<span class="n">imask</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INTERRUPT_REG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">imask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INTERRUPT_REG</span><span class="p">,</span> <span class="n">imask</span><span class="p">);</span> <span class="cm">/* Clear */</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_done_map</span> <span class="o">|=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_DONEMAP_REG</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span> <span class="o">|=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_DONEMAP_REG</span><span class="p">);</span>

	<span class="n">handle_done_ptds</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">irqret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="nl">leave:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irqret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Workaround for problem described in chip errata 2:</span>
<span class="cm"> *</span>
<span class="cm"> * Sometimes interrupts are not generated when ATL (not INT?) completion occurs.</span>
<span class="cm"> * One solution suggested in the errata is to use SOF interrupts _instead_of_</span>
<span class="cm"> * ATL done interrupts (the &quot;instead of&quot; might be important since it seems</span>
<span class="cm"> * enabling ATL interrupts also causes the chip to sometimes - rarely - &quot;forget&quot;</span>
<span class="cm"> * to set the PTD&#39;s done bit in addition to not generating an interrupt!).</span>
<span class="cm"> *</span>
<span class="cm"> * So if we use SOF + ATL interrupts, we sometimes get stale PTDs since their</span>
<span class="cm"> * done bit is not being set. This is bad - it blocks the endpoint until reboot.</span>
<span class="cm"> *</span>
<span class="cm"> * If we use SOF interrupts only, we get latency between ptd completion and the</span>
<span class="cm"> * actual handling. This is very noticeable in testusb runs which takes several</span>
<span class="cm"> * minutes longer without ATL interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * A better solution is to run the code below every SLOT_CHECK_PERIOD ms. If it</span>
<span class="cm"> * finds active ATL slots which are older than SLOT_TIMEOUT ms, it checks the</span>
<span class="cm"> * slot&#39;s ACTIVE and VALID bits. If these are not set, the ptd is considered</span>
<span class="cm"> * completed and its done map bit is set.</span>
<span class="cm"> *</span>
<span class="cm"> * The values of SLOT_TIMEOUT and SLOT_CHECK_PERIOD have been arbitrarily chosen</span>
<span class="cm"> * not to cause too much lag when this HW bug occurs, while still hopefully</span>
<span class="cm"> * ensuring that the check does not falsely trigger.</span>
<span class="cm"> */</span>
<span class="cp">#define SLOT_TIMEOUT 300</span>
<span class="cp">#define SLOT_CHECK_PERIOD 200</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">errata2_timer</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">errata2_function</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptd</span> <span class="n">ptd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spinflags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">slot</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_slots</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">+</span>
					<span class="n">SLOT_TIMEOUT</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ptd_read</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">ATL_PTD_OFFSET</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FROM_DW0_VALID</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">FROM_DW3_ACTIVE</span><span class="p">(</span><span class="n">ptd</span><span class="p">.</span><span class="n">dw3</span><span class="p">))</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">slot</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_done_map</span><span class="p">)</span>
		<span class="n">handle_done_ptds</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>

	<span class="n">errata2_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SLOT_CHECK_PERIOD</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errata2_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">isp1760_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chipid</span><span class="p">;</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>

	<span class="cm">/* Set PTD interrupt AND &amp; OR maps */</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_IRQ_MASK_AND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_IRQ_MASK_OR_REG</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_IRQ_MASK_AND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_IRQ_MASK_OR_REG</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ISO_IRQ_MASK_AND_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ISO_IRQ_MASK_OR_REG</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="cm">/* step 23 passed */</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">,</span> <span class="n">temp</span> <span class="o">|</span> <span class="n">HW_GLOBAL_INTR_EN</span><span class="p">);</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_LRESET</span><span class="o">|</span><span class="n">CMD_RESET</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">,</span> <span class="n">CMD_RUN</span><span class="p">,</span> <span class="n">CMD_RUN</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX</span>
<span class="cm">	 * Spec says to write FLAG_CF as last config action, priv code grabs</span>
<span class="cm">	 * the semaphore while doing so.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_CONFIGFLAG</span><span class="p">,</span> <span class="n">FLAG_CF</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">HC_CONFIGFLAG</span><span class="p">,</span> <span class="n">FLAG_CF</span><span class="p">,</span> <span class="n">FLAG_CF</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errata2_timer</span><span class="p">);</span>
	<span class="n">errata2_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">errata2_function</span><span class="p">;</span>
	<span class="n">errata2_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hcd</span><span class="p">;</span>
	<span class="n">errata2_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SLOT_CHECK_PERIOD</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errata2_timer</span><span class="p">);</span>

	<span class="n">chipid</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_CHIP_ID_REG</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;USB ISP %04x HW rev. %d started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">chipid</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">chipid</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* PTD Register Init Part 2, Step 28 */</span>

	<span class="cm">/* Setup registers controlling PTD checking */</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_LASTPTD_REG</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_LASTPTD_REG</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ISO_PTD_LASTPTD_REG</span><span class="p">,</span> <span class="mh">0x00000001</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ISO_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_BUFFER_STATUS_REG</span><span class="p">,</span>
						<span class="n">ATL_BUF_FILL</span> <span class="o">|</span> <span class="n">INT_BUF_FILL</span><span class="p">);</span>

	<span class="cm">/* GRR this is run-once init(), being done every time the HC starts.</span>
<span class="cm">	 * So long as they&#39;re part of class devices, we can&#39;t do it init()</span>
<span class="cm">	 * since the class device isn&#39;t created that early.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qtd_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">databuffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">data_buffer</span> <span class="o">=</span> <span class="n">databuffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_PAYLOAD_SIZE</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">MAX_PAYLOAD_SIZE</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qtd_list_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qtd_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="o">*</span><span class="n">qtd_next</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">qtd_next</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">qtd_free</span><span class="p">(</span><span class="n">qtd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Packetize urb-&gt;transfer_buffer into list of packets of size wMaxPacketSize.</span>
<span class="cm"> * Also calculate the PID type (SETUP/IN/OUT) for each packet.</span>
<span class="cm"> */</span>
<span class="cp">#define max_packet(wMaxPacketSize) ((wMaxPacketSize) &amp; 0x07ff)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">packetize_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">maxpacketsize</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">packet_type</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * URBs map to sequences of QTDs:  one logical transaction</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX This looks like usb storage / SCSI bug */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
				<span class="s">&quot;buf is null, dma is %08lx len is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">packet_type</span> <span class="o">=</span> <span class="n">IN_PID</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">packet_type</span> <span class="o">=</span> <span class="n">OUT_PID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">qtd_alloc</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">SETUP_PID</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">qtd_fill</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">));</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

		<span class="cm">/* for zero length DATA stages, STATUS is always IN */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">packet_type</span> <span class="o">=</span> <span class="n">IN_PID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">maxpacketsize</span> <span class="o">=</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span>
						<span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * buffer gets wrapped in one or more qtds;</span>
<span class="cm">	 * last one may be &quot;short&quot; (including zero len)</span>
<span class="cm">	 * and may serve as a control status ack</span>
<span class="cm">	 */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">this_qtd_len</span><span class="p">;</span>

		<span class="n">qtd</span> <span class="o">=</span> <span class="n">qtd_alloc</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">packet_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">this_qtd_len</span> <span class="o">=</span> <span class="n">qtd_fill</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">this_qtd_len</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">this_qtd_len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * control requests may need a terminating data &quot;status&quot; ack;</span>
<span class="cm">	 * bulk ones may need a terminating short packet (zero length).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">one_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">one_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">packet_type</span> <span class="o">==</span> <span class="n">IN_PID</span><span class="p">)</span>
				<span class="n">packet_type</span> <span class="o">=</span> <span class="n">OUT_PID</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">packet_type</span> <span class="o">=</span> <span class="n">IN_PID</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_pipebulk</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ZERO_PACKET</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">%</span>
							<span class="n">maxpacketsize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">one_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">one_more</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="n">qtd_alloc</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">packet_type</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

			<span class="cm">/* never any data in such packets */</span>
			<span class="n">qtd_fill</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="n">qtd_list_free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">isp1760_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ep_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="o">*</span><span class="n">qhit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spinflags</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">new_qtds</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qh_in_queue</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PIPE_CONTROL</span>:
		<span class="n">ep_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">[</span><span class="n">QH_CONTROL</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PIPE_BULK</span>:
		<span class="n">ep_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">[</span><span class="n">QH_BULK</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PIPE_INTERRUPT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* FIXME: Check bandwidth  */</span>
		<span class="n">ep_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">[</span><span class="n">QH_INTERRUPT</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PIPE_ISOCHRONOUS</span>:
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s: isochronous USB packets &quot;</span>
							<span class="s">&quot;not yet supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;%s: unknown pipe type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">packetize_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_qtds</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_qtds</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="n">qtd_list_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_qtds</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qtd_list_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_qtds</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh_in_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">qhit</span><span class="p">,</span> <span class="n">ep_queue</span><span class="p">,</span> <span class="n">qh_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qhit</span> <span class="o">==</span> <span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">qh_in_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh_in_queue</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">,</span> <span class="n">ep_queue</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_alloc</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
			<span class="n">qtd_list_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_qtds</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">,</span> <span class="n">ep_queue</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_splice_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_qtds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
	<span class="n">schedule_ptds</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">skip_map</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* We need to forcefully reclaim the slot since some transfers never</span>
<span class="cm">	   return, e.g. interrupt transfers and NAKed bulk transfers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">||</span> <span class="n">usb_pipebulk</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skip_map</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_SKIPMAP_REG</span><span class="p">);</span>
		<span class="n">skip_map</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
		<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_ATL_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="n">skip_map</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_slots</span><span class="p">[</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">atl_slots</span><span class="p">[</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skip_map</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_SKIPMAP_REG</span><span class="p">);</span>
		<span class="n">skip_map</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
		<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_INT_PTD_SKIPMAP_REG</span><span class="p">,</span> <span class="n">skip_map</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_slots</span><span class="p">[</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">].</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_slots</span><span class="p">[</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">].</span><span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retire the qtds beginning at &#39;qtd&#39; and belonging all to the same urb, killing</span>
<span class="cm"> * any active transfer belonging to the urb in the process.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_urb_from_qtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">urb_was_running</span><span class="p">;</span>

	<span class="n">urb</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="n">urb_was_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry_from</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">!=</span> <span class="n">urb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">QTD_XFER_STARTED</span><span class="p">)</span>
			<span class="n">urb_was_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_qtd_of_urb</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">qh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">QTD_XFER_COMPLETE</span><span class="p">))</span>
			<span class="n">urb_was_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">QTD_XFER_STARTED</span><span class="p">)</span>
			<span class="n">kill_transfer</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">QTD_RETIRE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">urb_was_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_buffer_dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_hub_clear_tt_buffer</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
			<span class="cm">/* Clear failed; let&#39;s hope things work anyway */</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_buffer_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">isp1760_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spinflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">==</span> <span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dequeue_urb_from_qtd</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">schedule_ptds</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1760_endpoint_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spinflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="o">*</span><span class="n">qh_iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QH_END</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">qh_iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qh_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh_iter</span> <span class="o">==</span> <span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh_iter</span><span class="o">-&gt;</span><span class="n">qh_list</span><span class="p">);</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">QH_END</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="n">qh_free</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">schedule_ptds</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">isp1760_hub_status_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* if !USB_SUSPEND, root hub timers won&#39;t get shut down ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* init status to no-changes */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">PORT_CSC</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CSC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_CSC</span><span class="p">;</span>
			<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return status information even for ports with OWNER set.</span>
<span class="cm">	 * Otherwise khubd wouldn&#39;t see the disconnect event when a</span>
<span class="cm">	 * high-speed device is switched over to the companion</span>
<span class="cm">	 * controller by the user.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
			<span class="o">||</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="o">&amp;&amp;</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">STS_PCD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME autosuspend idle root hubs */</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1760_hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ports</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>
	<span class="cm">/* priv 1.0, 2.3.9 says 20ms max */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bPwrOn2PwrGood</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span> <span class="o">=</span> <span class="n">ports</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">ports</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescLength</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* ports removable, and usb 1.0 legacy PortPwrCtrlMask */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="n">temp</span><span class="p">],</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>

	<span class="cm">/* per-port overcurrent reporting */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mh">0x0008</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCS_PPC</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
		<span class="cm">/* per-port power control */</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="mh">0x0001</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* no power switching */</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="mh">0x0002</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_reset_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">port_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">port_status</span><span class="p">;</span>

	<span class="cm">/* if reset finished and it&#39;s still not enabled -- handoff */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
					<span class="s">&quot;port %d full speed --&gt; companion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">port_status</span> <span class="o">|=</span> <span class="n">PORT_OWNER</span><span class="p">;</span>
		<span class="n">port_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_RWC_BITS</span><span class="p">;</span>
		<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">port_status</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;port %d high speed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">port_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">isp1760_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ports</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">selector</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.</span>
<span class="cm">	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.</span>
<span class="cm">	 * (track current state ourselves) ... blink for diagnostics,</span>
<span class="cm">	 * power, &quot;this is the one&quot;, etc.  EHCI spec supports this.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ClearHubFeature</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">C_HUB_LOCAL_POWER</span>:
		<span class="k">case</span> <span class="n">C_HUB_OVER_CURRENT</span>:
			<span class="cm">/* no hub-wide feature/status flags */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ClearPortFeature</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Even if OWNER is set, so the port is owned by the</span>
<span class="cm">		 * companion controller, khubd needs to be able to clear</span>
<span class="cm">		 * the port-change status bits (especially</span>
<span class="cm">		 * USB_PORT_STAT_C_CONNECTION).</span>
<span class="cm">		 */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_ENABLE</span>:
			<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_PE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_ENABLE</span>:
			<span class="cm">/* XXX error? */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="cm">/* resume signaling for 20 msec */</span>
				<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span><span class="p">);</span>
				<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span>
							<span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_RESUME</span><span class="p">);</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span>:
			<span class="cm">/* we auto-clear this feature */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">HCS_PPC</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
				<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span>
							<span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_POWER</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span>:
			<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_CSC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span>:
			<span class="cm">/* XXX error ?*/</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
			<span class="cm">/* GetPortStatus clears reset */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
		<span class="n">isp1760_hub_descriptor</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubStatus</span>:
		<span class="cm">/* no hub-wide feature/status flags */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetPortStatus</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">);</span>

		<span class="cm">/* wPortChange bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CSC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>


		<span class="cm">/* whoever resumes must GetPortStatus to complete it!! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;Port resume should be skipped.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/* Remote Wakeup received? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* resume signaling for 20 msec */</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span> <span class="o">=</span> <span class="n">jiffies</span>
						<span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
				<span class="cm">/* check the port again */</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* resume completed? */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_SUSPEND</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="cm">/* stop resume signaling */</span>
				<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">);</span>
				<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span>
					<span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_RESUME</span><span class="p">));</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span>
					   <span class="n">PORT_RESUME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span> <span class="cm">/* 2msec */</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
						<span class="s">&quot;port %d resume error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_SUSPEND</span><span class="o">|</span><span class="n">PORT_RESUME</span><span class="o">|</span><span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* whoever resets must GetPortStatus to complete it!! */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* force reset to complete */</span>
			<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_RESET</span><span class="p">);</span>
			<span class="cm">/* REVISIT:  some hardware needs 550+ usec to clear</span>
<span class="cm">			 * this bit; seems too long to spin routinely...</span>
<span class="cm">			 */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span>
					<span class="n">PORT_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">750</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;port %d reset error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* see what we found out */</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">check_reset_complete</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
					<span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Even if OWNER is set, there&#39;s no harm letting khubd</span>
<span class="cm">		 * see the wPortStatus values (they should all be 0 except</span>
<span class="cm">		 * for PORT_POWER anyway).</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;PORT_OWNER is set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">;</span>
			<span class="cm">/* status may be from integrated TT */</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PORT_SUSPEND</span><span class="o">|</span><span class="n">PORT_RESUME</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_SUSPEND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_RESET</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_POWER</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_POWER</span><span class="p">;</span>

		<span class="n">put_unaligned</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SetHubFeature</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">C_HUB_LOCAL_POWER</span>:
		<span class="k">case</span> <span class="n">C_HUB_OVER_CURRENT</span>:
			<span class="cm">/* no hub-wide feature/status flags */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SetPortFeature</span>:
		<span class="n">selector</span> <span class="o">=</span> <span class="n">wIndex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">wIndex</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

<span class="cm">/*		temp &amp;= ~PORT_RWC_BITS; */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_ENABLE</span>:
			<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_PE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
					<span class="o">||</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

			<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_SUSPEND</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">HCS_PPC</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
				<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span>
							<span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_POWER</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_RESET</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="cm">/* line status bits may report this as low speed,</span>
<span class="cm">			 * which can be fine if this root hub has a</span>
<span class="cm">			 * transaction translator built in.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PORT_PE</span><span class="o">|</span><span class="n">PORT_CONNECT</span><span class="p">))</span> <span class="o">==</span> <span class="n">PORT_CONNECT</span>
					<span class="o">&amp;&amp;</span> <span class="n">PORT_USB11</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_OWNER</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_RESET</span><span class="p">;</span>
				<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_PE</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * caller must wait, then call GetPortStatus</span>
<span class="cm">				 * usb 2.0 spec says 50 ms resets on root</span>
<span class="cm">				 */</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">reset_done</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_PORTSC1</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
<span class="nl">error:</span>
		<span class="cm">/* &quot;stall&quot; on error */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">isp1760_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">fr</span><span class="p">;</span>

	<span class="n">fr</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_FRINDEX</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">fr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1760_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errata2_timer</span><span class="p">);</span>

	<span class="n">isp1760_hub_control</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">ClearPortFeature</span><span class="p">,</span> <span class="n">USB_PORT_FEAT_POWER</span><span class="p">,</span>	<span class="mi">1</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ehci_reset</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="cm">/* Disable IRQ */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HW_GLOBAL_INTR_EN</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_CONFIGFLAG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1760_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">isp1760_stop</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">);</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_HW_MODE_CTRL</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HW_GLOBAL_INTR_EN</span><span class="p">);</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">reg_read32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">);</span>
	<span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">reg_write32</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">HC_USBCMD</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp1760_clear_tt_buffer_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isp1760_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spinflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_buffer_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">schedule_ptds</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">spinflags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="n">isp1760_hc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>		<span class="o">=</span> <span class="s">&quot;isp1760-hcd&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">product_desc</span>		<span class="o">=</span> <span class="s">&quot;NXP ISP1760 USB Host Controller&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hcd_priv_size</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_hcd</span><span class="p">),</span>
	<span class="p">.</span><span class="n">irq</span>			<span class="o">=</span> <span class="n">isp1760_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">HCD_MEMORY</span> <span class="o">|</span> <span class="n">HCD_USB2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>			<span class="o">=</span> <span class="n">isp1760_hc_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>			<span class="o">=</span> <span class="n">isp1760_run</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>			<span class="o">=</span> <span class="n">isp1760_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>		<span class="o">=</span> <span class="n">isp1760_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">urb_enqueue</span>		<span class="o">=</span> <span class="n">isp1760_urb_enqueue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">urb_dequeue</span>		<span class="o">=</span> <span class="n">isp1760_urb_dequeue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint_disable</span>	<span class="o">=</span> <span class="n">isp1760_endpoint_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_frame_number</span>	<span class="o">=</span> <span class="n">isp1760_get_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hub_status_data</span>	<span class="o">=</span> <span class="n">isp1760_hub_status_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hub_control</span>		<span class="o">=</span> <span class="n">isp1760_hub_control</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_tt_buffer_complete</span>	<span class="o">=</span> <span class="n">isp1760_clear_tt_buffer_complete</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_kmem_once</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">urb_listitem_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;isp1760_urb_listitem&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb_listitem</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_TEMPORARY</span> <span class="o">|</span>
			<span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb_listitem_cachep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">qtd_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;isp1760_qtd&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qtd</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_TEMPORARY</span> <span class="o">|</span>
			<span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd_cachep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">qh_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;isp1760_qh&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp1760_qh</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_TEMPORARY</span> <span class="o">|</span> <span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh_cachep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">qtd_cachep</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">deinit_kmem_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">qtd_cachep</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">qh_cachep</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">urb_listitem_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">isp1760_register</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">res_start</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">res_len</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">rst_gpio</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">busname</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp1760_hcd</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="cm">/* prevent usb-core allocating DMA pages */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">usb_create_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isp1760_hc_driver</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">hcd_to_priv</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">devflags</span> <span class="o">=</span> <span class="n">devflags</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rst_gpio</span> <span class="o">=</span> <span class="n">rst_gpio</span><span class="p">;</span>
	<span class="n">init_memory</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res_start</span><span class="p">,</span> <span class="n">res_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_start</span> <span class="o">=</span> <span class="n">res_start</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_len</span> <span class="o">=</span> <span class="n">res_len</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unmap</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hcd</span><span class="p">;</span>

<span class="nl">err_unmap:</span>
	 <span class="n">iounmap</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

<span class="nl">err_put:</span>
	 <span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	 <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for the ISP1760 USB-controller from NXP&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Sebastian Siewior &lt;bigeasy@linuxtronix.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
