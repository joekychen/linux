<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › isp116x.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>isp116x.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ISP116x register declarations and HCD data structures</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 Olav Kongas &lt;ok@artecdesign.ee&gt;</span>
<span class="cm"> * Portions:</span>
<span class="cm"> * Copyright (C) 2004 Lothar Wassmann</span>
<span class="cm"> * Copyright (C) 2004 Psion Teklogix</span>
<span class="cm"> * Copyright (C) 2004 David Brownell</span>
<span class="cm"> */</span>

<span class="cm">/* us of 1ms frame */</span>
<span class="cp">#define  MAX_LOAD_LIMIT		850</span>

<span class="cm">/* Full speed: max # of bytes to transfer for a single urb</span>
<span class="cm">   at a time must be &lt; 1024 &amp;&amp; must be multiple of 64.</span>
<span class="cm">   832 allows transferring 4kiB within 5 frames. */</span>
<span class="cp">#define MAX_TRANSFER_SIZE_FULLSPEED	832</span>

<span class="cm">/* Low speed: there is no reason to schedule in very big</span>
<span class="cm">   chunks; often the requested long transfers are for</span>
<span class="cm">   string descriptors containing short strings. */</span>
<span class="cp">#define MAX_TRANSFER_SIZE_LOWSPEED	64</span>

<span class="cm">/* Bytetime (us), a rough indication of how much time it</span>
<span class="cm">   would take to transfer a byte of useful data over USB */</span>
<span class="cp">#define BYTE_TIME_FULLSPEED	1</span>
<span class="cp">#define BYTE_TIME_LOWSPEED	20</span>

<span class="cm">/* Buffer sizes */</span>
<span class="cp">#define ISP116x_BUF_SIZE	4096</span>
<span class="cp">#define ISP116x_ITL_BUFSIZE	0</span>
<span class="cp">#define ISP116x_ATL_BUFSIZE	((ISP116x_BUF_SIZE) - 2*(ISP116x_ITL_BUFSIZE))</span>

<span class="cp">#define ISP116x_WRITE_OFFSET	0x80</span>

<span class="cm">/*------------ ISP116x registers/bits ------------*/</span>
<span class="cp">#define	HCREVISION	0x00</span>
<span class="cp">#define	HCCONTROL	0x01</span>
<span class="cp">#define		HCCONTROL_HCFS	(3 &lt;&lt; 6)	</span><span class="cm">/* host controller</span>
<span class="cm">						   functional state */</span><span class="cp"></span>
<span class="cp">#define		HCCONTROL_USB_RESET	(0 &lt;&lt; 6)</span>
<span class="cp">#define		HCCONTROL_USB_RESUME	(1 &lt;&lt; 6)</span>
<span class="cp">#define		HCCONTROL_USB_OPER	(2 &lt;&lt; 6)</span>
<span class="cp">#define		HCCONTROL_USB_SUSPEND	(3 &lt;&lt; 6)</span>
<span class="cp">#define		HCCONTROL_RWC	(1 &lt;&lt; 9)	</span><span class="cm">/* remote wakeup connected */</span><span class="cp"></span>
<span class="cp">#define		HCCONTROL_RWE	(1 &lt;&lt; 10)	</span><span class="cm">/* remote wakeup enable */</span><span class="cp"></span>
<span class="cp">#define	HCCMDSTAT	0x02</span>
<span class="cp">#define		HCCMDSTAT_HCR	(1 &lt;&lt; 0)	</span><span class="cm">/* host controller reset */</span><span class="cp"></span>
<span class="cp">#define		HCCMDSTAT_SOC	(3 &lt;&lt; 16)	</span><span class="cm">/* scheduling overrun count */</span><span class="cp"></span>
<span class="cp">#define	HCINTSTAT	0x03</span>
<span class="cp">#define		HCINT_SO	(1 &lt;&lt; 0)	</span><span class="cm">/* scheduling overrun */</span><span class="cp"></span>
<span class="cp">#define		HCINT_WDH	(1 &lt;&lt; 1)	</span><span class="cm">/* writeback of done_head */</span><span class="cp"></span>
<span class="cp">#define		HCINT_SF	(1 &lt;&lt; 2)	</span><span class="cm">/* start frame */</span><span class="cp"></span>
<span class="cp">#define		HCINT_RD	(1 &lt;&lt; 3)	</span><span class="cm">/* resume detect */</span><span class="cp"></span>
<span class="cp">#define		HCINT_UE	(1 &lt;&lt; 4)	</span><span class="cm">/* unrecoverable error */</span><span class="cp"></span>
<span class="cp">#define		HCINT_FNO	(1 &lt;&lt; 5)	</span><span class="cm">/* frame number overflow */</span><span class="cp"></span>
<span class="cp">#define		HCINT_RHSC	(1 &lt;&lt; 6)	</span><span class="cm">/* root hub status change */</span><span class="cp"></span>
<span class="cp">#define		HCINT_OC	(1 &lt;&lt; 30)	</span><span class="cm">/* ownership change */</span><span class="cp"></span>
<span class="cp">#define		HCINT_MIE	(1 &lt;&lt; 31)	</span><span class="cm">/* master interrupt enable */</span><span class="cp"></span>
<span class="cp">#define	HCINTENB	0x04</span>
<span class="cp">#define	HCINTDIS	0x05</span>
<span class="cp">#define	HCFMINTVL	0x0d</span>
<span class="cp">#define	HCFMREM		0x0e</span>
<span class="cp">#define	HCFMNUM		0x0f</span>
<span class="cp">#define	HCLSTHRESH	0x11</span>
<span class="cp">#define	HCRHDESCA	0x12</span>
<span class="cp">#define		RH_A_NDP	(0x3 &lt;&lt; 0)	</span><span class="cm">/* # downstream ports */</span><span class="cp"></span>
<span class="cp">#define		RH_A_PSM	(1 &lt;&lt; 8)	</span><span class="cm">/* power switching mode */</span><span class="cp"></span>
<span class="cp">#define		RH_A_NPS	(1 &lt;&lt; 9)	</span><span class="cm">/* no power switching */</span><span class="cp"></span>
<span class="cp">#define		RH_A_DT		(1 &lt;&lt; 10)	</span><span class="cm">/* device type (mbz) */</span><span class="cp"></span>
<span class="cp">#define		RH_A_OCPM	(1 &lt;&lt; 11)	</span><span class="cm">/* overcurrent protection</span>
<span class="cm">						   mode */</span><span class="cp"></span>
<span class="cp">#define		RH_A_NOCP	(1 &lt;&lt; 12)	</span><span class="cm">/* no overcurrent protection */</span><span class="cp"></span>
<span class="cp">#define		RH_A_POTPGT	(0xff &lt;&lt; 24)	</span><span class="cm">/* power on -&gt; power good</span>
<span class="cm">						   time */</span><span class="cp"></span>
<span class="cp">#define	HCRHDESCB	0x13</span>
<span class="cp">#define		RH_B_DR		(0xffff &lt;&lt; 0)	</span><span class="cm">/* device removable flags */</span><span class="cp"></span>
<span class="cp">#define		RH_B_PPCM	(0xffff &lt;&lt; 16)	</span><span class="cm">/* port power control mask */</span><span class="cp"></span>
<span class="cp">#define	HCRHSTATUS	0x14</span>
<span class="cp">#define		RH_HS_LPS	(1 &lt;&lt; 0)	</span><span class="cm">/* local power status */</span><span class="cp"></span>
<span class="cp">#define		RH_HS_OCI	(1 &lt;&lt; 1)	</span><span class="cm">/* over current indicator */</span><span class="cp"></span>
<span class="cp">#define		RH_HS_DRWE	(1 &lt;&lt; 15)	</span><span class="cm">/* device remote wakeup</span>
<span class="cm">						   enable */</span><span class="cp"></span>
<span class="cp">#define		RH_HS_LPSC	(1 &lt;&lt; 16)	</span><span class="cm">/* local power status change */</span><span class="cp"></span>
<span class="cp">#define		RH_HS_OCIC	(1 &lt;&lt; 17)	</span><span class="cm">/* over current indicator</span>
<span class="cm">						   change */</span><span class="cp"></span>
<span class="cp">#define		RH_HS_CRWE	(1 &lt;&lt; 31)	</span><span class="cm">/* clear remote wakeup</span>
<span class="cm">						   enable */</span><span class="cp"></span>
<span class="cp">#define	HCRHPORT1	0x15</span>
<span class="cp">#define		RH_PS_CCS	(1 &lt;&lt; 0)	</span><span class="cm">/* current connect status */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_PES	(1 &lt;&lt; 1)	</span><span class="cm">/* port enable status */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_PSS	(1 &lt;&lt; 2)	</span><span class="cm">/* port suspend status */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_POCI	(1 &lt;&lt; 3)	</span><span class="cm">/* port over current</span>
<span class="cm">						   indicator */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_PRS	(1 &lt;&lt; 4)	</span><span class="cm">/* port reset status */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_PPS	(1 &lt;&lt; 8)	</span><span class="cm">/* port power status */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_LSDA	(1 &lt;&lt; 9)	</span><span class="cm">/* low speed device attached */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_CSC	(1 &lt;&lt; 16)	</span><span class="cm">/* connect status change */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_PESC	(1 &lt;&lt; 17)	</span><span class="cm">/* port enable status change */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_PSSC	(1 &lt;&lt; 18)	</span><span class="cm">/* port suspend status</span>
<span class="cm">						   change */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_OCIC	(1 &lt;&lt; 19)	</span><span class="cm">/* over current indicator</span>
<span class="cm">						   change */</span><span class="cp"></span>
<span class="cp">#define		RH_PS_PRSC	(1 &lt;&lt; 20)	</span><span class="cm">/* port reset status change */</span><span class="cp"></span>
<span class="cp">#define		HCRHPORT_CLRMASK	(0x1f &lt;&lt; 16)</span>
<span class="cp">#define	HCRHPORT2	0x16</span>
<span class="cp">#define	HCHWCFG		0x20</span>
<span class="cp">#define		HCHWCFG_15KRSEL		(1 &lt;&lt; 12)</span>
<span class="cp">#define		HCHWCFG_CLKNOTSTOP	(1 &lt;&lt; 11)</span>
<span class="cp">#define		HCHWCFG_ANALOG_OC	(1 &lt;&lt; 10)</span>
<span class="cp">#define		HCHWCFG_DACK_MODE	(1 &lt;&lt; 8)</span>
<span class="cp">#define		HCHWCFG_EOT_POL		(1 &lt;&lt; 7)</span>
<span class="cp">#define		HCHWCFG_DACK_POL	(1 &lt;&lt; 6)</span>
<span class="cp">#define		HCHWCFG_DREQ_POL	(1 &lt;&lt; 5)</span>
<span class="cp">#define		HCHWCFG_DBWIDTH_MASK	(0x03 &lt;&lt; 3)</span>
<span class="cp">#define		HCHWCFG_DBWIDTH(n)	(((n) &lt;&lt; 3) &amp; HCHWCFG_DBWIDTH_MASK)</span>
<span class="cp">#define		HCHWCFG_INT_POL		(1 &lt;&lt; 2)</span>
<span class="cp">#define		HCHWCFG_INT_TRIGGER	(1 &lt;&lt; 1)</span>
<span class="cp">#define		HCHWCFG_INT_ENABLE	(1 &lt;&lt; 0)</span>
<span class="cp">#define	HCDMACFG	0x21</span>
<span class="cp">#define		HCDMACFG_BURST_LEN_MASK	(0x03 &lt;&lt; 5)</span>
<span class="cp">#define		HCDMACFG_BURST_LEN(n)	(((n) &lt;&lt; 5) &amp; HCDMACFG_BURST_LEN_MASK)</span>
<span class="cp">#define		HCDMACFG_BURST_LEN_1	HCDMACFG_BURST_LEN(0)</span>
<span class="cp">#define		HCDMACFG_BURST_LEN_4	HCDMACFG_BURST_LEN(1)</span>
<span class="cp">#define		HCDMACFG_BURST_LEN_8	HCDMACFG_BURST_LEN(2)</span>
<span class="cp">#define		HCDMACFG_DMA_ENABLE	(1 &lt;&lt; 4)</span>
<span class="cp">#define		HCDMACFG_BUF_TYPE_MASK	(0x07 &lt;&lt; 1)</span>
<span class="cp">#define		HCDMACFG_CTR_SEL	(1 &lt;&lt; 2)</span>
<span class="cp">#define		HCDMACFG_ITLATL_SEL	(1 &lt;&lt; 1)</span>
<span class="cp">#define		HCDMACFG_DMA_RW_SELECT	(1 &lt;&lt; 0)</span>
<span class="cp">#define	HCXFERCTR	0x22</span>
<span class="cp">#define	HCuPINT		0x24</span>
<span class="cp">#define		HCuPINT_SOF		(1 &lt;&lt; 0)</span>
<span class="cp">#define		HCuPINT_ATL		(1 &lt;&lt; 1)</span>
<span class="cp">#define		HCuPINT_AIIEOT		(1 &lt;&lt; 2)</span>
<span class="cp">#define		HCuPINT_OPR		(1 &lt;&lt; 4)</span>
<span class="cp">#define		HCuPINT_SUSP		(1 &lt;&lt; 5)</span>
<span class="cp">#define		HCuPINT_CLKRDY		(1 &lt;&lt; 6)</span>
<span class="cp">#define	HCuPINTENB	0x25</span>
<span class="cp">#define	HCCHIPID	0x27</span>
<span class="cp">#define		HCCHIPID_MASK		0xff00</span>
<span class="cp">#define		HCCHIPID_MAGIC		0x6100</span>
<span class="cp">#define	HCSCRATCH	0x28</span>
<span class="cp">#define	HCSWRES		0x29</span>
<span class="cp">#define		HCSWRES_MAGIC		0x00f6</span>
<span class="cp">#define	HCITLBUFLEN	0x2a</span>
<span class="cp">#define	HCATLBUFLEN	0x2b</span>
<span class="cp">#define	HCBUFSTAT	0x2c</span>
<span class="cp">#define		HCBUFSTAT_ITL0_FULL	(1 &lt;&lt; 0)</span>
<span class="cp">#define		HCBUFSTAT_ITL1_FULL	(1 &lt;&lt; 1)</span>
<span class="cp">#define		HCBUFSTAT_ATL_FULL	(1 &lt;&lt; 2)</span>
<span class="cp">#define		HCBUFSTAT_ITL0_DONE	(1 &lt;&lt; 3)</span>
<span class="cp">#define		HCBUFSTAT_ITL1_DONE	(1 &lt;&lt; 4)</span>
<span class="cp">#define		HCBUFSTAT_ATL_DONE	(1 &lt;&lt; 5)</span>
<span class="cp">#define	HCRDITL0LEN	0x2d</span>
<span class="cp">#define	HCRDITL1LEN	0x2e</span>
<span class="cp">#define	HCITLPORT	0x40</span>
<span class="cp">#define	HCATLPORT	0x41</span>

<span class="cm">/* Philips transfer descriptor */</span>
<span class="k">struct</span> <span class="n">ptd</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">count</span><span class="p">;</span>
<span class="cp">#define	PTD_COUNT_MSK	(0x3ff &lt;&lt; 0)</span>
<span class="cp">#define	PTD_TOGGLE_MSK	(1 &lt;&lt; 10)</span>
<span class="cp">#define	PTD_ACTIVE_MSK	(1 &lt;&lt; 11)</span>
<span class="cp">#define	PTD_CC_MSK	(0xf &lt;&lt; 12)</span>
	<span class="n">u16</span> <span class="n">mps</span><span class="p">;</span>
<span class="cp">#define	PTD_MPS_MSK	(0x3ff &lt;&lt; 0)</span>
<span class="cp">#define	PTD_SPD_MSK	(1 &lt;&lt; 10)</span>
<span class="cp">#define	PTD_LAST_MSK	(1 &lt;&lt; 11)</span>
<span class="cp">#define	PTD_EP_MSK	(0xf &lt;&lt; 12)</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">;</span>
<span class="cp">#define	PTD_LEN_MSK	(0x3ff &lt;&lt; 0)</span>
<span class="cp">#define	PTD_DIR_MSK	(3 &lt;&lt; 10)</span>
<span class="cp">#define	PTD_DIR_SETUP	(0)</span>
<span class="cp">#define	PTD_DIR_OUT	(1)</span>
<span class="cp">#define	PTD_DIR_IN	(2)</span>
<span class="cp">#define	PTD_B5_5_MSK	(1 &lt;&lt; 13)</span>
	<span class="n">u16</span> <span class="n">faddr</span><span class="p">;</span>
<span class="cp">#define	PTD_FA_MSK	(0x7f &lt;&lt; 0)</span>
<span class="cp">#define	PTD_FMT_MSK	(1 &lt;&lt; 7)</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span>

<span class="cm">/* PTD accessor macros. */</span>
<span class="cp">#define PTD_GET_COUNT(p)	(((p)-&gt;count &amp; PTD_COUNT_MSK) &gt;&gt; 0)</span>
<span class="cp">#define PTD_COUNT(v)		(((v) &lt;&lt; 0) &amp; PTD_COUNT_MSK)</span>
<span class="cp">#define PTD_GET_TOGGLE(p)	(((p)-&gt;count &amp; PTD_TOGGLE_MSK) &gt;&gt; 10)</span>
<span class="cp">#define PTD_TOGGLE(v)		(((v) &lt;&lt; 10) &amp; PTD_TOGGLE_MSK)</span>
<span class="cp">#define PTD_GET_ACTIVE(p)	(((p)-&gt;count &amp; PTD_ACTIVE_MSK) &gt;&gt; 11)</span>
<span class="cp">#define PTD_ACTIVE(v)		(((v) &lt;&lt; 11) &amp; PTD_ACTIVE_MSK)</span>
<span class="cp">#define PTD_GET_CC(p)		(((p)-&gt;count &amp; PTD_CC_MSK) &gt;&gt; 12)</span>
<span class="cp">#define PTD_CC(v)		(((v) &lt;&lt; 12) &amp; PTD_CC_MSK)</span>
<span class="cp">#define PTD_GET_MPS(p)		(((p)-&gt;mps &amp; PTD_MPS_MSK) &gt;&gt; 0)</span>
<span class="cp">#define PTD_MPS(v)		(((v) &lt;&lt; 0) &amp; PTD_MPS_MSK)</span>
<span class="cp">#define PTD_GET_SPD(p)		(((p)-&gt;mps &amp; PTD_SPD_MSK) &gt;&gt; 10)</span>
<span class="cp">#define PTD_SPD(v)		(((v) &lt;&lt; 10) &amp; PTD_SPD_MSK)</span>
<span class="cp">#define PTD_GET_LAST(p)		(((p)-&gt;mps &amp; PTD_LAST_MSK) &gt;&gt; 11)</span>
<span class="cp">#define PTD_LAST(v)		(((v) &lt;&lt; 11) &amp; PTD_LAST_MSK)</span>
<span class="cp">#define PTD_GET_EP(p)		(((p)-&gt;mps &amp; PTD_EP_MSK) &gt;&gt; 12)</span>
<span class="cp">#define PTD_EP(v)		(((v) &lt;&lt; 12) &amp; PTD_EP_MSK)</span>
<span class="cp">#define PTD_GET_LEN(p)		(((p)-&gt;len &amp; PTD_LEN_MSK) &gt;&gt; 0)</span>
<span class="cp">#define PTD_LEN(v)		(((v) &lt;&lt; 0) &amp; PTD_LEN_MSK)</span>
<span class="cp">#define PTD_GET_DIR(p)		(((p)-&gt;len &amp; PTD_DIR_MSK) &gt;&gt; 10)</span>
<span class="cp">#define PTD_DIR(v)		(((v) &lt;&lt; 10) &amp; PTD_DIR_MSK)</span>
<span class="cp">#define PTD_GET_B5_5(p)		(((p)-&gt;len &amp; PTD_B5_5_MSK) &gt;&gt; 13)</span>
<span class="cp">#define PTD_B5_5(v)		(((v) &lt;&lt; 13) &amp; PTD_B5_5_MSK)</span>
<span class="cp">#define PTD_GET_FA(p)		(((p)-&gt;faddr &amp; PTD_FA_MSK) &gt;&gt; 0)</span>
<span class="cp">#define PTD_FA(v)		(((v) &lt;&lt; 0) &amp; PTD_FA_MSK)</span>
<span class="cp">#define PTD_GET_FMT(p)		(((p)-&gt;faddr &amp; PTD_FMT_MSK) &gt;&gt; 7)</span>
<span class="cp">#define PTD_FMT(v)		(((v) &lt;&lt; 7) &amp; PTD_FMT_MSK)</span>

<span class="cm">/*  Hardware transfer status codes -- CC from ptd-&gt;count */</span>
<span class="cp">#define TD_CC_NOERROR      0x00</span>
<span class="cp">#define TD_CC_CRC          0x01</span>
<span class="cp">#define TD_CC_BITSTUFFING  0x02</span>
<span class="cp">#define TD_CC_DATATOGGLEM  0x03</span>
<span class="cp">#define TD_CC_STALL        0x04</span>
<span class="cp">#define TD_DEVNOTRESP      0x05</span>
<span class="cp">#define TD_PIDCHECKFAIL    0x06</span>
<span class="cp">#define TD_UNEXPECTEDPID   0x07</span>
<span class="cp">#define TD_DATAOVERRUN     0x08</span>
<span class="cp">#define TD_DATAUNDERRUN    0x09</span>
    <span class="cm">/* 0x0A, 0x0B reserved for hardware */</span>
<span class="cp">#define TD_BUFFEROVERRUN   0x0C</span>
<span class="cp">#define TD_BUFFERUNDERRUN  0x0D</span>
    <span class="cm">/* 0x0E, 0x0F reserved for HCD */</span>
<span class="cp">#define TD_NOTACCESSED     0x0F</span>

<span class="cm">/* map PTD status codes (CC) to errno values */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cc_to_error</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* No  Error  */</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* CRC Error  */</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">,</span>
	<span class="cm">/* Bit Stuff  */</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">,</span>
	<span class="cm">/* Data Togg  */</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">,</span>
	<span class="cm">/* Stall      */</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">,</span>
	<span class="cm">/* DevNotResp */</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">,</span>
	<span class="cm">/* PIDCheck   */</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">,</span>
	<span class="cm">/* UnExpPID   */</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">,</span>
	<span class="cm">/* DataOver   */</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">,</span>
	<span class="cm">/* DataUnder  */</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">,</span>
	<span class="cm">/* (for hw)   */</span> <span class="o">-</span><span class="n">EIO</span><span class="p">,</span>
	<span class="cm">/* (for hw)   */</span> <span class="o">-</span><span class="n">EIO</span><span class="p">,</span>
	<span class="cm">/* BufferOver */</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">,</span>
	<span class="cm">/* BuffUnder  */</span> <span class="o">-</span><span class="n">ENOSR</span><span class="p">,</span>
	<span class="cm">/* (for HCD)  */</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">,</span>
	<span class="cm">/* (for HCD)  */</span> <span class="o">-</span><span class="n">EALREADY</span>
<span class="p">};</span>

<span class="cm">/*--------------------------------------------------------------*/</span>

<span class="cp">#define	LOG2_PERIODIC_SIZE	5	</span><span class="cm">/* arbitrary; this matches OHCI */</span><span class="cp"></span>
<span class="cp">#define	PERIODIC_SIZE		(1 &lt;&lt; LOG2_PERIODIC_SIZE)</span>

<span class="k">struct</span> <span class="n">isp116x</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr_reg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_reg</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">isp116x_platform_data</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stat1</span><span class="p">,</span> <span class="n">stat2</span><span class="p">,</span> <span class="n">stat4</span><span class="p">,</span> <span class="n">stat8</span><span class="p">,</span> <span class="n">stat16</span><span class="p">;</span>

	<span class="cm">/* HC registers */</span>
	<span class="n">u32</span> <span class="n">intenb</span><span class="p">;</span>		<span class="cm">/* &quot;OHCI&quot; interrupts */</span>
	<span class="n">u16</span> <span class="n">irqenb</span><span class="p">;</span>		<span class="cm">/* uP interrupts */</span>

	<span class="cm">/* Root hub registers */</span>
	<span class="n">u32</span> <span class="n">rhdesca</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rhdescb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rhstatus</span><span class="p">;</span>

	<span class="cm">/* async schedule: control, bulk */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">async</span><span class="p">;</span>

	<span class="cm">/* periodic schedule: int */</span>
	<span class="n">u16</span> <span class="n">load</span><span class="p">[</span><span class="n">PERIODIC_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">isp116x_ep</span> <span class="o">*</span><span class="n">periodic</span><span class="p">[</span><span class="n">PERIODIC_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">periodic_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fmindex</span><span class="p">;</span>

	<span class="cm">/* Schedule for the current frame */</span>
	<span class="k">struct</span> <span class="n">isp116x_ep</span> <span class="o">*</span><span class="n">atl_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">atl_buflen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">atl_bufshrt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">atl_last_dir</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">atl_finishing</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="nf">hcd_to_isp116x</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="p">)(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">isp116x_to_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">isp116x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">isp116x_ep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">hep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptd</span> <span class="n">ptd</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">epnum</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nextpid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">error_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">;</span>		<span class="cm">/* of current packet */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>	<span class="cm">/* to databuf */</span>
	<span class="cm">/* queue of active EP&#39;s (the ones scheduled for the</span>
<span class="cm">	   current frame) */</span>
	<span class="k">struct</span> <span class="n">isp116x_ep</span> <span class="o">*</span><span class="n">active</span><span class="p">;</span>

	<span class="cm">/* periodic schedule */</span>
	<span class="n">u16</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">branch</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">load</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isp116x_ep</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* async schedule */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">schedule</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DBG(stuff...)		printk(KERN_DEBUG &quot;116x: &quot; stuff)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(stuff...)		do{}while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef VERBOSE</span>
<span class="cp">#    define VDBG		DBG</span>
<span class="cp">#else</span>
<span class="cp">#    define VDBG(stuff...)	do{}while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#define ERR(stuff...)		printk(KERN_ERR &quot;116x: &quot; stuff)</span>
<span class="cp">#define WARNING(stuff...)	printk(KERN_WARNING &quot;116x: &quot; stuff)</span>
<span class="cp">#define INFO(stuff...)		printk(KERN_INFO &quot;116x: &quot; stuff)</span>

<span class="cm">/* ------------------------------------------------- */</span>

<span class="cp">#if defined(USE_PLATFORM_DELAY)</span>
<span class="cp">#if defined(USE_NDELAY)</span>
<span class="cp">#error USE_PLATFORM_DELAY and USE_NDELAY simultaneously defined.</span>
<span class="cp">#endif</span>
<span class="cp">#define	isp116x_delay(h,d)	(h)-&gt;board-&gt;delay(	\</span>
<span class="cp">				isp116x_to_hcd(h)-&gt;self.controller,d)</span>
<span class="cp">#define isp116x_check_platform_delay(h)	((h)-&gt;board-&gt;delay == NULL)</span>
<span class="cp">#elif defined(USE_NDELAY)</span>
<span class="cp">#define	isp116x_delay(h,d)	ndelay(d)</span>
<span class="cp">#define isp116x_check_platform_delay(h)	0</span>
<span class="cp">#else</span>
<span class="cp">#define	isp116x_delay(h,d)	do{}while(0)</span>
<span class="cp">#define isp116x_check_platform_delay(h)	0</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(DEBUG)</span>
<span class="cp">#define	IRQ_TEST()	BUG_ON(!irqs_disabled())</span>
<span class="cp">#else</span>
<span class="cp">#define	IRQ_TEST()	do{}while(0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">isp116x_write_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRQ_TEST</span><span class="p">();</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">addr_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">isp116x_write_data16</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">isp116x_raw_write_data16</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writew</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">isp116x_read_data16</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">isp116x_raw_read_data16</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">__raw_readw</span><span class="p">(</span><span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">isp116x_write_data32</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">isp116x_read_data32</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">readw</span><span class="p">(</span><span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">readw</span><span class="p">(</span><span class="n">isp116x</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">isp116x_delay</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Let&#39;s keep register access functions out of line. Hint:</span>
<span class="cm">   we wait at least 150 ns at every access.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">isp116x_read_reg16</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isp116x_write_addr</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">isp116x_read_data16</span><span class="p">(</span><span class="n">isp116x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">isp116x_read_reg32</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isp116x_write_addr</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">isp116x_read_data32</span><span class="p">(</span><span class="n">isp116x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp116x_write_reg16</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isp116x_write_addr</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="n">ISP116x_WRITE_OFFSET</span><span class="p">);</span>
	<span class="n">isp116x_write_data16</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isp116x_write_reg32</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isp116x_write_addr</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="n">ISP116x_WRITE_OFFSET</span><span class="p">);</span>
	<span class="n">isp116x_write_data32</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define isp116x_show_reg_log(d,r,s) {				\</span>
<span class="cp">	if ((r) &lt; 0x20) {			                \</span>
<span class="cp">		DBG(&quot;%-12s[%02x]: %08x\n&quot;, #r,			\</span>
<span class="cp">			r, isp116x_read_reg32(d, r));		\</span>
<span class="cp">	} else {						\</span>
<span class="cp">		DBG(&quot;%-12s[%02x]:     %04x\n&quot;, #r,		\</span>
<span class="cp">			r, isp116x_read_reg16(d, r));	    	\</span>
<span class="cp">	}							\</span>
<span class="cp">}</span>
<span class="cp">#define isp116x_show_reg_seq(d,r,s) {				\</span>
<span class="cp">	if ((r) &lt; 0x20) {					\</span>
<span class="cp">		seq_printf(s, &quot;%-12s[%02x]: %08x\n&quot;, #r,	\</span>
<span class="cp">			r, isp116x_read_reg32(d, r));		\</span>
<span class="cp">	} else {						\</span>
<span class="cp">		seq_printf(s, &quot;%-12s[%02x]:     %04x\n&quot;, #r,	\</span>
<span class="cp">			r, isp116x_read_reg16(d, r));		\</span>
<span class="cp">	}							\</span>
<span class="cp">}</span>

<span class="cp">#define isp116x_show_regs(d,type,s) {			\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCREVISION, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCCONTROL, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCCMDSTAT, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCINTSTAT, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCINTENB, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCFMINTVL, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCFMREM, s);		\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCFMNUM, s);		\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCLSTHRESH, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCRHDESCA, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCRHDESCB, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCRHSTATUS, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCRHPORT1, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCRHPORT2, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCHWCFG, s);		\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCDMACFG, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCXFERCTR, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCuPINT, s);		\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCuPINTENB, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCCHIPID, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCSCRATCH, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCITLBUFLEN, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCATLBUFLEN, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCBUFSTAT, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCRDITL0LEN, s);	\</span>
<span class="cp">	isp116x_show_reg_##type(d, HCRDITL1LEN, s);	\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm">   Dump registers for debugfs.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">isp116x_show_regs_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isp116x_show_regs</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">   Dump registers to syslog.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">isp116x_show_regs_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">isp116x</span> <span class="o">*</span><span class="n">isp116x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isp116x_show_regs</span><span class="p">(</span><span class="n">isp116x</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(URB_TRACE)</span>

<span class="cp">#define PIPETYPE(pipe)  ({ char *__s;			\</span>
<span class="cp">	if (usb_pipecontrol(pipe))	__s = &quot;ctrl&quot;;	\</span>
<span class="cp">	else if (usb_pipeint(pipe))	__s = &quot;int&quot;;	\</span>
<span class="cp">	else if (usb_pipebulk(pipe))	__s = &quot;bulk&quot;;	\</span>
<span class="cp">	else				__s = &quot;iso&quot;;	\</span>
<span class="cp">	__s;})</span>
<span class="cp">#define PIPEDIR(pipe)   ({ usb_pipein(pipe) ? &quot;in&quot; : &quot;out&quot;; })</span>
<span class="cp">#define URB_NOTSHORT(urb) ({ (urb)-&gt;transfer_flags &amp; URB_SHORT_NOT_OK ? \</span>
<span class="cp">	&quot;short_not_ok&quot; : &quot;&quot;; })</span>

<span class="cm">/* print debug info about the URB */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">urb_dbg</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%s: zero urb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%s: FA %d ep%d%s %s: len %d/%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
	    <span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span>
	    <span class="n">PIPEDIR</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span> <span class="n">PIPETYPE</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span>
	    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span> <span class="n">URB_NOTSHORT</span><span class="p">(</span><span class="n">urb</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define  urb_dbg(urb,msg)   do{}while(0)</span>

<span class="cp">#endif				</span><span class="cm">/* ! defined(URB_TRACE) */</span><span class="cp"></span>

<span class="cp">#if defined(PTD_TRACE)</span>

<span class="cp">#define PTD_DIR_STR(ptd)  ({char __c;		\</span>
<span class="cp">	switch(PTD_GET_DIR(ptd)){		\</span>
<span class="cp">	case 0:  __c = &#39;s&#39;; break;		\</span>
<span class="cp">	case 1:  __c = &#39;o&#39;; break;		\</span>
<span class="cp">	default: __c = &#39;i&#39;; break;		\</span>
<span class="cp">	}; __c;})</span>

<span class="cm">/*</span>
<span class="cm">  Dump PTD info. The code documents the format</span>
<span class="cm">  perfectly, right :)</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_ptd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;td: %x %d%c%d %d,%d,%d  %x %x%x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">PTD_GET_CC</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span> <span class="n">PTD_GET_FA</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span>
	       <span class="n">PTD_DIR_STR</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span> <span class="n">PTD_GET_EP</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span>
	       <span class="n">PTD_GET_COUNT</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span> <span class="n">PTD_GET_LEN</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span> <span class="n">PTD_GET_MPS</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span>
	       <span class="n">PTD_GET_TOGGLE</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span> <span class="n">PTD_GET_ACTIVE</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span>
	       <span class="n">PTD_GET_SPD</span><span class="p">(</span><span class="n">ptd</span><span class="p">),</span> <span class="n">PTD_GET_LAST</span><span class="p">(</span><span class="n">ptd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_ptd_out_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PTD_GET_DIR</span><span class="p">(</span><span class="n">ptd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PTD_DIR_IN</span> <span class="o">&amp;&amp;</span> <span class="n">PTD_GET_LEN</span><span class="p">(</span><span class="n">ptd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;-&gt; &quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">PTD_GET_LEN</span><span class="p">(</span><span class="n">ptd</span><span class="p">);</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">)[</span><span class="n">k</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_ptd_in_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptd</span> <span class="o">*</span><span class="n">ptd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PTD_GET_DIR</span><span class="p">(</span><span class="n">ptd</span><span class="p">)</span> <span class="o">==</span> <span class="n">PTD_DIR_IN</span> <span class="o">&amp;&amp;</span> <span class="n">PTD_GET_COUNT</span><span class="p">(</span><span class="n">ptd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;&lt;- &quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">PTD_GET_COUNT</span><span class="p">(</span><span class="n">ptd</span><span class="p">);</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">)[</span><span class="n">k</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PTD_GET_LAST</span><span class="p">(</span><span class="n">ptd</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;-</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define dump_ptd(ptd)               do{}while(0)</span>
<span class="cp">#define dump_ptd_in_data(ptd,buf)   do{}while(0)</span>
<span class="cp">#define dump_ptd_out_data(ptd,buf)  do{}while(0)</span>

<span class="cp">#endif				</span><span class="cm">/* ! defined(PTD_TRACE) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
