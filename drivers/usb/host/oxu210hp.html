<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › oxu210hp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>oxu210hp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Host interface registers</span>
<span class="cm"> */</span>

<span class="cp">#define OXU_DEVICEID			0x00</span>
	<span class="cp">#define OXU_REV_MASK		0xffff0000</span>
	<span class="cp">#define OXU_REV_SHIFT		16</span>
	<span class="cp">#define OXU_REV_2100		0x2100</span>
	<span class="cp">#define OXU_BO_SHIFT		8</span>
	<span class="cp">#define OXU_BO_MASK		(0x3 &lt;&lt; OXU_BO_SHIFT)</span>
	<span class="cp">#define OXU_MAJ_REV_SHIFT	4</span>
	<span class="cp">#define OXU_MAJ_REV_MASK	(0xf &lt;&lt; OXU_MAJ_REV_SHIFT)</span>
	<span class="cp">#define OXU_MIN_REV_SHIFT	0</span>
	<span class="cp">#define OXU_MIN_REV_MASK	(0xf &lt;&lt; OXU_MIN_REV_SHIFT)</span>
<span class="cp">#define OXU_HOSTIFCONFIG		0x04</span>
<span class="cp">#define OXU_SOFTRESET			0x08</span>
	<span class="cp">#define OXU_SRESET		(1 &lt;&lt; 0)</span>

<span class="cp">#define OXU_PIOBURSTREADCTRL		0x0C</span>

<span class="cp">#define OXU_CHIPIRQSTATUS		0x10</span>
<span class="cp">#define OXU_CHIPIRQEN_SET		0x14</span>
<span class="cp">#define OXU_CHIPIRQEN_CLR		0x18</span>
	<span class="cp">#define OXU_USBSPHLPWUI		0x00000080</span>
	<span class="cp">#define OXU_USBOTGLPWUI		0x00000040</span>
	<span class="cp">#define OXU_USBSPHI		0x00000002</span>
	<span class="cp">#define OXU_USBOTGI		0x00000001</span>

<span class="cp">#define OXU_CLKCTRL_SET			0x1C</span>
	<span class="cp">#define OXU_SYSCLKEN		0x00000008</span>
	<span class="cp">#define OXU_USBSPHCLKEN		0x00000002</span>
	<span class="cp">#define OXU_USBOTGCLKEN		0x00000001</span>

<span class="cp">#define OXU_ASO				0x68</span>
	<span class="cp">#define OXU_SPHPOEN		0x00000100</span>
	<span class="cp">#define OXU_OVRCCURPUPDEN	0x00000800</span>
	<span class="cp">#define OXU_ASO_OP		(1 &lt;&lt; 10)</span>
	<span class="cp">#define OXU_COMPARATOR		0x000004000</span>

<span class="cp">#define OXU_USBMODE			0x1A8</span>
	<span class="cp">#define OXU_VBPS		0x00000020</span>
	<span class="cp">#define OXU_ES_LITTLE		0x00000000</span>
	<span class="cp">#define OXU_CM_HOST_ONLY	0x00000003</span>

<span class="cm">/*</span>
<span class="cm"> * Proper EHCI structs &amp; defines</span>
<span class="cm"> */</span>

<span class="cm">/* Magic numbers that can affect system performance */</span>
<span class="cp">#define EHCI_TUNE_CERR		3	</span><span class="cm">/* 0-3 qtd retries; 0 == don&#39;t stop */</span><span class="cp"></span>
<span class="cp">#define EHCI_TUNE_RL_HS		4	</span><span class="cm">/* nak throttle; see 4.9 */</span><span class="cp"></span>
<span class="cp">#define EHCI_TUNE_RL_TT		0</span>
<span class="cp">#define EHCI_TUNE_MULT_HS	1	</span><span class="cm">/* 1-3 transactions/uframe; 4.10.3 */</span><span class="cp"></span>
<span class="cp">#define EHCI_TUNE_MULT_TT	1</span>
<span class="cp">#define EHCI_TUNE_FLS		2	</span><span class="cm">/* (small) 256 frame schedule */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">oxu_hcd</span><span class="p">;</span>

<span class="cm">/* EHCI register interface, corresponds to EHCI Revision 0.95 specification */</span>

<span class="cm">/* Section 2.2 Host Controller Capability Registers */</span>
<span class="k">struct</span> <span class="n">ehci_caps</span> <span class="p">{</span>
	<span class="cm">/* these fields are specified as 8 and 16 bit registers,</span>
<span class="cm">	 * but some hosts can&#39;t perform 8 or 16 bit PCI accesses.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>		<span class="n">hc_capbase</span><span class="p">;</span>
<span class="cp">#define HC_LENGTH(p)		(((p)&gt;&gt;00)&amp;0x00ff)	</span><span class="cm">/* bits 7:0 */</span><span class="cp"></span>
<span class="cp">#define HC_VERSION(p)		(((p)&gt;&gt;16)&amp;0xffff)	</span><span class="cm">/* bits 31:16 */</span><span class="cp"></span>
	<span class="n">u32</span>		<span class="n">hcs_params</span><span class="p">;</span>     <span class="cm">/* HCSPARAMS - offset 0x4 */</span>
<span class="cp">#define HCS_DEBUG_PORT(p)	(((p)&gt;&gt;20)&amp;0xf)	</span><span class="cm">/* bits 23:20, debug port? */</span><span class="cp"></span>
<span class="cp">#define HCS_INDICATOR(p)	((p)&amp;(1 &lt;&lt; 16))	</span><span class="cm">/* true: has port indicators */</span><span class="cp"></span>
<span class="cp">#define HCS_N_CC(p)		(((p)&gt;&gt;12)&amp;0xf)	</span><span class="cm">/* bits 15:12, #companion HCs */</span><span class="cp"></span>
<span class="cp">#define HCS_N_PCC(p)		(((p)&gt;&gt;8)&amp;0xf)	</span><span class="cm">/* bits 11:8, ports per CC */</span><span class="cp"></span>
<span class="cp">#define HCS_PORTROUTED(p)	((p)&amp;(1 &lt;&lt; 7))	</span><span class="cm">/* true: port routing */</span><span class="cp"></span>
<span class="cp">#define HCS_PPC(p)		((p)&amp;(1 &lt;&lt; 4))	</span><span class="cm">/* true: port power control */</span><span class="cp"></span>
<span class="cp">#define HCS_N_PORTS(p)		(((p)&gt;&gt;0)&amp;0xf)	</span><span class="cm">/* bits 3:0, ports on HC */</span><span class="cp"></span>

	<span class="n">u32</span>		<span class="n">hcc_params</span><span class="p">;</span>      <span class="cm">/* HCCPARAMS - offset 0x8 */</span>
<span class="cp">#define HCC_EXT_CAPS(p)		(((p)&gt;&gt;8)&amp;0xff)	</span><span class="cm">/* for pci extended caps */</span><span class="cp"></span>
<span class="cp">#define HCC_ISOC_CACHE(p)       ((p)&amp;(1 &lt;&lt; 7))  </span><span class="cm">/* true: can cache isoc frame */</span><span class="cp"></span>
<span class="cp">#define HCC_ISOC_THRES(p)       (((p)&gt;&gt;4)&amp;0x7)  </span><span class="cm">/* bits 6:4, uframes cached */</span><span class="cp"></span>
<span class="cp">#define HCC_CANPARK(p)		((p)&amp;(1 &lt;&lt; 2))  </span><span class="cm">/* true: can park on async qh */</span><span class="cp"></span>
<span class="cp">#define HCC_PGM_FRAMELISTLEN(p) ((p)&amp;(1 &lt;&lt; 1))  </span><span class="cm">/* true: periodic_size changes*/</span><span class="cp"></span>
<span class="cp">#define HCC_64BIT_ADDR(p)       ((p)&amp;(1))       </span><span class="cm">/* true: can use 64-bit addr */</span><span class="cp"></span>
	<span class="n">u8</span>		<span class="n">portroute</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	 <span class="cm">/* nibbles for routing - offset 0xC */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="cm">/* Section 2.3 Host Controller Operational Registers */</span>
<span class="k">struct</span> <span class="n">ehci_regs</span> <span class="p">{</span>
	<span class="cm">/* USBCMD: offset 0x00 */</span>
	<span class="n">u32</span>		<span class="n">command</span><span class="p">;</span>
<span class="cm">/* 23:16 is r/w intr rate, in microframes; default &quot;8&quot; == 1/msec */</span>
<span class="cp">#define CMD_PARK	(1&lt;&lt;11)		</span><span class="cm">/* enable &quot;park&quot; on async qh */</span><span class="cp"></span>
<span class="cp">#define CMD_PARK_CNT(c)	(((c)&gt;&gt;8)&amp;3)	</span><span class="cm">/* how many transfers to park for */</span><span class="cp"></span>
<span class="cp">#define CMD_LRESET	(1&lt;&lt;7)		</span><span class="cm">/* partial reset (no ports, etc) */</span><span class="cp"></span>
<span class="cp">#define CMD_IAAD	(1&lt;&lt;6)		</span><span class="cm">/* &quot;doorbell&quot; interrupt async advance */</span><span class="cp"></span>
<span class="cp">#define CMD_ASE		(1&lt;&lt;5)		</span><span class="cm">/* async schedule enable */</span><span class="cp"></span>
<span class="cp">#define CMD_PSE		(1&lt;&lt;4)		</span><span class="cm">/* periodic schedule enable */</span><span class="cp"></span>
<span class="cm">/* 3:2 is periodic frame list size */</span>
<span class="cp">#define CMD_RESET	(1&lt;&lt;1)		</span><span class="cm">/* reset HC not bus */</span><span class="cp"></span>
<span class="cp">#define CMD_RUN		(1&lt;&lt;0)		</span><span class="cm">/* start/stop HC */</span><span class="cp"></span>

	<span class="cm">/* USBSTS: offset 0x04 */</span>
	<span class="n">u32</span>		<span class="n">status</span><span class="p">;</span>
<span class="cp">#define STS_ASS		(1&lt;&lt;15)		</span><span class="cm">/* Async Schedule Status */</span><span class="cp"></span>
<span class="cp">#define STS_PSS		(1&lt;&lt;14)		</span><span class="cm">/* Periodic Schedule Status */</span><span class="cp"></span>
<span class="cp">#define STS_RECL	(1&lt;&lt;13)		</span><span class="cm">/* Reclamation */</span><span class="cp"></span>
<span class="cp">#define STS_HALT	(1&lt;&lt;12)		</span><span class="cm">/* Not running (any reason) */</span><span class="cp"></span>
<span class="cm">/* some bits reserved */</span>
	<span class="cm">/* these STS_* flags are also intr_enable bits (USBINTR) */</span>
<span class="cp">#define STS_IAA		(1&lt;&lt;5)		</span><span class="cm">/* Interrupted on async advance */</span><span class="cp"></span>
<span class="cp">#define STS_FATAL	(1&lt;&lt;4)		</span><span class="cm">/* such as some PCI access errors */</span><span class="cp"></span>
<span class="cp">#define STS_FLR		(1&lt;&lt;3)		</span><span class="cm">/* frame list rolled over */</span><span class="cp"></span>
<span class="cp">#define STS_PCD		(1&lt;&lt;2)		</span><span class="cm">/* port change detect */</span><span class="cp"></span>
<span class="cp">#define STS_ERR		(1&lt;&lt;1)		</span><span class="cm">/* &quot;error&quot; completion (overflow, ...) */</span><span class="cp"></span>
<span class="cp">#define STS_INT		(1&lt;&lt;0)		</span><span class="cm">/* &quot;normal&quot; completion (short, ...) */</span><span class="cp"></span>

<span class="cp">#define INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)</span>

	<span class="cm">/* USBINTR: offset 0x08 */</span>
	<span class="n">u32</span>		<span class="n">intr_enable</span><span class="p">;</span>

	<span class="cm">/* FRINDEX: offset 0x0C */</span>
	<span class="n">u32</span>		<span class="n">frame_index</span><span class="p">;</span>	<span class="cm">/* current microframe number */</span>
	<span class="cm">/* CTRLDSSEGMENT: offset 0x10 */</span>
	<span class="n">u32</span>		<span class="n">segment</span><span class="p">;</span>	<span class="cm">/* address bits 63:32 if needed */</span>
	<span class="cm">/* PERIODICLISTBASE: offset 0x14 */</span>
	<span class="n">u32</span>		<span class="n">frame_list</span><span class="p">;</span>	<span class="cm">/* points to periodic list */</span>
	<span class="cm">/* ASYNCLISTADDR: offset 0x18 */</span>
	<span class="n">u32</span>		<span class="n">async_next</span><span class="p">;</span>	<span class="cm">/* address of next async queue head */</span>

	<span class="n">u32</span>		<span class="n">reserved</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

	<span class="cm">/* CONFIGFLAG: offset 0x40 */</span>
	<span class="n">u32</span>		<span class="n">configured_flag</span><span class="p">;</span>
<span class="cp">#define FLAG_CF		(1&lt;&lt;0)		</span><span class="cm">/* true: we&#39;ll support &quot;high speed&quot; */</span><span class="cp"></span>

	<span class="cm">/* PORTSC: offset 0x44 */</span>
	<span class="n">u32</span>		<span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* up to N_PORTS */</span>
<span class="cm">/* 31:23 reserved */</span>
<span class="cp">#define PORT_WKOC_E	(1&lt;&lt;22)		</span><span class="cm">/* wake on overcurrent (enable) */</span><span class="cp"></span>
<span class="cp">#define PORT_WKDISC_E	(1&lt;&lt;21)		</span><span class="cm">/* wake on disconnect (enable) */</span><span class="cp"></span>
<span class="cp">#define PORT_WKCONN_E	(1&lt;&lt;20)		</span><span class="cm">/* wake on connect (enable) */</span><span class="cp"></span>
<span class="cm">/* 19:16 for port testing */</span>
<span class="cp">#define PORT_LED_OFF	(0&lt;&lt;14)</span>
<span class="cp">#define PORT_LED_AMBER	(1&lt;&lt;14)</span>
<span class="cp">#define PORT_LED_GREEN	(2&lt;&lt;14)</span>
<span class="cp">#define PORT_LED_MASK	(3&lt;&lt;14)</span>
<span class="cp">#define PORT_OWNER	(1&lt;&lt;13)		</span><span class="cm">/* true: companion hc owns this port */</span><span class="cp"></span>
<span class="cp">#define PORT_POWER	(1&lt;&lt;12)		</span><span class="cm">/* true: has power (see PPC) */</span><span class="cp"></span>
<span class="cp">#define PORT_USB11(x) (((x)&amp;(3&lt;&lt;10)) == (1&lt;&lt;10))	</span><span class="cm">/* USB 1.1 device */</span><span class="cp"></span>
<span class="cm">/* 11:10 for detecting lowspeed devices (reset vs release ownership) */</span>
<span class="cm">/* 9 reserved */</span>
<span class="cp">#define PORT_RESET	(1&lt;&lt;8)		</span><span class="cm">/* reset port */</span><span class="cp"></span>
<span class="cp">#define PORT_SUSPEND	(1&lt;&lt;7)		</span><span class="cm">/* suspend port */</span><span class="cp"></span>
<span class="cp">#define PORT_RESUME	(1&lt;&lt;6)		</span><span class="cm">/* resume it */</span><span class="cp"></span>
<span class="cp">#define PORT_OCC	(1&lt;&lt;5)		</span><span class="cm">/* over current change */</span><span class="cp"></span>
<span class="cp">#define PORT_OC		(1&lt;&lt;4)		</span><span class="cm">/* over current active */</span><span class="cp"></span>
<span class="cp">#define PORT_PEC	(1&lt;&lt;3)		</span><span class="cm">/* port enable change */</span><span class="cp"></span>
<span class="cp">#define PORT_PE		(1&lt;&lt;2)		</span><span class="cm">/* port enable */</span><span class="cp"></span>
<span class="cp">#define PORT_CSC	(1&lt;&lt;1)		</span><span class="cm">/* connect status change */</span><span class="cp"></span>
<span class="cp">#define PORT_CONNECT	(1&lt;&lt;0)		</span><span class="cm">/* device connected */</span><span class="cp"></span>
<span class="cp">#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* Appendix C, Debug port ... intended for use with special &quot;debug devices&quot;</span>
<span class="cm"> * that can help if there&#39;s no serial console.  (nonstandard enumeration.)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_dbg_port</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">control</span><span class="p">;</span>
<span class="cp">#define DBGP_OWNER	(1&lt;&lt;30)</span>
<span class="cp">#define DBGP_ENABLED	(1&lt;&lt;28)</span>
<span class="cp">#define DBGP_DONE	(1&lt;&lt;16)</span>
<span class="cp">#define DBGP_INUSE	(1&lt;&lt;10)</span>
<span class="cp">#define DBGP_ERRCODE(x)	(((x)&gt;&gt;7)&amp;0x07)</span>
<span class="cp">#	define DBGP_ERR_BAD	1</span>
<span class="cp">#	define DBGP_ERR_SIGNAL	2</span>
<span class="cp">#define DBGP_ERROR	(1&lt;&lt;6)</span>
<span class="cp">#define DBGP_GO		(1&lt;&lt;5)</span>
<span class="cp">#define DBGP_OUT	(1&lt;&lt;4)</span>
<span class="cp">#define DBGP_LEN(x)	(((x)&gt;&gt;0)&amp;0x0f)</span>
	<span class="n">u32</span>	<span class="n">pids</span><span class="p">;</span>
<span class="cp">#define DBGP_PID_GET(x)		(((x)&gt;&gt;16)&amp;0xff)</span>
<span class="cp">#define DBGP_PID_SET(data, tok)	(((data)&lt;&lt;8)|(tok))</span>
	<span class="n">u32</span>	<span class="n">data03</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">data47</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">address</span><span class="p">;</span>
<span class="cp">#define DBGP_EPADDR(dev, ep)	(((dev)&lt;&lt;8)|(ep))</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="cp">#define	QTD_NEXT(dma)	cpu_to_le32((u32)dma)</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI Specification 0.95 Section 3.5</span>
<span class="cm"> * QTD: describe data transfer components (buffer, direction, ...)</span>
<span class="cm"> * See Fig 3-6 &quot;Queue Element Transfer Descriptor Block Diagram&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * These are associated only with &quot;QH&quot; (Queue Head) structures,</span>
<span class="cm"> * used with control, bulk, and interrupt transfers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="p">{</span>
	<span class="cm">/* first part defined by EHCI spec */</span>
	<span class="n">__le32</span>			<span class="n">hw_next</span><span class="p">;</span>		<span class="cm">/* see EHCI 3.5.1 */</span>
	<span class="n">__le32</span>			<span class="n">hw_alt_next</span><span class="p">;</span>		<span class="cm">/* see EHCI 3.5.2 */</span>
	<span class="n">__le32</span>			<span class="n">hw_token</span><span class="p">;</span>		<span class="cm">/* see EHCI 3.5.3 */</span>
<span class="cp">#define	QTD_TOGGLE	(1 &lt;&lt; 31)	</span><span class="cm">/* data toggle */</span><span class="cp"></span>
<span class="cp">#define	QTD_LENGTH(tok)	(((tok)&gt;&gt;16) &amp; 0x7fff)</span>
<span class="cp">#define	QTD_IOC		(1 &lt;&lt; 15)	</span><span class="cm">/* interrupt on complete */</span><span class="cp"></span>
<span class="cp">#define	QTD_CERR(tok)	(((tok)&gt;&gt;10) &amp; 0x3)</span>
<span class="cp">#define	QTD_PID(tok)	(((tok)&gt;&gt;8) &amp; 0x3)</span>
<span class="cp">#define	QTD_STS_ACTIVE	(1 &lt;&lt; 7)	</span><span class="cm">/* HC may execute this */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_HALT	(1 &lt;&lt; 6)	</span><span class="cm">/* halted on error */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_DBE	(1 &lt;&lt; 5)	</span><span class="cm">/* data buffer error (in HC) */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_BABBLE	(1 &lt;&lt; 4)	</span><span class="cm">/* device was babbling (qtd halted) */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_XACT	(1 &lt;&lt; 3)	</span><span class="cm">/* device gave illegal response */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_MMF	(1 &lt;&lt; 2)	</span><span class="cm">/* incomplete split transaction */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_STS	(1 &lt;&lt; 1)	</span><span class="cm">/* split transaction state */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_PING	(1 &lt;&lt; 0)	</span><span class="cm">/* issue PING? */</span><span class="cp"></span>
	<span class="n">__le32</span>			<span class="n">hw_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>		<span class="cm">/* see EHCI 3.5.4 */</span>
	<span class="n">__le32</span>			<span class="n">hw_buf_hi</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>		<span class="cm">/* Appendix B */</span>

	<span class="cm">/* the rest is HCD-private */</span>
	<span class="n">dma_addr_t</span>		<span class="n">qtd_dma</span><span class="p">;</span>		<span class="cm">/* qtd address */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">qtd_list</span><span class="p">;</span>		<span class="cm">/* sw qtd list */</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>			<span class="cm">/* qtd&#39;s urb */</span>
	<span class="kt">size_t</span>			<span class="n">length</span><span class="p">;</span>			<span class="cm">/* length of buffer */</span>

	<span class="n">u32</span>			<span class="n">qtd_buffer_len</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">buffer_dma</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">transfer_dma</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="cm">/* mask NakCnt+T in qh-&gt;hw_alt_next */</span>
<span class="cp">#define QTD_MASK cpu_to_le32 (~0x1f)</span>

<span class="cp">#define IS_SHORT_READ(token) (QTD_LENGTH(token) != 0 &amp;&amp; QTD_PID(token) == 1)</span>

<span class="cm">/* Type tag from {qh, itd, sitd, fstn}-&gt;hw_next */</span>
<span class="cp">#define Q_NEXT_TYPE(dma) ((dma) &amp; cpu_to_le32 (3 &lt;&lt; 1))</span>

<span class="cm">/* values for that type tag */</span>
<span class="cp">#define Q_TYPE_QH	cpu_to_le32 (1 &lt;&lt; 1)</span>

<span class="cm">/* next async queue entry, or pointer to interrupt/periodic QH */</span>
<span class="cp">#define	QH_NEXT(dma)	(cpu_to_le32(((u32)dma)&amp;~0x01f)|Q_TYPE_QH)</span>

<span class="cm">/* for periodic/async schedules and qtd lists, mark end of list */</span>
<span class="cp">#define	EHCI_LIST_END	cpu_to_le32(1) </span><span class="cm">/* &quot;null pointer&quot; to hw */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Entries in periodic shadow table are pointers to one of four kinds</span>
<span class="cm"> * of data structure.  That&#39;s dictated by the hardware; a type tag is</span>
<span class="cm"> * encoded in the low bits of the hardware&#39;s periodic schedule.  Use</span>
<span class="cm"> * Q_NEXT_TYPE to get the tag.</span>
<span class="cm"> *</span>
<span class="cm"> * For entries in the async schedule, the type tag always says &quot;qh&quot;.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">ehci_shadow</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">;</span>		<span class="cm">/* Q_TYPE_QH */</span>
	<span class="n">__le32</span>			<span class="o">*</span><span class="n">hw_next</span><span class="p">;</span>	<span class="cm">/* (all types) */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI Specification 0.95 Section 3.6</span>
<span class="cm"> * QH: describes control/bulk/interrupt endpoints</span>
<span class="cm"> * See Fig 3-7 &quot;Queue Head Structure Layout&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * These appear in both the async and (for interrupt) periodic schedules.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="p">{</span>
	<span class="cm">/* first part defined by EHCI spec */</span>
	<span class="n">__le32</span>			<span class="n">hw_next</span><span class="p">;</span>	 <span class="cm">/* see EHCI 3.6.1 */</span>
	<span class="n">__le32</span>			<span class="n">hw_info1</span><span class="p">;</span>	<span class="cm">/* see EHCI 3.6.2 */</span>
<span class="cp">#define	QH_HEAD		0x00008000</span>
	<span class="n">__le32</span>			<span class="n">hw_info2</span><span class="p">;</span>	<span class="cm">/* see EHCI 3.6.2 */</span>
<span class="cp">#define	QH_SMASK	0x000000ff</span>
<span class="cp">#define	QH_CMASK	0x0000ff00</span>
<span class="cp">#define	QH_HUBADDR	0x007f0000</span>
<span class="cp">#define	QH_HUBPORT	0x3f800000</span>
<span class="cp">#define	QH_MULT		0xc0000000</span>
	<span class="n">__le32</span>			<span class="n">hw_current</span><span class="p">;</span>	 <span class="cm">/* qtd list - see EHCI 3.6.4 */</span>

	<span class="cm">/* qtd overlay (hardware parts of a struct ehci_qtd) */</span>
	<span class="n">__le32</span>			<span class="n">hw_qtd_next</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">hw_alt_next</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">hw_token</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">hw_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">__le32</span>			<span class="n">hw_buf_hi</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="cm">/* the rest is HCD-private */</span>
	<span class="n">dma_addr_t</span>		<span class="n">qh_dma</span><span class="p">;</span>		<span class="cm">/* address of qh */</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">qh_next</span><span class="p">;</span>	<span class="cm">/* ptr to qh; or periodic */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">qtd_list</span><span class="p">;</span>	<span class="cm">/* sw qtd list */</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span>		<span class="o">*</span><span class="n">dummy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">reclaim</span><span class="p">;</span>	<span class="cm">/* next to reclaim */</span>

	<span class="k">struct</span> <span class="n">oxu_hcd</span>		<span class="o">*</span><span class="n">oxu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">kref</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">stamp</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">qh_state</span><span class="p">;</span>
<span class="cp">#define	QH_STATE_LINKED		1		</span><span class="cm">/* HC sees this */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_UNLINK		2		</span><span class="cm">/* HC may still see this */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_IDLE		3		</span><span class="cm">/* HC doesn&#39;t see this */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_UNLINK_WAIT	4		</span><span class="cm">/* LINKED and on reclaim q */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_COMPLETING	5		</span><span class="cm">/* don&#39;t touch token.HALT */</span><span class="cp"></span>

	<span class="cm">/* periodic schedule info */</span>
	<span class="n">u8</span>			<span class="n">usecs</span><span class="p">;</span>		<span class="cm">/* intr bandwidth */</span>
	<span class="n">u8</span>			<span class="n">gap_uf</span><span class="p">;</span>		<span class="cm">/* uframes split/csplit gap */</span>
	<span class="n">u8</span>			<span class="n">c_usecs</span><span class="p">;</span>	<span class="cm">/* ... split completion bw */</span>
	<span class="n">u16</span>			<span class="n">tt_usecs</span><span class="p">;</span>	<span class="cm">/* tt downstream bandwidth */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">period</span><span class="p">;</span>		<span class="cm">/* polling interval */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">start</span><span class="p">;</span>		<span class="cm">/* where polling starts */</span>
<span class="cp">#define NO_FRAME ((unsigned short)~0)			</span><span class="cm">/* pick new start */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* access to TT */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * Proper OXU210HP structs</span>
<span class="cm"> */</span>

<span class="cp">#define OXU_OTG_CORE_OFFSET	0x00400</span>
<span class="cp">#define OXU_OTG_CAP_OFFSET	(OXU_OTG_CORE_OFFSET + 0x100)</span>
<span class="cp">#define OXU_SPH_CORE_OFFSET	0x00800</span>
<span class="cp">#define OXU_SPH_CAP_OFFSET	(OXU_SPH_CORE_OFFSET + 0x100)</span>

<span class="cp">#define OXU_OTG_MEM		0xE000</span>
<span class="cp">#define OXU_SPH_MEM		0x16000</span>

<span class="cm">/* Only how many elements &amp; element structure are specifies here. */</span>
<span class="cm">/* 2 host controllers are enabled - total size &lt;= 28 kbytes */</span>
<span class="cp">#define	DEFAULT_I_TDPS		1024</span>
<span class="cp">#define QHEAD_NUM		16</span>
<span class="cp">#define QTD_NUM			32</span>
<span class="cp">#define SITD_NUM		8</span>
<span class="cp">#define MURB_NUM		8</span>

<span class="cp">#define BUFFER_NUM		8</span>
<span class="cp">#define BUFFER_SIZE		512</span>

<span class="k">struct</span> <span class="n">oxu_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">oxu_buf</span> <span class="p">{</span>
	<span class="n">u8</span>			<span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">)));</span>

<span class="k">struct</span> <span class="n">oxu_onchip_mem</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_buf</span>		<span class="n">db_pool</span><span class="p">[</span><span class="n">BUFFER_NUM</span><span class="p">];</span>

	<span class="n">u32</span>			<span class="n">frame_list</span><span class="p">[</span><span class="n">DEFAULT_I_TDPS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="n">qh_pool</span><span class="p">[</span><span class="n">QHEAD_NUM</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span>		<span class="n">qtd_pool</span><span class="p">[</span><span class="n">QTD_NUM</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)));</span>

<span class="cp">#define	EHCI_MAX_ROOT_PORTS	15		</span><span class="cm">/* see HCS_N_PORTS */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">oxu_murb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">main</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">last</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="p">{</span>				<span class="cm">/* one per controller */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">is_otg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">qh_used</span><span class="p">[</span><span class="n">QHEAD_NUM</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">qtd_used</span><span class="p">[</span><span class="n">QTD_NUM</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">db_used</span><span class="p">[</span><span class="n">BUFFER_NUM</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">murb_used</span><span class="p">[</span><span class="n">MURB_NUM</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">oxu_onchip_mem</span>	<span class="n">__iomem</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">mem_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">urb_timer</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ehci_caps</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">caps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">__u32</span>			<span class="n">hcs_params</span><span class="p">;</span>	<span class="cm">/* cached register copy */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* async schedule support */</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">reclaim</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">reclaim_ready</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">scanning</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* periodic schedule support */</span>
	<span class="kt">unsigned</span>		<span class="n">periodic_size</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="o">*</span><span class="n">periodic</span><span class="p">;</span>	<span class="cm">/* hw periodic table */</span>
	<span class="n">dma_addr_t</span>		<span class="n">periodic_dma</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i_thresh</span><span class="p">;</span>	<span class="cm">/* uframes HC might cache */</span>

	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">pshadow</span><span class="p">;</span>	<span class="cm">/* mirror hw periodic table */</span>
	<span class="kt">int</span>			<span class="n">next_uframe</span><span class="p">;</span>	<span class="cm">/* scan periodic, start here */</span>
	<span class="kt">unsigned</span>		<span class="n">periodic_sched</span><span class="p">;</span>	<span class="cm">/* periodic activity count */</span>

	<span class="cm">/* per root hub port */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">reset_done</span><span class="p">[</span><span class="n">EHCI_MAX_ROOT_PORTS</span><span class="p">];</span>
	<span class="cm">/* bit vectors (one bit per port) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bus_suspended</span><span class="p">;</span>	<span class="cm">/* which ports were</span>
<span class="cm">						 * already suspended at the</span>
<span class="cm">						 * start of a bus suspend</span>
<span class="cm">						 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">companion_ports</span><span class="p">;</span><span class="cm">/* which ports are dedicated</span>
<span class="cm">						 * to the companion controller</span>
<span class="cm">						 */</span>

	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">watchdog</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">actions</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">stamp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">next_statechange</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">command</span><span class="p">;</span>

	<span class="cm">/* SILICON QUIRKS */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">urb_list</span><span class="p">;</span>	<span class="cm">/* this is the head to urb</span>
<span class="cm">						 * queue that didn&#39;t get enough</span>
<span class="cm">						 * resources</span>
<span class="cm">						 */</span>
	<span class="k">struct</span> <span class="n">oxu_murb</span>		<span class="o">*</span><span class="n">murb_pool</span><span class="p">;</span>	<span class="cm">/* murb per split big urb */</span>
	<span class="kt">unsigned</span> <span class="n">urb_len</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">sbrn</span><span class="p">;</span>		<span class="cm">/* packed release number */</span>
<span class="p">};</span>

<span class="cp">#define EHCI_IAA_JIFFIES	(HZ/100)	</span><span class="cm">/* arbitrary; ~10 msec */</span><span class="cp"></span>
<span class="cp">#define EHCI_IO_JIFFIES	 	(HZ/10)		</span><span class="cm">/* io watchdog &gt; irq_thresh */</span><span class="cp"></span>
<span class="cp">#define EHCI_ASYNC_JIFFIES      (HZ/20)		</span><span class="cm">/* async idle timeout */</span><span class="cp"></span>
<span class="cp">#define EHCI_SHRINK_JIFFIES     (HZ/200)	</span><span class="cm">/* async qh unlink delay */</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">ehci_timer_action</span> <span class="p">{</span>
	<span class="n">TIMER_IO_WATCHDOG</span><span class="p">,</span>
	<span class="n">TIMER_IAA_WATCHDOG</span><span class="p">,</span>
	<span class="n">TIMER_ASYNC_SHRINK</span><span class="p">,</span>
	<span class="n">TIMER_ASYNC_OFF</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#include &lt;linux/oxu210hp.h&gt;</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
