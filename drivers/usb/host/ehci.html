<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › ehci.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ehci.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2001-2002 by David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_EHCI_HCD_H</span>
<span class="cp">#define __LINUX_EHCI_HCD_H</span>

<span class="cm">/* definitions used for the EHCI driver */</span>

<span class="cm">/*</span>
<span class="cm"> * __hc32 and __hc16 are &quot;Host Controller&quot; types, they may be equivalent to</span>
<span class="cm"> * __leXX (normally) or __beXX (given EHCI_BIG_ENDIAN_DESC), depending on</span>
<span class="cm"> * the host controller implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * To facilitate the strongest possible byte-order checking from &quot;sparse&quot;</span>
<span class="cm"> * and so on, we use __leXX unless that&#39;s not practical.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_DESC</span>
<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">__bitwise</span> <span class="n">__hc32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u16</span> <span class="n">__bitwise</span> <span class="n">__hc16</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define __hc32	__le32</span>
<span class="cp">#define __hc16	__le16</span>
<span class="cp">#endif</span>

<span class="cm">/* statistics can be kept for tuning/monitoring */</span>
<span class="k">struct</span> <span class="n">ehci_stats</span> <span class="p">{</span>
	<span class="cm">/* irq usage */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">normal</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">reclaim</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lost_iaa</span><span class="p">;</span>

	<span class="cm">/* termination of urbs from core */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">complete</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">unlink</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* ehci_hcd-&gt;lock guards shared data against other CPUs:</span>
<span class="cm"> *   ehci_hcd:	async, reclaim, periodic (and shadow), ...</span>
<span class="cm"> *   usb_host_endpoint: hcpriv</span>
<span class="cm"> *   ehci_qh:	qh_next, qtd_list</span>
<span class="cm"> *   ehci_qtd:	qtd_list</span>
<span class="cm"> *</span>
<span class="cm"> * Also, hold this lock when talking to HC registers or</span>
<span class="cm"> * when updating hw_* fields in shared qh/qtd/... structures.</span>
<span class="cm"> */</span>

<span class="cp">#define	EHCI_MAX_ROOT_PORTS	15		</span><span class="cm">/* see HCS_N_PORTS */</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">ehci_rh_state</span> <span class="p">{</span>
	<span class="n">EHCI_RH_HALTED</span><span class="p">,</span>
	<span class="n">EHCI_RH_SUSPENDED</span><span class="p">,</span>
	<span class="n">EHCI_RH_RUNNING</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="p">{</span>			<span class="cm">/* one per controller */</span>
	<span class="cm">/* glue to PCI and HCD framework */</span>
	<span class="k">struct</span> <span class="n">ehci_caps</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">caps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_dbg_port</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">debug</span><span class="p">;</span>

	<span class="n">__u32</span>			<span class="n">hcs_params</span><span class="p">;</span>	<span class="cm">/* cached register copy */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ehci_rh_state</span>	<span class="n">rh_state</span><span class="p">;</span>

	<span class="cm">/* async schedule support */</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">dummy</span><span class="p">;</span>		<span class="cm">/* For AMD quirk use */</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">reclaim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh_scan_next</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">scanning</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* periodic schedule support */</span>
<span class="cp">#define	DEFAULT_I_TDPS		1024		</span><span class="cm">/* some HCs can do less */</span><span class="cp"></span>
	<span class="kt">unsigned</span>		<span class="n">periodic_size</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">periodic</span><span class="p">;</span>	<span class="cm">/* hw periodic table */</span>
	<span class="n">dma_addr_t</span>		<span class="n">periodic_dma</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">i_thresh</span><span class="p">;</span>	<span class="cm">/* uframes HC might cache */</span>

	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">pshadow</span><span class="p">;</span>	<span class="cm">/* mirror hw periodic table */</span>
	<span class="kt">int</span>			<span class="n">next_uframe</span><span class="p">;</span>	<span class="cm">/* scan periodic, start here */</span>
	<span class="kt">unsigned</span>		<span class="n">periodic_sched</span><span class="p">;</span>	<span class="cm">/* periodic activity count */</span>
	<span class="kt">unsigned</span>		<span class="n">uframe_periodic_max</span><span class="p">;</span> <span class="cm">/* max periodic time per uframe */</span>


	<span class="cm">/* list of itds &amp; sitds completed while clock_frame was still active */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cached_itd_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cached_sitd_list</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">clock_frame</span><span class="p">;</span>

	<span class="cm">/* per root hub port */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">reset_done</span> <span class="p">[</span><span class="n">EHCI_MAX_ROOT_PORTS</span><span class="p">];</span>

	<span class="cm">/* bit vectors (one bit per port) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bus_suspended</span><span class="p">;</span>		<span class="cm">/* which ports were</span>
<span class="cm">			already suspended at the start of a bus suspend */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">companion_ports</span><span class="p">;</span>	<span class="cm">/* which ports are</span>
<span class="cm">			dedicated to the companion controller */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">owned_ports</span><span class="p">;</span>		<span class="cm">/* which ports are</span>
<span class="cm">			owned by the companion during a bus suspend */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">port_c_suspend</span><span class="p">;</span>		<span class="cm">/* which ports have</span>
<span class="cm">			the change-suspend feature turned on */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">suspended_ports</span><span class="p">;</span>	<span class="cm">/* which ports are</span>
<span class="cm">			suspended */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">resuming_ports</span><span class="p">;</span>		<span class="cm">/* which ports have</span>
<span class="cm">			started to resume */</span>

	<span class="cm">/* per-HC memory pools (could be per-bus, but ...) */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">qh_pool</span><span class="p">;</span>	<span class="cm">/* qh per active urb */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">qtd_pool</span><span class="p">;</span>	<span class="cm">/* one or more per qh */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">itd_pool</span><span class="p">;</span>	<span class="cm">/* itd per iso urb */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">sitd_pool</span><span class="p">;</span>	<span class="cm">/* sitd per split iso urb */</span>

	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">iaa_watchdog</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">watchdog</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">actions</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">periodic_stamp</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">random_frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">next_statechange</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">last_periodic_enable</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">command</span><span class="p">;</span>

	<span class="cm">/* SILICON QUIRKS */</span>
	<span class="kt">unsigned</span>		<span class="n">no_selective_suspend</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">has_fsl_port_bug</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* FreeScale */</span>
	<span class="kt">unsigned</span>		<span class="n">big_endian_mmio</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">big_endian_desc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">big_endian_capbase</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">has_amcc_usb23</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">need_io_watchdog</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">broken_periodic</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">amd_pll_fix</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">fs_i_thresh</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Intel iso scheduling */</span>
	<span class="kt">unsigned</span>		<span class="n">use_dummy_qh</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* AMD Frame List table quirk*/</span>
	<span class="kt">unsigned</span>		<span class="n">has_synopsys_hc_bug</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Synopsys HC */</span>
	<span class="kt">unsigned</span>		<span class="n">frame_index_bug</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* MosChip (AKA NetMos) */</span>

	<span class="cm">/* required for usb32 quirk */</span>
	<span class="cp">#define OHCI_CTRL_HCFS          (3 &lt;&lt; 6)</span>
	<span class="cp">#define OHCI_USB_OPER           (2 &lt;&lt; 6)</span>
	<span class="cp">#define OHCI_USB_SUSPEND        (3 &lt;&lt; 6)</span>

	<span class="cp">#define OHCI_HCCTRL_OFFSET      0x4</span>
	<span class="cp">#define OHCI_HCCTRL_LEN         0x4</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">ohci_hcctrl_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">has_hostpc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">has_lpm</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* support link power management */</span>
	<span class="kt">unsigned</span>		<span class="n">has_ppcd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* support per-port change bits */</span>
	<span class="n">u8</span>			<span class="n">sbrn</span><span class="p">;</span>		<span class="cm">/* packed release number */</span>

	<span class="cm">/* irq statistics */</span>
<span class="cp">#ifdef EHCI_STATS</span>
	<span class="k">struct</span> <span class="n">ehci_stats</span>	<span class="n">stats</span><span class="p">;</span>
<span class="cp">#	define COUNT(x) do { (x)++; } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#	define COUNT(x) do {} while (0)</span>
<span class="cp">#endif</span>

	<span class="cm">/* debug files */</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">debug_dir</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * OTG controllers and transceivers need software interaction</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">usb_phy</span>	<span class="o">*</span><span class="n">transceiver</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* convert between an HCD pointer and the corresponding EHCI_HCD */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="nf">hcd_to_ehci</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">ehci_to_hcd</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">iaa_watchdog_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">));</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">,</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">EHCI_IAA_MSECS</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iaa_watchdog_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">iaa_watchdog</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ehci_timer_action</span> <span class="p">{</span>
	<span class="n">TIMER_IO_WATCHDOG</span><span class="p">,</span>
	<span class="n">TIMER_ASYNC_SHRINK</span><span class="p">,</span>
	<span class="n">TIMER_ASYNC_OFF</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">timer_action_done</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ehci_timer_action</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span> <span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">actions</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_cached_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#include &lt;linux/usb/ehci_def.h&gt;</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define	QTD_NEXT(ehci, dma)	cpu_to_hc32(ehci, (u32)dma)</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI Specification 0.95 Section 3.5</span>
<span class="cm"> * QTD: describe data transfer components (buffer, direction, ...)</span>
<span class="cm"> * See Fig 3-6 &quot;Queue Element Transfer Descriptor Block Diagram&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * These are associated only with &quot;QH&quot; (Queue Head) structures,</span>
<span class="cm"> * used with control, bulk, and interrupt transfers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="p">{</span>
	<span class="cm">/* first part defined by EHCI spec */</span>
	<span class="n">__hc32</span>			<span class="n">hw_next</span><span class="p">;</span>	<span class="cm">/* see EHCI 3.5.1 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_alt_next</span><span class="p">;</span>    <span class="cm">/* see EHCI 3.5.2 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_token</span><span class="p">;</span>       <span class="cm">/* see EHCI 3.5.3 */</span>
<span class="cp">#define	QTD_TOGGLE	(1 &lt;&lt; 31)	</span><span class="cm">/* data toggle */</span><span class="cp"></span>
<span class="cp">#define	QTD_LENGTH(tok)	(((tok)&gt;&gt;16) &amp; 0x7fff)</span>
<span class="cp">#define	QTD_IOC		(1 &lt;&lt; 15)	</span><span class="cm">/* interrupt on complete */</span><span class="cp"></span>
<span class="cp">#define	QTD_CERR(tok)	(((tok)&gt;&gt;10) &amp; 0x3)</span>
<span class="cp">#define	QTD_PID(tok)	(((tok)&gt;&gt;8) &amp; 0x3)</span>
<span class="cp">#define	QTD_STS_ACTIVE	(1 &lt;&lt; 7)	</span><span class="cm">/* HC may execute this */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_HALT	(1 &lt;&lt; 6)	</span><span class="cm">/* halted on error */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_DBE	(1 &lt;&lt; 5)	</span><span class="cm">/* data buffer error (in HC) */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_BABBLE	(1 &lt;&lt; 4)	</span><span class="cm">/* device was babbling (qtd halted) */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_XACT	(1 &lt;&lt; 3)	</span><span class="cm">/* device gave illegal response */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_MMF	(1 &lt;&lt; 2)	</span><span class="cm">/* incomplete split transaction */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_STS	(1 &lt;&lt; 1)	</span><span class="cm">/* split transaction state */</span><span class="cp"></span>
<span class="cp">#define	QTD_STS_PING	(1 &lt;&lt; 0)	</span><span class="cm">/* issue PING? */</span><span class="cp"></span>

<span class="cp">#define ACTIVE_BIT(ehci)	cpu_to_hc32(ehci, QTD_STS_ACTIVE)</span>
<span class="cp">#define HALT_BIT(ehci)		cpu_to_hc32(ehci, QTD_STS_HALT)</span>
<span class="cp">#define STATUS_BIT(ehci)	cpu_to_hc32(ehci, QTD_STS_STS)</span>

	<span class="n">__hc32</span>			<span class="n">hw_buf</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span>        <span class="cm">/* see EHCI 3.5.4 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_buf_hi</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span>        <span class="cm">/* Appendix B */</span>

	<span class="cm">/* the rest is HCD-private */</span>
	<span class="n">dma_addr_t</span>		<span class="n">qtd_dma</span><span class="p">;</span>		<span class="cm">/* qtd address */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">qtd_list</span><span class="p">;</span>		<span class="cm">/* sw qtd list */</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>			<span class="cm">/* qtd&#39;s urb */</span>
	<span class="kt">size_t</span>			<span class="n">length</span><span class="p">;</span>			<span class="cm">/* length of buffer */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="cm">/* mask NakCnt+T in qh-&gt;hw_alt_next */</span>
<span class="cp">#define QTD_MASK(ehci)	cpu_to_hc32 (ehci, ~0x1f)</span>

<span class="cp">#define IS_SHORT_READ(token) (QTD_LENGTH (token) != 0 &amp;&amp; QTD_PID (token) == 1)</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* type tag from {qh,itd,sitd,fstn}-&gt;hw_next */</span>
<span class="cp">#define Q_NEXT_TYPE(ehci,dma)	((dma) &amp; cpu_to_hc32(ehci, 3 &lt;&lt; 1))</span>

<span class="cm">/*</span>
<span class="cm"> * Now the following defines are not converted using the</span>
<span class="cm"> * cpu_to_le32() macro anymore, since we have to support</span>
<span class="cm"> * &quot;dynamic&quot; switching between be and le support, so that the driver</span>
<span class="cm"> * can be used on one system with SoC EHCI controller using big-endian</span>
<span class="cm"> * descriptors as well as a normal little-endian PCI EHCI controller.</span>
<span class="cm"> */</span>
<span class="cm">/* values for that type tag */</span>
<span class="cp">#define Q_TYPE_ITD	(0 &lt;&lt; 1)</span>
<span class="cp">#define Q_TYPE_QH	(1 &lt;&lt; 1)</span>
<span class="cp">#define Q_TYPE_SITD	(2 &lt;&lt; 1)</span>
<span class="cp">#define Q_TYPE_FSTN	(3 &lt;&lt; 1)</span>

<span class="cm">/* next async queue entry, or pointer to interrupt/periodic QH */</span>
<span class="cp">#define QH_NEXT(ehci,dma)	(cpu_to_hc32(ehci, (((u32)dma)&amp;~0x01f)|Q_TYPE_QH))</span>

<span class="cm">/* for periodic/async schedules and qtd lists, mark end of list */</span>
<span class="cp">#define EHCI_LIST_END(ehci)	cpu_to_hc32(ehci, 1) </span><span class="cm">/* &quot;null pointer&quot; to hw */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Entries in periodic shadow table are pointers to one of four kinds</span>
<span class="cm"> * of data structure.  That&#39;s dictated by the hardware; a type tag is</span>
<span class="cm"> * encoded in the low bits of the hardware&#39;s periodic schedule.  Use</span>
<span class="cm"> * Q_NEXT_TYPE to get the tag.</span>
<span class="cm"> *</span>
<span class="cm"> * For entries in the async schedule, the type tag always says &quot;qh&quot;.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">ehci_shadow</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">;</span>		<span class="cm">/* Q_TYPE_QH */</span>
	<span class="k">struct</span> <span class="n">ehci_itd</span>		<span class="o">*</span><span class="n">itd</span><span class="p">;</span>		<span class="cm">/* Q_TYPE_ITD */</span>
	<span class="k">struct</span> <span class="n">ehci_sitd</span>	<span class="o">*</span><span class="n">sitd</span><span class="p">;</span>		<span class="cm">/* Q_TYPE_SITD */</span>
	<span class="k">struct</span> <span class="n">ehci_fstn</span>	<span class="o">*</span><span class="n">fstn</span><span class="p">;</span>		<span class="cm">/* Q_TYPE_FSTN */</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">hw_next</span><span class="p">;</span>	<span class="cm">/* (all types) */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI Specification 0.95 Section 3.6</span>
<span class="cm"> * QH: describes control/bulk/interrupt endpoints</span>
<span class="cm"> * See Fig 3-7 &quot;Queue Head Structure Layout&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * These appear in both the async and (for interrupt) periodic schedules.</span>
<span class="cm"> */</span>

<span class="cm">/* first part defined by EHCI spec */</span>
<span class="k">struct</span> <span class="n">ehci_qh_hw</span> <span class="p">{</span>
	<span class="n">__hc32</span>			<span class="n">hw_next</span><span class="p">;</span>	<span class="cm">/* see EHCI 3.6.1 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_info1</span><span class="p">;</span>       <span class="cm">/* see EHCI 3.6.2 */</span>
<span class="cp">#define	QH_HEAD		0x00008000</span>
	<span class="n">__hc32</span>			<span class="n">hw_info2</span><span class="p">;</span>        <span class="cm">/* see EHCI 3.6.2 */</span>
<span class="cp">#define	QH_SMASK	0x000000ff</span>
<span class="cp">#define	QH_CMASK	0x0000ff00</span>
<span class="cp">#define	QH_HUBADDR	0x007f0000</span>
<span class="cp">#define	QH_HUBPORT	0x3f800000</span>
<span class="cp">#define	QH_MULT		0xc0000000</span>
	<span class="n">__hc32</span>			<span class="n">hw_current</span><span class="p">;</span>	<span class="cm">/* qtd list - see EHCI 3.6.4 */</span>

	<span class="cm">/* qtd overlay (hardware parts of a struct ehci_qtd) */</span>
	<span class="n">__hc32</span>			<span class="n">hw_qtd_next</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">hw_alt_next</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">hw_token</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">hw_buf</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">__hc32</span>			<span class="n">hw_buf_hi</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="cm">/* the rest is HCD-private */</span>
	<span class="n">dma_addr_t</span>		<span class="n">qh_dma</span><span class="p">;</span>		<span class="cm">/* address of qh */</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">qh_next</span><span class="p">;</span>	<span class="cm">/* ptr to qh; or periodic */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">qtd_list</span><span class="p">;</span>	<span class="cm">/* sw qtd list */</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span>		<span class="o">*</span><span class="n">dummy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">reclaim</span><span class="p">;</span>	<span class="cm">/* next to reclaim */</span>

	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">unlink_time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do NOT use atomic operations for QH refcounting. On some CPUs</span>
<span class="cm">	 * (PPC7448 for example), atomic operations cannot be performed on</span>
<span class="cm">	 * memory that is cache-inhibited (i.e. being used for DMA).</span>
<span class="cm">	 * Spinlocks are used to protect all QH fields.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>			<span class="n">refcount</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">stamp</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">needs_rescan</span><span class="p">;</span>	<span class="cm">/* Dequeue during giveback */</span>
	<span class="n">u8</span>			<span class="n">qh_state</span><span class="p">;</span>
<span class="cp">#define	QH_STATE_LINKED		1		</span><span class="cm">/* HC sees this */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_UNLINK		2		</span><span class="cm">/* HC may still see this */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_IDLE		3		</span><span class="cm">/* HC doesn&#39;t see this */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_UNLINK_WAIT	4		</span><span class="cm">/* LINKED and on reclaim q */</span><span class="cp"></span>
<span class="cp">#define	QH_STATE_COMPLETING	5		</span><span class="cm">/* don&#39;t touch token.HALT */</span><span class="cp"></span>

	<span class="n">u8</span>			<span class="n">xacterrs</span><span class="p">;</span>	<span class="cm">/* XactErr retry counter */</span>
<span class="cp">#define	QH_XACTERR_MAX		32		</span><span class="cm">/* XactErr retry limit */</span><span class="cp"></span>

	<span class="cm">/* periodic schedule info */</span>
	<span class="n">u8</span>			<span class="n">usecs</span><span class="p">;</span>		<span class="cm">/* intr bandwidth */</span>
	<span class="n">u8</span>			<span class="n">gap_uf</span><span class="p">;</span>		<span class="cm">/* uframes split/csplit gap */</span>
	<span class="n">u8</span>			<span class="n">c_usecs</span><span class="p">;</span>	<span class="cm">/* ... split completion bw */</span>
	<span class="n">u16</span>			<span class="n">tt_usecs</span><span class="p">;</span>	<span class="cm">/* tt downstream bandwidth */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">period</span><span class="p">;</span>		<span class="cm">/* polling interval */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">start</span><span class="p">;</span>		<span class="cm">/* where polling starts */</span>
<span class="cp">#define NO_FRAME ((unsigned short)~0)			</span><span class="cm">/* pick new start */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* access to TT */</span>
	<span class="kt">unsigned</span>		<span class="n">is_out</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* bulk or intr OUT */</span>
	<span class="kt">unsigned</span>		<span class="n">clearing_tt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Clear-TT-Buf in progress */</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* description of one iso transaction (up to 3 KB data if highspeed) */</span>
<span class="k">struct</span> <span class="n">ehci_iso_packet</span> <span class="p">{</span>
	<span class="cm">/* These will be copied to iTD when scheduling */</span>
	<span class="n">u64</span>			<span class="n">bufp</span><span class="p">;</span>		<span class="cm">/* itd-&gt;hw_bufp{,_hi}[pg] |= */</span>
	<span class="n">__hc32</span>			<span class="n">transaction</span><span class="p">;</span>	<span class="cm">/* itd-&gt;hw_transaction[i] |= */</span>
	<span class="n">u8</span>			<span class="n">cross</span><span class="p">;</span>		<span class="cm">/* buf crosses pages */</span>
	<span class="cm">/* for full speed OUT splits */</span>
	<span class="n">u32</span>			<span class="n">buf1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* temporary schedule data for packets from iso urbs (both speeds)</span>
<span class="cm"> * each packet is one logical usb transaction to the device (not TT),</span>
<span class="cm"> * beginning at stream-&gt;next_uframe</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_iso_sched</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">td_list</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">span</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_packet</span>	<span class="n">packet</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ehci_iso_stream - groups all (s)itds for this endpoint.</span>
<span class="cm"> * acts like a qh would, if EHCI had them for ISO.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="p">{</span>
	<span class="cm">/* first field matches ehci_hq, but is NULL */</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">refcount</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">bEndpointAddress</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">highspeed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">td_list</span><span class="p">;</span>	<span class="cm">/* queued itds/sitds */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">free_list</span><span class="p">;</span>	<span class="cm">/* list of unused itds/sitds */</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* output of (re)scheduling */</span>
	<span class="kt">int</span>			<span class="n">next_uframe</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">splits</span><span class="p">;</span>

	<span class="cm">/* the rest is derived from the endpoint descriptor,</span>
<span class="cm">	 * trusting urb-&gt;interval == f(epdesc-&gt;bInterval) and</span>
<span class="cm">	 * including the extra info for hw_bufp[0..2]</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>			<span class="n">usecs</span><span class="p">,</span> <span class="n">c_usecs</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">interval</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">tt_usecs</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">maxp</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">raw_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">bandwidth</span><span class="p">;</span>

	<span class="cm">/* This is used to initialize iTD&#39;s hw_bufp fields */</span>
	<span class="n">__hc32</span>			<span class="n">buf0</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">buf1</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">buf2</span><span class="p">;</span>

	<span class="cm">/* this is used to initialize sITD&#39;s tt info */</span>
	<span class="n">__hc32</span>			<span class="n">address</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI Specification 0.95 Section 3.3</span>
<span class="cm"> * Fig 3-4 &quot;Isochronous Transaction Descriptor (iTD)&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Schedule records for high speed iso xfers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_itd</span> <span class="p">{</span>
	<span class="cm">/* first part defined by EHCI spec */</span>
	<span class="n">__hc32</span>			<span class="n">hw_next</span><span class="p">;</span>           <span class="cm">/* see EHCI 3.3.1 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_transaction</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* see EHCI 3.3.2 */</span>
<span class="cp">#define EHCI_ISOC_ACTIVE        (1&lt;&lt;31)        </span><span class="cm">/* activate transfer this slot */</span><span class="cp"></span>
<span class="cp">#define EHCI_ISOC_BUF_ERR       (1&lt;&lt;30)        </span><span class="cm">/* Data buffer error */</span><span class="cp"></span>
<span class="cp">#define EHCI_ISOC_BABBLE        (1&lt;&lt;29)        </span><span class="cm">/* babble detected */</span><span class="cp"></span>
<span class="cp">#define EHCI_ISOC_XACTERR       (1&lt;&lt;28)        </span><span class="cm">/* XactErr - transaction error */</span><span class="cp"></span>
<span class="cp">#define	EHCI_ITD_LENGTH(tok)	(((tok)&gt;&gt;16) &amp; 0x0fff)</span>
<span class="cp">#define	EHCI_ITD_IOC		(1 &lt;&lt; 15)	</span><span class="cm">/* interrupt on complete */</span><span class="cp"></span>

<span class="cp">#define ITD_ACTIVE(ehci)	cpu_to_hc32(ehci, EHCI_ISOC_ACTIVE)</span>

	<span class="n">__hc32</span>			<span class="n">hw_bufp</span> <span class="p">[</span><span class="mi">7</span><span class="p">];</span>	<span class="cm">/* see EHCI 3.3.3 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_bufp_hi</span> <span class="p">[</span><span class="mi">7</span><span class="p">];</span>	<span class="cm">/* Appendix B */</span>

	<span class="cm">/* the rest is HCD-private */</span>
	<span class="n">dma_addr_t</span>		<span class="n">itd_dma</span><span class="p">;</span>	<span class="cm">/* for this itd */</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">itd_next</span><span class="p">;</span>	<span class="cm">/* ptr to periodic q entry */</span>

	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">;</span>	<span class="cm">/* endpoint&#39;s queue */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">itd_list</span><span class="p">;</span>	<span class="cm">/* list of stream&#39;s itds */</span>

	<span class="cm">/* any/all hw_transactions here may be used by that urb */</span>
	<span class="kt">unsigned</span>		<span class="n">frame</span><span class="p">;</span>		<span class="cm">/* where scheduled */</span>
	<span class="kt">unsigned</span>		<span class="n">pg</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">index</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* in urb-&gt;iso_frame_desc */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI Specification 0.95 Section 3.4</span>
<span class="cm"> * siTD, aka split-transaction isochronous Transfer Descriptor</span>
<span class="cm"> *       ... describe full speed iso xfers through TT in hubs</span>
<span class="cm"> * see Figure 3-5 &quot;Split-transaction Isochronous Transaction Descriptor (siTD)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_sitd</span> <span class="p">{</span>
	<span class="cm">/* first part defined by EHCI spec */</span>
	<span class="n">__hc32</span>			<span class="n">hw_next</span><span class="p">;</span>
<span class="cm">/* uses bit field macros above - see EHCI 0.95 Table 3-8 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_fullspeed_ep</span><span class="p">;</span>	<span class="cm">/* EHCI table 3-9 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_uframe</span><span class="p">;</span>		<span class="cm">/* EHCI table 3-10 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_results</span><span class="p">;</span>		<span class="cm">/* EHCI table 3-11 */</span>
<span class="cp">#define	SITD_IOC	(1 &lt;&lt; 31)	</span><span class="cm">/* interrupt on completion */</span><span class="cp"></span>
<span class="cp">#define	SITD_PAGE	(1 &lt;&lt; 30)	</span><span class="cm">/* buffer 0/1 */</span><span class="cp"></span>
<span class="cp">#define	SITD_LENGTH(x)	(0x3ff &amp; ((x)&gt;&gt;16))</span>
<span class="cp">#define	SITD_STS_ACTIVE	(1 &lt;&lt; 7)	</span><span class="cm">/* HC may execute this */</span><span class="cp"></span>
<span class="cp">#define	SITD_STS_ERR	(1 &lt;&lt; 6)	</span><span class="cm">/* error from TT */</span><span class="cp"></span>
<span class="cp">#define	SITD_STS_DBE	(1 &lt;&lt; 5)	</span><span class="cm">/* data buffer error (in HC) */</span><span class="cp"></span>
<span class="cp">#define	SITD_STS_BABBLE	(1 &lt;&lt; 4)	</span><span class="cm">/* device was babbling */</span><span class="cp"></span>
<span class="cp">#define	SITD_STS_XACT	(1 &lt;&lt; 3)	</span><span class="cm">/* illegal IN response */</span><span class="cp"></span>
<span class="cp">#define	SITD_STS_MMF	(1 &lt;&lt; 2)	</span><span class="cm">/* incomplete split transaction */</span><span class="cp"></span>
<span class="cp">#define	SITD_STS_STS	(1 &lt;&lt; 1)	</span><span class="cm">/* split transaction state */</span><span class="cp"></span>

<span class="cp">#define SITD_ACTIVE(ehci)	cpu_to_hc32(ehci, SITD_STS_ACTIVE)</span>

	<span class="n">__hc32</span>			<span class="n">hw_buf</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* EHCI table 3-12 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_backpointer</span><span class="p">;</span>		<span class="cm">/* EHCI table 3-13 */</span>
	<span class="n">__hc32</span>			<span class="n">hw_buf_hi</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* Appendix B */</span>

	<span class="cm">/* the rest is HCD-private */</span>
	<span class="n">dma_addr_t</span>		<span class="n">sitd_dma</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">sitd_next</span><span class="p">;</span>	<span class="cm">/* ptr to periodic q entry */</span>

	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">;</span>	<span class="cm">/* endpoint&#39;s queue */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sitd_list</span><span class="p">;</span>	<span class="cm">/* list of stream&#39;s sitds */</span>
	<span class="kt">unsigned</span>		<span class="n">frame</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">index</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI Specification 0.96 Section 3.7</span>
<span class="cm"> * Periodic Frame Span Traversal Node (FSTN)</span>
<span class="cm"> *</span>
<span class="cm"> * Manages split interrupt transactions (using TT) that span frame boundaries</span>
<span class="cm"> * into uframes 0/1; see 4.12.2.2.  In those uframes, a &quot;save place&quot; FSTN</span>
<span class="cm"> * makes the HC jump (back) to a QH to scan for fs/ls QH completions until</span>
<span class="cm"> * it hits a &quot;restore&quot; FSTN; then it returns to finish other uframe 0/1 work.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_fstn</span> <span class="p">{</span>
	<span class="n">__hc32</span>			<span class="n">hw_next</span><span class="p">;</span>	<span class="cm">/* any periodic q entry */</span>
	<span class="n">__hc32</span>			<span class="n">hw_prev</span><span class="p">;</span>	<span class="cm">/* qh or EHCI_LIST_END */</span>

	<span class="cm">/* the rest is HCD-private */</span>
	<span class="n">dma_addr_t</span>		<span class="n">fstn_dma</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">fstn_next</span><span class="p">;</span>	<span class="cm">/* ptr to periodic q entry */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Prepare the PORTSC wakeup flags during controller suspend/resume */</span>

<span class="cp">#define ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup)	\</span>
<span class="cp">		ehci_adjust_port_wakeup_flags(ehci, true, do_wakeup);</span>

<span class="cp">#define ehci_prepare_ports_for_controller_resume(ehci)			\</span>
<span class="cp">		ehci_adjust_port_wakeup_flags(ehci, false, false);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_ROOT_HUB_TT</span>

<span class="cm">/*</span>
<span class="cm"> * Some EHCI controllers have a Transaction Translator built into the</span>
<span class="cm"> * root hub. This is a non-standard feature.  Each controller will need</span>
<span class="cm"> * to add code to the following inline functions, and call them as</span>
<span class="cm"> * needed (mostly in root hub code).</span>
<span class="cm"> */</span>

<span class="cp">#define	ehci_is_TDI(e)			(ehci_to_hcd(e)-&gt;has_tt)</span>

<span class="cm">/* Returns the speed of a device attached to a port on the root hub. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ehci_port_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">portsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_is_TDI</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">((</span><span class="n">portsc</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">has_hostpc</span> <span class="o">?</span> <span class="mi">25</span> <span class="o">:</span> <span class="mi">26</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="k">return</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define	ehci_is_TDI(e)			(0)</span>

<span class="cp">#define	ehci_port_speed(ehci, portsc)	USB_PORT_STAT_HIGH_SPEED</span>
<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef CONFIG_PPC_83xx</span>
<span class="cm">/* Some Freescale processors have an erratum in which the TT</span>
<span class="cm"> * port number in the queue head was 0..N-1 instead of 1..N.</span>
<span class="cm"> */</span>
<span class="cp">#define	ehci_has_fsl_portno_bug(e)		((e)-&gt;has_fsl_port_bug)</span>
<span class="cp">#else</span>
<span class="cp">#define	ehci_has_fsl_portno_bug(e)		(0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * While most USB host controllers implement their registers in</span>
<span class="cm"> * little-endian format, a minority (celleb companion chip) implement</span>
<span class="cm"> * them in big endian format.</span>
<span class="cm"> *</span>
<span class="cm"> * This attempts to support either format at compile time without a</span>
<span class="cm"> * runtime penalty, or both formats with the additional overhead</span>
<span class="cm"> * of checking a flag bit.</span>
<span class="cm"> *</span>
<span class="cm"> * ehci_big_endian_capbase is a special quirk for controllers that</span>
<span class="cm"> * implement the HC capability registers as separate registers and not</span>
<span class="cm"> * as fields of a 32-bit register.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO</span>
<span class="cp">#define ehci_big_endian_mmio(e)		((e)-&gt;big_endian_mmio)</span>
<span class="cp">#define ehci_big_endian_capbase(e)	((e)-&gt;big_endian_capbase)</span>
<span class="cp">#else</span>
<span class="cp">#define ehci_big_endian_mmio(e)		0</span>
<span class="cp">#define ehci_big_endian_capbase(e)	0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Big-endian read/write functions are arch-specific.</span>
<span class="cm"> * Other arches can be added if/when they&#39;re needed.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_ARM) &amp;&amp; defined(CONFIG_ARCH_IXP4XX)</span>
<span class="cp">#define readl_be(addr)		__raw_readl((__force unsigned *)addr)</span>
<span class="cp">#define writel_be(val, addr)	__raw_writel(val, (__force unsigned *)addr)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ehci_readl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
		<span class="n">__u32</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO</span>
	<span class="k">return</span> <span class="n">ehci_big_endian_mmio</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">readl_be</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ehci_writel</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO</span>
	<span class="n">ehci_big_endian_mmio</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">writel_be</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On certain ppc-44x SoC there is a HW issue, that could only worked around with</span>
<span class="cm"> * explicit suspend/operate of OHCI. This function hereby makes sense only on that arch.</span>
<span class="cm"> * Other common bits are dependent on has_amcc_usb23 quirk flag.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_44x</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_ohci_hcfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">operational</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hc_control</span><span class="p">;</span>

	<span class="n">hc_control</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl_be</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">ohci_hcctrl_reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">OHCI_CTRL_HCFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">operational</span><span class="p">)</span>
		<span class="n">hc_control</span> <span class="o">|=</span> <span class="n">OHCI_USB_OPER</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hc_control</span> <span class="o">|=</span> <span class="n">OHCI_USB_SUSPEND</span><span class="p">;</span>

	<span class="n">writel_be</span><span class="p">(</span><span class="n">hc_control</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">ohci_hcctrl_reg</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">ohci_hcctrl_reg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_ohci_hcfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">operational</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * The AMCC 440EPx not only implements its EHCI registers in big-endian</span>
<span class="cm"> * format, but also its DMA data structures (descriptors).</span>
<span class="cm"> *</span>
<span class="cm"> * EHCI controllers accessed through PCI work normally (little-endian</span>
<span class="cm"> * everywhere), so we won&#39;t bother supporting a BE-only mode for now.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_DESC</span>
<span class="cp">#define ehci_big_endian_desc(e)		((e)-&gt;big_endian_desc)</span>

<span class="cm">/* cpu to ehci */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc32</span> <span class="nf">cpu_to_hc32</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ehci_big_endian_desc</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span>
		<span class="o">?</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__hc32</span><span class="p">)</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__hc32</span><span class="p">)</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ehci to cpu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpu</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ehci_big_endian_desc</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">be32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span><span class="p">)</span><span class="n">x</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">le32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpup</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ehci_big_endian_desc</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">be32_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">le32_to_cpup</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cm">/* cpu to ehci */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__hc32</span> <span class="nf">cpu_to_hc32</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ehci to cpu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpu</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hc32_to_cpup</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">const</span> <span class="n">__hc32</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpup</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef CONFIG_PCI</span>

<span class="cm">/* For working around the MosChip frame-index-register bug */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">ehci_read_frame_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifndef DEBUG</span>
<span class="cp">#define STUB_DEBUG_FILES</span>
<span class="cp">#endif	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_EHCI_HCD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
