<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › fhci.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fhci.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale QUICC Engine USB Host Controller Driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) Freescale Semicondutor, Inc. 2006.</span>
<span class="cm"> *               Shlomi Gridish &lt;gridish@freescale.com&gt;</span>
<span class="cm"> *               Jerry Huang &lt;Chang-Ming.Huang@freescale.com&gt;</span>
<span class="cm"> * Copyright (c) Logic Product Development, Inc. 2007</span>
<span class="cm"> *               Peter Barada &lt;peterb@logicpd.com&gt;</span>
<span class="cm"> * Copyright (c) MontaVista Software, Inc. 2008.</span>
<span class="cm"> *               Anton Vorontsov &lt;avorontsov@ru.mvista.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __FHCI_H</span>
<span class="cp">#define __FHCI_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kfifo.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;asm/qe.h&gt;</span>

<span class="cp">#define USB_CLOCK	48000000</span>

<span class="cp">#define FHCI_PRAM_SIZE 0x100</span>

<span class="cp">#define MAX_EDS		32</span>
<span class="cp">#define MAX_TDS		32</span>


<span class="cm">/* CRC16 field size */</span>
<span class="cp">#define CRC_SIZE 2</span>

<span class="cm">/* USB protocol overhead for each frame transmitted from the host */</span>
<span class="cp">#define PROTOCOL_OVERHEAD 7</span>

<span class="cm">/* Packet structure, info field */</span>
<span class="cp">#define PKT_PID_DATA0		0x80000000 </span><span class="cm">/* PID - Data toggle zero */</span><span class="cp"></span>
<span class="cp">#define PKT_PID_DATA1		0x40000000 </span><span class="cm">/* PID - Data toggle one  */</span><span class="cp"></span>
<span class="cp">#define PKT_PID_SETUP		0x20000000 </span><span class="cm">/* PID - Setup bit */</span><span class="cp"></span>
<span class="cp">#define PKT_SETUP_STATUS	0x10000000 </span><span class="cm">/* Setup status bit */</span><span class="cp"></span>
<span class="cp">#define PKT_SETADDR_STATUS	0x08000000 </span><span class="cm">/* Set address status bit */</span><span class="cp"></span>
<span class="cp">#define PKT_SET_HOST_LAST	0x04000000 </span><span class="cm">/* Last data packet */</span><span class="cp"></span>
<span class="cp">#define PKT_HOST_DATA		0x02000000 </span><span class="cm">/* Data packet */</span><span class="cp"></span>
<span class="cp">#define PKT_FIRST_IN_FRAME	0x01000000 </span><span class="cm">/* First packet in the frame */</span><span class="cp"></span>
<span class="cp">#define PKT_TOKEN_FRAME		0x00800000 </span><span class="cm">/* Token packet */</span><span class="cp"></span>
<span class="cp">#define PKT_ZLP			0x00400000 </span><span class="cm">/* Zero length packet */</span><span class="cp"></span>
<span class="cp">#define PKT_IN_TOKEN_FRAME	0x00200000 </span><span class="cm">/* IN token packet */</span><span class="cp"></span>
<span class="cp">#define PKT_OUT_TOKEN_FRAME	0x00100000 </span><span class="cm">/* OUT token packet */</span><span class="cp"></span>
<span class="cp">#define PKT_SETUP_TOKEN_FRAME	0x00080000 </span><span class="cm">/* SETUP token packet */</span><span class="cp"></span>
<span class="cp">#define PKT_STALL_FRAME		0x00040000 </span><span class="cm">/* STALL packet */</span><span class="cp"></span>
<span class="cp">#define PKT_NACK_FRAME		0x00020000 </span><span class="cm">/* NACK packet */</span><span class="cp"></span>
<span class="cp">#define PKT_NO_PID		0x00010000 </span><span class="cm">/* No PID */</span><span class="cp"></span>
<span class="cp">#define PKT_NO_CRC		0x00008000 </span><span class="cm">/* don&#39;t append CRC */</span><span class="cp"></span>
<span class="cp">#define PKT_HOST_COMMAND	0x00004000 </span><span class="cm">/* Host command packet */</span><span class="cp"></span>
<span class="cp">#define PKT_DUMMY_PACKET	0x00002000 </span><span class="cm">/* Dummy packet, used for mmm */</span><span class="cp"></span>
<span class="cp">#define PKT_LOW_SPEED_PACKET	0x00001000 </span><span class="cm">/* Low-Speed packet */</span><span class="cp"></span>

<span class="cp">#define TRANS_OK		(0)</span>
<span class="cp">#define TRANS_INPROGRESS	(-1)</span>
<span class="cp">#define TRANS_DISCARD		(-2)</span>
<span class="cp">#define TRANS_FAIL		(-3)</span>

<span class="cp">#define PS_INT		0</span>
<span class="cp">#define PS_DISCONNECTED	1</span>
<span class="cp">#define PS_CONNECTED	2</span>
<span class="cp">#define PS_READY	3</span>
<span class="cp">#define PS_MISSING	4</span>

<span class="cm">/* Transfer Descriptor status field */</span>
<span class="cp">#define USB_TD_OK		0x00000000 </span><span class="cm">/* TD transmited or received ok */</span><span class="cp"></span>
<span class="cp">#define USB_TD_INPROGRESS	0x80000000 </span><span class="cm">/* TD is being transmitted */</span><span class="cp"></span>
<span class="cp">#define USB_TD_RX_ER_NONOCT	0x40000000 </span><span class="cm">/* Tx Non Octet Aligned Packet */</span><span class="cp"></span>
<span class="cp">#define USB_TD_RX_ER_BITSTUFF	0x20000000 </span><span class="cm">/* Frame Aborted-Received pkt */</span><span class="cp"></span>
<span class="cp">#define USB_TD_RX_ER_CRC	0x10000000 </span><span class="cm">/* CRC error */</span><span class="cp"></span>
<span class="cp">#define USB_TD_RX_ER_OVERUN	0x08000000 </span><span class="cm">/* Over - run occurred */</span><span class="cp"></span>
<span class="cp">#define USB_TD_RX_ER_PID	0x04000000 </span><span class="cm">/* wrong PID received */</span><span class="cp"></span>
<span class="cp">#define USB_TD_RX_DATA_UNDERUN	0x02000000 </span><span class="cm">/* shorter than expected */</span><span class="cp"></span>
<span class="cp">#define USB_TD_RX_DATA_OVERUN	0x01000000 </span><span class="cm">/* longer than expected */</span><span class="cp"></span>
<span class="cp">#define USB_TD_TX_ER_NAK	0x00800000 </span><span class="cm">/* NAK handshake */</span><span class="cp"></span>
<span class="cp">#define USB_TD_TX_ER_STALL	0x00400000 </span><span class="cm">/* STALL handshake */</span><span class="cp"></span>
<span class="cp">#define USB_TD_TX_ER_TIMEOUT	0x00200000 </span><span class="cm">/* transmit time out */</span><span class="cp"></span>
<span class="cp">#define USB_TD_TX_ER_UNDERUN	0x00100000 </span><span class="cm">/* transmit underrun */</span><span class="cp"></span>

<span class="cp">#define USB_TD_ERROR (USB_TD_RX_ER_NONOCT | USB_TD_RX_ER_BITSTUFF | \</span>
<span class="cp">		USB_TD_RX_ER_CRC | USB_TD_RX_ER_OVERUN | USB_TD_RX_ER_PID | \</span>
<span class="cp">		USB_TD_RX_DATA_UNDERUN | USB_TD_RX_DATA_OVERUN | \</span>
<span class="cp">		USB_TD_TX_ER_NAK | USB_TD_TX_ER_STALL | \</span>
<span class="cp">		USB_TD_TX_ER_TIMEOUT | USB_TD_TX_ER_UNDERUN)</span>

<span class="cm">/* Transfer Descriptor toggle field */</span>
<span class="cp">#define USB_TD_TOGGLE_DATA0	0</span>
<span class="cp">#define USB_TD_TOGGLE_DATA1	1</span>
<span class="cp">#define USB_TD_TOGGLE_CARRY	2</span>

<span class="cm">/* #define MULTI_DATA_BUS */</span>

<span class="cm">/* Bus mode register RBMR/TBMR */</span>
<span class="cp">#define BUS_MODE_GBL	0x20	</span><span class="cm">/* Global snooping */</span><span class="cp"></span>
<span class="cp">#define BUS_MODE_BO	0x18	</span><span class="cm">/* Byte ordering */</span><span class="cp"></span>
<span class="cp">#define BUS_MODE_BO_BE	0x10	</span><span class="cm">/* Byte ordering - Big-endian */</span><span class="cp"></span>
<span class="cp">#define BUS_MODE_DTB	0x02	</span><span class="cm">/* Data bus */</span><span class="cp"></span>

<span class="cm">/* FHCI QE USB Register Description */</span>

<span class="cm">/* USB Mode Register bit define */</span>
<span class="cp">#define USB_MODE_EN		0x01</span>
<span class="cp">#define USB_MODE_HOST		0x02</span>
<span class="cp">#define USB_MODE_TEST		0x04</span>
<span class="cp">#define USB_MODE_SFTE		0x08</span>
<span class="cp">#define USB_MODE_RESUME		0x40</span>
<span class="cp">#define USB_MODE_LSS		0x80</span>

<span class="cm">/* USB Slave Address Register Mask */</span>
<span class="cp">#define USB_SLVADDR_MASK	0x7F</span>

<span class="cm">/* USB Endpoint register define */</span>
<span class="cp">#define USB_EPNUM_MASK		0xF000</span>
<span class="cp">#define USB_EPNUM_SHIFT		12</span>

<span class="cp">#define USB_TRANS_MODE_SHIFT	8</span>
<span class="cp">#define USB_TRANS_CTR		0x0000</span>
<span class="cp">#define USB_TRANS_INT		0x0100</span>
<span class="cp">#define USB_TRANS_BULK		0x0200</span>
<span class="cp">#define USB_TRANS_ISO		0x0300</span>

<span class="cp">#define USB_EP_MF		0x0020</span>
<span class="cp">#define USB_EP_RTE		0x0010</span>

<span class="cp">#define USB_THS_SHIFT		2</span>
<span class="cp">#define USB_THS_MASK		0x000c</span>
<span class="cp">#define USB_THS_NORMAL		0x0</span>
<span class="cp">#define USB_THS_IGNORE_IN	0x0004</span>
<span class="cp">#define USB_THS_NACK		0x0008</span>
<span class="cp">#define USB_THS_STALL		0x000c</span>

<span class="cp">#define USB_RHS_SHIFT   	0</span>
<span class="cp">#define USB_RHS_MASK		0x0003</span>
<span class="cp">#define USB_RHS_NORMAL  	0x0</span>
<span class="cp">#define USB_RHS_IGNORE_OUT	0x0001</span>
<span class="cp">#define USB_RHS_NACK		0x0002</span>
<span class="cp">#define USB_RHS_STALL		0x0003</span>

<span class="cp">#define USB_RTHS_MASK		0x000f</span>

<span class="cm">/* USB Command Register define */</span>
<span class="cp">#define USB_CMD_STR_FIFO	0x80</span>
<span class="cp">#define USB_CMD_FLUSH_FIFO	0x40</span>
<span class="cp">#define USB_CMD_ISFT		0x20</span>
<span class="cp">#define USB_CMD_DSFT		0x10</span>
<span class="cp">#define USB_CMD_EP_MASK		0x03</span>

<span class="cm">/* USB Event and Mask Register define */</span>
<span class="cp">#define USB_E_MSF_MASK		0x0800</span>
<span class="cp">#define USB_E_SFT_MASK		0x0400</span>
<span class="cp">#define USB_E_RESET_MASK	0x0200</span>
<span class="cp">#define USB_E_IDLE_MASK		0x0100</span>
<span class="cp">#define USB_E_TXE4_MASK		0x0080</span>
<span class="cp">#define USB_E_TXE3_MASK		0x0040</span>
<span class="cp">#define USB_E_TXE2_MASK		0x0020</span>
<span class="cp">#define USB_E_TXE1_MASK		0x0010</span>
<span class="cp">#define USB_E_SOF_MASK		0x0008</span>
<span class="cp">#define USB_E_BSY_MASK		0x0004</span>
<span class="cp">#define USB_E_TXB_MASK		0x0002</span>
<span class="cp">#define USB_E_RXB_MASK		0x0001</span>

<span class="cm">/* Freescale USB Host controller registers */</span>
<span class="k">struct</span> <span class="n">fhci_regs</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">usb_mod</span><span class="p">;</span>		<span class="cm">/* mode register */</span>
	<span class="n">u8</span> <span class="n">usb_addr</span><span class="p">;</span>		<span class="cm">/* address register */</span>
	<span class="n">u8</span> <span class="n">usb_comm</span><span class="p">;</span>		<span class="cm">/* command register */</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">usb_ep</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* endpoint register */</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">usb_event</span><span class="p">;</span>	<span class="cm">/* event register */</span>
	<span class="n">u8</span> <span class="n">reserved3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">usb_mask</span><span class="p">;</span>	<span class="cm">/* mask register */</span>
	<span class="n">u8</span> <span class="n">reserved4</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">usb_status</span><span class="p">;</span>		<span class="cm">/* status register */</span>
	<span class="n">__be16</span> <span class="n">usb_sof_tmr</span><span class="p">;</span>	<span class="cm">/* Start Of Frame timer */</span>
	<span class="n">u8</span> <span class="n">reserved5</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">usb_frame_num</span><span class="p">;</span>	<span class="cm">/* frame number register */</span>
	<span class="n">u8</span> <span class="n">reserved6</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Freescale USB HOST */</span>
<span class="k">struct</span> <span class="n">fhci_pram</span> <span class="p">{</span>
	<span class="n">__be16</span> <span class="n">ep_ptr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* Endpoint porter reg */</span>
	<span class="n">__be32</span> <span class="n">rx_state</span><span class="p">;</span>	<span class="cm">/* Rx internal state */</span>
	<span class="n">__be32</span> <span class="n">rx_ptr</span><span class="p">;</span>		<span class="cm">/* Rx internal data pointer */</span>
	<span class="n">__be16</span> <span class="n">frame_num</span><span class="p">;</span>	<span class="cm">/* Frame number */</span>
	<span class="n">__be16</span> <span class="n">rx_cnt</span><span class="p">;</span>		<span class="cm">/* Rx byte count */</span>
	<span class="n">__be32</span> <span class="n">rx_temp</span><span class="p">;</span>		<span class="cm">/* Rx temp */</span>
	<span class="n">__be32</span> <span class="n">rx_data_temp</span><span class="p">;</span>	<span class="cm">/* Rx data temp */</span>
	<span class="n">__be16</span> <span class="n">rx_u_ptr</span><span class="p">;</span>	<span class="cm">/* Rx microcode return address temp */</span>
	<span class="n">u8</span> <span class="n">reserved1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* reserved area */</span>
	<span class="n">__be32</span> <span class="n">sof_tbl</span><span class="p">;</span>		<span class="cm">/* SOF lookup table pointer */</span>
	<span class="n">u8</span> <span class="n">sof_u_crc_temp</span><span class="p">;</span>	<span class="cm">/* SOF micorcode CRC5 temp reg */</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">[</span><span class="mh">0xdb</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Freescale USB Endpoint*/</span>
<span class="k">struct</span> <span class="n">fhci_ep_pram</span> <span class="p">{</span>
	<span class="n">__be16</span> <span class="n">rx_base</span><span class="p">;</span>		<span class="cm">/* Rx BD base address */</span>
	<span class="n">__be16</span> <span class="n">tx_base</span><span class="p">;</span>		<span class="cm">/* Tx BD base address */</span>
	<span class="n">u8</span> <span class="n">rx_func_code</span><span class="p">;</span>	<span class="cm">/* Rx function code */</span>
	<span class="n">u8</span> <span class="n">tx_func_code</span><span class="p">;</span>	<span class="cm">/* Tx function code */</span>
	<span class="n">__be16</span> <span class="n">rx_buff_len</span><span class="p">;</span>	<span class="cm">/* Rx buffer length */</span>
	<span class="n">__be16</span> <span class="n">rx_bd_ptr</span><span class="p">;</span>	<span class="cm">/* Rx BD pointer */</span>
	<span class="n">__be16</span> <span class="n">tx_bd_ptr</span><span class="p">;</span>	<span class="cm">/* Tx BD pointer */</span>
	<span class="n">__be32</span> <span class="n">tx_state</span><span class="p">;</span>	<span class="cm">/* Tx internal state */</span>
	<span class="n">__be32</span> <span class="n">tx_ptr</span><span class="p">;</span>		<span class="cm">/* Tx internal data pointer */</span>
	<span class="n">__be16</span> <span class="n">tx_crc</span><span class="p">;</span>		<span class="cm">/* temp transmit CRC */</span>
	<span class="n">__be16</span> <span class="n">tx_cnt</span><span class="p">;</span>		<span class="cm">/* Tx byte count */</span>
	<span class="n">__be32</span> <span class="n">tx_temp</span><span class="p">;</span>		<span class="cm">/* Tx temp */</span>
	<span class="n">__be16</span> <span class="n">tx_u_ptr</span><span class="p">;</span>	<span class="cm">/* Tx microcode return address temp */</span>
	<span class="n">__be16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fhci_controller_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ctrl_list</span><span class="p">;</span>	<span class="cm">/* control endpoints */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bulk_list</span><span class="p">;</span>	<span class="cm">/* bulk endpoints */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">iso_list</span><span class="p">;</span>	<span class="cm">/* isochronous endpoints */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">intr_list</span><span class="p">;</span>	<span class="cm">/* interruput endpoints */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">done_list</span><span class="p">;</span>	<span class="cm">/* done transfers */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">virtual_root_hub</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">dev_num</span><span class="p">;</span>	<span class="cm">/* USB address of the root hub */</span>
	<span class="n">u32</span> <span class="n">feature</span><span class="p">;</span>	<span class="cm">/* indicates what feature has been set */</span>
	<span class="k">struct</span> <span class="n">usb_hub_status</span> <span class="n">hub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_port_status</span> <span class="n">port</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fhci_gpios</span> <span class="p">{</span>
	<span class="n">GPIO_USBOE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">GPIO_USBTP</span><span class="p">,</span>
	<span class="n">GPIO_USBTN</span><span class="p">,</span>
	<span class="n">GPIO_USBRP</span><span class="p">,</span>
	<span class="n">GPIO_USBRN</span><span class="p">,</span>
	<span class="cm">/* these are optional */</span>
	<span class="n">GPIO_SPEED</span><span class="p">,</span>
	<span class="n">GPIO_POWER</span><span class="p">,</span>
	<span class="n">NUM_GPIOS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fhci_pins</span> <span class="p">{</span>
	<span class="n">PIN_USBOE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PIN_USBTP</span><span class="p">,</span>
	<span class="n">PIN_USBTN</span><span class="p">,</span>
	<span class="n">NUM_PINS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">qe_clock</span> <span class="n">fullspeed_clk</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">qe_clock</span> <span class="n">lowspeed_clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qe_pin</span> <span class="o">*</span><span class="n">pins</span><span class="p">[</span><span class="n">NUM_PINS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">gpios</span><span class="p">[</span><span class="n">NUM_GPIOS</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">alow_gpios</span><span class="p">[</span><span class="n">NUM_GPIOS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">fhci_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>	<span class="cm">/* I/O memory used to communicate */</span>
	<span class="k">struct</span> <span class="n">fhci_pram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pram</span><span class="p">;</span>	<span class="cm">/* Parameter RAM */</span>
	<span class="k">struct</span> <span class="n">gtm_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb_lld</span><span class="p">;</span> <span class="cm">/* Low-level driver */</span>
	<span class="k">struct</span> <span class="n">virtual_root_hub</span> <span class="o">*</span><span class="n">vroot_hub</span><span class="p">;</span> <span class="cm">/* the virtual root hub */</span>
	<span class="kt">int</span> <span class="n">active_urbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fhci_controller_list</span> <span class="o">*</span><span class="n">hc_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">process_done_task</span><span class="p">;</span> <span class="cm">/* tasklet for done list */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">empty_eds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">empty_tds</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FHCI_DEBUG</span>
	<span class="kt">int</span> <span class="n">usb_irq_stat</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_irq_stat</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define USB_FRAME_USAGE 90</span>
<span class="cp">#define FRAME_TIME_USAGE (USB_FRAME_USAGE*10)	</span><span class="cm">/* frame time usage */</span><span class="cp"></span>
<span class="cp">#define SW_FIX_TIME_BETWEEN_TRANSACTION 150	</span><span class="cm">/* SW */</span><span class="cp"></span>
<span class="cp">#define MAX_BYTES_PER_FRAME (USB_FRAME_USAGE*15)</span>
<span class="cp">#define MAX_PERIODIC_FRAME_USAGE 90</span>

<span class="cm">/* transaction type */</span>
<span class="k">enum</span> <span class="n">fhci_ta_type</span> <span class="p">{</span>
	<span class="n">FHCI_TA_IN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* input transaction */</span>
	<span class="n">FHCI_TA_OUT</span><span class="p">,</span>	<span class="cm">/* output transaction */</span>
	<span class="n">FHCI_TA_SETUP</span><span class="p">,</span>	<span class="cm">/* setup transaction */</span>
<span class="p">};</span>

<span class="cm">/* transfer mode */</span>
<span class="k">enum</span> <span class="n">fhci_tf_mode</span> <span class="p">{</span>
	<span class="n">FHCI_TF_CTRL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">FHCI_TF_ISO</span><span class="p">,</span>
	<span class="n">FHCI_TF_BULK</span><span class="p">,</span>
	<span class="n">FHCI_TF_INTR</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fhci_speed</span> <span class="p">{</span>
	<span class="n">FHCI_FULL_SPEED</span><span class="p">,</span>
	<span class="n">FHCI_LOW_SPEED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* endpoint state */</span>
<span class="k">enum</span> <span class="n">fhci_ed_state</span> <span class="p">{</span>
	<span class="n">FHCI_ED_NEW</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* pipe is new */</span>
	<span class="n">FHCI_ED_OPER</span><span class="p">,</span>    <span class="cm">/* pipe is operating */</span>
	<span class="n">FHCI_ED_URB_DEL</span><span class="p">,</span> <span class="cm">/* pipe is in hold because urb is being deleted */</span>
	<span class="n">FHCI_ED_SKIP</span><span class="p">,</span>    <span class="cm">/* skip this pipe */</span>
	<span class="n">FHCI_ED_HALTED</span><span class="p">,</span>  <span class="cm">/* pipe is halted */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fhci_port_status</span> <span class="p">{</span>
	<span class="n">FHCI_PORT_POWER_OFF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">FHCI_PORT_DISABLED</span><span class="p">,</span>
	<span class="n">FHCI_PORT_DISCONNECTING</span><span class="p">,</span>
	<span class="n">FHCI_PORT_WAITING</span><span class="p">,</span>	<span class="cm">/* waiting for connection */</span>
	<span class="n">FHCI_PORT_FULL</span><span class="p">,</span>		<span class="cm">/* full speed connected */</span>
	<span class="n">FHCI_PORT_LOW</span><span class="p">,</span>		<span class="cm">/* low speed connected */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fhci_mem_alloc</span> <span class="p">{</span>
	<span class="n">MEM_CACHABLE_SYS</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>	<span class="cm">/* primary DDR,cachable */</span>
	<span class="n">MEM_NOCACHE_SYS</span> <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>	<span class="cm">/* primary DDR,non-cachable */</span>
	<span class="n">MEM_SECONDARY</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>	<span class="cm">/* either secondary DDR or SDRAM */</span>
	<span class="n">MEM_PRAM</span> <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>		<span class="cm">/* multi-user RAM identifier */</span>
<span class="p">};</span>

<span class="cm">/* USB default parameters*/</span>
<span class="cp">#define DEFAULT_RING_LEN	8</span>
<span class="cp">#define DEFAULT_DATA_MEM	MEM_CACHABLE_SYS</span>

<span class="k">struct</span> <span class="n">ed</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">dev_addr</span><span class="p">;</span>		<span class="cm">/* device address */</span>
	<span class="n">u8</span> <span class="n">ep_addr</span><span class="p">;</span>		<span class="cm">/* endpoint address */</span>
	<span class="k">enum</span> <span class="n">fhci_tf_mode</span> <span class="n">mode</span><span class="p">;</span>	<span class="cm">/* USB transfer mode */</span>
	<span class="k">enum</span> <span class="n">fhci_speed</span> <span class="n">speed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_pkt_size</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fhci_ed_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">td_list</span><span class="p">;</span> <span class="cm">/* a list of all queued TD to this pipe */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* read only parameters, should be cleared upon initialization */</span>
	<span class="n">u8</span> <span class="n">toggle_carry</span><span class="p">;</span>	<span class="cm">/* toggle carry from the last TD submitted */</span>
	<span class="n">u32</span> <span class="n">last_iso</span><span class="p">;</span>		<span class="cm">/* time stamp of last queued ISO transfer */</span>
	<span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">td_head</span><span class="p">;</span>	<span class="cm">/* a pointer to the current TD handled */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">td</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>		 <span class="cm">/* a pointer to the data buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>	 <span class="cm">/* length of the data to be submitted */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">actual_len</span><span class="p">;</span> <span class="cm">/* actual bytes transferred on this td */</span>
	<span class="k">enum</span> <span class="n">fhci_ta_type</span> <span class="n">type</span><span class="p">;</span>	 <span class="cm">/* transaction type */</span>
	<span class="n">u8</span> <span class="n">toggle</span><span class="p">;</span>		 <span class="cm">/* toggle for next trans. within this TD */</span>
	<span class="n">u16</span> <span class="n">iso_index</span><span class="p">;</span>		 <span class="cm">/* ISO transaction index */</span>
	<span class="n">u16</span> <span class="n">start_frame</span><span class="p">;</span>	 <span class="cm">/* start frame time stamp */</span>
	<span class="n">u16</span> <span class="n">interval</span><span class="p">;</span>		 <span class="cm">/* interval between trans. (for ISO/Intr) */</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>		 <span class="cm">/* status of the TD */</span>
	<span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">;</span>		 <span class="cm">/* a handle to the corresponding ED */</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>	 <span class="cm">/* a handle to the corresponding URB */</span>
	<span class="n">bool</span> <span class="n">ioc</span><span class="p">;</span>		 <span class="cm">/* Inform On Completion */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* read only parameters should be cleared upon initialization */</span>
	<span class="k">struct</span> <span class="n">packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nak_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">frame_lh</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">packet</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>	<span class="cm">/* packet data */</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* packet length */</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* status of the packet - equivalent to the status</span>
<span class="cm">			 * field for the corresponding structure td */</span>
	<span class="n">u32</span> <span class="n">info</span><span class="p">;</span>	<span class="cm">/* packet information */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv_data</span><span class="p">;</span> <span class="cm">/* private data of the driver (TDs or BDs) */</span>
<span class="p">};</span>

<span class="cm">/* struct for each URB */</span>
<span class="cp">#define URB_INPROGRESS	0</span>
<span class="cp">#define URB_DEL		1</span>

<span class="cm">/* URB states (state field) */</span>
<span class="cp">#define US_BULK		0</span>
<span class="cp">#define US_BULK0	1</span>

<span class="cm">/* three setup states */</span>
<span class="cp">#define US_CTRL_SETUP	2</span>
<span class="cp">#define US_CTRL_DATA	1</span>
<span class="cp">#define US_CTRL_ACK	0</span>

<span class="cp">#define EP_ZERO	0</span>

<span class="k">struct</span> <span class="n">urb_priv</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_of_tds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tds_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">td</span> <span class="o">**</span><span class="n">tds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">time_out</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">endpoint</span> <span class="p">{</span>
	<span class="cm">/* Pointer to ep parameter RAM */</span>
	<span class="k">struct</span> <span class="n">fhci_ep_pram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ep_pram_ptr</span><span class="p">;</span>

	<span class="cm">/* Host transactions */</span>
	<span class="k">struct</span> <span class="n">usb_td</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">td_base</span><span class="p">;</span> <span class="cm">/* first TD in the ring */</span>
	<span class="k">struct</span> <span class="n">usb_td</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">conf_td</span><span class="p">;</span> <span class="cm">/* next TD for confirm after transac */</span>
	<span class="k">struct</span> <span class="n">usb_td</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">empty_td</span><span class="p">;</span><span class="cm">/* next TD for new transaction req. */</span>
	<span class="k">struct</span> <span class="n">kfifo</span> <span class="n">empty_frame_Q</span><span class="p">;</span>  <span class="cm">/* Empty frames list to use */</span>
	<span class="k">struct</span> <span class="n">kfifo</span> <span class="n">conf_frame_Q</span><span class="p">;</span>   <span class="cm">/* frames passed to TDs,waiting for tx */</span>
	<span class="k">struct</span> <span class="n">kfifo</span> <span class="n">dummy_packets_Q</span><span class="p">;</span><span class="cm">/* dummy packets for the CRC overun */</span>

	<span class="n">bool</span> <span class="n">already_pushed_dummy_bd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* struct for each 1mSec frame time */</span>
<span class="cp">#define FRAME_IS_TRANSMITTED		0x00</span>
<span class="cp">#define FRAME_TIMER_END_TRANSMISSION	0x01</span>
<span class="cp">#define FRAME_DATA_END_TRANSMISSION	0x02</span>
<span class="cp">#define FRAME_END_TRANSMISSION		0x03</span>
<span class="cp">#define FRAME_IS_PREPARED		0x04</span>

<span class="k">struct</span> <span class="n">fhci_time_frame</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">frame_num</span><span class="p">;</span>	 <span class="cm">/* frame number */</span>
	<span class="n">u16</span> <span class="n">total_bytes</span><span class="p">;</span> <span class="cm">/* total bytes submitted within this frame */</span>
	<span class="n">u8</span> <span class="n">frame_status</span><span class="p">;</span> <span class="cm">/* flag that indicates to stop fill this frame */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tds_list</span><span class="p">;</span> <span class="cm">/* all tds of this frame */</span>
<span class="p">};</span>

<span class="cm">/* internal driver structure*/</span>
<span class="k">struct</span> <span class="n">fhci_usb</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">saved_msk</span><span class="p">;</span>		 <span class="cm">/* saving of the USB mask register */</span>
	<span class="k">struct</span> <span class="n">endpoint</span> <span class="o">*</span><span class="n">ep0</span><span class="p">;</span>	 <span class="cm">/* pointer for endpoint0 structure */</span>
	<span class="kt">int</span> <span class="n">intr_nesting_cnt</span><span class="p">;</span>	 <span class="cm">/* interrupt nesting counter */</span>
	<span class="n">u16</span> <span class="n">max_frame_usage</span><span class="p">;</span>	 <span class="cm">/* max frame time usage,in micro-sec */</span>
	<span class="n">u16</span> <span class="n">max_bytes_per_frame</span><span class="p">;</span> <span class="cm">/* max byte can be tx in one time frame */</span>
	<span class="n">u32</span> <span class="n">sw_transaction_time</span><span class="p">;</span> <span class="cm">/* sw complete trans time,in micro-sec */</span>
	<span class="k">struct</span> <span class="n">fhci_time_frame</span> <span class="o">*</span><span class="n">actual_frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fhci_controller_list</span> <span class="o">*</span><span class="n">hc_list</span><span class="p">;</span>	<span class="cm">/* main structure for hc */</span>
	<span class="k">struct</span> <span class="n">virtual_root_hub</span> <span class="o">*</span><span class="n">vroot_hub</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fhci_port_status</span> <span class="n">port_status</span><span class="p">;</span>	<span class="cm">/* v_rh port status */</span>

	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">transfer_confirm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Various helpers and prototypes below.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">get_frame_num</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fhci</span><span class="o">-&gt;</span><span class="n">pram</span><span class="o">-&gt;</span><span class="n">frame_num</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07ff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define fhci_dbg(fhci, fmt, args...) \</span>
<span class="cp">		dev_dbg(fhci_to_hcd(fhci)-&gt;self.controller, fmt, ##args)</span>
<span class="cp">#define fhci_vdbg(fhci, fmt, args...) \</span>
<span class="cp">		dev_vdbg(fhci_to_hcd(fhci)-&gt;self.controller, fmt, ##args)</span>
<span class="cp">#define fhci_err(fhci, fmt, args...) \</span>
<span class="cp">		dev_err(fhci_to_hcd(fhci)-&gt;self.controller, fmt, ##args)</span>
<span class="cp">#define fhci_info(fhci, fmt, args...) \</span>
<span class="cp">		dev_info(fhci_to_hcd(fhci)-&gt;self.controller, fmt, ##args)</span>
<span class="cp">#define fhci_warn(fhci, fmt, args...) \</span>
<span class="cp">		dev_warn(fhci_to_hcd(fhci)-&gt;self.controller, fmt, ##args)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="nf">hcd_to_fhci</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="p">)</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">fhci_to_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* fifo of pointers */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cq_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kfifo_alloc</span><span class="p">(</span><span class="n">fifo</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cq_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">kfifo</span> <span class="o">*</span><span class="n">kfifo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfifo_free</span><span class="p">(</span><span class="n">kfifo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cq_howmany</span><span class="p">(</span><span class="k">struct</span> <span class="n">kfifo</span> <span class="o">*</span><span class="n">kfifo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kfifo_len</span><span class="p">(</span><span class="n">kfifo</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cq_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kfifo</span> <span class="o">*</span><span class="n">kfifo</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kfifo_in</span><span class="p">(</span><span class="n">kfifo</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cq_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">kfifo</span> <span class="o">*</span><span class="n">kfifo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="n">kfifo_out</span><span class="p">(</span><span class="n">kfifo</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* fhci-hcd.c */</span>
<span class="kt">void</span> <span class="n">fhci_start_sof_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_stop_sof_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">fhci_get_sof_timer_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_usb_enable_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_usb_disable_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fhci_ioports_check_bus_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>

<span class="cm">/* fhci-mem.c */</span>
<span class="kt">void</span> <span class="n">fhci_recycle_empty_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">td</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_recycle_empty_ed</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">fhci_get_empty_ed</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">fhci_td_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">urb_priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">fhci_ta_type</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">toggle</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">interval</span><span class="p">,</span> <span class="n">u16</span> <span class="n">start_frame</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ioc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_add_tds_to_ed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">,</span> <span class="k">struct</span> <span class="n">td</span> <span class="o">**</span><span class="n">td_list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span><span class="p">);</span>

<span class="cm">/* fhci-hub.c */</span>
<span class="kt">void</span> <span class="n">fhci_config_transceiver</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">fhci_port_status</span> <span class="n">status</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_port_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_port_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">lld</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_io_port_generate_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_port_reset</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">lld</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fhci_hub_status_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fhci_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
		     <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">);</span>

<span class="cm">/* fhci-tds.c */</span>
<span class="kt">void</span> <span class="n">fhci_flush_bds</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_flush_actual_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">fhci_host_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">fhci_ta_type</span> <span class="n">trans_type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dest_addr</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">dest_ep</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fhci_tf_mode</span> <span class="n">trans_mode</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">fhci_speed</span> <span class="n">dest_speed</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data_toggle</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_host_transmit_actual_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_tx_conf_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_push_dummy_bd</span><span class="p">(</span><span class="k">struct</span> <span class="n">endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">fhci_create_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fhci_mem_alloc</span> <span class="n">data_mem</span><span class="p">,</span>
		   <span class="n">u32</span> <span class="n">ring_len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_init_ep_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">fhci_mem_alloc</span> <span class="n">data_mem</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_ep0_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>

<span class="cm">/* fhci-sched.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">fhci_tasklet</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">fhci_transaction_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_flush_all_transmissions</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_schedule_transactions</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_device_connected_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_device_disconnected_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_queue_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">fhci_transfer_confirm_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="n">irqreturn_t</span> <span class="n">fhci_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="n">irqreturn_t</span> <span class="n">fhci_frame_limit_timer_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_hcd</span><span class="p">);</span>

<span class="cm">/* fhci-q.h */</span>
<span class="kt">void</span> <span class="n">fhci_urb_complete_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">fhci_remove_td_from_ed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">fhci_remove_td_from_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_time_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_move_td_from_ed_to_done_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_usb</span> <span class="o">*</span><span class="n">usb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">fhci_peek_td_from_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_time_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_add_td_to_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_time_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">td</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">fhci_remove_td_from_done_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_controller_list</span> <span class="o">*</span><span class="n">p_list</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_done_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">td</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_del_ed_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FHCI_DEBUG</span>

<span class="kt">void</span> <span class="n">fhci_dbg_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usb_er</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_dfs_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fhci_dfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fhci_dbg_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usb_er</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fhci_dfs_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fhci_dfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fhci_hcd</span> <span class="o">*</span><span class="n">fhci</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FHCI_DEBUG */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __FHCI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
