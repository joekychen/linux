<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › oxu210hp-hcd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>oxu210hp-hcd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2008 Rodolfo Giometti &lt;giometti@linux.it&gt;</span>
<span class="cm"> * Copyright (c) 2008 Eurotech S.p.A. &lt;info@eurtech.it&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This code is *strongly* based on EHCI-HCD code by David Brownell since</span>
<span class="cm"> * the chip is a quasi-EHCI compatible.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>

<span class="cp">#include &quot;oxu210hp.h&quot;</span>

<span class="cp">#define DRIVER_VERSION &quot;0.0.50&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Main defines</span>
<span class="cm"> */</span>

<span class="cp">#define oxu_dbg(oxu, fmt, args...) \</span>
<span class="cp">		dev_dbg(oxu_to_hcd(oxu)-&gt;self.controller , fmt , ## args)</span>
<span class="cp">#define oxu_err(oxu, fmt, args...) \</span>
<span class="cp">		dev_err(oxu_to_hcd(oxu)-&gt;self.controller , fmt , ## args)</span>
<span class="cp">#define oxu_info(oxu, fmt, args...) \</span>
<span class="cp">		dev_info(oxu_to_hcd(oxu)-&gt;self.controller , fmt , ## args)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">oxu_to_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="nf">hcd_to_oxu</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Debug stuff</span>
<span class="cm"> */</span>

<span class="cp">#undef OXU_URB_TRACE</span>
<span class="cp">#undef OXU_VERBOSE_DEBUG</span>

<span class="cp">#ifdef OXU_VERBOSE_DEBUG</span>
<span class="cp">#define oxu_vdbg			oxu_dbg</span>
<span class="cp">#else</span>
<span class="cp">#define oxu_vdbg(oxu, fmt, args...)	</span><span class="cm">/* Nop */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span>
<span class="n">dbg_status_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s&quot;</span><span class="p">,</span>
		<span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_ASS</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Async&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_PSS</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Periodic&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_RECL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Recl&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_HALT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Halt&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_IAA</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; IAA&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_FATAL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; FATAL&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_FLR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; FLR&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_PCD</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; PCD&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_ERR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; ERR&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_INT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; INT&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span>
		<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span>
<span class="n">dbg_intr_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u32</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s%sintrenable %02x%s%s%s%s%s%s&quot;</span><span class="p">,</span>
		<span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span>
		<span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">STS_IAA</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; IAA&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">STS_FATAL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; FATAL&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">STS_FLR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; FLR&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">STS_PCD</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; PCD&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">STS_ERR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; ERR&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">STS_INT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; INT&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span>
		<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">fls_strings</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="s">&quot;1024&quot;</span><span class="p">,</span> <span class="s">&quot;512&quot;</span><span class="p">,</span> <span class="s">&quot;256&quot;</span><span class="p">,</span> <span class="s">&quot;??&quot;</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_command_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u32</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="s">&quot;%s%scommand %06x %s=%d ithresh=%d%s%s%s%s period=%s%s %s&quot;</span><span class="p">,</span>
		<span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_PARK</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;park&quot;</span> <span class="o">:</span> <span class="s">&quot;(park)&quot;</span><span class="p">,</span>
		<span class="n">CMD_PARK_CNT</span><span class="p">(</span><span class="n">command</span><span class="p">),</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">,</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_LRESET</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; LReset&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_IAAD</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; IAAD&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_ASE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Async&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_PSE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Periodic&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">fls_strings</span><span class="p">[(</span><span class="n">command</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">],</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_RESET</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Reset&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_RUN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;RUN&quot;</span> <span class="o">:</span> <span class="s">&quot;HALT&quot;</span>
		<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_port_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">sig</span><span class="p">;</span>

	<span class="cm">/* signaling state */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>:
		<span class="n">sig</span> <span class="o">=</span> <span class="s">&quot;se0&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>:
		<span class="n">sig</span> <span class="o">=</span> <span class="s">&quot;k&quot;</span><span class="p">;</span>	<span class="cm">/* low speed */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>:
		<span class="n">sig</span> <span class="o">=</span> <span class="s">&quot;j&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="s">&quot;%s%sport %d status %06x%s%s sig=%s%s%s%s%s%s%s%s%s%s&quot;</span><span class="p">,</span>
		<span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_POWER</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; POWER&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; OWNER&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">sig</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; RESET&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; SUSPEND&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; RESUME&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_OCC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; OCC&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_OC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; OC&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_PEC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; PEC&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; PE&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_CSC</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; CSC&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; CONNECT&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span>
	    <span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span>
<span class="n">dbg_status_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span>
<span class="n">dbg_command_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u32</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span>
<span class="n">dbg_intr_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u32</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span>
<span class="n">dbg_port_buf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/* functions have the &quot;wrong&quot; filename when they&#39;re output... */</span>
<span class="cp">#define dbg_status(oxu, label, status) { \</span>
<span class="cp">	char _buf[80]; \</span>
<span class="cp">	dbg_status_buf(_buf, sizeof _buf, label, status); \</span>
<span class="cp">	oxu_dbg(oxu, &quot;%s\n&quot;, _buf); \</span>
<span class="cp">}</span>

<span class="cp">#define dbg_cmd(oxu, label, command) { \</span>
<span class="cp">	char _buf[80]; \</span>
<span class="cp">	dbg_command_buf(_buf, sizeof _buf, label, command); \</span>
<span class="cp">	oxu_dbg(oxu, &quot;%s\n&quot;, _buf); \</span>
<span class="cp">}</span>

<span class="cp">#define dbg_port(oxu, label, port, status) { \</span>
<span class="cp">	char _buf[80]; \</span>
<span class="cp">	dbg_port_buf(_buf, sizeof _buf, label, port, status); \</span>
<span class="cp">	oxu_dbg(oxu, &quot;%s\n&quot;, _buf); \</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Module parameters</span>
<span class="cm"> */</span>

<span class="cm">/* Initial IRQ latency: faster than hw default */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">log2_irq_thresh</span><span class="p">;</span>			<span class="cm">/* 0 to 6 */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">log2_irq_thresh</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">log2_irq_thresh</span><span class="p">,</span> <span class="s">&quot;log2 IRQ latency, 1-64 microframes&quot;</span><span class="p">);</span>

<span class="cm">/* Initial park setting: slower than hw default */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">park</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">park</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">park</span><span class="p">,</span> <span class="s">&quot;park setting; 1-3 back-to-back async packets&quot;</span><span class="p">);</span>

<span class="cm">/* For flakey hardware, ignore overcurrent indicators */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">ignore_oc</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ignore_oc</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ignore_oc</span><span class="p">,</span> <span class="s">&quot;ignore bogus hardware overcurrent indications&quot;</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">ehci_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">oxu_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Local functions</span>
<span class="cm"> */</span>

<span class="cm">/* Low level read/write registers functions */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">oxu_readl</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">oxu_writel</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_action_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">ehci_timer_action</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">actions</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">ehci_timer_action</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">actions</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TIMER_IAA_WATCHDOG</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">EHCI_IAA_JIFFIES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TIMER_IO_WATCHDOG</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">EHCI_IO_JIFFIES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TIMER_ASYNC_OFF</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">EHCI_ASYNC_JIFFIES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TIMER_ASYNC_SHRINK</span>:
		<span class="nl">default:</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">EHCI_SHRINK_JIFFIES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">t</span> <span class="o">+=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="cm">/* all timings except IAA watchdog can be overridden.</span>
<span class="cm">		 * async queue SHRINK often precedes IAA.  while it&#39;s ready</span>
<span class="cm">		 * to go OFF neither can matter, and afterwards the IO</span>
<span class="cm">		 * watchdog stops unless there&#39;s still periodic traffic.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="n">TIMER_IAA_WATCHDOG</span>
				<span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">.</span><span class="n">expires</span>
				<span class="o">&amp;&amp;</span> <span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handshake - spin reading hc until handshake completes or fails</span>
<span class="cm"> * @ptr: address of hc register to be read</span>
<span class="cm"> * @mask: bits to look at in result of read</span>
<span class="cm"> * @done: value of those bits when handshake succeeds</span>
<span class="cm"> * @usec: timeout in microseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative errno, or zero on success</span>
<span class="cm"> *</span>
<span class="cm"> * Success happens when the &quot;mask&quot; bits have the specified value (hardware</span>
<span class="cm"> * handshake done).  There are two failure modes:  &quot;usec&quot; have passed (major</span>
<span class="cm"> * hardware flakeout), or the register reads as all-ones (hardware removed).</span>
<span class="cm"> *</span>
<span class="cm"> * That last failure should_only happen in cases like physical cardbus eject</span>
<span class="cm"> * before driver shutdown. But it also seems to be caused by bugs in cardbus</span>
<span class="cm"> * bridge shutdown:  shutting down the bridge before the devices using it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>		<span class="cm">/* card removed */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">usec</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">usec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Force HC to halt state from unknown (EHCI spec section 2.3) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* disable any irqs left enabled by previous code */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">STS_HALT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
			  <span class="n">STS_HALT</span><span class="p">,</span> <span class="n">STS_HALT</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Put TDI/ARC silicon into EHCI mode */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tdi_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">reg_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(((</span><span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x68</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">reg_ptr</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">reg_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Reset a non-running (STS_HALT == 1) controller */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">command</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RESET</span><span class="p">;</span>
	<span class="n">dbg_cmd</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span>
			    <span class="n">CMD_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">tdi_reset</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Idle the controller (from running) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">temp</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* wait for any schedule enables/disables to take effect */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="n">STS_ASS</span> <span class="o">|</span> <span class="n">STS_PSS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">STS_ASS</span> <span class="o">|</span> <span class="n">STS_PSS</span><span class="p">,</span>
				<span class="n">temp</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">125</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* then disable anything that&#39;s still active */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_ASE</span> <span class="o">|</span> <span class="n">CMD_IAAD</span> <span class="o">|</span> <span class="n">CMD_PSE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/* hardware can take 16 microframes to turn off ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">STS_ASS</span> <span class="o">|</span> <span class="n">STS_PSS</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">125</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_reset_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">status_reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">port_status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if reset finished and it&#39;s still not enabled -- handoff */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;Failed to enable port %d on root hub TT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">port_status</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;port %d high speed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">port_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ports</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bPwrOn2PwrGood</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>	<span class="cm">/* oxu 1.0, 2.3.9 says 20ms max */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span> <span class="o">=</span> <span class="n">ports</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">ports</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescLength</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* ports removable, and usb 1.0 legacy PortPwrCtrlMask */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="n">temp</span><span class="p">],</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="mh">0x0008</span><span class="p">;</span>			<span class="cm">/* per-port overcurrent reporting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCS_PPC</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="mh">0x0001</span><span class="p">;</span>		<span class="cm">/* per-port power control */</span>
	<span class="k">else</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="mh">0x0002</span><span class="p">;</span>		<span class="cm">/* no power switching */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__u16</span><span class="p">)</span><span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Allocate an OXU210HP on-chip memory data buffer</span>
<span class="cm"> *</span>
<span class="cm"> * An on-chip memory data buffer is required for each OXU210HP USB transfer.</span>
<span class="cm"> * Each transfer descriptor has one or more on-chip memory data buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Data buffers are allocated from a fix sized pool of data blocks.</span>
<span class="cm"> * To minimise fragmentation and give reasonable memory utlisation,</span>
<span class="cm"> * data buffers are allocated with sizes the power of 2 multiples of</span>
<span class="cm"> * the block size, starting on an address a multiple of the allocated size.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: callers of this function require a buffer to be allocated for</span>
<span class="cm"> * len=0. This is a waste of on-chip memory and should be fix. Then this</span>
<span class="cm"> * function should be changed to not allocate a buffer for len=0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_buf_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_blocks</span><span class="p">;</span>	<span class="cm">/* minium blocks needed to hold len */</span>
	<span class="kt">int</span> <span class="n">a_blocks</span><span class="p">;</span>	<span class="cm">/* blocks allocated */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allocte bigger than supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">BUFFER_SIZE</span> <span class="o">*</span> <span class="n">BUFFER_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_err</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;buffer too big (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="cm">/* Number of blocks needed to hold len */</span>
	<span class="n">n_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">BUFFER_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

	<span class="cm">/* Round the number of blocks up to the power of 2 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">a_blocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a_blocks</span> <span class="o">&lt;</span> <span class="n">n_blocks</span><span class="p">;</span> <span class="n">a_blocks</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="cm">/* Find a suitable available data buffer */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BUFFER_NUM</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">max</span><span class="p">(</span><span class="n">a_blocks</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">db_used</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>

		<span class="cm">/* Check all the required blocks are available */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">a_blocks</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">db_used</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">a_blocks</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Allocate blocks found! */</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">db_pool</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer_dma</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>

		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_buffer_len</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span> <span class="o">*</span> <span class="n">a_blocks</span><span class="p">;</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">db_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_blocks</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Failed */</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_buf_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">db_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
							 <span class="o">/</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">db_used</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_buffer_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ehci_qtd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">qtd</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_STS_HALT</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">oxu_qtd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">oxu_buf_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">qtd</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">qtd_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qtd_used</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="nf">ehci_qtd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QTD_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qtd_used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">QTD_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">qtd_pool</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">qtd</span><span class="p">);</span>

		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_STS_HALT</span><span class="p">);</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>

		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">qtd</span><span class="p">);</span>

		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qtd_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">qtd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_qh_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">qh</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">qh_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qh_used</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qh_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">oxu</span><span class="p">;</span>

	<span class="cm">/* clean qtds first, and know this is not linked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="o">||</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;unused qh not empty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">)</span>
		<span class="n">oxu_qtd_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">);</span>
	<span class="n">oxu_qh_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="nf">oxu_qh_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QHEAD_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qh_used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">QHEAD_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">qh_pool</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>

		<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">oxu</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_dma</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>

		<span class="cm">/* dummy td enables safe urb queuing */</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;no dummy td</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qh_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qh_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* to share a qh (cpu threads, or hc) */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="nf">qh_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">qh_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">qh_destroy</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_murb_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="n">murb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">murb</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_used</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="nf">oxu_murb_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>

<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="n">murb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MURB_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MURB_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">murb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_pool</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">murb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The queue heads and transfer descriptors are managed from pools tied</span>
<span class="cm"> * to each of the &quot;per device&quot; structures.</span>
<span class="cm"> * This is the initialisation and cleanup code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_mem_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_pool</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">)</span>
		<span class="n">qh_put</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">urb_timer</span><span class="p">);</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* shadow periodic table */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remember to add cleanup code (above) if you add anything here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehci_mem_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">frame_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QHEAD_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qh_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QTD_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">qtd_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_pool</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">MURB_NUM</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_murb</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MURB_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">murb_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span> <span class="o">=</span> <span class="n">oxu_qh_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">frame_list</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_dma</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>

	<span class="cm">/* software shadow of hardware table */</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t init memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ehci_mem_cleanup</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fill a qtd, returning how much of the buffer we were able to queue up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qtd_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">token</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxpacket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* one buffer entry per 4K ... first might be short or unaligned */</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf_hi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="p">(</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="mh">0x0fff</span><span class="p">);</span>	<span class="cm">/* rest of that page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">))</span>		<span class="cm">/* ... iff needed */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">+=</span>  <span class="mh">0x1000</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x0fff</span><span class="p">;</span>

		<span class="cm">/* per-qtd limit: from 16K to 20K (best alignment) */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf_hi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">count</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* short packets may only terminate transfers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">-=</span> <span class="p">(</span><span class="n">count</span> <span class="o">%</span> <span class="n">maxpacket</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">token</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">qh_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* writes to an active overlay are unsafe */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_IDLE</span><span class="p">);</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_qtd_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>

	<span class="cm">/* Except for control endpoints, we make hardware maintain data</span>
<span class="cm">	 * toggle (like OHCI) ... here (re)initialize the toggle in the QH,</span>
<span class="cm">	 * and set the pseudo-toggle in udev. Only usb_clear_halt() will</span>
<span class="cm">	 * ever clear it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">is_out</span><span class="p">,</span> <span class="n">epnum</span><span class="p">;</span>

		<span class="n">is_out</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="n">epnum</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">usb_gettoggle</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">is_out</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_TOGGLE</span><span class="p">);</span>
			<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">is_out</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* HC must see latest qtd and qh data before we clear ACTIVE+HALT */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_TOGGLE</span> <span class="o">|</span> <span class="n">QTD_STS_PING</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If it weren&#39;t for a common silicon quirk (writing the dummy into the qh</span>
<span class="cm"> * overlay, so qh-&gt;hw_token wrongly becomes inactive/halted), only fault</span>
<span class="cm"> * recovery (including urb dequeue) would need software changes to a QH...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qh_refresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
		<span class="cm">/* first qtd may already be partially processed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">)</span> <span class="o">==</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_current</span><span class="p">)</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="p">)</span>
		<span class="n">qh_update</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qtd_copy_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">u32</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* count IN/OUT bytes, not SETUP (even short packets) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">QTD_PID</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">QTD_LENGTH</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>

	<span class="cm">/* don&#39;t modify error codes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* force cleanup after short read; not always an error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_SHORT_READ</span><span class="p">(</span><span class="n">token</span><span class="p">)))</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>

	<span class="cm">/* serious &quot;can&#39;t proceed&quot; faults reported by the hardware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_HALT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_BABBLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIXME &quot;must&quot; disable babbling device&#39;s port too */</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_MMF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* fs/ls interrupt xfer missed the complete-split */</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_DBE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">QTD_PID</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* IN ? */</span>
				<span class="o">?</span> <span class="o">-</span><span class="n">ENOSR</span>  <span class="cm">/* hc couldn&#39;t read data */</span>
				<span class="o">:</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">;</span> <span class="cm">/* hc couldn&#39;t write data */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_XACT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* timeout, bad crc, wrong PID, etc; retried */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">QTD_CERR</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;devpath %s ep%d%s 3strikes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
					<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
					<span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="cm">/* CERR nonzero + no errors + halt --&gt; stall */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">QTD_CERR</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">else</span>	<span class="cm">/* unknown */</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>

		<span class="n">oxu_vdbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;dev%d ep%d%s qtd token %08x --&gt; status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
			<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
			<span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			<span class="n">token</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_urb_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qh</span>	<span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

		<span class="cm">/* S-mask in a QH means it&#39;s an interrupt urb */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QH_SMASK</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* ... update hc-wide periodic stats (for usbfs) */</span>
			<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_int_reqs</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:		<span class="cm">/* success */</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>			<span class="cm">/* fault */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EREMOTEIO</span>:		<span class="cm">/* fault or normal */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">))</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:		<span class="cm">/* canceled */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef OXU_URB_TRACE</span>
	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;%s %s urb %p ep%d%s status %d len %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
		<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
		<span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* complete() can reenter this HCD */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">),</span> <span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">start_unlink_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">unlink_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">intr_deschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qh_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>

<span class="cp">#define HALT_BIT cpu_to_le32(QTD_STS_HALT)</span>

<span class="cm">/* Process and free completed qtds for a qh, returning URBs to drivers.</span>
<span class="cm"> * Chases up to qh-&gt;hw_current.  Returns number of completions called,</span>
<span class="cm"> * indicating how much &quot;real&quot; work we did.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">qh_completions</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stopped</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="n">murb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* completions (or tasks on other cpus) must never clobber HALT</span>
<span class="cm">	 * till we&#39;ve gone through and cleaned everything up, even when</span>
<span class="cm">	 * they add urbs to this qh&#39;s queue or mark them for unlinking.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  unlinking expects to be done in queue order.</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_COMPLETING</span><span class="p">;</span>
	<span class="n">stopped</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">);</span>

	<span class="cm">/* remove de-activated QTDs from front of queue.</span>
<span class="cm">	 * after faults (including short reads), cleanup this urb</span>
<span class="cm">	 * then let the queue advance.</span>
<span class="cm">	 * if queue is stopped, handles unlinks.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">token</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

		<span class="cm">/* Clean up any state from previous QTD ...*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">!=</span> <span class="n">urb</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">murb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="p">)</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
					<span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">murb</span><span class="o">-&gt;</span><span class="n">main</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">murb</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
						<span class="n">count</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">oxu_murb_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">murb</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
					<span class="n">count</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">oxu_qtd_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
			<span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* ignore urbs submitted during completions we reported */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* hardware copies qtd out of qh overlay */</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="n">token</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span><span class="p">);</span>

		<span class="cm">/* always clean up qtds the hc de-activated */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_HALT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* magic dummy for some short reads; qh won&#39;t advance.</span>
<span class="cm">			 * that silicon quirk can kick in with this dummy too.</span>
<span class="cm">			 */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_SHORT_READ</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">&amp;</span> <span class="n">EHCI_LIST_END</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">halt</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="cm">/* stop scanning when we reach qtds the hc is using */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">stopped</span> <span class="o">&amp;&amp;</span>
				<span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

			<span class="cm">/* ignore active urbs unless some previous qtd</span>
<span class="cm">			 * for the urb faulted (including short read) or</span>
<span class="cm">			 * its urb was canceled.  we may patch qh or qtds.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* issue status after short control reads */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="n">QTD_PID</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="cm">/* OUT */</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">do_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* token in overlay may be most current */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span>
					<span class="o">&amp;&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">)</span>
						<span class="o">==</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_current</span><span class="p">)</span>
				<span class="n">token</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_token</span><span class="p">);</span>

			<span class="cm">/* force halt for unlinked or blocked qh, so we&#39;ll</span>
<span class="cm">			 * patch the qh later and so that completions can&#39;t</span>
<span class="cm">			 * activate it while we &quot;know&quot; it&#39;s stopped.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">HALT_BIT</span> <span class="o">&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">halt:</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">|=</span> <span class="n">HALT_BIT</span><span class="p">;</span>
				<span class="n">wmb</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Remove it from the queue */</span>
		<span class="n">qtd_copy_status</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">?</span>
					<span class="n">urb</span> <span class="o">:</span> <span class="p">((</span><span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">main</span><span class="p">,</span>
				<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">))</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">do_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stopped</span> <span class="o">&amp;&amp;</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">prev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">last</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* last urb&#39;s completion might still need calling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">last</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">murb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="p">)</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
			<span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">murb</span><span class="o">-&gt;</span><span class="n">main</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">murb</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">oxu_murb_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">murb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">oxu_qtd_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* restore original state; caller must unlink or relink */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* be sure the hardware&#39;s done with the qh before refreshing</span>
<span class="cm">	 * it after fault cleanup, or recovering from silicon wrongly</span>
<span class="cm">	 * overlaying the dummy qtd (which reduces DMA chatter).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stopped</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_qtd_next</span> <span class="o">==</span> <span class="n">EHCI_LIST_END</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">QH_STATE_IDLE</span>:
			<span class="n">qh_refresh</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">QH_STATE_LINKED</span>:
			<span class="cm">/* should be rare for periodic transfers,</span>
<span class="cm">			 * except maybe high bandwidth ...</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QH_SMASK</span><span class="p">)</span>
					<span class="o">&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">intr_deschedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">qh_schedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* otherwise, unlink already started */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* High bandwidth multiplier, as encoded in highspeed endpoint descriptors */</span>
<span class="cp">#define hb_mult(wMaxPacketSize)		(1 + (((wMaxPacketSize) &gt;&gt; 11) &amp; 0x03))</span>
<span class="cm">/* ... and packet size, for any kind of endpoint descriptor */</span>
<span class="cp">#define max_packet(wMaxPacketSize)	((wMaxPacketSize) &amp; 0x07ff)</span>

<span class="cm">/* Reverse of qh_urb_transaction: free a list of TDs.</span>
<span class="cm"> * used for cleanup after errors, before HC sees an URB&#39;s TDs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qtd_list_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qtd_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

		<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">oxu_qtd_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Create a list of filled qtds for this URB; won&#39;t link into qh.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">qh_urb_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="o">*</span><span class="n">qtd_prev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">maxpacket</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_input</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">token</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">transfer_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * URBs map to sequences of QTDs: one logical transaction</span>
<span class="cm">	 */</span>
	<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

	<span class="n">token</span> <span class="o">=</span> <span class="n">QTD_STS_ACTIVE</span><span class="p">;</span>
	<span class="n">token</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_CERR</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="cm">/* for split transactions, SplitXState initialized to zero */</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="n">is_input</span> <span class="o">=</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&amp;&amp;</span> <span class="n">is_input</span><span class="p">)</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* SETUP pid */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">oxu_buf_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

		<span class="n">qtd_fill</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">),</span>
				<span class="n">token</span> <span class="o">|</span> <span class="p">(</span><span class="mi">2</span> <span class="cm">/* &quot;setup&quot; */</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">));</span>

		<span class="cm">/* ... and always at least one more pid */</span>
		<span class="n">token</span> <span class="o">^=</span> <span class="n">QTD_TOGGLE</span><span class="p">;</span>
		<span class="n">qtd_prev</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">qtd_prev</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

		<span class="cm">/* for zero length DATA stages, STATUS is always IN */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">token</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="cm">/* &quot;in&quot; */</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Data transfer stage: buffer setup</span>
<span class="cm">	 */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">oxu_buf_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">;</span>
	<span class="n">transfer_buf</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_input</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span>
		<span class="n">token</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="cm">/* &quot;in&quot; */</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* else it&#39;s already initted to &quot;out&quot; pid (0 &lt;&lt; 8) */</span>

	<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="o">!</span><span class="n">is_input</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * buffer gets wrapped in one or more qtds;</span>
<span class="cm">	 * last one may be &quot;short&quot; (including zero len)</span>
<span class="cm">	 * and may serve as a control status ack</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">this_qtd_len</span><span class="p">;</span>

		<span class="n">this_qtd_len</span> <span class="o">=</span> <span class="n">qtd_fill</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">maxpacket</span><span class="p">);</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">transfer_buf</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">this_qtd_len</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">this_qtd_len</span><span class="p">;</span>
		<span class="n">transfer_buf</span> <span class="o">+=</span> <span class="n">this_qtd_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span><span class="p">;</span>

		<span class="cm">/* qh makes control packets use qtd toggle; maybe switch it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">maxpacket</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">this_qtd_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">token</span> <span class="o">^=</span> <span class="n">QTD_TOGGLE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">qtd_prev</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">oxu_buf_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">qtd_prev</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* unless the bulk/interrupt caller wants a chance to clean</span>
<span class="cm">	 * up after short reads, hc should advance qh past this urb</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
				<span class="o">||</span> <span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)))</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * control requests may need a terminating data &quot;status&quot; ack;</span>
<span class="cm">	 * bulk ones may need a terminating short packet (zero length).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">one_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">one_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">token</span> <span class="o">^=</span> <span class="mh">0x0100</span><span class="p">;</span>	<span class="cm">/* &quot;in&quot; &lt;--&gt; &quot;out&quot;  */</span>
			<span class="n">token</span> <span class="o">|=</span> <span class="n">QTD_TOGGLE</span><span class="p">;</span>	<span class="cm">/* force DATA1 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_pipebulk</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ZERO_PACKET</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">%</span> <span class="n">maxpacket</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">one_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">one_more</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qtd_prev</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
			<span class="n">qtd_prev</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

			<span class="cm">/* never any data in such packets */</span>
			<span class="n">qtd_fill</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* by default, enable interrupt on urb completion */</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_IOC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">head</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="n">qtd_list_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Each QH holds a qtd list; a QH is used for everything except iso.</span>
<span class="cm"> *</span>
<span class="cm"> * For interrupt urbs, the scheduler must set the microframe scheduling</span>
<span class="cm"> * mask(s) each time the QH gets scheduled.  For highspeed, that&#39;s</span>
<span class="cm"> * just one microframe in the s-mask.  For split interrupt transactions</span>
<span class="cm"> * there are additional complications: c-mask, maybe FSTNs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="nf">qh_make</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">oxu_qh_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">info1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_input</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * init endpoint/device data for this QH</span>
<span class="cm">	 */</span>
	<span class="n">info1</span> <span class="o">|=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">info1</span> <span class="o">|=</span> <span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">is_input</span> <span class="o">=</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="o">!</span><span class="n">is_input</span><span class="p">);</span>

	<span class="cm">/* Compute interrupt scheduling parameters just once, and save.</span>
<span class="cm">	 * - allowing for high bandwidth, how many nsec/uframe are used?</span>
<span class="cm">	 * - split transactions need a second CSPLIT uframe; same question</span>
<span class="cm">	 * - splits also need a schedule gap (for full/low speed I/O)</span>
<span class="cm">	 * - qh has a polling interval</span>
<span class="cm">	 *</span>
<span class="cm">	 * For control/bulk requests, the HC or TT handles these.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_INTERRUPT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">=</span> <span class="n">NS_TO_US</span><span class="p">(</span><span class="n">usb_calc_bus_time</span><span class="p">(</span><span class="n">USB_SPEED_HIGH</span><span class="p">,</span>
								<span class="n">is_input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">hb_mult</span><span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">)));</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">NO_FRAME</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">gap_uf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* NOTE interval 2 or 4 uframes could work.</span>
<span class="cm">				 * But interval 1 scheduling is simpler, and</span>
<span class="cm">				 * includes high bandwidth.</span>
<span class="cm">				 */</span>
				<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;intr period %d uframes, NYET!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_tt</span>	<span class="o">*</span><span class="n">tt</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">;</span>
			<span class="kt">int</span>		<span class="n">think_time</span><span class="p">;</span>

			<span class="cm">/* gap is f(FS/LS transfer times) */</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">gap_uf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">usb_calc_bus_time</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span>
					<span class="n">is_input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">125</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

			<span class="cm">/* FIXME this just approximates SPLIT/CSPLIT times */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* SPLIT, gap, CSPLIT+DATA */</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+</span> <span class="n">HS_USECS</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">=</span> <span class="n">HS_USECS</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* SPLIT+DATA, gap, CSPLIT */</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+=</span> <span class="n">HS_USECS</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">=</span> <span class="n">HS_USECS</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">think_time</span> <span class="o">=</span> <span class="n">tt</span> <span class="o">?</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">think_time</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_usecs</span> <span class="o">=</span> <span class="n">NS_TO_US</span><span class="p">(</span><span class="n">think_time</span> <span class="o">+</span>
					<span class="n">usb_calc_bus_time</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span>
					<span class="n">is_input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">)));</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* support for tt scheduling, and access to toggles */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* using TT? */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
		<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>	<span class="cm">/* EPS &quot;low&quot; */</span>
		<span class="cm">/* FALL THROUGH */</span>

	<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:
		<span class="cm">/* EPS 0 means &quot;full&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PIPE_INTERRUPT</span><span class="p">)</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_RL_TT</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span>	<span class="cm">/* for TT */</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">;</span>	<span class="cm">/* toggle from qtd */</span>
		<span class="p">}</span>
		<span class="n">info1</span> <span class="o">|=</span> <span class="n">maxp</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="n">info2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_MULT_TT</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="n">info2</span> <span class="o">|=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ttport</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span>

		<span class="cm">/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets c-mask } */</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:		<span class="cm">/* no TT involved */</span>
		<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>	<span class="cm">/* EPS &quot;high&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_RL_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="mi">64</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* usb2 fixed maxpacket */</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">;</span>	<span class="cm">/* toggle from qtd */</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_MULT_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_BULK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_RL_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="mi">512</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* usb2 fixed maxpacket */</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_MULT_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* PIPE_INTERRUPT */</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="n">hb_mult</span><span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;bogus dev %p speed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>
<span class="nl">done:</span>
		<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */</span>

	<span class="cm">/* init as live, toggle clear, advance to dummy */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">info1</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">info2</span><span class="p">);</span>
	<span class="n">usb_settoggle</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span> <span class="o">!</span><span class="n">is_input</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">qh_refresh</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Move qh (and its qtds) onto async queue; maybe enable queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qh_link_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="n">dma</span> <span class="o">=</span> <span class="n">QH_NEXT</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* (re)start the async schedule? */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="n">timer_action_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_ASYNC_OFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span>	<span class="n">cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">CMD_ASE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* in case a clear of CMD_ASE didn&#39;t take yet */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
					<span class="n">STS_ASS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
			<span class="n">cmd</span> <span class="o">|=</span> <span class="n">CMD_ASE</span> <span class="o">|</span> <span class="n">CMD_RUN</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
			<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>
			<span class="cm">/* posted write need not be known to HC yet ... */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* clear halt and/or toggle; and maybe recover from silicon quirk */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">)</span>
		<span class="n">qh_refresh</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* splice right after start */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">head</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_LINKED</span><span class="p">;</span>
	<span class="cm">/* qtd completions reported later by interrupt */</span>
<span class="p">}</span>

<span class="cp">#define	QH_ADDR_MASK	cpu_to_le32(0x7f)</span>

<span class="cm">/*</span>
<span class="cm"> * For control/bulk/interrupt, return QH with these TDs appended.</span>
<span class="cm"> * Allocates and initializes the QH if necessary.</span>
<span class="cm"> * Returns null if it can&#39;t allocate a QH it needs to.</span>
<span class="cm"> * If the QH has TDs (urbs) already, that&#39;s great.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="nf">qh_append_tds</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qtd_list</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">epnum</span><span class="p">,</span> <span class="kt">void</span>	<span class="o">**</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t sleep here, we have oxu-&gt;lock... */</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_make</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">qh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">qtd_list</span><span class="p">)))</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qtd_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span>
					<span class="n">qtd_list</span><span class="p">);</span>

		<span class="cm">/* control qh may need patching ... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">epnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* usb_reset_device() briefly reverts to address 0 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipedevice</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QH_ADDR_MASK</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* just one way to queue requests: swap with the dummy qtd.</span>
<span class="cm">		 * only hc or qh_refresh() ever modify the overlay.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">qtd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">dummy</span><span class="p">;</span>
			<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
			<span class="n">__le32</span> <span class="n">token</span><span class="p">;</span>

			<span class="cm">/* to avoid racing the HC, use the dummy td instead of</span>
<span class="cm">			 * the first td of our list (becomes new dummy).  both</span>
<span class="cm">			 * tds stay deactivated until we&#39;re done, when the</span>
<span class="cm">			 * HC is allowed to fetch the old dummy (4.10.2).</span>
<span class="cm">			 */</span>
			<span class="n">token</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">HALT_BIT</span><span class="p">;</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">;</span>

			<span class="n">dma</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">;</span>
			<span class="o">*</span><span class="n">dummy</span> <span class="o">=</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
			<span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>

			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">list_splice</span><span class="p">(</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

			<span class="n">ehci_qtd_init</span><span class="p">(</span><span class="n">qtd</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>

			<span class="cm">/* hc must see the new dummy at list end */</span>
			<span class="n">dma</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">;</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>

			<span class="cm">/* let the hc process these next qtds */</span>
			<span class="n">dummy</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x80</span><span class="p">));</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">dummy</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>

			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">qh_get</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">submit_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span>	<span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">epnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qtd_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
	<span class="n">epnum</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>

<span class="cp">#ifdef OXU_URB_TRACE</span>
	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;%s %s urb %p ep%d%s len %d, qtd %p [qh %p]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
		<span class="n">epnum</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="p">(</span><span class="n">epnum</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
		<span class="n">qtd</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_append_tds</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Control/bulk operations through TTs don&#39;t need scheduling,</span>
<span class="cm">	 * the HC and TT handle it when the TT has a buffer ready.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">))</span>
		<span class="n">qh_link_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh_get</span><span class="p">(</span><span class="n">qh</span><span class="p">));</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">qtd_list_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The async qh for the qtds being reclaimed are now unlinked from the HC */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_unlink_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">timer_action_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_IAA_WATCHDOG</span><span class="p">);</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>			<span class="cm">/* refcount from reclaim */</span>

	<span class="cm">/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">qh_completions</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">qh_link_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>		<span class="cm">/* refcount from async list */</span>

		<span class="cm">/* it&#39;s not free to turn the async schedule on/off; leave it</span>
<span class="cm">		 * active but idle for a while once it empties.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">timer_action</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_ASYNC_OFF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">start_unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* makes sure the async qh will become idle */</span>
<span class="cm">/* caller must own oxu-&gt;lock */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_unlink_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">||</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_LINKED</span>
				<span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_UNLINK_WAIT</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* stop async schedule right now? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t get here without STS_ASS set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">HC_STATE_HALT</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ... and CMD_IAAD clear */</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CMD_ASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="cm">/* handshake later, if we need to */</span>
			<span class="n">timer_action_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_ASYNC_OFF</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_UNLINK</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="n">qh</span> <span class="o">=</span> <span class="n">qh_get</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">!=</span> <span class="n">qh</span><span class="p">)</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>

	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh_next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">HC_STATE_HALT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* if (unlikely(qh-&gt;reclaim != 0))</span>
<span class="cm">		 *	this will recurse, probably not much</span>
<span class="cm">		 */</span>
		<span class="n">end_unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">CMD_IAAD</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">timer_action</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_IAA_WATCHDOG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ehci_timer_action</span> <span class="n">action</span> <span class="o">=</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!++</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">))</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">timer_action_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">);</span>
<span class="nl">rescan:</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">qh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/* clean any finished work for this qh */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">stamp</span> <span class="o">!=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>

				<span class="cm">/* unlinks could happen here; completion</span>
<span class="cm">				 * reporting drops the lock.  rescan using</span>
<span class="cm">				 * the latest schedule, but don&#39;t rescan</span>
<span class="cm">				 * qhs we already finished (no looping).</span>
<span class="cm">				 */</span>
				<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_get</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">stamp</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">;</span>
				<span class="n">temp</span> <span class="o">=</span> <span class="n">qh_completions</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
				<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* unlink idle entries, reducing HC PCI usage as well</span>
<span class="cm">			 * as HCD schedule-scanning costs.  delay for any qh</span>
<span class="cm">			 * we just scanned, there&#39;s a not-unusual case that it</span>
<span class="cm">			 * doesn&#39;t stay idle for long.</span>
<span class="cm">			 * (plus, avoids some kind of re-activation race.)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">stamp</span> <span class="o">==</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">)</span>
					<span class="n">action</span> <span class="o">=</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span>
					    <span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_LINKED</span><span class="p">)</span>
					<span class="n">start_unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">qh</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">)</span>
		<span class="n">timer_action</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * periodic_next_shadow - return &quot;next&quot; pointer on shadow list</span>
<span class="cm"> * @periodic: host pointer to qh/itd/sitd</span>
<span class="cm"> * @tag: hardware tag for type of this record</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">union</span> <span class="n">ehci_shadow</span> <span class="o">*</span><span class="nf">periodic_next_shadow</span><span class="p">(</span><span class="k">union</span> <span class="n">ehci_shadow</span> <span class="o">*</span><span class="n">periodic</span><span class="p">,</span>
						<span class="n">__le32</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">periodic</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* caller must hold oxu-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">periodic_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span> <span class="o">*</span><span class="n">prev_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span> <span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev_p</span><span class="p">;</span>

	<span class="cm">/* find predecessor of &quot;ptr&quot;; hw and shadow lists are in sync */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="n">here</span><span class="p">.</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev_p</span> <span class="o">=</span> <span class="n">periodic_next_shadow</span><span class="p">(</span><span class="n">prev_p</span><span class="p">,</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="o">*</span><span class="n">hw_p</span><span class="p">));</span>
		<span class="n">hw_p</span> <span class="o">=</span> <span class="n">here</span><span class="p">.</span><span class="n">hw_next</span><span class="p">;</span>
		<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev_p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* an interrupt entry (at list end) could have been shared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* update shadow and hardware lists ... the old &quot;next&quot; pointers</span>
<span class="cm">	 * from ptr may still be in use, the caller updates them.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">prev_p</span> <span class="o">=</span> <span class="o">*</span><span class="n">periodic_next_shadow</span><span class="p">(</span><span class="o">&amp;</span><span class="n">here</span><span class="p">,</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="o">*</span><span class="n">hw_p</span><span class="p">));</span>
	<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">*</span><span class="n">here</span><span class="p">.</span><span class="n">hw_next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* how many of the uframe&#39;s 125 usecs are allocated? */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">periodic_usecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">uframe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">usecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="o">*</span><span class="n">hw_p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
		<span class="nl">default:</span>
			<span class="cm">/* is it in the S-mask? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">uframe</span><span class="p">))</span>
				<span class="n">usecs</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">;</span>
			<span class="cm">/* ... or C-mask? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">uframe</span><span class="p">)))</span>
				<span class="n">usecs</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">;</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usecs</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="n">oxu_err</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;uframe %d sched overrun: %d usecs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">frame</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">uframe</span><span class="p">,</span> <span class="n">usecs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">usecs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enable_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* did clearing PSE did take effect yet?</span>
<span class="cm">	 * takes effect only at frame boundaries...</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">STS_PSS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>
		<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">|</span> <span class="n">CMD_PSE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="cm">/* posted write ... PSS happens later */</span>
	<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>

	<span class="cm">/* make sure ehci_work scans these */</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_index</span><span class="p">)</span>
		<span class="o">%</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">disable_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* did setting PSE not take effect yet?</span>
<span class="cm">	 * takes effect only at frame boundaries...</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">STS_PSS</span><span class="p">,</span> <span class="n">STS_PSS</span><span class="p">,</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>
		<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CMD_PSE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="cm">/* posted write ... */</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* periodic schedule slots have iso tds (normal or split) first, then a</span>
<span class="cm"> * sparse tree for active interrupt transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * this just links in a qh; caller guarantees uframe masks are set right.</span>
<span class="cm"> * no FSTN support (yet; oxu 0.96+)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qh_link_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">period</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;link qh%d-%04x/%p start %d [%d/%d us]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">period</span><span class="p">,</span> <span class="n">le32_to_cpup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">QH_CMASK</span> <span class="o">|</span> <span class="n">QH_SMASK</span><span class="p">),</span>
		<span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">);</span>

	<span class="cm">/* high bandwidth, or otherwise every microframe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">__le32</span>			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">__le32</span>			<span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* skip the iso nodes at list head */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="o">*</span><span class="n">hw_p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Q_TYPE_QH</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">periodic_next_shadow</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* sorting each branch by period (slow--&gt;fast)</span>
<span class="cm">		 * enables sharing interior tree nodes</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="n">qh</span> <span class="o">!=</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* link in this qh, unless some earlier pass did that */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span> <span class="o">!=</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span> <span class="o">=</span> <span class="n">here</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">;</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">QH_NEXT</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_LINKED</span><span class="p">;</span>
	<span class="n">qh_get</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* update per-qh bandwidth for usbfs */</span>
	<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span> <span class="o">+=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">)</span> <span class="o">/</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* maybe enable periodic schedule processing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_sched</span><span class="o">++</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">enable_periodic</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qh_unlink_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">period</span><span class="p">;</span>

	<span class="cm">/* FIXME:</span>
<span class="cm">	 *   IF this isn&#39;t high speed</span>
<span class="cm">	 *   and this qh is active in the current uframe</span>
<span class="cm">	 *   (and overlay token SplitXstate is false?)</span>
<span class="cm">	 * THEN</span>
<span class="cm">	 *   qh-&gt;hw_info1 |= cpu_to_le32(1 &lt;&lt; 7 &quot;ignore&quot;);</span>
<span class="cm">	 */</span>

	<span class="cm">/* high bandwidth, or otherwise part of every microframe */</span>
	<span class="n">period</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span>
		<span class="n">periodic_unlink</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* update per-qh bandwidth for usbfs */</span>
	<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span> <span class="o">-=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">)</span> <span class="o">/</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;unlink qh%d-%04x/%p start %d [%d/%d us]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span>
		<span class="n">le32_to_cpup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">QH_CMASK</span> <span class="o">|</span> <span class="n">QH_SMASK</span><span class="p">),</span>
		<span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">);</span>

	<span class="cm">/* qh-&gt;qh_next still &quot;live&quot; to HC */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_UNLINK</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* maybe turn off periodic schedule */</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_sched</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_sched</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">disable_periodic</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intr_deschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">wait</span><span class="p">;</span>

	<span class="n">qh_unlink_periodic</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* simple/paranoid:  always delay, expecting the HC needs to read</span>
<span class="cm">	 * qh-&gt;hw_next or finish a writeback after SPLIT/CSPLIT ... and</span>
<span class="cm">	 * expect khubd to clean up after any CSPLITs we won&#39;t issue.</span>
<span class="cm">	 * active high speed queues may need bigger delays...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QH_CMASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wait</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wait</span> <span class="o">=</span> <span class="mi">55</span><span class="p">;</span>	<span class="cm">/* worst case: 3 * 1024 */</span>

	<span class="n">udelay</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">uframe</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">period</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">usecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">claimed</span><span class="p">;</span>

	<span class="cm">/* complete split running into next frame?</span>
<span class="cm">	 * given FSTN support, we could sometimes check...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 80% periodic == 100 usec/uframe available</span>
<span class="cm">	 * convert &quot;usecs we need&quot; to &quot;max already claimed&quot;</span>
<span class="cm">	 */</span>
	<span class="n">usecs</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">usecs</span><span class="p">;</span>

	<span class="cm">/* we &quot;know&quot; 2 and 4 uframe intervals were rejected; so</span>
<span class="cm">	 * for period 0, check _every_ microframe in the schedule.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uframe</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">uframe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">claimed</span> <span class="o">=</span> <span class="n">periodic_usecs</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">claimed</span> <span class="o">&gt;</span> <span class="n">usecs</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">);</span>

	<span class="cm">/* just check the specified uframe, at that period */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">claimed</span> <span class="o">=</span> <span class="n">periodic_usecs</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">claimed</span> <span class="o">&gt;</span> <span class="n">usecs</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">frame</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_intr_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span>	<span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">uframe</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">c_maskp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">&amp;&amp;</span> <span class="n">uframe</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>		<span class="cm">/* FSTN territory? */</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_period</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">c_maskp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* &quot;first fit&quot; scheduling policy used the first time through,</span>
<span class="cm"> * or when the previous schedule slot can&#39;t be re-used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qh_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">uframe</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">c_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">frame</span><span class="p">;</span>		<span class="cm">/* 0..(qh-&gt;period - 1), or NO_FRAME */</span>

	<span class="n">qh_refresh</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* reuse the previous schedule slots, if we can */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span> <span class="o">&lt;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uframe</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">le32_to_cpup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">QH_SMASK</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">check_intr_schedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">--</span><span class="n">uframe</span><span class="p">,</span>
				<span class="n">qh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c_mask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* else scan the schedule to find a group of slots such that all</span>
<span class="cm">	 * uframes have enough periodic bandwidth available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &quot;normal&quot; case, uframing flexible except with splits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uframe</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">uframe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="n">check_intr_schedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span>
							<span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">c_mask</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">frame</span><span class="o">--</span><span class="p">);</span>

		<span class="cm">/* qh-&gt;period == 0 means every uframe */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">check_intr_schedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c_mask</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>

		<span class="cm">/* reset S-frame and (maybe) C-frame masks */</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">QH_CMASK</span> <span class="o">|</span> <span class="n">QH_SMASK</span><span class="p">));</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">|=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span>
			<span class="o">?</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">uframe</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QH_SMASK</span><span class="p">);</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">|=</span> <span class="n">c_mask</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;reused qh %p schedule</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* stuff into the periodic schedule */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">qh_link_periodic</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intr_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">epnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">empty</span><span class="p">;</span>

	<span class="cm">/* get endpoint and transfer/schedule data */</span>
	<span class="n">epnum</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get qh and force any scheduling errors */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_append_tds</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">qh_schedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* then queue the urb&#39;s tds to the qh */</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_append_tds</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* ... update usbfs periodic stats */</span>
	<span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_int_reqs</span><span class="o">++</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">qtd_list_free</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">itd_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;iso support is missing!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sitd_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;split iso support is missing!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">now_uframe</span><span class="p">,</span> <span class="n">mod</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">modified</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When running, scan from last scan point up to &quot;now&quot;</span>
<span class="cm">	 * else clean up by scanning everything that&#39;s left.</span>
<span class="cm">	 * Touches as few pages as possible:  cache-friendly.</span>
<span class="cm">	 */</span>
	<span class="n">now_uframe</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_uframe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_index</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="n">now_uframe</span> <span class="o">+</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">clock</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">q_p</span><span class="p">;</span>
		<span class="n">__le32</span>			<span class="n">type</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">;</span>
		<span class="kt">unsigned</span>		<span class="n">uframes</span><span class="p">;</span>

		<span class="cm">/* don&#39;t scan past the live uframe */</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">now_uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frame</span> <span class="o">==</span> <span class="p">(</span><span class="n">clock</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">))</span>
			<span class="n">uframes</span> <span class="o">=</span> <span class="n">now_uframe</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* safe to scan the whole frame at once */</span>
			<span class="n">now_uframe</span> <span class="o">|=</span> <span class="mh">0x07</span><span class="p">;</span>
			<span class="n">uframes</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">restart:</span>
		<span class="cm">/* scan each element in frame&#39;s queue for completions */</span>
		<span class="n">q_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
		<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
		<span class="n">q</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">q_p</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="o">*</span><span class="n">hw_p</span><span class="p">);</span>
		<span class="n">modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">ehci_shadow</span> <span class="n">temp</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">live</span><span class="p">;</span>

			<span class="n">live</span> <span class="o">=</span> <span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
				<span class="cm">/* handle any completions */</span>
				<span class="n">temp</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh_get</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
				<span class="n">modified</span> <span class="o">=</span> <span class="n">qh_completions</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)))</span>
					<span class="n">intr_deschedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
				<span class="n">qh_put</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;corrupt type %d frame %d shadow %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">type</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
				<span class="n">q</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* assume completion callbacks modify the queue */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">modified</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Stop when we catch up to the HC */</span>

		<span class="cm">/* FIXME:  this assumes we won&#39;t get lapped when</span>
<span class="cm">		 * latencies climb; that should be rare, but...</span>
<span class="cm">		 * detect it, and just go all the way around.</span>
<span class="cm">		 * FLR might help detect this case, so long as latencies</span>
<span class="cm">		 * don&#39;t exceed periodic_size msec (default 1.024 sec).</span>
<span class="cm">		 */</span>

		<span class="cm">/* FIXME: likewise assumes HC doesn&#39;t halt mid-scan */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">now_uframe</span> <span class="o">==</span> <span class="n">clock</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span>	<span class="n">now</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">now_uframe</span><span class="p">;</span>
			<span class="n">now</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_index</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">now_uframe</span> <span class="o">==</span> <span class="n">now</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* rescan the rest of this frame, then ... */</span>
			<span class="n">clock</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">now_uframe</span><span class="o">++</span><span class="p">;</span>
			<span class="n">now_uframe</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* On some systems, leaving remote wakeup enabled prevents system shutdown.</span>
<span class="cm"> * The firmware seems to think that powering off is a wakeup event!</span>
<span class="cm"> * This routine turns off remote wakeup and everything else, on all ports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_turn_off_all_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">port</span><span class="o">--</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_port_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCS_PPC</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;...power%s ports...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">is_on</span> <span class="o">?</span> <span class="s">&quot;up&quot;</span> <span class="o">:</span> <span class="s">&quot;down&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span> <span class="n">port</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">oxu_hub_control</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">),</span>
				<span class="n">is_on</span> <span class="o">?</span> <span class="n">SetPortFeature</span> <span class="o">:</span> <span class="n">ClearPortFeature</span><span class="p">,</span>
				<span class="n">USB_PORT_FEAT_POWER</span><span class="p">,</span>
				<span class="n">port</span><span class="o">--</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called from some interrupts, timers, and so on.</span>
<span class="cm"> * It calls driver completion functions, after dropping oxu-&gt;lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer_action_done</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim_ready</span><span class="p">)</span>
		<span class="n">end_unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="cm">/* another CPU may drop oxu-&gt;lock during a schedule scan while</span>
<span class="cm">	 * it reports urb completions.  this flag guards against bogus</span>
<span class="cm">	 * attempts at re-entrant schedule scanning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">scanning</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">scanning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scan_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">scan_periodic</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">scanning</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the IO watchdog guards against hardware or driver bugs that</span>
<span class="cm">	 * misplace IRQs, and should let us run completely without IRQs.</span>
<span class="cm">	 * such lossage has been observed on both VT6202 and VT8235.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
			 <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_sched</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">timer_action</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if we need to use IAA and it&#39;s busy, defer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_LINKED</span>
			<span class="o">&amp;&amp;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span>
			<span class="o">&amp;&amp;</span> <span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">last</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">last</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
				<span class="n">last</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
				<span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_UNLINK_WAIT</span><span class="p">;</span>
		<span class="n">last</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>

	<span class="cm">/* bypass IAA if the hc can&#39;t care */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span>
		<span class="n">end_unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="cm">/* something else might have unlinked the qh by now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_LINKED</span><span class="p">)</span>
		<span class="n">start_unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * USB host controller methods</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">oxu210_hcd_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">pcd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bh</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* e.g. cardbus physical eject */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;device removed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dead</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Shared IRQ? */</span>
	<span class="n">status</span> <span class="o">&amp;=</span> <span class="n">INTR_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">HC_STATE_HALT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear (just) interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>	<span class="cm">/* unblock posted write */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef OXU_VERBOSE_DEBUG</span>
	<span class="cm">/* unrequested/ignored: Frame List Rollover */</span>
	<span class="n">dbg_status</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;irq&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* INT, ERR, and IAA interrupt rates can be throttled */</span>

	<span class="cm">/* normal [4.15.1.2] or error [4.15.1.1] completion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STS_INT</span><span class="o">|</span><span class="n">STS_ERR</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* complete the unlinking of some qh [4.15.2.3] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_IAA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remote wakeup [4.3.1] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_PCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
		<span class="n">pcd_status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

		<span class="cm">/* resume root hub? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CMD_RUN</span><span class="p">))</span>
			<span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">pstatus</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pstatus</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pstatus</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span>
					<span class="o">||</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* start 20 msec resume signaling from this port,</span>
<span class="cm">			 * and make khubd collect PORT_STAT_C_SUSPEND to</span>
<span class="cm">			 * stop that signaling.</span>
<span class="cm">			 */</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;port %d remote wakeup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* PCI errors [4.15.2.4] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_FATAL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* bogus &quot;fatal&quot; IRQs appear on some chips... why?  */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">dbg_cmd</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;fatal&quot;</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">));</span>
		<span class="n">dbg_status</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;fatal&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_HALT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oxu_err</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;fatal error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">dead:</span>
			<span class="n">ehci_reset</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>
			<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
			<span class="cm">/* generic layer kills/unlinks all urbs, then</span>
<span class="cm">			 * uses oxu_stop to clean up the rest</span>
<span class="cm">			 */</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">ehci_work</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcd_status</span> <span class="o">&amp;</span> <span class="n">STS_PCD</span><span class="p">)</span>
		<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">oxu_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">oxu_readl</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">OXU_CHIPIRQSTATUS</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">enable</span> <span class="o">=</span> <span class="n">oxu_readl</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">OXU_CHIPIRQEN_SET</span><span class="p">);</span>

	<span class="cm">/* Disable all interrupt */</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">OXU_CHIPIRQEN_CLR</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">is_otg</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">OXU_USBOTGI</span><span class="p">))</span> <span class="o">||</span>
		<span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">is_otg</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">OXU_USBSPHI</span><span class="p">)))</span>
		<span class="n">oxu210_hcd_irq</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Enable all interrupt back */</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">OXU_CHIPIRQEN_SET</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span>	<span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* lost IAA irqs wedge things badly; seen with a vt8235 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STS_IAA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oxu_vdbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;lost IAA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">STS_IAA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* stop async processing after it&#39;s idled a bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TIMER_ASYNC_OFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">actions</span><span class="p">))</span>
		<span class="n">start_unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">);</span>

	<span class="cm">/* oxu could run by timer, without IRQs ... */</span>
	<span class="n">ehci_work</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* One-time init, only for memory state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_hcd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hcc_params</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">oxu_watchdog</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">oxu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * hw default: 1K periodic list heads, one per frame.</span>
<span class="cm">	 * periodic_size can shrink by USBCMD update if hcc_params allows.</span>
<span class="cm">	 */</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">=</span> <span class="n">DEFAULT_I_TDPS</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ehci_mem_init</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* controllers may cache some of the periodic schedule ... */</span>
	<span class="n">hcc_params</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_ISOC_CACHE</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span>		<span class="cm">/* full frame cache */</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">i_thresh</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span>					<span class="cm">/* N microframes cached */</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">i_thresh</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">HCC_ISOC_THRES</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">);</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * dedicate a qh for the async ring head, since we couldn&#39;t unlink</span>
<span class="cm">	 * a &#39;real&#39; qh without stopping the async schedule [4.8].  use it</span>
<span class="cm">	 * as the &#39;reclamation list head&#39; too.</span>
<span class="cm">	 * its dummy is used in hw_alt_next of many tds, to prevent the qh</span>
<span class="cm">	 * from automatically advancing to the next td after short reads.</span>
<span class="cm">	 */</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QH_NEXT</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QH_HEAD</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_STS_HALT</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw_qtd_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_LINKED</span><span class="p">;</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>

	<span class="cm">/* clear interrupt enables, set irq latency */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log2_irq_thresh</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">log2_irq_thresh</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">log2_irq_thresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">log2_irq_thresh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_CANPARK</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* HW default park == 3, on hardware that supports it (like</span>
<span class="cm">		 * NVidia and ALI silicon), maximizes throughput on the async</span>
<span class="cm">		 * schedule by avoiding QH fetches between transfers.</span>
<span class="cm">		 *</span>
<span class="cm">		 * With fast usb storage devices and NForce2, &quot;park&quot; seems to</span>
<span class="cm">		 * make problems:  throughput reduction (!), data errors...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">park</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">park</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">park</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">CMD_PARK</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">park</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;park %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">park</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_PGM_FRAMELISTLEN</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* periodic schedule size can be smaller than default */</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_FLS</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called during probe() after chip reset completes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">urb_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* FIMXE */</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">is_otg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">OXU_OTG_CAP_OFFSET</span><span class="p">;</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">OXU_OTG_CAP_OFFSET</span> <span class="o">+</span> \
			<span class="n">HC_LENGTH</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">));</span>

		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">OXU_SPH_MEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">OXU_SPH_CAP_OFFSET</span><span class="p">;</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">OXU_SPH_CAP_OFFSET</span> <span class="o">+</span> \
			<span class="n">HC_LENGTH</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">));</span>

		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">mem</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">OXU_OTG_MEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">sbrn</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">oxu_hcd_init</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">hcc_params</span><span class="p">;</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* EHCI spec section 4.1 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ehci_reset</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_mem_cleanup</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_list</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">async_next</span><span class="p">);</span>

	<span class="cm">/* hcc_params controls whether oxu-&gt;regs-&gt;segment must (!!!)</span>
<span class="cm">	 * be used; it constrains QH/ITD/SITD and QTD locations.</span>
<span class="cm">	 * pci_pool consistent memory always uses segment zero.</span>
<span class="cm">	 * streaming mappings for I/O buffers, like pci_map_single(),</span>
<span class="cm">	 * can return segments above 4GB, if the device allows.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  the dma mask is visible through dma_supported(), so</span>
<span class="cm">	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,</span>
<span class="cm">	 * Scsi_Host.highmem_io, and so forth.  It&#39;s readonly to all</span>
<span class="cm">	 * host side drivers though.</span>
<span class="cm">	 */</span>
	<span class="n">hcc_params</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_64BIT_ADDR</span><span class="p">(</span><span class="n">hcc_params</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">);</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_LRESET</span> <span class="o">|</span> <span class="n">CMD_IAAD</span> <span class="o">|</span> <span class="n">CMD_PSE</span> <span class="o">|</span>
				<span class="n">CMD_ASE</span> <span class="o">|</span> <span class="n">CMD_RESET</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">dbg_cmd</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;init&quot;</span><span class="p">,</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices</span>
<span class="cm">	 * are explicitly handed to companion controller(s), so no TT is</span>
<span class="cm">	 * involved with the root hub.  (Except where one is integrated,</span>
<span class="cm">	 * and there&#39;s no companion controller unless maybe for USB OTG.)</span>
<span class="cm">	 */</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">FLAG_CF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>	<span class="cm">/* unblock posted writes */</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">HC_VERSION</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">));</span>
	<span class="n">oxu_info</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;USB %x.%x started, quasi-EHCI %x.%02x, driver %s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">((</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">sbrn</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">sbrn</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">),</span>
		<span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">,</span>
		<span class="n">ignore_oc</span> <span class="o">?</span> <span class="s">&quot;, overcurrent ignored&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">INTR_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span> <span class="cm">/* Turn On Interrupts */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/* Turn off port power on all root hub ports. */</span>
	<span class="n">ehci_port_power</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* no more interrupts ... */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">ehci_quiesce</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="n">ehci_reset</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* let companion controllers work when we aren&#39;t */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>

	<span class="cm">/* root hub is shut down separately (first, when possible) */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">)</span>
		<span class="n">ehci_work</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ehci_mem_cleanup</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="n">dbg_status</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;oxu_stop completed&quot;</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Kick in for silicon on any bus (not just pci, etc).</span>
<span class="cm"> * This forcibly disables dma and IRQs, helping kexec and other cases</span>
<span class="cm"> * where the next system software may expect clean state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ehci_halt</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="n">ehci_turn_off_all_ports</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="cm">/* make BIOS/etc use companion controller during reboot */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>

	<span class="cm">/* unblock posted writes */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Non-error returns are a promise to giveback() the urb later</span>
<span class="cm"> * we drop ownership so next owner (or urb unlink) can get it</span>
<span class="cm"> *</span>
<span class="cm"> * urb + dev is in hcd.self.controller.urb_list</span>
<span class="cm"> * we&#39;re queueing TDs onto software and hardware lists</span>
<span class="cm"> *</span>
<span class="cm"> * hcd-specific init for hcpriv hasn&#39;t been done yet</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  control, bulk, and interrupt share the same code to append TDs</span>
<span class="cm"> * to a (possibly active) QH, and the same QH scanning code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__oxu_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">qtd_list</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PIPE_CONTROL</span>:
	<span class="k">case</span> <span class="n">PIPE_BULK</span>:
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh_urb_transaction</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">submit_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PIPE_INTERRUPT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh_urb_transaction</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">intr_submit</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PIPE_ISOCHRONOUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">itd_submit</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">sitd_submit</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This function is responsible for breaking URBs with big data size</span>
<span class="cm"> * into smaller size and processing small urbs in sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_urb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">rem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">murb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If not bulk pipe just enqueue the URB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_pipebulk</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__oxu_urb_enqueue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="cm">/* Otherwise we should verify the USB transfer buffer size! */</span>
	<span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">/</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">%</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If URB is smaller than 4096 bytes just enqueue it! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__oxu_urb_enqueue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="cm">/* Ok, we have more job to do! :) */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get free micro URB poll till a free urb is received */</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">murb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">)</span> <span class="n">oxu_murb_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">murb</span><span class="p">)</span>
				<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">murb</span><span class="p">);</span>

		<span class="cm">/* Coping the urb */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">murb</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span><span class="p">));</span>

		<span class="n">murb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
		<span class="n">murb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">;</span>

		<span class="cm">/* Null pointer for the encodes that this is a micro urb */</span>
		<span class="n">murb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="p">((</span><span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="p">)</span> <span class="n">murb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">main</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="p">((</span><span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="p">)</span> <span class="n">murb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* This loop is to guarantee urb to be processed when there&#39;s</span>
<span class="cm">		 * not enough resources at a particular time by retrying.</span>
<span class="cm">		 */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span>  <span class="o">=</span> <span class="n">__oxu_urb_enqueue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">murb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Last urb requires special handling  */</span>

	<span class="cm">/* Get free micro URB poll till a free urb is received */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">murb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">)</span> <span class="n">oxu_murb_alloc</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">murb</span><span class="p">)</span>
			<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">murb</span><span class="p">);</span>

	<span class="cm">/* Coping the urb */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">murb</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span><span class="p">));</span>

	<span class="n">murb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">rem</span> <span class="o">:</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="n">murb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">transfer_buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">;</span>

	<span class="cm">/* Null pointer for the encodes that this is a micro urb */</span>
	<span class="n">murb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="p">((</span><span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="p">)</span> <span class="n">murb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">main</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">oxu_murb</span> <span class="o">*</span><span class="p">)</span> <span class="n">murb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__oxu_urb_enqueue</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">murb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove from hardware lists.</span>
<span class="cm"> * Completions normally happen asynchronously</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PIPE_CONTROL</span>:
	<span class="k">case</span> <span class="n">PIPE_BULK</span>:
	<span class="nl">default:</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PIPE_INTERRUPT</span>:
		<span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">QH_STATE_LINKED</span>:
			<span class="n">intr_deschedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="cm">/* FALL THROUGH */</span>
		<span class="k">case</span> <span class="n">QH_STATE_IDLE</span>:
			<span class="n">qh_completions</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;bogus qh %p state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* reschedule QH iff another request is queued */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">qh_schedule</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* shouldn&#39;t happen often, but ...</span>
<span class="cm">				 * FIXME kill those tds&#39; urbs</span>
<span class="cm">				 */</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
					<span class="s">&quot;can&#39;t reschedule qh %p, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span>
					<span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Bulk qh holds the data toggle */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_endpoint_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* ASSERT:  any requests/urbs are being unlinked */</span>
	<span class="cm">/* ASSERT:  nobody can be submitting urbs for this any more */</span>

<span class="nl">rescan:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* endpoints can be iso streams.  for now, we don&#39;t</span>
<span class="cm">	 * accelerate iso completions ... so spin a while.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu_vdbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;iso delay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">idle_timeout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">QH_STATE_LINKED</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">qh</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* periodic qh self-unlinks on empty */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nogood</span><span class="p">;</span>
		<span class="n">unlink_async</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
		<span class="cm">/* FALL THROUGH */</span>
	<span class="k">case</span> <span class="n">QH_STATE_UNLINK</span>:		<span class="cm">/* wait for hw to finish? */</span>
<span class="nl">idle_timeout:</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">QH_STATE_IDLE</span>:		<span class="cm">/* fully unlinked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* else FALL THROUGH */</span>
	<span class="nl">default:</span>
<span class="nl">nogood:</span>
		<span class="cm">/* caller was supposed to have unlinked any requests;</span>
<span class="cm">		 * that&#39;s not our job.  just leak this memory.</span>
<span class="cm">		 */</span>
		<span class="n">oxu_err</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;qh %p (#%02x) state %d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">qh</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">,</span>
			<span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;(has tds)&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_index</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Build &quot;status change&quot; packet (one or two bytes) from HC registers */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_hub_status_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ports</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* if !USB_SUSPEND, root hub timers won&#39;t get shut down ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* init status to no-changes */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ports</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ports</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">retval</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Some boards (mostly VIA?) report bogus overcurrent indications,</span>
<span class="cm">	 * causing massive log spam unless we completely ignore them.  It</span>
<span class="cm">	 * may be relevant that VIA VT8235 controllers, where PORT_POWER is</span>
<span class="cm">	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to</span>
<span class="cm">	 * PORT_POWER; that&#39;s surprising, but maybe within-spec.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ignore_oc</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">PORT_CSC</span> <span class="o">|</span> <span class="n">PORT_PEC</span> <span class="o">|</span> <span class="n">PORT_OCC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">PORT_CSC</span> <span class="o">|</span> <span class="n">PORT_PEC</span><span class="p">;</span>

	<span class="cm">/* no hub change reports (bit 0) for now (power, ...) */</span>

	<span class="cm">/* port N changes (bit N)? */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Return status information even for ports with OWNER set.</span>
<span class="cm">		 * Otherwise khubd wouldn&#39;t see the disconnect event when a</span>
<span class="cm">		 * high-speed device is switched over to the companion</span>
<span class="cm">		 * controller by the user.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">))</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">)</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">7</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">STS_PCD</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME autosuspend idle root hubs */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns the speed of a device attached to a port on the root hub. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">oxu_port_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">portsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">portsc</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ports</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">status_reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">wIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">selector</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.</span>
<span class="cm">	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.</span>
<span class="cm">	 * (track current state ourselves) ... blink for diagnostics,</span>
<span class="cm">	 * power, &quot;this is the one&quot;, etc.  EHCI spec supports this.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ClearHubFeature</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">C_HUB_LOCAL_POWER</span>:
		<span class="k">case</span> <span class="n">C_HUB_OVER_CURRENT</span>:
			<span class="cm">/* no hub-wide feature/status flags */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ClearPortFeature</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">status_reg</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Even if OWNER is set, so the port is owned by the</span>
<span class="cm">		 * companion controller, khubd needs to be able to clear</span>
<span class="cm">		 * the port-change status bits (especially</span>
<span class="cm">		 * USB_PORT_STAT_C_CONNECTION).</span>
<span class="cm">		 */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_ENABLE</span>:
			<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_PE</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_ENABLE</span>:
			<span class="n">writel</span><span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_RWC_BITS</span><span class="p">)</span> <span class="o">|</span> <span class="n">PORT_PEC</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="cm">/* resume signaling for 20 msec */</span>
				<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_WAKE_BITS</span><span class="p">);</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_RESUME</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
				<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span>
						<span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span>:
			<span class="cm">/* we auto-clear this feature */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">HCS_PPC</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_POWER</span><span class="p">),</span>
					  <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span>:
			<span class="n">writel</span><span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_RWC_BITS</span><span class="p">)</span> <span class="o">|</span> <span class="n">PORT_CSC</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span>:
			<span class="n">writel</span><span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_RWC_BITS</span><span class="p">)</span> <span class="o">|</span> <span class="n">PORT_OCC</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
			<span class="cm">/* GetPortStatus clears reset */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>	<span class="cm">/* unblock posted write */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
		<span class="n">ehci_hub_descriptor</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubStatus</span>:
		<span class="cm">/* no hub-wide feature/status flags */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetPortStatus</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">status_reg</span><span class="p">);</span>

		<span class="cm">/* wPortChange bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CSC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PEC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OCC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ignore_oc</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_OVERCURRENT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="cm">/* whoever resumes must GetPortStatus to complete it!! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Remote Wakeup received? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">])</span> <span class="p">{</span>
				<span class="cm">/* resume signaling for 20 msec */</span>
				<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span>
						<span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
				<span class="cm">/* check the port again */</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu_to_hcd</span><span class="p">(</span><span class="n">oxu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rh_timer</span><span class="p">,</span>
						<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="cm">/* resume completed? */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_SUSPEND</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="cm">/* stop resume signaling */</span>
				<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">status_reg</span><span class="p">);</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_RESUME</span><span class="p">),</span>
					<span class="n">status_reg</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">,</span>
					   <span class="n">PORT_RESUME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span> <span class="cm">/* 2msec */</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">oxu_err</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span>
						<span class="s">&quot;port %d resume error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_SUSPEND</span><span class="o">|</span><span class="n">PORT_RESUME</span><span class="o">|</span><span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* whoever resets must GetPortStatus to complete it!! */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* force reset to complete */</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_RESET</span><span class="p">),</span>
					<span class="n">status_reg</span><span class="p">);</span>
			<span class="cm">/* REVISIT:  some hardware needs 550+ usec to clear</span>
<span class="cm">			 * this bit; seems too long to spin routinely...</span>
<span class="cm">			 */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">handshake</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">,</span>
					<span class="n">PORT_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">750</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">oxu_err</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;port %d reset error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* see what we found out */</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">check_reset_complete</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">,</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">status_reg</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* transfer dedicated ports to the companion hc */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">test_bit</span><span class="p">(</span><span class="n">wIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">companion_ports</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_RWC_BITS</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_OWNER</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;port %d --&gt; companion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">status_reg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Even if OWNER is set, there&#39;s no harm letting khubd</span>
<span class="cm">		 * see the wPortStatus values (they should all be 0 except</span>
<span class="cm">		 * for PORT_POWER anyway).</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">;</span>
			<span class="cm">/* status may be from integrated TT */</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">oxu_port_speed</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PORT_SUSPEND</span><span class="o">|</span><span class="n">PORT_RESUME</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_SUSPEND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_OVERCURRENT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_RESET</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_POWER</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_POWER</span><span class="p">;</span>

<span class="cp">#ifndef	OXU_VERBOSE_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">)</span>	<span class="cm">/* only if wPortChange is interesting */</span>
<span class="cp">#endif</span>
		<span class="n">dbg_port</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;GetStatus&quot;</span><span class="p">,</span> <span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">put_unaligned</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SetHubFeature</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">C_HUB_LOCAL_POWER</span>:
		<span class="k">case</span> <span class="n">C_HUB_OVER_CURRENT</span>:
			<span class="cm">/* no hub-wide feature/status flags */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SetPortFeature</span>:
		<span class="n">selector</span> <span class="o">=</span> <span class="n">wIndex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">wIndex</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_RWC_BITS</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
					<span class="o">||</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
				<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_WAKE_BITS</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_SUSPEND</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">HCS_PPC</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">))</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_POWER</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_RESET</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESUME</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="cm">/* line status bits may report this as low speed,</span>
<span class="cm">			 * which can be fine if this root hub has a</span>
<span class="cm">			 * transaction translator built in.</span>
<span class="cm">			 */</span>
			<span class="n">oxu_vdbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;port %d reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_RESET</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_PE</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * caller must wait, then call GetPortStatus</span>
<span class="cm">			 * usb 2.0 spec says 50 ms resets on root</span>
<span class="cm">			 */</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span>
					<span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* For downstream facing ports (these):  one hub port is put</span>
<span class="cm">		 * into test mode according to USB2 11.24.2.13, then the hub</span>
<span class="cm">		 * must be reset (which for root hub now means rmmod+modprobe,</span>
<span class="cm">		 * or else system reboot).  See EHCI 2.3.9 and 4.14 for info</span>
<span class="cm">		 * about the EHCI-specific stuff.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_TEST</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selector</span> <span class="o">||</span> <span class="n">selector</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">ehci_quiesce</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
			<span class="n">ehci_halt</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">selector</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>	<span class="cm">/* unblock posted writes */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
<span class="nl">error:</span>
		<span class="cm">/* &quot;stall&quot; on error */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;suspend root hub</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_statechange</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* stop schedules, clean any completed work */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HC_IS_RUNNING</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_quiesce</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_QUIESCING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reclaim_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ehci_work</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>

	<span class="cm">/* Unlike other USB host controller types, EHCI doesn&#39;t have</span>
<span class="cm">	 * any notion of &quot;global&quot; or bus-wide suspend.  The driver has</span>
<span class="cm">	 * to manually suspend all the active unsuspended ports, and</span>
<span class="cm">	 * then manually resume them in the bus_resume() routine.</span>
<span class="cm">	 */</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">bus_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">port</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="n">u32</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_RWC_BITS</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span><span class="p">;</span>

		<span class="cm">/* keep track of which ports we suspend */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">t1</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">t1</span> <span class="o">&amp;</span> <span class="n">PORT_OWNER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">t1</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">t2</span> <span class="o">|=</span> <span class="n">PORT_SUSPEND</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">bus_suspended</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* enable remote wakeup on all ports */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">t2</span> <span class="o">|=</span> <span class="n">PORT_WKOC_E</span><span class="o">|</span><span class="n">PORT_WKDISC_E</span><span class="o">|</span><span class="n">PORT_WKCONN_E</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">t2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_WKOC_E</span><span class="o">|</span><span class="n">PORT_WKDISC_E</span><span class="o">|</span><span class="n">PORT_WKCONN_E</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">!=</span> <span class="n">t2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oxu_vdbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;port %d, %08x -&gt; %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* turn off now-idle HC */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>
	<span class="n">ehci_halt</span><span class="p">(</span><span class="n">oxu</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">;</span>

	<span class="cm">/* allow remote wakeup */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">INTR_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">STS_PCD</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller has locked the root hub, and should reset/reinit on error */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_statechange</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Ideally and we&#39;ve got a real resume here, and no port&#39;s power</span>
<span class="cm">	 * was lost.  (For PCI, that means Vaux was maintained.)  But we</span>
<span class="cm">	 * could instead be restoring a swsusp snapshot -- so that BIOS was</span>
<span class="cm">	 * the last user of the controller, not reset/pm hardware keeping</span>
<span class="cm">	 * state we gave to it.</span>
<span class="cm">	 */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>
	<span class="n">oxu_dbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;resume root hub%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; after power loss&quot;</span><span class="p">);</span>

	<span class="cm">/* at least some APM implementations will try to deliver</span>
<span class="cm">	 * IRQs right away, so delay them until we&#39;re ready.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>

	<span class="cm">/* re-init operational registers */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_list</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">async_next</span><span class="p">);</span>

	<span class="cm">/* restore CMD_RUN, framelist size, and irq threshold */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/* Some controller/firmware combinations need a delay during which</span>
<span class="cm">	 * they set up the port statuses.  See Bugzilla #8190. */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* manually resume the ports we suspended during bus_suspend() */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span>
			<span class="o">|</span> <span class="n">PORT_WKOC_E</span> <span class="o">|</span> <span class="n">PORT_WKDISC_E</span> <span class="o">|</span> <span class="n">PORT_WKCONN_E</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">bus_suspended</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_RESUME</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">HCS_N_PORTS</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">bus_suspended</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_RESUME</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">oxu_vdbg</span><span class="p">(</span><span class="n">oxu</span><span class="p">,</span> <span class="s">&quot;resumed port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="cm">/* maybe re-activate the schedule(s) */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">CMD_ASE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">periodic_sched</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">CMD_PSE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">|=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_RUNNING</span><span class="p">;</span>

	<span class="cm">/* Now we can safely re-enable irqs */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">INTR_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="n">oxu_hc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span> <span class="o">=</span>		<span class="s">&quot;oxu210hp_hcd&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">product_desc</span> <span class="o">=</span>		<span class="s">&quot;oxu210hp HCD&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hcd_priv_size</span> <span class="o">=</span>	<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_hcd</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generic hardware linkage</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">irq</span> <span class="o">=</span>			<span class="n">oxu_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>		<span class="n">HCD_MEMORY</span> <span class="o">|</span> <span class="n">HCD_USB2</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Basic lifecycle operations</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">reset</span> <span class="o">=</span>		<span class="n">oxu_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span>		<span class="n">oxu_run</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span>			<span class="n">oxu_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>		<span class="n">oxu_shutdown</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Managing i/o requests and associated device resources</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">urb_enqueue</span> <span class="o">=</span>		<span class="n">oxu_urb_enqueue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">urb_dequeue</span> <span class="o">=</span>		<span class="n">oxu_urb_dequeue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint_disable</span> <span class="o">=</span>	<span class="n">oxu_endpoint_disable</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scheduling support</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">get_frame_number</span> <span class="o">=</span>	<span class="n">oxu_get_frame</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Root hub support</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">hub_status_data</span> <span class="o">=</span>	<span class="n">oxu_hub_status_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hub_control</span> <span class="o">=</span>		<span class="n">oxu_hub_control</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_suspend</span> <span class="o">=</span>		<span class="n">oxu_bus_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_resume</span> <span class="o">=</span>		<span class="n">oxu_bus_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Module stuff</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Initialize top level registers.</span>
<span class="cm">	 * First write ever</span>
<span class="cm">	 */</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_HOSTIFCONFIG</span><span class="p">,</span> <span class="mh">0x0000037D</span><span class="p">);</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_SOFTRESET</span><span class="p">,</span> <span class="n">OXU_SRESET</span><span class="p">);</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_HOSTIFCONFIG</span><span class="p">,</span> <span class="mh">0x0000037D</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">oxu_readl</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_PIOBURSTREADCTRL</span><span class="p">);</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_PIOBURSTREADCTRL</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">|</span> <span class="mh">0x0040</span><span class="p">);</span>

	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_ASO</span><span class="p">,</span> <span class="n">OXU_SPHPOEN</span> <span class="o">|</span> <span class="n">OXU_OVRCCURPUPDEN</span> <span class="o">|</span>
					<span class="n">OXU_COMPARATOR</span> <span class="o">|</span> <span class="n">OXU_ASO_OP</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">oxu_readl</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_CLKCTRL_SET</span><span class="p">);</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_CLKCTRL_SET</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">|</span> <span class="n">OXU_SYSCLKEN</span> <span class="o">|</span> <span class="n">OXU_USBOTGCLKEN</span><span class="p">);</span>

	<span class="cm">/* Clear all top interrupt enable */</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_CHIPIRQEN_CLR</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="cm">/* Clear all top interrupt status */</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_CHIPIRQSTATUS</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="cm">/* Enable all needed top interrupt except OTG SPH core */</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_CHIPIRQEN_SET</span><span class="p">,</span> <span class="n">OXU_USBSPHLPWUI</span> <span class="o">|</span> <span class="n">OXU_USBOTGLPWUI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_verify_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">bo</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;reserved&quot;</span><span class="p">,</span>
		<span class="s">&quot;128-pin LQFP&quot;</span><span class="p">,</span>
		<span class="s">&quot;84-pin TFBGA&quot;</span><span class="p">,</span>
		<span class="s">&quot;reserved&quot;</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="cm">/* Read controller signature register to find a match */</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">oxu_readl</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_DEVICEID</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device ID %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">OXU_REV_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">OXU_REV_2100</span> <span class="o">&lt;&lt;</span> <span class="n">OXU_REV_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;found device %x %s (%04x:%04x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">OXU_REV_SHIFT</span><span class="p">,</span>
		<span class="n">bo</span><span class="p">[(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">OXU_BO_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">OXU_BO_SHIFT</span><span class="p">],</span>
		<span class="p">(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">OXU_MAJ_REV_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">OXU_MAJ_REV_SHIFT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">OXU_MIN_REV_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">OXU_MIN_REV_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="n">oxu_hc_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">oxu_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memlen</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">otg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">oxu_hcd</span> <span class="o">*</span><span class="n">oxu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Set endian mode and host mode */</span>
	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">otg</span> <span class="o">?</span> <span class="n">OXU_OTG_CORE_OFFSET</span> <span class="o">:</span> <span class="n">OXU_SPH_CORE_OFFSET</span><span class="p">),</span>
				<span class="n">OXU_USBMODE</span><span class="p">,</span>
				<span class="n">OXU_CM_HOST_ONLY</span> <span class="o">|</span> <span class="n">OXU_ES_LITTLE</span> <span class="o">|</span> <span class="n">OXU_VBPS</span><span class="p">);</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">usb_create_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oxu_hc_driver</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				<span class="n">otg</span> <span class="o">?</span> <span class="s">&quot;oxu210hp_otg&quot;</span> <span class="o">:</span> <span class="s">&quot;oxu210hp_sph&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_start</span> <span class="o">=</span> <span class="n">memstart</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_len</span> <span class="o">=</span> <span class="n">memlen</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_HALT</span><span class="p">;</span>

	<span class="n">oxu</span> <span class="o">=</span> <span class="n">hcd_to_oxu</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">oxu</span><span class="o">-&gt;</span><span class="n">is_otg</span> <span class="o">=</span> <span class="n">otg</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hcd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memlen</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* First time configuration at start up */</span>
	<span class="n">oxu_configuration</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">oxu_verify_id</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no devices found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create the OTG controller */</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">oxu_create</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot create OTG controller!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_create_otg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hcd</span><span class="p">;</span>

	<span class="cm">/* Create the SPH host controller */</span>
	<span class="n">hcd</span> <span class="o">=</span> <span class="n">oxu_create</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot create SPH controller!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_create_sph</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hcd</span><span class="p">;</span>

	<span class="n">oxu_writel</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_CHIPIRQEN_SET</span><span class="p">,</span>
		<span class="n">oxu_readl</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">OXU_CHIPIRQEN_SET</span><span class="p">)</span> <span class="o">|</span> <span class="mi">3</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_create_sph:</span>
	<span class="n">usb_remove_hcd</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="nl">error_create_otg:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_drv_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">oxu_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the platform resources</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;no IRQ! Check %s setup!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IRQ resource %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no registers address! Check %s setup!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memstart</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">memlen</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MEM resource %lx-%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">,</span>
				<span class="n">oxu_hc_driver</span><span class="p">.</span><span class="n">description</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;memory area already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">irq_set_irq_type</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQF_TRIGGER_FALLING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error setting irq type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_set_irq_type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error mapping memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate a driver data struct to hold useful info for both</span>
<span class="cm">	 * SPH &amp; OTG devices</span>
<span class="cm">	 */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">oxu_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error allocating memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">oxu_init</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot init USB devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;devices enabled and running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_init:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">error_alloc:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>

<span class="nl">error_set_irq_type:</span>
<span class="nl">error_ioremap:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">);</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;init %s fail, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_remove_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oxu_drv_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oxu_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memstart</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rsrc_start</span><span class="p">,</span>
			<span class="n">memlen</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rsrc_len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">oxu_remove</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">oxu_remove</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hcd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">memstart</span><span class="p">,</span> <span class="n">memlen</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">oxu_drv_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">oxu_drv_remove</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* FIXME: TODO */</span>
<span class="c">static int oxu_drv_suspend(struct device *dev)</span>
<span class="c">{</span>
<span class="c">	struct platform_device *pdev = to_platform_device(dev);</span>
<span class="c">	struct usb_hcd *hcd = dev_get_drvdata(dev);</span>

<span class="c">	return 0;</span>
<span class="c">}</span>

<span class="c">static int oxu_drv_resume(struct device *dev)</span>
<span class="c">{</span>
<span class="c">	struct platform_device *pdev = to_platform_device(dev);</span>
<span class="c">	struct usb_hcd *hcd = dev_get_drvdata(dev);</span>

<span class="c">	return 0;</span>
<span class="c">}</span>
<span class="cp">#else</span>
<span class="cp">#define oxu_drv_suspend	NULL</span>
<span class="cp">#define oxu_drv_resume	NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">oxu_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">oxu_drv_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">oxu_drv_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">oxu_drv_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">oxu_drv_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">oxu_drv_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;oxu210hp-hcd&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">platform_bus_type</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">oxu_driver</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Oxford OXU210HP HCD driver - ver. &quot;</span> <span class="n">DRIVER_VERSION</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Rodolfo Giometti &lt;giometti@linux.it&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
