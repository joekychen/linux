<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › xhci-ext-caps.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xhci-ext-caps.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * xHCI host controller driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Sarah Sharp</span>
<span class="cm"> * Some code borrowed from the Linux EHCI driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>
<span class="cm">/* Up to 16 ms to halt an HC */</span>
<span class="cp">#define XHCI_MAX_HALT_USEC	(16*1000)</span>
<span class="cm">/* HC not running - set to 1 when run/stop bit is cleared. */</span>
<span class="cp">#define XHCI_STS_HALT		(1&lt;&lt;0)</span>

<span class="cm">/* HCCPARAMS offset from PCI base address */</span>
<span class="cp">#define XHCI_HCC_PARAMS_OFFSET	0x10</span>
<span class="cm">/* HCCPARAMS contains the first extended capability pointer */</span>
<span class="cp">#define XHCI_HCC_EXT_CAPS(p)	(((p)&gt;&gt;16)&amp;0xffff)</span>

<span class="cm">/* Command and Status registers offset from the Operational Registers address */</span>
<span class="cp">#define XHCI_CMD_OFFSET		0x00</span>
<span class="cp">#define XHCI_STS_OFFSET		0x04</span>

<span class="cp">#define XHCI_MAX_EXT_CAPS		50</span>

<span class="cm">/* Capability Register */</span>
<span class="cm">/* bits 7:0 - how long is the Capabilities register */</span>
<span class="cp">#define XHCI_HC_LENGTH(p)	(((p)&gt;&gt;00)&amp;0x00ff)</span>

<span class="cm">/* Extended capability register fields */</span>
<span class="cp">#define XHCI_EXT_CAPS_ID(p)	(((p)&gt;&gt;0)&amp;0xff)</span>
<span class="cp">#define XHCI_EXT_CAPS_NEXT(p)	(((p)&gt;&gt;8)&amp;0xff)</span>
<span class="cp">#define	XHCI_EXT_CAPS_VAL(p)	((p)&gt;&gt;16)</span>
<span class="cm">/* Extended capability IDs - ID 0 reserved */</span>
<span class="cp">#define XHCI_EXT_CAPS_LEGACY	1</span>
<span class="cp">#define XHCI_EXT_CAPS_PROTOCOL	2</span>
<span class="cp">#define XHCI_EXT_CAPS_PM	3</span>
<span class="cp">#define XHCI_EXT_CAPS_VIRT	4</span>
<span class="cp">#define XHCI_EXT_CAPS_ROUTE	5</span>
<span class="cm">/* IDs 6-9 reserved */</span>
<span class="cp">#define XHCI_EXT_CAPS_DEBUG	10</span>
<span class="cm">/* USB Legacy Support Capability - section 7.1.1 */</span>
<span class="cp">#define XHCI_HC_BIOS_OWNED	(1 &lt;&lt; 16)</span>
<span class="cp">#define XHCI_HC_OS_OWNED	(1 &lt;&lt; 24)</span>

<span class="cm">/* USB Legacy Support Capability - section 7.1.1 */</span>
<span class="cm">/* Add this offset, plus the value of xECP in HCCPARAMS to the base address */</span>
<span class="cp">#define XHCI_LEGACY_SUPPORT_OFFSET	(0x00)</span>

<span class="cm">/* USB Legacy Support Control and Status Register  - section 7.1.2 */</span>
<span class="cm">/* Add this offset, plus the value of xECP in HCCPARAMS to the base address */</span>
<span class="cp">#define XHCI_LEGACY_CONTROL_OFFSET	(0x04)</span>
<span class="cm">/* bits 1:3, 5:12, and 17:19 need to be preserved; bits 21:28 should be zero */</span>
<span class="cp">#define	XHCI_LEGACY_DISABLE_SMI		((0x7 &lt;&lt; 1) + (0xff &lt;&lt; 5) + (0x7 &lt;&lt; 17))</span>
<span class="cp">#define XHCI_LEGACY_SMI_EVENTS		(0x7 &lt;&lt; 29)</span>

<span class="cm">/* USB 2.0 xHCI 0.96 L1C capability - section 7.2.2.1.3.2 */</span>
<span class="cp">#define XHCI_L1C               (1 &lt;&lt; 16)</span>

<span class="cm">/* USB 2.0 xHCI 1.0 hardware LMP capability - section 7.2.2.1.3.2 */</span>
<span class="cp">#define XHCI_HLC               (1 &lt;&lt; 19)</span>

<span class="cm">/* command register values to disable interrupts and halt the HC */</span>
<span class="cm">/* start/stop HC execution - do not write unless HC is halted*/</span>
<span class="cp">#define XHCI_CMD_RUN		(1 &lt;&lt; 0)</span>
<span class="cm">/* Event Interrupt Enable - get irq when EINT bit is set in USBSTS register */</span>
<span class="cp">#define XHCI_CMD_EIE		(1 &lt;&lt; 2)</span>
<span class="cm">/* Host System Error Interrupt Enable - get irq when HSEIE bit set in USBSTS */</span>
<span class="cp">#define XHCI_CMD_HSEIE		(1 &lt;&lt; 3)</span>
<span class="cm">/* Enable Wrap Event - &#39;1&#39; means xHC generates an event when MFINDEX wraps. */</span>
<span class="cp">#define XHCI_CMD_EWE		(1 &lt;&lt; 10)</span>

<span class="cp">#define XHCI_IRQS		(XHCI_CMD_EIE | XHCI_CMD_HSEIE | XHCI_CMD_EWE)</span>

<span class="cm">/* true: Controller Not Ready to accept doorbell or op reg writes after reset */</span>
<span class="cp">#define XHCI_STS_CNR		(1 &lt;&lt; 11)</span>

<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * Return the next extended capability pointer register.</span>
<span class="cm"> *</span>
<span class="cm"> * @base	PCI register base address.</span>
<span class="cm"> *</span>
<span class="cm"> * @ext_offset	Offset of the 32-bit register that contains the extended</span>
<span class="cm"> * capabilites pointer.  If searching for the first extended capability, pass</span>
<span class="cm"> * in XHCI_HCC_PARAMS_OFFSET.  If searching for the next extended capability,</span>
<span class="cm"> * pass in the offset of the current extended capability register.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if there is no next extended capability register or returns the register offset</span>
<span class="cm"> * from the PCI registers base address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xhci_find_next_cap_offset</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ext_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">ext_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext_offset</span> <span class="o">==</span> <span class="n">XHCI_HCC_PARAMS_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Find the first extended capability */</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">XHCI_HCC_EXT_CAPS</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="n">ext_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Find the next extended capability */</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">XHCI_EXT_CAPS_NEXT</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Address calculation from offset of extended capabilities</span>
<span class="cm">	 * (or HCCPARAMS) register - see section 5.3.6 and section 7.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ext_offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Find the offset of the extended capabilities with capability ID id.</span>
<span class="cm"> *</span>
<span class="cm"> * @base PCI MMIO registers base address.</span>
<span class="cm"> * @ext_offset Offset from base of the first extended capability to look at,</span>
<span class="cm"> * 		or the address of HCCPARAMS.</span>
<span class="cm"> * @id Extended capability ID to search for.</span>
<span class="cm"> *</span>
<span class="cm"> * This uses an arbitrary limit of XHCI_MAX_EXT_CAPS extended capabilities</span>
<span class="cm"> * to make sure that the list doesn&#39;t contain a loop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xhci_find_ext_cap_by_id</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ext_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">XHCI_MAX_EXT_CAPS</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ext_offset</span> <span class="o">&amp;&amp;</span> <span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">ext_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XHCI_EXT_CAPS_ID</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ext_offset</span> <span class="o">=</span> <span class="n">xhci_find_next_cap_offset</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ext_offset</span><span class="p">);</span>
		<span class="n">limit</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ext_offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
