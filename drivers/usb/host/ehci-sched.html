<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › ehci-sched.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ehci-sched.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2001-2004 by David Brownell</span>
<span class="cm"> * Copyright (c) 2003 Michal Sojka, for high-speed iso transfers</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/* this file is part of ehci-hcd.c */</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI scheduled transaction support:  interrupt, iso, split iso</span>
<span class="cm"> * These are called &quot;periodic&quot; transactions in the EHCI spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that for interrupt transfers, the QH/QTD manipulation is shared</span>
<span class="cm"> * with the &quot;asynchronous&quot; transaction support (control/bulk transfers).</span>
<span class="cm"> * The only real difference is in how interrupt transfers are scheduled.</span>
<span class="cm"> *</span>
<span class="cm"> * For ISO, we make an &quot;iso_stream&quot; head to serve the same role as a QH.</span>
<span class="cm"> * It keeps track of every ITD (or SITD) that&#39;s linked, and holds enough</span>
<span class="cm"> * pre-calculated schedule data to make appending to the queue be quick.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ehci_get_frame</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ehci_read_frame_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">uf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The MosChip MCS9990 controller updates its microframe counter</span>
<span class="cm">	 * a little before the frame counter, and occasionally we will read</span>
<span class="cm">	 * the invalid intermediate value.  Avoid problems by checking the</span>
<span class="cm">	 * microframe number (the low-order 3 bits); if they are 0 then</span>
<span class="cm">	 * re-read the register to get the correct value.</span>
<span class="cm">	 */</span>
	<span class="n">uf</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">frame_index_bug</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">uf</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="n">uf</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_index</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">uf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * periodic_next_shadow - return &quot;next&quot; pointer on shadow list</span>
<span class="cm"> * @periodic: host pointer to qh/itd/sitd</span>
<span class="cm"> * @tag: hardware tag for type of this record</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">union</span> <span class="n">ehci_shadow</span> <span class="o">*</span>
<span class="nf">periodic_next_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">union</span> <span class="n">ehci_shadow</span> <span class="o">*</span><span class="n">periodic</span><span class="p">,</span>
		<span class="n">__hc32</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">periodic</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">Q_TYPE_FSTN</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">periodic</span><span class="o">-&gt;</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">fstn_next</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">Q_TYPE_ITD</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">periodic</span><span class="o">-&gt;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_next</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>case Q<em>TYPE</em>SITD:</p></td><td class="code"><div class="highlight"><pre>	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">periodic</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__hc32</span> <span class="o">*</span>
<span class="nf">shadow_next_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">union</span> <span class="n">ehci_shadow</span> <span class="o">*</span><span class="n">periodic</span><span class="p">,</span>
		<span class="n">__hc32</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span> <span class="p">{</span>
	<span class="cm">/* our ehci_shadow.qh is actually software part */</span>
	<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">periodic</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
	<span class="cm">/* others are hw parts */</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">periodic</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* caller must hold ehci-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">periodic_unlink</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">prev_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev_p</span><span class="p">;</span>

	<span class="cm">/* find predecessor of &quot;ptr&quot;; hw and shadow lists are in sync */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="n">here</span><span class="p">.</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev_p</span> <span class="o">=</span> <span class="n">periodic_next_shadow</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">prev_p</span><span class="p">,</span>
				<span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">));</span>
		<span class="n">hw_p</span> <span class="o">=</span> <span class="n">shadow_next_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">,</span>
				<span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">));</span>
		<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev_p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* an interrupt entry (at list end) could have been shared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* update shadow and hardware lists ... the old &quot;next&quot; pointers</span>
<span class="cm">	 * from ptr may still be in use, the caller updates them.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">prev_p</span> <span class="o">=</span> <span class="o">*</span><span class="n">periodic_next_shadow</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">,</span>
			<span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">use_dummy_qh</span> <span class="o">||</span>
	    <span class="o">*</span><span class="n">shadow_next_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">,</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">))</span>
			<span class="o">!=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span>
		<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">*</span><span class="n">shadow_next_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">,</span>
				<span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* how many of the uframe&#39;s 125 usecs are allocated? */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">periodic_usecs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">uframe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="kt">unsigned</span>		<span class="n">usecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
			<span class="n">hw</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
			<span class="cm">/* is it in the S-mask? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">uframe</span><span class="p">))</span>
				<span class="n">usecs</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">;</span>
			<span class="cm">/* ... or C-mask? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
					<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">uframe</span><span class="p">)))</span>
				<span class="n">usecs</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">;</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>case Q<em>TYPE</em>FSTN:</p></td><td class="code"><div class="highlight"><pre>		<span class="nl">default:</span>
			<span class="cm">/* for &quot;save place&quot; FSTNs, count the relevant INTR</span>
<span class="cm">			 * bandwidth from the previous frame</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">hw_prev</span> <span class="o">!=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;ignoring FSTN cost ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">fstn_next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Q_TYPE_ITD</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_transaction</span><span class="p">[</span><span class="n">uframe</span><span class="p">])</span>
				<span class="n">usecs</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">;</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Q_TYPE_SITD</span>:
			<span class="cm">/* is it in the S-mask?  (count SPLIT, DATA) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_uframe</span> <span class="o">&amp;</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
					<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">uframe</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_fullspeed_ep</span> <span class="o">&amp;</span>
						<span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">31</span><span class="p">))</span>
					<span class="n">usecs</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">;</span>
				<span class="k">else</span>	<span class="cm">/* worst case for OUT start-split */</span>
					<span class="n">usecs</span> <span class="o">+=</span> <span class="n">HS_USECS_ISO</span> <span class="p">(</span><span class="mi">188</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* ... C-mask?  (count CSPLIT, DATA) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_uframe</span> <span class="o">&amp;</span>
					<span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">uframe</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/* worst case for IN complete-split */</span>
				<span class="n">usecs</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef	DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usecs</span> <span class="o">&gt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">uframe_periodic_max</span><span class="p">)</span>
		<span class="n">ehci_err</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;uframe %d sched overrun: %d usecs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">frame</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">uframe</span><span class="p">,</span> <span class="n">usecs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">usecs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">same_tt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev2</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">!=</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">multi</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev1</span><span class="o">-&gt;</span><span class="n">ttport</span> <span class="o">==</span> <span class="n">dev2</span><span class="o">-&gt;</span><span class="n">ttport</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_TT_NEWSCHED</span>

<span class="cm">/* Which uframe does the low/fullspeed transfer start in?</span>
<span class="cm"> *</span>
<span class="cm"> * The parameter is the mask of ssplits in &quot;H-frame&quot; terms</span>
<span class="cm"> * and this returns the transfer start uframe in &quot;B-frame&quot; terms,</span>
<span class="cm"> * which allows both to match, e.g. a ssplit in &quot;H-frame&quot; uframe 0</span>
<span class="cm"> * will cause a transfer in &quot;B-frame&quot; uframe 0.  &quot;B-frames&quot; lag</span>
<span class="cm"> * &quot;H-frames&quot; by 1 uframe.  See the EHCI spec sec 4.5 and figure 4.7.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">tt_start_uframe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="n">__hc32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">smask</span> <span class="o">=</span> <span class="n">QH_SMASK</span> <span class="o">&amp;</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_err</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;invalid empty smask!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* uframe 7 can&#39;t have bw so this will indicate failure */</span>
		<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ffs</span><span class="p">(</span><span class="n">smask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span>
<span class="n">max_tt_usecs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cm">/* carryover low/fullspeed bandwidth that crosses uframe boundries */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">carryover_tt_bandwidth</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* How many of the tt&#39;s periodic downstream 1000 usecs are allocated?</span>
<span class="cm"> *</span>
<span class="cm"> * While this measures the bandwidth in terms of usecs/uframe,</span>
<span class="cm"> * the low/fullspeed bus has no notion of uframes, so any particular</span>
<span class="cm"> * low/fullspeed transfer can &quot;carry over&quot; from one uframe to the next,</span>
<span class="cm"> * since the TT just performs downstream transfers in sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * For example two separate 100 usec transfers can start in the same uframe,</span>
<span class="cm"> * and the second one would &quot;carry over&quot; 75 usecs into the next uframe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">periodic_tt_usecs</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">uf</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tt_usecs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Q_TYPE_ITD</span>:
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">same_tt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">uf</span> <span class="o">=</span> <span class="n">tt_start_uframe</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">);</span>
				<span class="n">tt_usecs</span><span class="p">[</span><span class="n">uf</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_usecs</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Q_TYPE_SITD</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">same_tt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">uf</span> <span class="o">=</span> <span class="n">tt_start_uframe</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_uframe</span><span class="p">);</span>
				<span class="n">tt_usecs</span><span class="p">[</span><span class="n">uf</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">tt_usecs</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>case Q<em>TYPE</em>FSTN:</p></td><td class="code"><div class="highlight"><pre>		<span class="nl">default:</span>
			<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;ignoring periodic frame %d FSTN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">frame</span><span class="p">);</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">fstn_next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">carryover_tt_bandwidth</span><span class="p">(</span><span class="n">tt_usecs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_tt_usecs</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
		<span class="n">ehci_err</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;frame %d tt sched overrun: %d usecs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">frame</span><span class="p">,</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_tt_usecs</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if the device&#39;s tt&#39;s downstream bus is available for a</span>
<span class="cm"> * periodic transfer of the specified length (usecs), starting at the</span>
<span class="cm"> * specified frame/uframe.  Note that (as summarized in section 11.19</span>
<span class="cm"> * of the usb 2.0 spec) TTs can buffer multiple transactions for each</span>
<span class="cm"> * uframe.</span>
<span class="cm"> *</span>
<span class="cm"> * The uframe parameter is when the fullspeed/lowspeed transfer</span>
<span class="cm"> * should be executed in &quot;B-frame&quot; terms, which is the same as the</span>
<span class="cm"> * highspeed ssplit&#39;s uframe (which is in &quot;H-frame&quot; terms).  For example</span>
<span class="cm"> * a ssplit in &quot;H-frame&quot; 0 causes a transfer in &quot;B-frame&quot; 0.</span>
<span class="cm"> * See the EHCI spec sec 4.5 and fig 4.7.</span>
<span class="cm"> *</span>
<span class="cm"> * This checks if the full/lowspeed bus, at the specified starting uframe,</span>
<span class="cm"> * has the specified bandwidth available, according to rules listed</span>
<span class="cm"> * in USB 2.0 spec section 11.18.1 fig 11-60.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not check if the transfer would exceed the max ssplit</span>
<span class="cm"> * limit of 16, specified in USB 2.0 spec section 11.18.4 requirement #4,</span>
<span class="cm"> * since proper scheduling limits ssplits to less than 16 per uframe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tt_available</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">period</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">frame</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">uframe</span><span class="p">,</span>
	<span class="n">u16</span>			<span class="n">usecs</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">&gt;=</span> <span class="mi">7</span><span class="p">))</span>	<span class="cm">/* error */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">frame</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

		<span class="n">periodic_tt_usecs</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">tt_usecs</span><span class="p">);</span>

		<span class="n">ehci_vdbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;tt frame %d check %d usecs start uframe %d in&quot;</span>
			<span class="s">&quot; schedule %d/%d/%d/%d/%d/%d/%d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">frame</span><span class="p">,</span> <span class="n">usecs</span><span class="p">,</span> <span class="n">uframe</span><span class="p">,</span>
			<span class="n">tt_usecs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">tt_usecs</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">max_tt_usecs</span><span class="p">[</span><span class="n">uframe</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="n">uframe</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ehci_vdbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;frame %d uframe %d fully scheduled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* special case for isoc transfers larger than 125us:</span>
<span class="cm">		 * the first and each subsequent fully used uframe</span>
<span class="cm">		 * must be empty, so as to not illegally delay</span>
<span class="cm">		 * already scheduled transactions</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">125</span> <span class="o">&lt;</span> <span class="n">usecs</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ufs</span> <span class="o">=</span> <span class="p">(</span><span class="n">usecs</span> <span class="o">/</span> <span class="mi">125</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">uframe</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">+</span> <span class="n">ufs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">ehci_vdbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
						<span class="s">&quot;multi-uframe xfer can&#39;t fit &quot;</span>
						<span class="s">&quot;in frame %d uframe %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">frame</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">tt_usecs</span><span class="p">[</span><span class="n">uframe</span><span class="p">]</span> <span class="o">+=</span> <span class="n">usecs</span><span class="p">;</span>

		<span class="n">carryover_tt_bandwidth</span><span class="p">(</span><span class="n">tt_usecs</span><span class="p">);</span>

		<span class="cm">/* fail if the carryover pushed bw past the last uframe&#39;s limit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_tt_usecs</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tt_usecs</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ehci_vdbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
				<span class="s">&quot;tt unavailable usecs %d frame %d uframe %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">usecs</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cm">/* return true iff the device&#39;s transaction translator is available</span>
<span class="cm"> * for a periodic transfer starting at the specified frame, using</span>
<span class="cm"> * all the uframes in the mask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tt_no_collision</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">period</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">frame</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">uf_mask</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* error */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* note bandwidth wastage:  split never follows csplit</span>
<span class="cm">	 * (different dev or endpoint) until the next uframe.</span>
<span class="cm">	 * calling convention doesn&#39;t make that distinction.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">frame</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">here</span><span class="p">;</span>
		<span class="n">__hc32</span>			<span class="n">type</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span><span class="p">;</span>

		<span class="n">here</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span> <span class="p">[</span><span class="n">frame</span><span class="p">]);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">Q_TYPE_ITD</span>:
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">here</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">here</span> <span class="o">=</span> <span class="n">here</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_next</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
				<span class="n">hw</span> <span class="o">=</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">same_tt</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">u32</span>		<span class="n">mask</span><span class="p">;</span>

					<span class="n">mask</span> <span class="o">=</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
							<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">);</span>
					<span class="cm">/* &quot;knows&quot; no gap is needed */</span>
					<span class="n">mask</span> <span class="o">|=</span> <span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">uf_mask</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">here</span> <span class="o">=</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">Q_TYPE_SITD</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">same_tt</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">here</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">u16</span>		<span class="n">mask</span><span class="p">;</span>

					<span class="n">mask</span> <span class="o">=</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">here</span><span class="p">.</span><span class="n">sitd</span>
								<span class="o">-&gt;</span><span class="n">hw_uframe</span><span class="p">);</span>
					<span class="cm">/* FIXME assumes no gap for IN! */</span>
					<span class="n">mask</span> <span class="o">|=</span> <span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">uf_mask</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">here</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">here</span> <span class="o">=</span> <span class="n">here</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_next</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>case Q<em>TYPE</em>FSTN:</p></td><td class="code"><div class="highlight"><pre>			<span class="nl">default:</span>
				<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
					<span class="s">&quot;periodic frame %d bogus type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">frame</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* collision or error */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* no collision */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_EHCI_TT_NEWSCHED */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">enable_periodic</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_sched</span><span class="o">++</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* did clearing PSE did take effect yet?</span>
<span class="cm">	 * takes effect only at frame boundaries...</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">handshake_on_error_set_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
					     <span class="n">STS_PSS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_PSE</span><span class="p">;</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="cm">/* posted write ... PSS happens later */</span>

	<span class="cm">/* make sure ehci_work scans these */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span>
		<span class="o">%</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">broken_periodic</span><span class="p">))</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">last_periodic_enable</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">disable_periodic</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_sched</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">broken_periodic</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* delay experimentally determined */</span>
		<span class="n">ktime_t</span> <span class="n">safe</span> <span class="o">=</span> <span class="n">ktime_add_us</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">last_periodic_enable</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="n">ktime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
		<span class="n">s64</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">ktime_us_delta</span><span class="p">(</span><span class="n">safe</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* did setting PSE not take effect yet?</span>
<span class="cm">	 * takes effect only at frame boundaries...</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">handshake_on_error_set_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
					     <span class="n">STS_PSS</span><span class="p">,</span> <span class="n">STS_PSS</span><span class="p">,</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_PSE</span><span class="p">;</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="cm">/* posted write ... */</span>

	<span class="n">free_cached_lists</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* periodic schedule slots have iso tds (normal or split) first, then a</span>
<span class="cm"> * sparse tree for active interrupt transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * this just links in a qh; caller guarantees uframe masks are set right.</span>
<span class="cm"> * no FSTN support (yet; ehci 0.96+)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qh_link_periodic</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">period</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>

	<span class="n">dev_dbg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;link qh%d-%04x/%p start %d [%d/%d us]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">period</span><span class="p">,</span> <span class="n">hc32_to_cpup</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="p">(</span><span class="n">QH_CMASK</span> <span class="o">|</span> <span class="n">QH_SMASK</span><span class="p">),</span>
		<span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">);</span>

	<span class="cm">/* high bandwidth, or otherwise every microframe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">__hc32</span>			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">__hc32</span>			<span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* skip the iso nodes at list head */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">Q_TYPE_QH</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">periodic_next_shadow</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="n">shadow_next_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* sorting each branch by period (slow--&gt;fast)</span>
<span class="cm">		 * enables sharing interior tree nodes</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="n">qh</span> <span class="o">!=</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
			<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
			<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* link in this qh, unless some earlier pass did that */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span> <span class="o">!=</span> <span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span> <span class="o">=</span> <span class="n">here</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">;</span>
			<span class="n">wmb</span> <span class="p">();</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">QH_NEXT</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_LINKED</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">xacterrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qh_get</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* update per-qh bandwidth for usbfs */</span>
	<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span> <span class="o">+=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">)</span> <span class="o">/</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* maybe enable periodic schedule processing */</span>
	<span class="k">return</span> <span class="n">enable_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qh_unlink_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">period</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>FIXME:
IF this isn't high speed
  and this qh is active in the current uframe
  (and overlay token SplitXstate is false?)
THEN
  qh->hw<em>info1 |= cpu</em>to_hc32(1 &lt;&lt; 7 /* "ignore" */);</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* high bandwidth, or otherwise part of every microframe */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">period</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span>
		<span class="n">periodic_unlink</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* update per-qh bandwidth for usbfs */</span>
	<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span> <span class="o">-=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">)</span> <span class="o">/</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">dev_dbg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;unlink qh%d-%04x/%p start %d [%d/%d us]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span>
		<span class="n">hc32_to_cpup</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">QH_CMASK</span> <span class="o">|</span> <span class="n">QH_SMASK</span><span class="p">),</span>
		<span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">);</span>

	<span class="cm">/* qh-&gt;qh_next still &quot;live&quot; to HC */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_UNLINK</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qh_put</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* maybe turn off periodic schedule */</span>
	<span class="k">return</span> <span class="n">disable_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intr_deschedule</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* If the QH isn&#39;t linked then there&#39;s nothing we can do</span>
<span class="cm">	 * unless we were called during a giveback, in which case</span>
<span class="cm">	 * qh_completions() has to deal with it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_LINKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_COMPLETING</span><span class="p">)</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qh_unlink_periodic</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* simple/paranoid:  always delay, expecting the HC needs to read</span>
<span class="cm">	 * qh-&gt;hw_next or finish a writeback after SPLIT/CSPLIT ... and</span>
<span class="cm">	 * expect khubd to clean up after any CSPLITs we won&#39;t issue.</span>
<span class="cm">	 * active high speed queues may need bigger delays...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QH_CMASK</span><span class="p">)</span>
					<span class="o">&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wait</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wait</span> <span class="o">=</span> <span class="mi">55</span><span class="p">;</span>	<span class="cm">/* worst case: 3 * 1024 */</span>

	<span class="n">udelay</span> <span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">wmb</span> <span class="p">();</span>

	<span class="n">qh_completions</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* reschedule QH iff another request is queued */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">qh_schedule</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

		<span class="cm">/* An error here likely indicates handshake failure</span>
<span class="cm">		 * or no space left in the schedule.  Neither fault</span>
<span class="cm">		 * should happen often ...</span>
<span class="cm">		 *</span>
<span class="cm">		 * FIXME kill the now-dysfunctional queued urbs</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ehci_err</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;can&#39;t reschedule qh %p, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">qh</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_period</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="kt">unsigned</span>	<span class="n">frame</span><span class="p">,</span>
	<span class="kt">unsigned</span>	<span class="n">uframe</span><span class="p">,</span>
	<span class="kt">unsigned</span>	<span class="n">period</span><span class="p">,</span>
	<span class="kt">unsigned</span>	<span class="n">usecs</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">claimed</span><span class="p">;</span>

	<span class="cm">/* complete split running into next frame?</span>
<span class="cm">	 * given FSTN support, we could sometimes check...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* convert &quot;usecs we need&quot; to &quot;max already claimed&quot; */</span>
	<span class="n">usecs</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">uframe_periodic_max</span> <span class="o">-</span> <span class="n">usecs</span><span class="p">;</span>

	<span class="cm">/* we &quot;know&quot; 2 and 4 uframe intervals were rejected; so</span>
<span class="cm">	 * for period 0, check _every_ microframe in the schedule.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uframe</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">uframe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">claimed</span> <span class="o">=</span> <span class="n">periodic_usecs</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">claimed</span> <span class="o">&gt;</span> <span class="n">usecs</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">);</span>

	<span class="cm">/* just check the specified uframe, at that period */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">claimed</span> <span class="o">=</span> <span class="n">periodic_usecs</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">claimed</span> <span class="o">&gt;</span> <span class="n">usecs</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">frame</span> <span class="o">+=</span> <span class="n">period</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>success!</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_intr_schedule</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">frame</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">uframe</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ehci_qh</span>	<span class="o">*</span><span class="n">qh</span><span class="p">,</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">c_maskp</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">&amp;&amp;</span> <span class="n">uframe</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>		<span class="cm">/* FSTN territory? */</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_period</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">c_maskp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_TT_NEWSCHED</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tt_available</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">,</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_usecs</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* TODO : this may need FSTN for SSPLIT in uframe 5. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">uframe</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">uframe</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_period</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="o">*</span><span class="n">c_maskp</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="cm">/* Make sure this tt&#39;s buffer is also available for CSPLITs.</span>
<span class="cm">	 * We pessimize a bit; probably the typical full speed case</span>
<span class="cm">	 * doesn&#39;t need the second CSPLIT.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  both SPLIT and CSPLIT could be checked in just</span>
<span class="cm">	 * one smart pass...</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">gap_uf</span><span class="p">);</span>
	<span class="o">*</span><span class="n">c_maskp</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">uframe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tt_no_collision</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_period</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">gap_uf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_period</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span> <span class="o">+</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">gap_uf</span><span class="p">,</span>
					<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* &quot;first fit&quot; scheduling policy used the first time through,</span>
<span class="cm"> * or when the previous schedule slot can&#39;t be re-used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qh_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">uframe</span><span class="p">;</span>
	<span class="n">__hc32</span>		<span class="n">c_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">frame</span><span class="p">;</span>		<span class="cm">/* 0..(qh-&gt;period - 1), or NO_FRAME */</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">qh_refresh</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* reuse the previous schedule slots, if we can */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span> <span class="o">&lt;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uframe</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">hc32_to_cpup</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">QH_SMASK</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">check_intr_schedule</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">--</span><span class="n">uframe</span><span class="p">,</span>
				<span class="n">qh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c_mask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* else scan the schedule to find a group of slots such that all</span>
<span class="cm">	 * uframes have enough periodic bandwidth available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &quot;normal&quot; case, uframing flexible except with splits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span> <span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">frame</span> <span class="o">=</span> <span class="o">++</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">random_frame</span> <span class="o">%</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uframe</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">uframe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="n">check_intr_schedule</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
							<span class="n">frame</span><span class="p">,</span> <span class="n">uframe</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">c_mask</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="cm">/* qh-&gt;period == 0 means every uframe */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">check_intr_schedule</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c_mask</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>

		<span class="cm">/* reset S-frame and (maybe) C-frame masks */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">QH_CMASK</span> <span class="o">|</span> <span class="n">QH_SMASK</span><span class="p">));</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">|=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span>
			<span class="o">?</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">uframe</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QH_SMASK</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">|=</span> <span class="n">c_mask</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;reused qh %p schedule</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* stuff into the periodic schedule */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">qh_link_periodic</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intr_submit</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">qtd_list</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">mem_flags</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">epnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">empty</span><span class="p">;</span>

	<span class="cm">/* get endpoint and transfer/schedule data */</span>
	<span class="n">epnum</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done_not_linked</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done_not_linked</span><span class="p">;</span>

	<span class="cm">/* get qh and force any scheduling errors */</span>
	<span class="n">INIT_LIST_HEAD</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_append_tds</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">qh_schedule</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* then queue the urb&#39;s tds to the qh */</span>
	<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_append_tds</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="n">BUG_ON</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* ... update usbfs periodic stats */</span>
	<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_int_reqs</span><span class="o">++</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
<span class="nl">done_not_linked:</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">qtd_list_free</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* ehci_iso_stream ops work with both ITD and SITD */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="o">*</span>
<span class="nf">iso_stream_alloc</span> <span class="p">(</span><span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>

	<span class="n">stream</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">stream</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">stream</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iso_stream_init</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pipe</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">interval</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">smask_out</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x3f</span> <span class="p">};</span>

	<span class="n">u32</span>			<span class="n">buf1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">epnum</span><span class="p">,</span> <span class="n">maxp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">is_input</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">bandwidth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this might be a &quot;high bandwidth&quot; highspeed endpoint,</span>
<span class="cm">	 * as encoded in the ep descriptor&#39;s wMaxPacket field</span>
<span class="cm">	 */</span>
	<span class="n">epnum</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">is_input</span> <span class="o">=</span> <span class="n">usb_pipein</span> <span class="p">(</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="n">USB_DIR_IN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="o">!</span><span class="n">is_input</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">buf1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* knows about ITD vs SITD */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">hb_mult</span><span class="p">(</span><span class="n">maxp</span><span class="p">);</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">highspeed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">maxp</span> <span class="o">=</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">);</span>
		<span class="n">buf1</span> <span class="o">|=</span> <span class="n">maxp</span><span class="p">;</span>
		<span class="n">maxp</span> <span class="o">*=</span> <span class="n">multi</span><span class="p">;</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf0</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">epnum</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf1</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">buf1</span><span class="p">);</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf2</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">multi</span><span class="p">);</span>

		<span class="cm">/* usbfs wants to report the average usecs per frame tied up</span>
<span class="cm">		 * when transfers on this endpoint are scheduled ...</span>
<span class="cm">		 */</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">=</span> <span class="n">HS_USECS_ISO</span> <span class="p">(</span><span class="n">maxp</span><span class="p">);</span>
		<span class="n">bandwidth</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">bandwidth</span> <span class="o">/=</span> <span class="n">interval</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span>		<span class="n">addr</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">think_time</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">hs_transfers</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ttport</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci_is_TDI</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span>
				<span class="o">||</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">hub</span> <span class="o">!=</span>
					<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">))</span>
			<span class="n">addr</span> <span class="o">|=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">|=</span> <span class="n">epnum</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">|=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">=</span> <span class="n">HS_USECS_ISO</span> <span class="p">(</span><span class="n">maxp</span><span class="p">);</span>
		<span class="n">think_time</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">think_time</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">tt_usecs</span> <span class="o">=</span> <span class="n">NS_TO_US</span> <span class="p">(</span><span class="n">think_time</span> <span class="o">+</span> <span class="n">usb_calc_bus_time</span> <span class="p">(</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span> <span class="n">is_input</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxp</span><span class="p">));</span>
		<span class="n">hs_transfers</span> <span class="o">=</span> <span class="n">max</span> <span class="p">(</span><span class="mi">1u</span><span class="p">,</span> <span class="p">(</span><span class="n">maxp</span> <span class="o">+</span> <span class="mi">187</span><span class="p">)</span> <span class="o">/</span> <span class="mi">188</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span>	<span class="n">tmp</span><span class="p">;</span>

			<span class="n">addr</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">;</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">=</span> <span class="n">HS_USECS_ISO</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">raw_mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* c-mask as specified in USB 2.0 11.18.4 3.c */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">hs_transfers</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">raw_mask</span> <span class="o">|=</span> <span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">raw_mask</span> <span class="o">=</span> <span class="n">smask_out</span> <span class="p">[</span><span class="n">hs_transfers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">bandwidth</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">;</span>
		<span class="n">bandwidth</span> <span class="o">/=</span> <span class="n">interval</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

		<span class="cm">/* stream-&gt;splits gets created from raw_mask later */</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span><span class="p">;</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">=</span> <span class="n">is_input</span> <span class="o">|</span> <span class="n">epnum</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">maxp</span> <span class="o">=</span> <span class="n">maxp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iso_stream_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* free whenever just a dev-&gt;ep reference remains.</span>
<span class="cm">	 * not like a QH -- no persistent state (toggle, halt)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>BUG<em>ON (!list</em>empty(&amp;stream->td_list));</p></td><td class="code"><div class="highlight"><pre>		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">entry</span><span class="p">;</span>

			<span class="n">entry</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="n">list_del</span> <span class="p">(</span><span class="n">entry</span><span class="p">);</span>

			<span class="cm">/* knows about ITD vs SITD */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">highspeed</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ehci_itd</span>		<span class="o">*</span><span class="n">itd</span><span class="p">;</span>

				<span class="n">itd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_itd</span><span class="p">,</span>
						<span class="n">itd_list</span><span class="p">);</span>
				<span class="n">dma_pool_free</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">itd_pool</span><span class="p">,</span> <span class="n">itd</span><span class="p">,</span>
						<span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_dma</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ehci_sitd</span>	<span class="o">*</span><span class="n">sitd</span><span class="p">;</span>

				<span class="n">sitd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_sitd</span><span class="p">,</span>
						<span class="n">sitd_list</span><span class="p">);</span>
				<span class="n">dma_pool_free</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">sitd_pool</span><span class="p">,</span> <span class="n">sitd</span><span class="p">,</span>
						<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_dma</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;=</span> <span class="mh">0x0f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="o">*</span>
<span class="nf">iso_stream_get</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">stream</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">stream</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="o">*</span>
<span class="nf">iso_stream_find</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">epnum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">epnum</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">stream</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stream</span> <span class="o">=</span> <span class="n">iso_stream_alloc</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">stream</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* dev-&gt;ep owns the initial refcount */</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">stream</span><span class="p">;</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="n">iso_stream_init</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/* if dev-&gt;ep [epnum] is a QH, hw is set */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;dev %s ep%d%s, not iso??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span>
			<span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>
		<span class="n">stream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* caller guarantees an eventual matching iso_stream_put */</span>
	<span class="n">stream</span> <span class="o">=</span> <span class="n">iso_stream_get</span> <span class="p">(</span><span class="n">stream</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stream</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* ehci_iso_sched ops can be ITD-only or SITD-only */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_iso_sched</span> <span class="o">*</span>
<span class="nf">iso_sched_alloc</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">packets</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">iso_sched</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">packets</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_iso_packet</span><span class="p">);</span>
	<span class="n">iso_sched</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">iso_sched</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">iso_sched</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">itd_sched_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>

	<span class="cm">/* how many uframes are needed for these transfers */</span>
	<span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">span</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">*</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>

	<span class="cm">/* figure out per-uframe itd fields that we&#39;ll need later</span>
<span class="cm">	 * when we fit new itds into the schedule.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_iso_packet</span>	<span class="o">*</span><span class="n">uframe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">packet</span> <span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span>		<span class="n">length</span><span class="p">;</span>
		<span class="n">dma_addr_t</span>		<span class="n">buf</span><span class="p">;</span>
		<span class="n">u32</span>			<span class="n">trans</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span> <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">dma</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span> <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>

		<span class="n">trans</span> <span class="o">=</span> <span class="n">EHCI_ISOC_ACTIVE</span><span class="p">;</span>
		<span class="n">trans</span> <span class="o">|=</span> <span class="n">buf</span> <span class="o">&amp;</span> <span class="mh">0x0fff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_INTERRUPT</span><span class="p">))</span>
			<span class="n">trans</span> <span class="o">|=</span> <span class="n">EHCI_ITD_IOC</span><span class="p">;</span>
		<span class="n">trans</span> <span class="o">|=</span> <span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">uframe</span><span class="o">-&gt;</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>

		<span class="cm">/* might need to cross a buffer page within a uframe */</span>
		<span class="n">uframe</span><span class="o">-&gt;</span><span class="n">bufp</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mh">0x0fff</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">((</span><span class="n">uframe</span><span class="o">-&gt;</span><span class="n">bufp</span> <span class="o">!=</span> <span class="p">(</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mh">0x0fff</span><span class="p">))))</span>
			<span class="n">uframe</span><span class="o">-&gt;</span><span class="n">cross</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iso_sched_free</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iso_sched</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>caller must hold ehci->lock!</p></td><td class="code"><div class="highlight"><pre>	<span class="n">list_splice</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="n">kfree</span> <span class="p">(</span><span class="n">iso_sched</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">itd_urb_transaction</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">mem_flags</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_itd</span>		<span class="o">*</span><span class="n">itd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">itd_dma</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">num_itds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">sched</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">sched</span> <span class="o">=</span> <span class="n">iso_sched_alloc</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">sched</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">itd_sched_init</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">num_itds</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">span</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">num_itds</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>

	<span class="cm">/* allocate/init ITDs */</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_itds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* free_list.next might be cache-hot ... but maybe</span>
<span class="cm">		 * the HC caches it too. avoid that issue for now.</span>
<span class="cm">		 */</span>

		<span class="cm">/* prefer previously-allocated itds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">itd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ehci_itd</span><span class="p">,</span> <span class="n">itd_list</span><span class="p">);</span>
			<span class="n">list_del</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_list</span><span class="p">);</span>
			<span class="n">itd_dma</span> <span class="o">=</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_dma</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">itd</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">itd_pool</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">itd_dma</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">itd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iso_sched_free</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">sched</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">memset</span> <span class="p">(</span><span class="n">itd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">itd</span><span class="p">);</span>
		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_dma</span> <span class="o">=</span> <span class="n">itd_dma</span><span class="p">;</span>
		<span class="n">list_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* temporarily store schedule info in hcpriv */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">sched</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">itd_slot_ok</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">mod</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">uframe</span><span class="p">,</span>
	<span class="n">u8</span>			<span class="n">usecs</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">period</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">uframe</span> <span class="o">%=</span> <span class="n">period</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t commit more than uframe_periodic_max usec */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">periodic_usecs</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">uframe</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
				<span class="o">&gt;</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">uframe_periodic_max</span> <span class="o">-</span> <span class="n">usecs</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* we know urb-&gt;interval is 2^N uframes */</span>
		<span class="n">uframe</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">sitd_slot_ok</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">mod</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">uframe</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">sched</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">period_uframes</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">mask</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">frame</span><span class="p">,</span> <span class="n">uf</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">raw_mask</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>

	<span class="cm">/* for IN, don&#39;t wrap CSPLIT into the next frame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check bandwidth */</span>
	<span class="n">uframe</span> <span class="o">%=</span> <span class="n">period_uframes</span><span class="p">;</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_USB_EHCI_TT_NEWSCHED</span>
	<span class="cm">/* The tt&#39;s fullspeed bus bandwidth must be available.</span>
<span class="cm">	 * tt_available scheduling guarantees 10+% for control/bulk.</span>
<span class="cm">	 */</span>
	<span class="n">uf</span> <span class="o">=</span> <span class="n">uframe</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tt_available</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">period_uframes</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">tt_usecs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* tt must be idle for start(s), any gap, and csplit.</span>
<span class="cm">	 * assume scheduling slop leaves 10+% for control/bulk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tt_no_collision</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">period_uframes</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* this multi-pass logic is simple, but performance may</span>
<span class="cm">	 * suffer when the schedule data isn&#39;t cached.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span>		<span class="n">max_used</span><span class="p">;</span>

		<span class="n">frame</span> <span class="o">=</span> <span class="n">uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">uf</span> <span class="o">=</span> <span class="n">uframe</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>

		<span class="cm">/* check starts (OUT uses more than one) */</span>
		<span class="n">max_used</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">uframe_periodic_max</span> <span class="o">-</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">raw_mask</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">uf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">periodic_usecs</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_used</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* for IN, check CSPLIT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uf</span> <span class="o">=</span> <span class="n">uframe</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">max_used</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">uframe_periodic_max</span> <span class="o">-</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">c_usecs</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">uf</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">raw_mask</span> <span class="o">&amp;</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">periodic_usecs</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">uf</span><span class="p">)</span>
						<span class="o">&gt;</span> <span class="n">max_used</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">uf</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* we know urb-&gt;interval is 2^N uframes */</span>
		<span class="n">uframe</span> <span class="o">+=</span> <span class="n">period_uframes</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="p">);</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">splits</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">raw_mask</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This scheduler plans almost as far into the future as it has actual</span>
<span class="cm"> * periodic schedule slots.  (Affected by TUNE_FLS, which defaults to</span>
<span class="cm"> * &quot;as small as possible&quot; to be cache-friendlier.)  That limits the size</span>
<span class="cm"> * transfers you can stream reliably; avoid more than 64 msec per urb.</span>
<span class="cm"> * Also avoid queue depths of less than ehci&#39;s worst irq latency (affected</span>
<span class="cm"> * by the per-urb URB_NO_INTERRUPT hint, the log2_irq_thresh module parameter,</span>
<span class="cm"> * and other factors); or more than about 230 msec total (for portability,</span>
<span class="cm"> * given EHCI_TUNE_FLS and the slop).  Or, write a smarter scheduler!</span>
<span class="cm"> */</span>

<span class="cp">#define SCHEDULE_SLOP	80	</span><span class="cm">/* microframes */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">iso_stream_schedule</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">now</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">span</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">mod</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">sched</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
	<span class="n">span</span> <span class="o">=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">highspeed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">span</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">span</span> <span class="o">&gt;</span> <span class="n">mod</span> <span class="o">-</span> <span class="n">SCHEDULE_SLOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;iso request %p too long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Typical case: reuse current schedule, stream is still active.</span>
<span class="cm">	 * Hopefully there are no gaps from the host falling behind</span>
<span class="cm">	 * (irq delays etc), but if there are we&#39;ll take the next</span>
<span class="cm">	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">u32</span>	<span class="n">excess</span><span class="p">;</span>

		<span class="cm">/* For high speed devices, allow scheduling within the</span>
<span class="cm">		 * isochronous scheduling threshold.  For full speed devices</span>
<span class="cm">		 * and Intel PCI-based controllers, don&#39;t (work around for</span>
<span class="cm">		 * Intel ICH9 bug).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">highspeed</span> <span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">fs_i_thresh</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">i_thresh</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

		<span class="cm">/* Fell behind (by up to twice the slop amount)?</span>
<span class="cm">		 * We decide based on the time of the last currently-scheduled</span>
<span class="cm">		 * slot, not the time of the next available slot.</span>
<span class="cm">		 */</span>
		<span class="n">excess</span> <span class="o">=</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">-</span> <span class="n">period</span> <span class="o">-</span> <span class="n">next</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">excess</span> <span class="o">&gt;=</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SCHEDULE_SLOP</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">next</span> <span class="o">+</span> <span class="n">excess</span> <span class="o">-</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">period</span> <span class="o">*</span>
					<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="n">excess</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">next</span> <span class="o">+</span> <span class="n">excess</span> <span class="o">+</span> <span class="n">period</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">now</span> <span class="o">&gt;=</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;request %p would overflow (%d+%d &gt;= %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">urb</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="n">now</span> <span class="o">-</span> <span class="n">period</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span>
					<span class="n">mod</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* need to schedule; when&#39;s the next (u)frame we could start?</span>
<span class="cm">	 * this is bigger than ehci-&gt;i_thresh allows; scheduling itself</span>
<span class="cm">	 * isn&#39;t free, the slop should handle reasonably slow cpus.  it</span>
<span class="cm">	 * can also help high bandwidth if the dma and irq loads don&#39;t</span>
<span class="cm">	 * jump until after the queue is primed.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">SCHEDULE_SLOP</span> <span class="o">+</span> <span class="p">(</span><span class="n">now</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x07</span><span class="p">);</span>

		<span class="cm">/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */</span>

		<span class="cm">/* find a uframe slot with enough bandwidth.</span>
<span class="cm">		 * Early uframes are more precious because full-speed</span>
<span class="cm">		 * iso IN transfers can&#39;t use late uframes,</span>
<span class="cm">		 * and therefore they should be allocated last.</span>
<span class="cm">		 */</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">start</span><span class="o">--</span><span class="p">;</span>
			<span class="cm">/* check schedule: enough space? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">highspeed</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">itd_slot_ok</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
						<span class="n">stream</span><span class="o">-&gt;</span><span class="n">usecs</span><span class="p">,</span> <span class="n">period</span><span class="p">))</span>
					<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sitd_slot_ok</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span>
						<span class="n">start</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">period</span><span class="p">))</span>
					<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">);</span>

		<span class="cm">/* no room in the schedule */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;iso resched full %p (now %d max %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urb</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">now</span> <span class="o">+</span> <span class="n">mod</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Tried to schedule too far into the future? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">now</span> <span class="o">+</span> <span class="n">span</span> <span class="o">-</span> <span class="n">period</span>
				<span class="o">&gt;=</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SCHEDULE_SLOP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;request %p would overflow (%d+%d &gt;= %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urb</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="n">now</span><span class="p">,</span> <span class="n">span</span> <span class="o">-</span> <span class="n">period</span><span class="p">,</span>
				<span class="n">mod</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SCHEDULE_SLOP</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* report high speed start in uframes; full speed, in frames */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">highspeed</span><span class="p">)</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">iso_sched_free</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">sched</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">itd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_iso_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ehci_itd</span> <span class="o">*</span><span class="n">itd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* it&#39;s been recently zeroed */</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf0</span><span class="p">;</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf1</span><span class="p">;</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* All other fields are filled when scheduling */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">itd_patch</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_itd</span>		<span class="o">*</span><span class="n">itd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span>			<span class="n">uframe</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_iso_packet</span>	<span class="o">*</span><span class="n">uf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">packet</span> <span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="kt">unsigned</span>		<span class="n">pg</span> <span class="o">=</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">pg</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>BUG_ON (pg == 6 &amp;&amp; uf->cross);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">uframe</span> <span class="o">&amp;=</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">index</span> <span class="p">[</span><span class="n">uframe</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_transaction</span><span class="p">[</span><span class="n">uframe</span><span class="p">]</span> <span class="o">=</span> <span class="n">uf</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="p">;</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_transaction</span><span class="p">[</span><span class="n">uframe</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">pg</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span><span class="p">[</span><span class="n">pg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">uf</span><span class="o">-&gt;</span><span class="n">bufp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_bufp_hi</span><span class="p">[</span><span class="n">pg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">uf</span><span class="o">-&gt;</span><span class="n">bufp</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>

	<span class="cm">/* iso_frame_desc[].offset must be strictly increasing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">uf</span><span class="o">-&gt;</span><span class="n">cross</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span>	<span class="n">bufp</span> <span class="o">=</span> <span class="n">uf</span><span class="o">-&gt;</span><span class="n">bufp</span> <span class="o">+</span> <span class="mi">4096</span><span class="p">;</span>

		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="o">++</span><span class="n">pg</span><span class="p">;</span>
		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_bufp</span><span class="p">[</span><span class="n">pg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">bufp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_bufp_hi</span><span class="p">[</span><span class="n">pg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">bufp</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">itd_link</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_itd</span> <span class="o">*</span><span class="n">itd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="n">__hc32</span>			<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* skip any iso nodes which might belong to previous microframes */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">Q_TYPE_QH</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">periodic_next_shadow</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">hw_p</span> <span class="o">=</span> <span class="n">shadow_next_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">here</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">here</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_next</span> <span class="o">=</span> <span class="n">here</span><span class="p">;</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">;</span>
	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">itd</span> <span class="o">=</span> <span class="n">itd</span><span class="p">;</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
	<span class="n">wmb</span> <span class="p">();</span>
	<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_dma</span> <span class="o">|</span> <span class="n">Q_TYPE_ITD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* fit urb&#39;s itds into the selected schedule slot; activate as needed */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">itd_link_urb</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">mod</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">packet</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">next_uframe</span><span class="p">,</span> <span class="n">uframe</span><span class="p">,</span> <span class="n">frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_itd</span>		<span class="o">*</span><span class="n">itd</span><span class="p">;</span>

	<span class="n">next_uframe</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span>
				<span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bandwidth</span><span class="p">;</span>
		<span class="n">ehci_vdbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
			<span class="s">&quot;schedule devp %s ep%d%s-iso period %d start %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span>
			<span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">,</span>
			<span class="n">next_uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">next_uframe</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">amd_pll_fix</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">usb_amd_quirk_pll_disable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* fill iTDs uframe by uframe */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">packet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">itd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">packet</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">itd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ASSERT:  we have all necessary itds */</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>BUG<em>ON (list</em>empty (&amp;iso<em>sched->td</em>list));</p></td><td class="code"><div class="highlight"><pre>			<span class="cm">/* ASSERT:  no itds for this endpoint in this uframe */</span>

			<span class="n">itd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ehci_itd</span><span class="p">,</span> <span class="n">itd_list</span><span class="p">);</span>
			<span class="n">list_move_tail</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
			<span class="n">itd</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="n">iso_stream_get</span> <span class="p">(</span><span class="n">stream</span><span class="p">);</span>
			<span class="n">itd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
			<span class="n">itd_init</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">itd</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">uframe</span> <span class="o">=</span> <span class="n">next_uframe</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">next_uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

		<span class="n">itd_patch</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">itd</span><span class="p">,</span> <span class="n">iso_sched</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">uframe</span><span class="p">);</span>

		<span class="n">next_uframe</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
		<span class="n">next_uframe</span> <span class="o">&amp;=</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">packet</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* link completed itds into the schedule */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">next_uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">frame</span><span class="p">)</span>
				<span class="o">||</span> <span class="n">packet</span> <span class="o">==</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">itd_link</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">frame</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">itd</span><span class="p">);</span>
			<span class="n">itd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">next_uframe</span><span class="p">;</span>

	<span class="cm">/* don&#39;t need that schedule data any more */</span>
	<span class="n">iso_sched_free</span> <span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">iso_sched</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">timer_action</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">enable_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define	ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)</span>

<span class="cm">/* Process and recycle a completed ITD.  Return true iff its urb completed,</span>
<span class="cm"> * and hence its completion callback probably added things to the hardware</span>
<span class="cm"> * schedule.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we carefully avoid recycling this descriptor until after any</span>
<span class="cm"> * completion callback runs, so that it won&#39;t be reused quickly.  That is,</span>
<span class="cm"> * assuming (a) no more than two urbs per frame on this endpoint, and also</span>
<span class="cm"> * (b) only this endpoint&#39;s completions submit URBs.  It seems some silicon</span>
<span class="cm"> * corrupts things if you reuse completed descriptors very quickly...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">itd_complete</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>	<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_itd</span>	<span class="o">*</span><span class="n">itd</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>				<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span>				<span class="n">uframe</span><span class="p">;</span>
	<span class="kt">int</span>					<span class="n">urb_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>			<span class="o">*</span><span class="n">stream</span> <span class="o">=</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>			<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span>				<span class="n">retval</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* for each uframe with a packet */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">uframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uframe</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">uframe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">uframe</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">urb_index</span> <span class="o">=</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="n">uframe</span><span class="p">];</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span> <span class="p">[</span><span class="n">urb_index</span><span class="p">];</span>

		<span class="n">t</span> <span class="o">=</span> <span class="n">hc32_to_cpup</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_transaction</span> <span class="p">[</span><span class="n">uframe</span><span class="p">]);</span>
		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_transaction</span> <span class="p">[</span><span class="n">uframe</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* report transfer status */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">ISO_ERRS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">EHCI_ISOC_BUF_ERR</span><span class="p">)</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span>
					<span class="o">?</span> <span class="o">-</span><span class="n">ENOSR</span>  <span class="cm">/* hc couldn&#39;t read */</span>
					<span class="o">:</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">;</span> <span class="cm">/* hc couldn&#39;t write */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">EHCI_ISOC_BABBLE</span><span class="p">)</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
			<span class="k">else</span> <span class="cm">/* (t &amp; EHCI_ISOC_XACTERR) */</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>

			<span class="cm">/* HC need not update length with this error */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">EHCI_ISOC_BABBLE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">EHCI_ITD_LENGTH</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">((</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">EHCI_ISOC_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">EHCI_ITD_LENGTH</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* URB was too late */</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* handle completion now? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">((</span><span class="n">urb_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* ASSERT: it&#39;s really the last itd for this urb</span>
<span class="cm">	list_for_each_entry (itd, &amp;stream-&gt;td_list, itd_list)</span>
<span class="cm">		BUG_ON (itd-&gt;urb == urb);</span>
<span class="cm">	 */</span>

	<span class="cm">/* give urb back to the driver; completion often (re)submits */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">disable_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">amd_pll_fix</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">usb_amd_quirk_pll_enable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span>
				<span class="o">-=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bandwidth</span><span class="p">;</span>
		<span class="n">ehci_vdbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
			<span class="s">&quot;deschedule devp %s ep%d%s-iso</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span>
			<span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iso_stream_put</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">itd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">clock_frame</span> <span class="o">!=</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">||</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* OK to recycle this ITD now. */</span>
		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">iso_stream_put</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* HW might remember this ITD, so we can&#39;t recycle it yet.</span>
<span class="cm">		 * Move it to a safe place until a new frame starts.</span>
<span class="cm">		 */</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">cached_itd_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If iso_stream_put() were called here, stream</span>
<span class="cm">			 * would be freed.  Instead, just prevent reuse.</span>
<span class="cm">			 */</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">itd_submit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">;</span>

	<span class="cm">/* Get iso_stream head */</span>
	<span class="n">stream</span> <span class="o">=</span> <span class="n">iso_stream_find</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;can&#39;t get iso stream</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">!=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;can&#39;t change iso interval %d --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef EHCI_URB_TRACE</span>
	<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
		<span class="s">&quot;%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
		<span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
		<span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">,</span>
		<span class="n">stream</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* allocate ITDs w/o locking anything */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">itd_urb_transaction</span> <span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;can&#39;t init itds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* schedule ... need to lock */</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done_not_linked</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done_not_linked</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">iso_stream_schedule</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">itd_link_urb</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
<span class="nl">done_not_linked:</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">iso_stream_put</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;Split ISO TDs&quot; ... used for USB 1.1 devices going through the</span>
<span class="cm"> * TTs in USB 2.0 hubs.  These need microframe scheduling.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sitd_sched_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>

	<span class="cm">/* how many frames are needed for these transfers */</span>
	<span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">span</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">*</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>

	<span class="cm">/* figure out per-frame sitd fields that we&#39;ll need later</span>
<span class="cm">	 * when we fit new sitds into the schedule.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_iso_packet</span>	<span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">packet</span> <span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span>		<span class="n">length</span><span class="p">;</span>
		<span class="n">dma_addr_t</span>		<span class="n">buf</span><span class="p">;</span>
		<span class="n">u32</span>			<span class="n">trans</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span> <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0x03ff</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">dma</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span> <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>

		<span class="n">trans</span> <span class="o">=</span> <span class="n">SITD_STS_ACTIVE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_INTERRUPT</span><span class="p">))</span>
			<span class="n">trans</span> <span class="o">|=</span> <span class="n">SITD_IOC</span><span class="p">;</span>
		<span class="n">trans</span> <span class="o">|=</span> <span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>

		<span class="cm">/* might need to cross a buffer page within a td */</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">bufp</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">buf1</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0fff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">buf1</span> <span class="o">!=</span> <span class="p">(</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mh">0x0fff</span><span class="p">))</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">cross</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* OUT uses multiple start-splits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">187</span><span class="p">)</span> <span class="o">/</span> <span class="mi">188</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* BEGIN vs ALL */</span>
			<span class="n">length</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">buf1</span> <span class="o">|=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sitd_urb_transaction</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">mem_flags</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_sitd</span>	<span class="o">*</span><span class="n">sitd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">sitd_dma</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">iso_sched</span> <span class="o">=</span> <span class="n">iso_sched_alloc</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iso_sched</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sitd_sched_init</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">iso_sched</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

	<span class="cm">/* allocate/init sITDs */</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* NOTE:  for now, we don&#39;t try to handle wraparound cases</span>
<span class="cm">		 * for IN (using sitd-&gt;hw_backpointer, like a FSTN), which</span>
<span class="cm">		 * means we never need two sitds for full speed packets.</span>
<span class="cm">		 */</span>

		<span class="cm">/* free_list.next might be cache-hot ... but maybe</span>
<span class="cm">		 * the HC caches it too. avoid that issue for now.</span>
<span class="cm">		 */</span>

		<span class="cm">/* prefer previously-allocated sitds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sitd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ehci_sitd</span><span class="p">,</span> <span class="n">sitd_list</span><span class="p">);</span>
			<span class="n">list_del</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_list</span><span class="p">);</span>
			<span class="n">sitd_dma</span> <span class="o">=</span> <span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_dma</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">sitd</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">sitd_pool</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sitd_dma</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sitd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iso_sched_free</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">iso_sched</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">memset</span> <span class="p">(</span><span class="n">sitd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">sitd</span><span class="p">);</span>
		<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_dma</span> <span class="o">=</span> <span class="n">sitd_dma</span><span class="p">;</span>
		<span class="n">list_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* temporarily store schedule info in hcpriv */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">iso_sched</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sitd_patch</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_sitd</span>	<span class="o">*</span><span class="n">sitd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">iso_sched</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">index</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_iso_packet</span>	<span class="o">*</span><span class="n">uf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iso_sched</span><span class="o">-&gt;</span><span class="n">packet</span> <span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">u64</span>			<span class="n">bufp</span> <span class="o">=</span> <span class="n">uf</span><span class="o">-&gt;</span><span class="n">bufp</span><span class="p">;</span>

	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_fullspeed_ep</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_uframe</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">splits</span><span class="p">;</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_results</span> <span class="o">=</span> <span class="n">uf</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="p">;</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_backpointer</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="n">bufp</span> <span class="o">=</span> <span class="n">uf</span><span class="o">-&gt;</span><span class="n">bufp</span><span class="p">;</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">bufp</span><span class="p">);</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_buf_hi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">bufp</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">uf</span><span class="o">-&gt;</span><span class="n">buf1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uf</span><span class="o">-&gt;</span><span class="n">cross</span><span class="p">)</span>
		<span class="n">bufp</span> <span class="o">+=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_buf_hi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">bufp</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sitd_link</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">frame</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_sitd</span> <span class="o">*</span><span class="n">sitd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* note: sitd ordering could matter (CSPLIT then SSPLIT) */</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_next</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="p">[</span><span class="n">frame</span><span class="p">].</span><span class="n">sitd</span> <span class="o">=</span> <span class="n">sitd</span><span class="p">;</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
	<span class="n">wmb</span> <span class="p">();</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_dma</span> <span class="o">|</span> <span class="n">Q_TYPE_SITD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* fit urb&#39;s sitds into the selected schedule slot; activate as needed */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sitd_link_urb</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">mod</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">packet</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">next_uframe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_sched</span>	<span class="o">*</span><span class="n">sched</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_sitd</span>	<span class="o">*</span><span class="n">sitd</span><span class="p">;</span>

	<span class="n">next_uframe</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* usbfs ignores TT bandwidth */</span>
		<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span>
				<span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bandwidth</span><span class="p">;</span>
		<span class="n">ehci_vdbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
			<span class="s">&quot;sched devp %s ep%d%s-iso [%d] %dms/%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span>
			<span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">next_uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">,</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">splits</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">amd_pll_fix</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">usb_amd_quirk_pll_disable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* fill sITDs frame by frame */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">packet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sitd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">packet</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
			<span class="n">packet</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* ASSERT:  we have all necessary sitds */</span>
		<span class="n">BUG_ON</span> <span class="p">(</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">));</span>

		<span class="cm">/* ASSERT:  no itds for this endpoint in this frame */</span>

		<span class="n">sitd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ehci_sitd</span><span class="p">,</span> <span class="n">sitd_list</span><span class="p">);</span>
		<span class="n">list_move_tail</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
		<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="n">iso_stream_get</span> <span class="p">(</span><span class="n">stream</span><span class="p">);</span>
		<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

		<span class="n">sitd_patch</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">sitd</span><span class="p">,</span> <span class="n">sched</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
		<span class="n">sitd_link</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">next_uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">sitd</span><span class="p">);</span>

		<span class="n">next_uframe</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">next_uframe</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* don&#39;t need that schedule data any more */</span>
	<span class="n">iso_sched_free</span> <span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">sched</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">timer_action</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">enable_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define	SITD_ERRS (SITD_STS_ERR | SITD_STS_DBE | SITD_STS_BABBLE \</span>
<span class="cp">				| SITD_STS_XACT | SITD_STS_MMF)</span>

<span class="cm">/* Process and recycle a completed SITD.  Return true iff its urb completed,</span>
<span class="cm"> * and hence its completion callback probably added things to the hardware</span>
<span class="cm"> * schedule.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we carefully avoid recycling this descriptor until after any</span>
<span class="cm"> * completion callback runs, so that it won&#39;t be reused quickly.  That is,</span>
<span class="cm"> * assuming (a) no more than two urbs per frame on this endpoint, and also</span>
<span class="cm"> * (b) only this endpoint&#39;s completions submit URBs.  It seems some silicon</span>
<span class="cm"> * corrupts things if you reuse completed descriptors very quickly...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">sitd_complete</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ehci_sitd</span>	<span class="o">*</span><span class="n">sitd</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span>				<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">sitd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span>					<span class="n">urb_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>			<span class="o">*</span><span class="n">stream</span> <span class="o">=</span> <span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>			<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span>				<span class="n">retval</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">urb_index</span> <span class="o">=</span> <span class="n">sitd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span> <span class="p">[</span><span class="n">urb_index</span><span class="p">];</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">hc32_to_cpup</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_results</span><span class="p">);</span>

	<span class="cm">/* report transfer status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">SITD_ERRS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">SITD_STS_DBE</span><span class="p">)</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span>
				<span class="o">?</span> <span class="o">-</span><span class="n">ENOSR</span>  <span class="cm">/* hc couldn&#39;t read */</span>
				<span class="o">:</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">;</span> <span class="cm">/* hc couldn&#39;t write */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">SITD_STS_BABBLE</span><span class="p">)</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="k">else</span> <span class="cm">/* XACT, MMF, etc */</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">SITD_LENGTH</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* handle completion now? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">urb_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* ASSERT: it&#39;s really the last sitd for this urb</span>
<span class="cm">	list_for_each_entry (sitd, &amp;stream-&gt;td_list, sitd_list)</span>
<span class="cm">		BUG_ON (sitd-&gt;urb == urb);</span>
<span class="cm">	 */</span>

	<span class="cm">/* give urb back to the driver; completion often (re)submits */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">disable_periodic</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_isoc_reqs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">amd_pll_fix</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">usb_amd_quirk_pll_enable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_allocated</span>
				<span class="o">-=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bandwidth</span><span class="p">;</span>
		<span class="n">ehci_vdbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
			<span class="s">&quot;deschedule devp %s ep%d%s-iso</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span>
			<span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iso_stream_put</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">clock_frame</span> <span class="o">!=</span> <span class="n">sitd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* OK to recycle this SITD now. */</span>
		<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">iso_stream_put</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* HW might remember this SITD, so we can&#39;t recycle it yet.</span>
<span class="cm">		 * Move it to a safe place until a new frame starts.</span>
<span class="cm">		 */</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">cached_sitd_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If iso_stream_put() were called here, stream</span>
<span class="cm">			 * would be freed.  Instead, just prevent reuse.</span>
<span class="cm">			 */</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sitd_submit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span><span class="p">;</span>

	<span class="cm">/* Get iso_stream head */</span>
	<span class="n">stream</span> <span class="o">=</span> <span class="n">iso_stream_find</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;can&#39;t get iso stream</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">!=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;can&#39;t change iso interval %d --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef EHCI_URB_TRACE</span>
	<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
		<span class="s">&quot;submit %p dev%s ep%d%s-iso len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">urb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
		<span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
		<span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* allocate SITDs */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sitd_urb_transaction</span> <span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;can&#39;t init sitds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* schedule ... need to lock */</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done_not_linked</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done_not_linked</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">iso_stream_schedule</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sitd_link_urb</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
<span class="nl">done_not_linked:</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iso_stream_put</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_cached_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_itd</span> <span class="o">*</span><span class="n">itd</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_sitd</span> <span class="o">*</span><span class="n">sitd</span><span class="p">,</span> <span class="o">*</span><span class="n">sn</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">itd</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">cached_itd_list</span><span class="p">,</span> <span class="n">itd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span> <span class="o">=</span> <span class="n">itd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
		<span class="n">itd</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">iso_stream_put</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sitd</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">cached_sitd_list</span><span class="p">,</span> <span class="n">sitd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_iso_stream</span>	<span class="o">*</span><span class="n">stream</span> <span class="o">=</span> <span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
		<span class="n">sitd</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">iso_stream_put</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">scan_periodic</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">now_uframe</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">clock_frame</span><span class="p">,</span> <span class="n">mod</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">modified</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When running, scan from last scan point up to &quot;now&quot;</span>
<span class="cm">	 * else clean up by scanning everything that&#39;s left.</span>
<span class="cm">	 * Touches as few pages as possible:  cache-friendly.</span>
<span class="cm">	 */</span>
	<span class="n">now_uframe</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_uframe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
		<span class="n">clock_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">clock</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="n">now_uframe</span> <span class="o">+</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">clock_frame</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">clock_frame</span> <span class="o">!=</span> <span class="n">clock_frame</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_cached_lists</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">clock_frame</span> <span class="o">=</span> <span class="n">clock_frame</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clock</span> <span class="o">&amp;=</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">clock_frame</span> <span class="o">=</span> <span class="n">clock</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="o">++</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_stamp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">q_p</span><span class="p">;</span>
		<span class="n">__hc32</span>			<span class="n">type</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">;</span>
		<span class="kt">unsigned</span>		<span class="n">incomplete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">frame</span> <span class="o">=</span> <span class="n">now_uframe</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

<span class="nl">restart:</span>
		<span class="cm">/* scan each element in frame&#39;s queue for completions */</span>
		<span class="n">q_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">pshadow</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
		<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic</span> <span class="p">[</span><span class="n">frame</span><span class="p">];</span>
		<span class="n">q</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">q_p</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_p</span><span class="p">);</span>
		<span class="n">modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span>		<span class="n">uf</span><span class="p">;</span>
			<span class="k">union</span> <span class="n">ehci_shadow</span>	<span class="n">temp</span><span class="p">;</span>
			<span class="kt">int</span>			<span class="n">live</span><span class="p">;</span>

			<span class="n">live</span> <span class="o">=</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">Q_TYPE_QH</span>:
				<span class="cm">/* handle any completions */</span>
				<span class="n">temp</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh_get</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">stamp</span> <span class="o">!=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_stamp</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">modified</span> <span class="o">=</span> <span class="n">qh_completions</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modified</span><span class="p">)</span>
						<span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">stamp</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_stamp</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="o">||</span>
							<span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span><span class="p">))</span>
						<span class="n">intr_deschedule</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">qh_put</span> <span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">qh</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">Q_TYPE_FSTN</span>:
				<span class="cm">/* for &quot;save place&quot; FSTNs, look at QH entries</span>
<span class="cm">				 * in the previous frame for completions.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">hw_prev</span> <span class="o">!=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
						<span class="s">&quot;ignoring completions from FSTNs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">fstn</span><span class="o">-&gt;</span><span class="n">fstn_next</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">Q_TYPE_ITD</span>:
				<span class="cm">/* If this ITD is still active, leave it for</span>
<span class="cm">				 * later processing ... check the next entry.</span>
<span class="cm">				 * No need to check for activity unless the</span>
<span class="cm">				 * frame is current.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">frame</span> <span class="o">==</span> <span class="n">clock_frame</span> <span class="o">&amp;&amp;</span> <span class="n">live</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">rmb</span><span class="p">();</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">uf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uf</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">uf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_transaction</span><span class="p">[</span><span class="n">uf</span><span class="p">]</span> <span class="o">&amp;</span>
							    <span class="n">ITD_ACTIVE</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span>
							<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">uf</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">incomplete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
						<span class="n">q_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_next</span><span class="p">;</span>
						<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
						<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
							<span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
						<span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">q_p</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="cm">/* Take finished ITDs out of the schedule</span>
<span class="cm">				 * and process them:  recycle, maybe report</span>
<span class="cm">				 * URB completion.  HC won&#39;t cache the</span>
<span class="cm">				 * pointer for much longer, if at all.</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">q_p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">itd_next</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">use_dummy_qh</span> <span class="o">||</span>
				    <span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">!=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span>
					<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">;</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">wmb</span><span class="p">();</span>
				<span class="n">modified</span> <span class="o">=</span> <span class="n">itd_complete</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">itd</span><span class="p">);</span>
				<span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">q_p</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">Q_TYPE_SITD</span>:
				<span class="cm">/* If this SITD is still active, leave it for</span>
<span class="cm">				 * later processing ... check the next entry.</span>
<span class="cm">				 * No need to check for activity unless the</span>
<span class="cm">				 * frame is current.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(((</span><span class="n">frame</span> <span class="o">==</span> <span class="n">clock_frame</span><span class="p">)</span> <span class="o">||</span>
				     <span class="p">(((</span><span class="n">frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
				      <span class="o">==</span> <span class="n">clock_frame</span><span class="p">))</span>
				    <span class="o">&amp;&amp;</span> <span class="n">live</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_results</span> <span class="o">&amp;</span>
					<span class="n">SITD_ACTIVE</span><span class="p">(</span><span class="n">ehci</span><span class="p">)))</span> <span class="p">{</span>

					<span class="n">incomplete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="n">q_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_next</span><span class="p">;</span>
					<span class="n">hw_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
					<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
							<span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
					<span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">q_p</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Take finished SITDs out of the schedule</span>
<span class="cm">				 * and process them:  recycle, maybe report</span>
<span class="cm">				 * URB completion.</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">q_p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">sitd_next</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">use_dummy_qh</span> <span class="o">||</span>
				    <span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">!=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span>
					<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="o">*</span><span class="n">hw_p</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">;</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">Q_NEXT_TYPE</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">);</span>
				<span class="n">wmb</span><span class="p">();</span>
				<span class="n">modified</span> <span class="o">=</span> <span class="n">sitd_complete</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">sitd</span><span class="p">);</span>
				<span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">q_p</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;corrupt type %d frame %d shadow %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">type</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>BUG ();</p></td><td class="code"><div class="highlight"><pre>				<span class="n">q</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* assume completion callbacks modify the queue */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">modified</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_sched</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
				<span class="cm">/* short-circuit this scan */</span>
				<span class="n">now_uframe</span> <span class="o">=</span> <span class="n">clock</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* If we can tell we caught up to the hardware, stop now.</span>
<span class="cm">		 * We can&#39;t advance our scan without collecting the ISO</span>
<span class="cm">		 * transfers that are still pending in this frame.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">incomplete</span> <span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">now_uframe</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>FIXME:  this assumes we won't get lapped when
latencies climb; that should be rare, but...
detect it, and just go all the way around.
FLR might help detect this case, so long as latencies
don't exceed periodic_size msec (default 1.024 sec).</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>FIXME:  likewise assumes HC doesn't halt mid-scan</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">now_uframe</span> <span class="o">==</span> <span class="n">clock</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span>	<span class="n">now</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_RUNNING</span>
					<span class="o">||</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_sched</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_uframe</span> <span class="o">=</span> <span class="n">now_uframe</span><span class="p">;</span>
			<span class="n">now</span> <span class="o">=</span> <span class="n">ehci_read_frame_index</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">now_uframe</span> <span class="o">==</span> <span class="n">now</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* rescan the rest of this frame, then ... */</span>
			<span class="n">clock</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
			<span class="n">clock_frame</span> <span class="o">=</span> <span class="n">clock</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">clock_frame</span> <span class="o">!=</span> <span class="n">clock_frame</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_cached_lists</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
				<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">clock_frame</span> <span class="o">=</span> <span class="n">clock_frame</span><span class="p">;</span>
				<span class="o">++</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_stamp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">now_uframe</span><span class="o">++</span><span class="p">;</span>
			<span class="n">now_uframe</span> <span class="o">&amp;=</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
