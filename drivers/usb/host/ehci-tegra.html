<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › ehci-tegra.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ehci-tegra.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * EHCI-compliant USB host controller driver for NVIDIA Tegra SoCs</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010 Google, Inc.</span>
<span class="cm"> * Copyright (C) 2009 NVIDIA Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/platform_data/tegra_usb.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/usb/otg.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_gpio.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>

<span class="cp">#include &lt;mach/usb_phy.h&gt;</span>
<span class="cp">#include &lt;mach/iomap.h&gt;</span>

<span class="cp">#define TEGRA_USB_DMA_ALIGN 32</span>

<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tegra_usb_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">emc_clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_phy</span> <span class="o">*</span><span class="n">transceiver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_resumed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port_resuming</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">tegra_usb_phy_port_speed</span> <span class="n">port_speed</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tegra_ehci_power_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">tegra_usb_phy_power_on</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">host_resumed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tegra_ehci_power_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>

	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">host_resumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tegra_usb_phy_power_off</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_internal_port_reset</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>	<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">portsc_reg</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">,</span> <span class="n">tries</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">saved_usbintr</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">saved_usbintr</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>
	<span class="cm">/* disable USB interrupt */</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we have to do Port Reset at most twice for</span>
<span class="cm">	 * Port Enable bit to be set.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">portsc_reg</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_RESET</span><span class="p">;</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">portsc_reg</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_RESET</span><span class="p">;</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">portsc_reg</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">tries</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Up to this point, Port Enable bit is</span>
<span class="cm">			 * expected to be set after 2 ms waiting.</span>
<span class="cm">			 * USB1 usually takes extra 45 ms, for safety,</span>
<span class="cm">			 * we take 100 ms as timeout.</span>
<span class="cm">			 */</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">portsc_reg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tries</span><span class="o">--</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Connect Status Change bit if it&#39;s set.</span>
<span class="cm">	 * We can&#39;t clear PORT_PEC. It will also cause PORT_PE to be cleared.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CSC</span><span class="p">)</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">PORT_CSC</span><span class="p">,</span> <span class="n">portsc_reg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write to clear any interrupt status bits that might be set</span>
<span class="cm">	 * during port reset.</span>
<span class="cm">	 */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* restore original interrupt enable bits */</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">saved_usbintr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intr_enable</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_hub_control</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>	<span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
	<span class="n">u16</span>		<span class="n">typeReq</span><span class="p">,</span>
	<span class="n">u16</span>		<span class="n">wValue</span><span class="p">,</span>
	<span class="n">u16</span>		<span class="n">wIndex</span><span class="p">,</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="n">u16</span>		<span class="n">wLength</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>	<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">status_reg</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status_reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[(</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">typeReq</span> <span class="o">==</span> <span class="n">GetPortStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_resuming</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Resume completed, re-enable disconnect detection */</span>
			<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_resuming</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tegra_usb_phy_postresume</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">typeReq</span> <span class="o">==</span> <span class="n">SetPortFeature</span> <span class="o">&amp;&amp;</span> <span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_PORT_FEAT_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_WKCONN_E</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_WKDISC_E</span> <span class="o">|</span> <span class="n">PORT_WKOC_E</span><span class="p">;</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_SUSPEND</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If a transaction is in progress, there may be a delay in</span>
<span class="cm">		 * suspending the port. Poll until the port is suspended.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">,</span> <span class="n">PORT_SUSPEND</span><span class="p">,</span>
						<span class="n">PORT_SUSPEND</span><span class="p">,</span> <span class="mi">5000</span><span class="p">))</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: timeout waiting for SUSPEND</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="n">set_bit</span><span class="p">((</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">suspended_ports</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For USB1 port we need to issue Port Reset twice internally */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">typeReq</span> <span class="o">==</span> <span class="n">SetPortFeature</span> <span class="o">&amp;&amp;</span> <span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_PORT_FEAT_RESET</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">tegra_ehci_internal_port_reset</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tegra host controller will time the resume operation to clear the bit</span>
<span class="cm">	 * when the port control state switches to HS or FS Idle. This behavior</span>
<span class="cm">	 * is different from EHCI where the host controller driver is required</span>
<span class="cm">	 * to set this bit to a zero after the resume duration is timed in the</span>
<span class="cm">	 * driver.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">typeReq</span> <span class="o">==</span> <span class="n">ClearPortFeature</span> <span class="o">&amp;&amp;</span>
					<span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_PORT_FEAT_SUSPEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_SUSPEND</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="cm">/* Disable disconnect detection during port resume */</span>
		<span class="n">tegra_usb_phy_preresume</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>

		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_WAKE_BITS</span><span class="p">);</span>
		<span class="cm">/* start resume signalling */</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_RESUME</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">wIndex</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">resuming_ports</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Poll until the controller clears RESUME and SUSPEND */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">,</span> <span class="n">PORT_RESUME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: timeout waiting for RESUME</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">,</span> <span class="n">PORT_SUSPEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: timeout waiting for SUSPEND</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reset_done</span><span class="p">[</span><span class="n">wIndex</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">wIndex</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">resuming_ports</span><span class="p">);</span>

		<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_resuming</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Handle the hub control events here */</span>
	<span class="k">return</span> <span class="n">ehci_hub_control</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wLength</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tegra_ehci_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">ehci_reset</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="cm">/* setup the frame list and Async q heads */</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">frame_list</span><span class="p">);</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">async_next</span><span class="p">);</span>
	<span class="cm">/* setup the command register and set the controller in RUN mode */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CMD_LRESET</span><span class="o">|</span><span class="n">CMD_IAAD</span><span class="o">|</span><span class="n">CMD_PSE</span><span class="o">|</span><span class="n">CMD_ASE</span><span class="o">|</span><span class="n">CMD_RESET</span><span class="p">);</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_RUN</span><span class="p">;</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">FLAG_CF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">configured_flag</span><span class="p">);</span>
	<span class="cm">/* flush posted writes */</span>
	<span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci_cf_port_reset_rwsem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tegra_ehci_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">);</span>

	<span class="cm">/* ehci_shutdown touches the USB controller registers, make sure</span>
<span class="cm">	 * controller has clocks to it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">host_resumed</span><span class="p">)</span>
		<span class="n">tegra_ehci_power_up</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">ehci_shutdown</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* EHCI registers start at offset 0x100 */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="mh">0x100</span> <span class="o">+</span>
		<span class="n">HC_LENGTH</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hc_capbase</span><span class="p">));</span>

	<span class="n">dbg_hcs_params</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">);</span>
	<span class="n">dbg_hcc_params</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">);</span>

	<span class="cm">/* cache this readonly data; minimize chip reads */</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">hcs_params</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">caps</span><span class="o">-&gt;</span><span class="n">hcs_params</span><span class="p">);</span>

	<span class="cm">/* switch to host mode */</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">has_tt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ehci_reset</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">ehci_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* data structure init */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ehci_init</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">sbrn</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>

	<span class="n">ehci_port_power</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dma_aligned_buffer</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kmalloc_ptr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">old_xfer_buffer</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_dma_aligned_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_aligned_buffer</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ALIGNED_TEMP_BUFFER</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dma_aligned_buffer</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_urb_dir_in</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">old_xfer_buffer</span><span class="p">,</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
		       <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">old_xfer_buffer</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">kmalloc_ptr</span><span class="p">);</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">URB_ALIGNED_TEMP_BUFFER</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_dma_aligned_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_aligned_buffer</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span> <span class="o">*</span><span class="n">kmalloc_ptr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">kmalloc_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span> <span class="o">||</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">||</span>
	    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TEGRA_USB_DMA_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Allocate a buffer with enough padding for alignment */</span>
	<span class="n">kmalloc_size</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_aligned_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">TEGRA_USB_DMA_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">kmalloc_ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">kmalloc_size</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmalloc_ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Position our struct dma_aligned_buffer such that data is aligned */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">kmalloc_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TEGRA_USB_DMA_ALIGN</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">temp</span><span class="o">-&gt;</span><span class="n">kmalloc_ptr</span> <span class="o">=</span> <span class="n">kmalloc_ptr</span><span class="p">;</span>
	<span class="n">temp</span><span class="o">-&gt;</span><span class="n">old_xfer_buffer</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_urb_dir_out</span><span class="p">(</span><span class="n">urb</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
		       <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_ALIGNED_TEMP_BUFFER</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_map_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				      <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_dma_aligned_buffer</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_hcd_map_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">free_dma_aligned_buffer</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tegra_ehci_unmap_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_hcd_unmap_urb_for_dma</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">free_dma_aligned_buffer</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="n">tegra_ehci_hc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">description</span>		<span class="o">=</span> <span class="n">hcd_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">product_desc</span>		<span class="o">=</span> <span class="s">&quot;Tegra EHCI Host Controller&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hcd_priv_size</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span><span class="p">),</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">HCD_USB2</span> <span class="o">|</span> <span class="n">HCD_MEMORY</span><span class="p">,</span>

	<span class="cm">/* standard ehci functions */</span>
	<span class="p">.</span><span class="n">irq</span>			<span class="o">=</span> <span class="n">ehci_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>			<span class="o">=</span> <span class="n">ehci_run</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>			<span class="o">=</span> <span class="n">ehci_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">urb_enqueue</span>		<span class="o">=</span> <span class="n">ehci_urb_enqueue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">urb_dequeue</span>		<span class="o">=</span> <span class="n">ehci_urb_dequeue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint_disable</span>	<span class="o">=</span> <span class="n">ehci_endpoint_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">endpoint_reset</span>		<span class="o">=</span> <span class="n">ehci_endpoint_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_frame_number</span>	<span class="o">=</span> <span class="n">ehci_get_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hub_status_data</span>	<span class="o">=</span> <span class="n">ehci_hub_status_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_tt_buffer_complete</span> <span class="o">=</span> <span class="n">ehci_clear_tt_buffer_complete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">relinquish_port</span>	<span class="o">=</span> <span class="n">ehci_relinquish_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">port_handed_over</span>	<span class="o">=</span> <span class="n">ehci_port_handed_over</span><span class="p">,</span>

	<span class="cm">/* modified ehci functions for tegra */</span>
	<span class="p">.</span><span class="n">reset</span>			<span class="o">=</span> <span class="n">tegra_ehci_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>		<span class="o">=</span> <span class="n">tegra_ehci_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_urb_for_dma</span>	<span class="o">=</span> <span class="n">tegra_ehci_map_urb_for_dma</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_urb_for_dma</span>	<span class="o">=</span> <span class="n">tegra_ehci_unmap_urb_for_dma</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hub_control</span>		<span class="o">=</span> <span class="n">tegra_ehci_hub_control</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">bus_suspend</span>		<span class="o">=</span> <span class="n">ehci_bus_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_resume</span>		<span class="o">=</span> <span class="n">ehci_bus_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_vbus_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tegra_ehci_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gpio</span><span class="p">;</span>

	<span class="n">gpio</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">vbus_gpio</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="n">gpio</span> <span class="o">=</span> <span class="n">of_get_named_gpio</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span>
					 <span class="s">&quot;nvidia,vbus-gpio&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="s">&quot;vbus_gpio&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t request vbus gpio %d&quot;</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t enable vbus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">controller_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span>
			<span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>	<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">tegra</span><span class="o">-&gt;</span><span class="n">ehci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">next_statechange</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">ehci_halt</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tegra_ehci_power_down</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">controller_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span>
			<span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>	<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">tegra</span><span class="o">-&gt;</span><span class="n">ehci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_HW_ACCESSIBLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">tegra_ehci_power_up</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_speed</span> <span class="o">&gt;</span> <span class="n">TEGRA_USB_PHY_PORT_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wait for the phy to detect new devices</span>
<span class="cm">		 * before we restart the controller */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Force the phy to keep data lines in suspend state */</span>
	<span class="n">tegra_ehci_phy_restore_start</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">,</span> <span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_speed</span><span class="p">);</span>

	<span class="cm">/* Enable host mode */</span>
	<span class="n">tdi_reset</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="cm">/* Enable Port Power */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">PORT_POWER</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* Check if the phy resume from LP0. When the phy resume from LP0</span>
<span class="cm">	 * USB register will be reset. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">async_next</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Program the field PTC based on the saved speed mode */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_TEST</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_speed</span> <span class="o">==</span> <span class="n">TEGRA_USB_PHY_PORT_SPEED_HIGH</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">PORT_TEST_FORCE</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_speed</span> <span class="o">==</span> <span class="n">TEGRA_USB_PHY_PORT_SPEED_FULL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">PORT_TEST</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_speed</span> <span class="o">==</span> <span class="n">TEGRA_USB_PHY_PORT_SPEED_LOW</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">PORT_TEST</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="cm">/* Disable test mode by setting PTC field to NORMAL_OP */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_TEST</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Poll until CCS is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PORT_CONNECT</span><span class="p">,</span>
						 <span class="n">PORT_CONNECT</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: timeout waiting for PORT_CONNECT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Poll until PE is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PORT_PE</span><span class="p">,</span>
						 <span class="n">PORT_PE</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: timeout waiting for USB_PORTSC1_PE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear the PCI status, to avoid an interrupt taken upon resume */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">STS_PCD</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* Put controller in suspend mode by writing 1 to SUSP bit of PORTSC */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PORT_POWER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">PORT_SUSPEND</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="cm">/* Wait until port suspend completes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PORT_SUSPEND</span><span class="p">,</span>
							 <span class="n">PORT_SUSPEND</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: timeout waiting for PORT_SUSPEND</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tegra_ehci_phy_restore_end</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

 <span class="nl">restart:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_speed</span> <span class="o">&lt;=</span> <span class="n">TEGRA_USB_PHY_PORT_SPEED_HIGH</span><span class="p">)</span>
		<span class="n">tegra_ehci_phy_restore_end</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>

	<span class="n">tegra_ehci_restart</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="n">tegra_usb_phy_preresume</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">port_resuming</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span>
			<span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">ehci</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When system sleep is supported and USB controller wakeup is</span>
<span class="cm">	 * implemented: If the controller is runtime-suspended and the</span>
<span class="cm">	 * wakeup setting needs to be changed, call pm_runtime_resume().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">controller_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">controller_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">controller_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">controller_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">tegra_ehci_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">tegra_ehci_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">tegra_ehci_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_suspend</span> <span class="o">=</span> <span class="n">tegra_ehci_runtime_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_resume</span>	<span class="o">=</span> <span class="n">tegra_ehci_runtime_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">tegra_ehci_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Platform data missing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Right now device-tree probed devices don&#39;t get dma_mask set.</span>
<span class="cm">	 * Since shared usb code relies on it, set it here for now.</span>
<span class="cm">	 * Once we have dma capability bindings this can go away.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tegra_ehci_dma_mask</span><span class="p">;</span>

	<span class="n">setup_vbus_gpio</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>

	<span class="n">tegra</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tegra_ehci_hcd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tegra</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">hcd</span> <span class="o">=</span> <span class="n">usb_create_hcd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tegra_ehci_hc_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to create HCD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_hcd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tegra</span><span class="p">);</span>

	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get ehci clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">clk_enable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_clken</span><span class="p">;</span>

	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;emc&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get emc clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_emc_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>
	<span class="n">clk_set_rate</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">,</span> <span class="mi">400000000</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to get I/O memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_io</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_start</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">rsrc_len</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to remap I/O memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_io</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is pretty ugly and needs to be fixed when we do only</span>
<span class="cm">	 * device-tree probing. Old code relies on the platform_device</span>
<span class="cm">	 * numbering that we lack for device-tree-instantiated devices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TEGRA_USB_BASE</span>:
			<span class="n">instance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TEGRA_USB2_BASE</span>:
			<span class="n">instance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TEGRA_USB3_BASE</span>:
			<span class="n">instance</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown usb instance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_phy</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span> <span class="o">=</span> <span class="n">tegra_usb_phy_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span>
					<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">phy_config</span><span class="p">,</span>
					<span class="n">TEGRA_USB_PHY_MODE_HOST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to open USB phy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_phy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">tegra_usb_phy_power_on</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to power on the phy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">host_resumed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to get IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_USB_OTG_UTILS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">operating_mode</span> <span class="o">==</span> <span class="n">TEGRA_USB_OTG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">usb_get_transceiver</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span>
			<span class="n">otg_set_host</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_add_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to add USB HCD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t skip the pm_runtime_forbid call if wakeup isn&#39;t working */</span>
	<span class="cm">/* if (!pdata-&gt;power_down_on_bus_suspend) */</span>
		<span class="n">pm_runtime_forbid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">fail:</span>
<span class="cp">#ifdef CONFIG_USB_OTG_UTILS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">otg_set_host</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">usb_put_transceiver</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">tegra_usb_phy_close</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
<span class="nl">fail_phy:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">fail_io:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>
<span class="nl">fail_emc_clk:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">fail_clken:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">fail_clk:</span>
	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="nl">fail_hcd:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tegra</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_ehci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">ehci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">hcd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_USB_OTG_UTILS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">otg_set_host</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">-&gt;</span><span class="n">otg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">usb_put_transceiver</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">usb_remove_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">usb_put_hcd</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">tegra_usb_phy_close</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">emc_clk</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">tegra</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tegra_ehci_hcd_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tegra_ehci_hcd</span> <span class="o">*</span><span class="n">tegra</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">tegra</span><span class="o">-&gt;</span><span class="n">ehci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">tegra_ehci_of_match</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;nvidia,tegra20-ehci&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">tegra_ehci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">tegra_ehci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">tegra_ehci_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">tegra_ehci_hcd_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;tegra-ehci&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">tegra_ehci_of_match</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
		<span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">tegra_ehci_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
