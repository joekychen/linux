<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › ehci-q.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ehci-q.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001-2004 by David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/* this file is part of ehci-hcd.c */</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * EHCI hardware queue manipulation ... the core.  QH/QTD manipulation.</span>
<span class="cm"> *</span>
<span class="cm"> * Control, bulk, and interrupt traffic all use &quot;qh&quot; lists.  They list &quot;qtd&quot;</span>
<span class="cm"> * entries describing USB transactions, max 16-20kB/entry (with 4kB-aligned</span>
<span class="cm"> * buffers needed for the larger number).  We use one QH per endpoint, queue</span>
<span class="cm"> * multiple urbs (all three types) per endpoint.  URBs may need several qtds.</span>
<span class="cm"> *</span>
<span class="cm"> * ISO traffic uses &quot;ISO TD&quot; (itd, and sitd) records, and (along with</span>
<span class="cm"> * interrupts) needs careful scheduling.  Performance improvements can be</span>
<span class="cm"> * an ongoing challenge.  That&#39;s in &quot;ehci-sched.c&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * USB 1.1 devices are handled (a) by &quot;companion&quot; OHCI or UHCI root hubs,</span>
<span class="cm"> * or otherwise through transaction translators (TTs) in USB 2.0 hubs using</span>
<span class="cm"> * (b) special fields in qh entries or (c) split iso entries.  TTs will</span>
<span class="cm"> * buffer low/full speed data so the host collects it at high speed.</span>
<span class="cm"> */</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* fill a qtd, returning how much of the buffer we were able to queue up */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">qtd_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">,</span>
		  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">token</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxpacket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* one buffer entry per 4K ... first might be short or unaligned */</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf_hi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="p">(</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="mh">0x0fff</span><span class="p">);</span>	<span class="cm">/* rest of that page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">))</span>		<span class="cm">/* ... iff needed */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">+=</span>  <span class="mh">0x1000</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x0fff</span><span class="p">;</span>

		<span class="cm">/* per-qtd limit: from 16K to 20K (best alignment) */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_buf_hi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">count</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* short packets may only terminate transfers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">-=</span> <span class="p">(</span><span class="n">count</span> <span class="o">%</span> <span class="n">maxpacket</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">token</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">qh_update</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* writes to an active overlay are unsafe */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_IDLE</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_qtd_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="cm">/* Except for control endpoints, we make hardware maintain data</span>
<span class="cm">	 * toggle (like OHCI) ... here (re)initialize the toggle in the QH,</span>
<span class="cm">	 * and set the pseudo-toggle in udev. Only usb_clear_halt() will</span>
<span class="cm">	 * ever clear it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">&amp;</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">is_out</span><span class="p">,</span> <span class="n">epnum</span><span class="p">;</span>

		<span class="n">is_out</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_out</span><span class="p">;</span>
		<span class="n">epnum</span> <span class="o">=</span> <span class="p">(</span><span class="n">hc32_to_cpup</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_gettoggle</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">is_out</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QTD_TOGGLE</span><span class="p">);</span>
			<span class="n">usb_settoggle</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">is_out</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">&amp;=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QTD_TOGGLE</span> <span class="o">|</span> <span class="n">QTD_STS_PING</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* if it weren&#39;t for a common silicon quirk (writing the dummy into the qh</span>
<span class="cm"> * overlay, so qh-&gt;hw_token wrongly becomes inactive/halted), only fault</span>
<span class="cm"> * recovery (including urb dequeue) would need software changes to a QH...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">qh_refresh</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
		<span class="cm">/* first qtd may already be partially processed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">)</span> <span class="o">==</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_current</span><span class="p">)</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span><span class="p">)</span>
		<span class="n">qh_update</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">qh_link_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_clear_tt_buffer_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span> <span class="o">=</span> <span class="n">hcd_to_ehci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">clearing_tt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span>
		<span class="n">qh_link_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehci_clear_tt_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* If an async split transaction gets an error or is unlinked,</span>
<span class="cm">	 * the TT buffer may be left in an indeterminate state.  We</span>
<span class="cm">	 * have to clear the TT buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: this routine is never called for Isochronous transfers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">usb_pipeint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">clearing_tt</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">tt</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">hub</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;clear tt buffer port %d, a%d ep%d t%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ttport</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span>
			<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span> <span class="n">token</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci_is_TDI</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span>
				<span class="o">||</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">hub</span> <span class="o">!=</span>
				   <span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_hub_clear_tt_buffer</span><span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">clearing_tt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="cm">/* REVISIT ARC-derived cores don&#39;t clear the root</span>
<span class="cm">			 * hub TT buffer in this way...</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qtd_copy_status</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">token</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

	<span class="cm">/* count IN/OUT bytes, not SETUP (even short packets) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">QTD_PID</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">QTD_LENGTH</span> <span class="p">(</span><span class="n">token</span><span class="p">);</span>

	<span class="cm">/* don&#39;t modify error codes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* force cleanup after short read; not always an error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">IS_SHORT_READ</span> <span class="p">(</span><span class="n">token</span><span class="p">)))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>

	<span class="cm">/* serious &quot;can&#39;t proceed&quot; faults reported by the hardware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_HALT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_BABBLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIXME &quot;must&quot; disable babbling device&#39;s port too */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="cm">/* CERR nonzero + halt --&gt; stall */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">QTD_CERR</span><span class="p">(</span><span class="n">token</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

		<span class="cm">/* In theory, more than one of the following bits can be set</span>
<span class="cm">		 * since they are sticky and the transaction is retried.</span>
<span class="cm">		 * Which to test first is rather arbitrary.</span>
<span class="cm">		 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_MMF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* fs/ls interrupt xfer missed the complete-split */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_DBE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">QTD_PID</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* IN ? */</span>
				<span class="o">?</span> <span class="o">-</span><span class="n">ENOSR</span>  <span class="cm">/* hc couldn&#39;t read data */</span>
				<span class="o">:</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">;</span> <span class="cm">/* hc couldn&#39;t write data */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_XACT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* timeout, bad CRC, wrong PID, etc */</span>
			<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;devpath %s ep%d%s 3strikes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span>
				<span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
				<span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* unknown */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ehci_vdbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
			<span class="s">&quot;dev%d ep%d%s qtd token %08x --&gt; status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">usb_pipedevice</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
			<span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
			<span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			<span class="n">token</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ehci_urb_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qh</span>	<span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

		<span class="cm">/* S-mask in a QH means it&#39;s an interrupt urb */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">&amp;</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QH_SMASK</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* ... update hc-wide periodic stats (for usbfs) */</span>
			<span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">bandwidth_int_reqs</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">qh_put</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">COUNT</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unlink</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* report non-error and short read status as zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">COUNT</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">complete</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef EHCI_URB_TRACE</span>
	<span class="n">ehci_dbg</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
		<span class="s">&quot;%s %s urb %p ep%d%s status %d len %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
		<span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span>
		<span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
		<span class="n">status</span><span class="p">,</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* complete() can reenter this HCD */</span>
	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">start_unlink_async</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">unlink_async</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">qh_schedule</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Process and free completed qtds for a qh, returning URBs to drivers.</span>
<span class="cm"> * Chases up to qh-&gt;hw_current.  Returns number of completions called,</span>
<span class="cm"> * indicating how much &quot;real&quot; work we did.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">qh_completions</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span>		<span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">last_status</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">stopped</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* completions (or tasks on other cpus) must never clobber HALT</span>
<span class="cm">	 * till we&#39;ve gone through and cleaned everything up, even when</span>
<span class="cm">	 * they add urbs to this qh&#39;s queue or mark them for unlinking.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:  unlinking expects to be done in queue order.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It&#39;s a bug for qh-&gt;qh_state to be anything other than</span>
<span class="cm">	 * QH_STATE_IDLE, unless our caller is scan_async() or</span>
<span class="cm">	 * scan_periodic().</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_COMPLETING</span><span class="p">;</span>
	<span class="n">stopped</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">);</span>

 <span class="nl">rescan:</span>
	<span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">last_status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* remove de-activated QTDs from front of queue.</span>
<span class="cm">	 * after faults (including short reads), cleanup this urb</span>
<span class="cm">	 * then let the queue advance.</span>
<span class="cm">	 * if queue is stopped, handles unlinks.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_safe</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
		<span class="n">u32</span>		<span class="n">token</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

		<span class="cm">/* clean up any state from previous QTD ...*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">!=</span> <span class="n">urb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">last_status</span><span class="p">);</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">last_status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ehci_qtd_free</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
			<span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* ignore urbs submitted during completions we reported */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qtd</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* hardware copies qtd out of qh overlay */</span>
		<span class="n">rmb</span> <span class="p">();</span>
		<span class="n">token</span> <span class="o">=</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span><span class="p">);</span>

		<span class="cm">/* always clean up qtds the hc de-activated */</span>
 <span class="nl">retry_xacterr:</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Report Data Buffer Error: non-fatal but useful */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_DBE</span><span class="p">)</span>
				<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
					<span class="s">&quot;detected DataBufferErr for urb %p ep%d%s len %d, qtd %p [qh %p]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">urb</span><span class="p">,</span>
					<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">),</span>
					<span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
					<span class="n">qtd</span><span class="p">,</span>
					<span class="n">qh</span><span class="p">);</span>

			<span class="cm">/* on STALL, error, and short reads this urb must</span>
<span class="cm">			 * complete and all its qtds must be recycled.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_HALT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* retry transaction errors until we</span>
<span class="cm">				 * reach the software xacterr limit</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">token</span> <span class="o">&amp;</span> <span class="n">QTD_STS_XACT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						<span class="n">QTD_CERR</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
						<span class="o">++</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">xacterrs</span> <span class="o">&lt;</span> <span class="n">QH_XACTERR_MAX</span> <span class="o">&amp;&amp;</span>
						<span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
	<span class="s">&quot;detected XactErr len %zu/%zu retry %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">QTD_LENGTH</span><span class="p">(</span><span class="n">token</span><span class="p">),</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">xacterrs</span><span class="p">);</span>

					<span class="cm">/* reset the token in the qtd and the</span>
<span class="cm">					 * qh overlay (which still contains</span>
<span class="cm">					 * the qtd) so that we pick up from</span>
<span class="cm">					 * where we left off</span>
<span class="cm">					 */</span>
					<span class="n">token</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QTD_STS_HALT</span><span class="p">;</span>
					<span class="n">token</span> <span class="o">|=</span> <span class="n">QTD_STS_ACTIVE</span> <span class="o">|</span>
							<span class="p">(</span><span class="n">EHCI_TUNE_CERR</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
					<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
							<span class="n">token</span><span class="p">);</span>
					<span class="n">wmb</span><span class="p">();</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
							<span class="n">token</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">retry_xacterr</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* magic dummy for some short reads; qh won&#39;t advance.</span>
<span class="cm">			 * that silicon quirk can kick in with this dummy too.</span>
<span class="cm">			 *</span>
<span class="cm">			 * other short reads won&#39;t stop the queue, including</span>
<span class="cm">			 * control transfers (status stage handles that) or</span>
<span class="cm">			 * most other single-qtd reads ... the queue stops if</span>
<span class="cm">			 * URB_SHORT_NOT_OK was set so the driver submitting</span>
<span class="cm">			 * the urbs could clean it up.</span>
<span class="cm">			 */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_SHORT_READ</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span>
						<span class="o">&amp;</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="cm">/* stop scanning when we reach qtds the hc is using */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="o">!</span><span class="n">stopped</span>
				<span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* scan the whole queue for unlinks whenever it stops */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* cancel everything if we halt, suspend, etc */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span>
				<span class="n">last_status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

			<span class="cm">/* this qtd is active; skip it unless a previous qtd</span>
<span class="cm">			 * for its urb faulted, or its urb was canceled.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">last_status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* qh unlinked; token in overlay may be most current */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span>
					<span class="o">&amp;&amp;</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">)</span>
						<span class="o">==</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_current</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">token</span> <span class="o">=</span> <span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_token</span><span class="p">);</span>

				<span class="cm">/* An unlink may leave an incomplete</span>
<span class="cm">				 * async transaction in the TT buffer.</span>
<span class="cm">				 * We have to clear it.</span>
<span class="cm">				 */</span>
				<span class="n">ehci_clear_tt_buffer</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* unless we already know the urb&#39;s status, collect qtd status</span>
<span class="cm">		 * and update count of bytes transferred.  in common short read</span>
<span class="cm">		 * cases with only one data qtd (including control transfers),</span>
<span class="cm">		 * queue processing won&#39;t halt.  but with two or more qtds (for</span>
<span class="cm">		 * example, with a 32 KB transfer), when the first qtd gets a</span>
<span class="cm">		 * short read the second must be removed by hand.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last_status</span> <span class="o">=</span> <span class="n">qtd_copy_status</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
					<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EREMOTEIO</span>
					<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span>
						<span class="o">&amp;</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">)))</span>
				<span class="n">last_status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

			<span class="cm">/* As part of low/full-speed endpoint-halt processing</span>
<span class="cm">			 * we must clear the TT buffer (11.17.5).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">last_status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span> <span class="o">&amp;&amp;</span>
					<span class="n">last_status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The TT&#39;s in some hubs malfunction when they</span>
<span class="cm">				 * receive this request following a STALL (they</span>
<span class="cm">				 * stop sending isochronous packets).  Since a</span>
<span class="cm">				 * STALL can&#39;t leave the TT buffer in a busy</span>
<span class="cm">				 * state (if you believe Figures 11-48 - 11-51</span>
<span class="cm">				 * in the USB 2.0 spec), we won&#39;t clear the TT</span>
<span class="cm">				 * buffer in this case.  Strictly speaking this</span>
<span class="cm">				 * is a violation of the spec.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">last_status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span>
					<span class="n">ehci_clear_tt_buffer</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
							<span class="n">token</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* if we&#39;re removing something not at the queue head,</span>
<span class="cm">		 * patch the hardware queue pointer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stopped</span> <span class="o">&amp;&amp;</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">prev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">last</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* remove qtd; it&#39;s recycled after possible urb completion */</span>
		<span class="n">list_del</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>

		<span class="cm">/* reinit the xacterr counter for the next qtd */</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">xacterrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* last urb&#39;s completion might still need calling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">last</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehci_urb_done</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">last_status</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ehci_qtd_free</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Do we need to rescan for URBs dequeued during a giveback? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If the QH is already unlinked, do the rescan now. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>

		<span class="cm">/* Otherwise we have to wait until the QH is fully unlinked.</span>
<span class="cm">		 * Our caller will start an unlink if qh-&gt;needs_rescan is</span>
<span class="cm">		 * set.  But if an unlink has already started, nothing needs</span>
<span class="cm">		 * to be done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">QH_STATE_LINKED</span><span class="p">)</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* restore original state; caller must unlink or relink */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* be sure the hardware&#39;s done with the qh before refreshing</span>
<span class="cm">	 * it after fault cleanup, or recovering from silicon wrongly</span>
<span class="cm">	 * overlaying the dummy qtd (which reduces DMA chatter).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stopped</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_qtd_next</span> <span class="o">==</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">QH_STATE_IDLE</span>:
			<span class="n">qh_refresh</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">QH_STATE_LINKED</span>:
			<span class="cm">/* We won&#39;t refresh a QH that&#39;s linked (after the HC</span>
<span class="cm">			 * stopped the queue).  That avoids a race:</span>
<span class="cm">			 *  - HC reads first part of QH;</span>
<span class="cm">			 *  - CPU updates that first part and the token;</span>
<span class="cm">			 *  - HC reads rest of that QH, including token</span>
<span class="cm">			 * Result:  HC gets an inconsistent image, and then</span>
<span class="cm">			 * DMAs to/from the wrong memory (corrupting it).</span>
<span class="cm">			 *</span>
<span class="cm">			 * That should be rare for interrupt transfers,</span>
<span class="cm">			 * except maybe high bandwidth ...</span>
<span class="cm">			 */</span>

			<span class="cm">/* Tell the caller to start an unlink */</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* otherwise, unlink already started */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>high bandwidth multiplier, as encoded in highspeed endpoint descriptors</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define hb_mult(wMaxPacketSize) (1 + (((wMaxPacketSize) &gt;&gt; 11) &amp; 0x03))</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>... and packet size, for any kind of endpoint descriptor</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define max_packet(wMaxPacketSize) ((wMaxPacketSize) &amp; 0x07ff)</span>

<span class="cm">/*</span>
<span class="cm"> * reverse of qh_urb_transaction:  free a list of TDs.</span>
<span class="cm"> * used for cleanup after errors, before HC sees an URB&#39;s TDs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qtd_list_free</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">qtd_list</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

		<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">list_del</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">ehci_qtd_free</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * create a list of filled qtds for this URB; won&#39;t link into qh.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span>
<span class="nf">qh_urb_transaction</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">flags</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qtd</span>		<span class="o">*</span><span class="n">qtd</span><span class="p">,</span> <span class="o">*</span><span class="n">qtd_prev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">,</span> <span class="n">this_sg_len</span><span class="p">,</span> <span class="n">maxpacket</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">is_input</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">token</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * URBs map to sequences of QTDs:  one logical transaction</span>
<span class="cm">	 */</span>
	<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_add_tail</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

	<span class="n">token</span> <span class="o">=</span> <span class="n">QTD_STS_ACTIVE</span><span class="p">;</span>
	<span class="n">token</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_CERR</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="cm">/* for split transactions, SplitXState initialized to zero */</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="n">is_input</span> <span class="o">=</span> <span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* SETUP pid */</span>
		<span class="n">qtd_fill</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_dma</span><span class="p">,</span>
				<span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">),</span>
				<span class="n">token</span> <span class="o">|</span> <span class="p">(</span><span class="mi">2</span> <span class="cm">/* &quot;setup&quot; */</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>

		<span class="cm">/* ... and always at least one more pid */</span>
		<span class="n">token</span> <span class="o">^=</span> <span class="n">QTD_TOGGLE</span><span class="p">;</span>
		<span class="n">qtd_prev</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">qtd_prev</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
		<span class="n">list_add_tail</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

		<span class="cm">/* for zero length DATA stages, STATUS is always IN */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">token</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="cm">/* &quot;in&quot; */</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * data transfer stage:  buffer setup</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_mapped_sgs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="cm">/* urb-&gt;transfer_buffer_length may be smaller than the</span>
<span class="cm">		 * size of the scatterlist (or vice versa)</span>
<span class="cm">		 */</span>
		<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>
		<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span>
		<span class="n">token</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="cm">/* &quot;in&quot; */</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* else it&#39;s already initted to &quot;out&quot; pid (0 &lt;&lt; 8) */</span>

	<span class="n">maxpacket</span> <span class="o">=</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="o">!</span><span class="n">is_input</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * buffer gets wrapped in one or more qtds;</span>
<span class="cm">	 * last one may be &quot;short&quot; (including zero len)</span>
<span class="cm">	 * and may serve as a control status ack</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">this_qtd_len</span><span class="p">;</span>

		<span class="n">this_qtd_len</span> <span class="o">=</span> <span class="n">qtd_fill</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">this_sg_len</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span>
				<span class="n">maxpacket</span><span class="p">);</span>
		<span class="n">this_sg_len</span> <span class="o">-=</span> <span class="n">this_qtd_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">this_qtd_len</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">this_qtd_len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * short reads advance to a &quot;magic&quot; dummy instead of the next</span>
<span class="cm">		 * qtd ... that forces the queue to stop, for manual cleanup.</span>
<span class="cm">		 * (this will usually be overridden later.)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span><span class="p">;</span>

		<span class="cm">/* qh makes control packets use qtd toggle; maybe switch it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">maxpacket</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">this_qtd_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">maxpacket</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">token</span> <span class="o">^=</span> <span class="n">QTD_TOGGLE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">this_sg_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">this_sg_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">qtd_prev</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">qtd_prev</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
		<span class="n">list_add_tail</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * unless the caller requires manual cleanup after short reads,</span>
<span class="cm">	 * have the alt_next mechanism keep the queue running after the</span>
<span class="cm">	 * last data qtd (the only one, for control and most other cases).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
				<span class="o">||</span> <span class="n">usb_pipecontrol</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)))</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_alt_next</span> <span class="o">=</span> <span class="n">EHCI_LIST_END</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * control requests may need a terminating data &quot;status&quot; ack;</span>
<span class="cm">	 * other OUT ones may need a terminating short packet</span>
<span class="cm">	 * (zero length).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">one_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">one_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">token</span> <span class="o">^=</span> <span class="mh">0x0100</span><span class="p">;</span>	<span class="cm">/* &quot;in&quot; &lt;--&gt; &quot;out&quot;  */</span>
			<span class="n">token</span> <span class="o">|=</span> <span class="n">QTD_TOGGLE</span><span class="p">;</span>	<span class="cm">/* force DATA1 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ZERO_PACKET</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">%</span> <span class="n">maxpacket</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">one_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">one_more</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qtd_prev</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="n">ehci_qtd_alloc</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">qtd</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
			<span class="n">qtd_prev</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
			<span class="n">list_add_tail</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

			<span class="cm">/* never any data in such packets */</span>
			<span class="n">qtd_fill</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* by default, enable interrupt on urb completion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_NO_INTERRUPT</span><span class="p">)))</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">QTD_IOC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">head</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="n">qtd_list_free</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Would be best to create all qh's from config descriptors,
when each interface/altsetting is established.  Unlink
any previous qh and cancel its urbs first; endpoints are
implicitly reset then (data toggle too).
That'd mean updating how usbcore talks to HCDs. (2.7?)</p></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Each QH holds a qtd list; a QH is used for everything except iso.</span>
<span class="cm"> *</span>
<span class="cm"> * For interrupt urbs, the scheduler must set the microframe scheduling</span>
<span class="cm"> * mask(s) each time the QH gets scheduled.  For highspeed, that&#39;s</span>
<span class="cm"> * just one microframe in the s-mask.  For split interrupt transactions</span>
<span class="cm"> * there are additional complications: c-mask, maybe FSTNs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span>
<span class="nf">qh_make</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">flags</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">ehci_qh_alloc</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">info1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">is_input</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">maxp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_tt</span>		<span class="o">*</span><span class="n">tt</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh_hw</span>	<span class="o">*</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * init endpoint/device data for this QH</span>
<span class="cm">	 */</span>
	<span class="n">info1</span> <span class="o">|=</span> <span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">info1</span> <span class="o">|=</span> <span class="n">usb_pipedevice</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">is_input</span> <span class="o">=</span> <span class="n">usb_pipein</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">usb_pipetype</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_maxpacket</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="o">!</span><span class="n">is_input</span><span class="p">);</span>

	<span class="cm">/* 1024 byte maxpacket is a hardware ceiling.  High bandwidth</span>
<span class="cm">	 * acts like up to 3KB, but is built from smaller packets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;bogus qh maxpacket %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Compute interrupt scheduling parameters just once, and save.</span>
<span class="cm">	 * - allowing for high bandwidth, how many nsec/uframe are used?</span>
<span class="cm">	 * - split transactions need a second CSPLIT uframe; same question</span>
<span class="cm">	 * - splits also need a schedule gap (for full/low speed I/O)</span>
<span class="cm">	 * - qh has a polling interval</span>
<span class="cm">	 *</span>
<span class="cm">	 * For control/bulk requests, the HC or TT handles these.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_INTERRUPT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">=</span> <span class="n">NS_TO_US</span><span class="p">(</span><span class="n">usb_calc_bus_time</span><span class="p">(</span><span class="n">USB_SPEED_HIGH</span><span class="p">,</span>
				<span class="n">is_input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">hb_mult</span><span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">)));</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">NO_FRAME</span><span class="p">;</span>
		<span class="n">qh</span><span class="o">-&gt;</span><span class="n">stamp</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_stamp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">gap_uf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* NOTE interval 2 or 4 uframes could work.</span>
<span class="cm">				 * But interval 1 scheduling is simpler, and</span>
<span class="cm">				 * includes high bandwidth.</span>
<span class="cm">				 */</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span>		<span class="n">think_time</span><span class="p">;</span>

			<span class="cm">/* gap is f(FS/LS transfer times) */</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">gap_uf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">usb_calc_bus_time</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span>
					<span class="n">is_input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">125</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

			<span class="cm">/* FIXME this just approximates SPLIT/CSPLIT times */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_input</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// SPLIT, gap, CSPLIT+DATA</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+</span> <span class="n">HS_USECS</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">=</span> <span class="n">HS_USECS</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="c1">// SPLIT+DATA, gap, CSPLIT</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">usecs</span> <span class="o">+=</span> <span class="n">HS_USECS</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">c_usecs</span> <span class="o">=</span> <span class="n">HS_USECS</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">think_time</span> <span class="o">=</span> <span class="n">tt</span> <span class="o">?</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">think_time</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">tt_usecs</span> <span class="o">=</span> <span class="n">NS_TO_US</span> <span class="p">(</span><span class="n">think_time</span> <span class="o">+</span>
					<span class="n">usb_calc_bus_time</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span>
					<span class="n">is_input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_packet</span> <span class="p">(</span><span class="n">maxp</span><span class="p">)));</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">periodic_size</span><span class="p">;</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* support for tt scheduling, and access to toggles */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* using TT? */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SPEED_LOW</span>:
		<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>	<span class="cm">/* EPS &quot;low&quot; */</span>
		<span class="cm">/* FALL THROUGH */</span>

	<span class="k">case</span> <span class="n">USB_SPEED_FULL</span>:
		<span class="cm">/* EPS 0 means &quot;full&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PIPE_INTERRUPT</span><span class="p">)</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_RL_TT</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span>	<span class="cm">/* for TT */</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">;</span>	<span class="cm">/* toggle from qtd */</span>
		<span class="p">}</span>
		<span class="n">info1</span> <span class="o">|=</span> <span class="n">maxp</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="n">info2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_MULT_TT</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>

		<span class="cm">/* Some Freescale processors have an erratum in which the</span>
<span class="cm">		 * port number in the queue head was 0..N-1 instead of 1..N.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci_has_fsl_portno_bug</span><span class="p">(</span><span class="n">ehci</span><span class="p">))</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ttport</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ttport</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span>

		<span class="cm">/* set the address of the TT; for TDI&#39;s integrated</span>
<span class="cm">		 * root hub tt, leave it zeroed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tt</span> <span class="o">&amp;&amp;</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">hub</span> <span class="o">!=</span> <span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="p">)</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="cm">/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets c-mask } */</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_SPEED_HIGH</span>:		<span class="cm">/* no TT involved */</span>
		<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>	<span class="cm">/* EPS &quot;high&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_RL_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="mi">64</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* usb2 fixed maxpacket */</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">;</span>	<span class="cm">/* toggle from qtd */</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_MULT_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_BULK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_RL_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
			<span class="cm">/* The USB spec says that high speed bulk endpoints</span>
<span class="cm">			 * always use 512 byte maxpacket.  But some device</span>
<span class="cm">			 * vendors decided to ignore that, and MSFT is happy</span>
<span class="cm">			 * to help them do so.  So now people expect to use</span>
<span class="cm">			 * such nonconformant devices with Linux too; sigh.</span>
<span class="cm">			 */</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="n">max_packet</span><span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EHCI_TUNE_MULT_HS</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* PIPE_INTERRUPT */</span>
			<span class="n">info1</span> <span class="o">|=</span> <span class="n">max_packet</span> <span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">info2</span> <span class="o">|=</span> <span class="n">hb_mult</span> <span class="p">(</span><span class="n">maxp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="s">&quot;bogus dev %p speed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">);</span>
<span class="nl">done:</span>
		<span class="n">qh_put</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */</span>

	<span class="cm">/* init as live, toggle clear, advance to dummy */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="n">hw</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">info1</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info2</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">info2</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">is_out</span> <span class="o">=</span> <span class="o">!</span><span class="n">is_input</span><span class="p">;</span>
	<span class="n">usb_settoggle</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_pipeendpoint</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">),</span> <span class="o">!</span><span class="n">is_input</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">qh_refresh</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* move qh (and its qtds) onto async queue; maybe enable queue.  */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qh_link_async</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__hc32</span>		<span class="n">dma</span> <span class="o">=</span> <span class="n">QH_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>	<span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t link a QH if there&#39;s a Clear-TT-Buffer pending */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">clearing_tt</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_IDLE</span><span class="p">);</span>

	<span class="cm">/* (re)start the async schedule? */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="n">timer_action_done</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_ASYNC_OFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">CMD_ASE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* in case a clear of CMD_ASE didn&#39;t take yet */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">handshake</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
					<span class="n">STS_ASS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
			<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">|=</span> <span class="n">CMD_ASE</span><span class="p">;</span>
			<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
			<span class="cm">/* posted write need not be known to HC yet ... */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* clear halt and/or toggle; and maybe recover from silicon quirk */</span>
	<span class="n">qh_refresh</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="cm">/* splice right after start */</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
	<span class="n">wmb</span> <span class="p">();</span>

	<span class="n">head</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>

	<span class="n">qh_get</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">xacterrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_LINKED</span><span class="p">;</span>
	<span class="cm">/* qtd completions reported later by interrupt */</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * For control/bulk/interrupt, return QH with these TDs appended.</span>
<span class="cm"> * Allocates and initializes the QH if necessary.</span>
<span class="cm"> * Returns null if it can&#39;t allocate a QH it needs to.</span>
<span class="cm"> * If the QH has TDs (urbs) already, that&#39;s great.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="nf">qh_append_tds</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">qtd_list</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">epnum</span><span class="p">,</span>
	<span class="kt">void</span>			<span class="o">**</span><span class="n">ptr</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__hc32</span>			<span class="n">qh_addr_mask</span> <span class="o">=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">);</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t sleep here, we have ehci-&gt;lock... */</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_make</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">qh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">qh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qtd</span>	<span class="o">*</span><span class="n">qtd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">list_empty</span> <span class="p">(</span><span class="n">qtd_list</span><span class="p">)))</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">qtd_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span>
					<span class="n">qtd_list</span><span class="p">);</span>

		<span class="cm">/* control qh may need patching ... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">epnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

                        <span class="cm">/* usb_reset_device() briefly reverts to address 0 */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">usb_pipedevice</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_info1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">qh_addr_mask</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* just one way to queue requests: swap with the dummy qtd.</span>
<span class="cm">		 * only hc or qh_refresh() ever modify the overlay.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">qtd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ehci_qtd</span>		<span class="o">*</span><span class="n">dummy</span><span class="p">;</span>
			<span class="n">dma_addr_t</span>		<span class="n">dma</span><span class="p">;</span>
			<span class="n">__hc32</span>			<span class="n">token</span><span class="p">;</span>

			<span class="cm">/* to avoid racing the HC, use the dummy td instead of</span>
<span class="cm">			 * the first td of our list (becomes new dummy).  both</span>
<span class="cm">			 * tds stay deactivated until we&#39;re done, when the</span>
<span class="cm">			 * HC is allowed to fetch the old dummy (4.10.2).</span>
<span class="cm">			 */</span>
			<span class="n">token</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span><span class="p">;</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">HALT_BIT</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>

			<span class="n">dummy</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">;</span>

			<span class="n">dma</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">;</span>
			<span class="o">*</span><span class="n">dummy</span> <span class="o">=</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
			<span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>

			<span class="n">list_del</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">list_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">list_splice_tail</span><span class="p">(</span><span class="n">qtd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">);</span>

			<span class="n">ehci_qtd_init</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qtd</span><span class="p">,</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">);</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">qtd</span><span class="p">;</span>

			<span class="cm">/* hc must see the new dummy at list end */</span>
			<span class="n">dma</span> <span class="o">=</span> <span class="n">qtd</span><span class="o">-&gt;</span><span class="n">qtd_dma</span><span class="p">;</span>
			<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">QTD_NEXT</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>

			<span class="cm">/* let the hc process these next qtds */</span>
			<span class="n">wmb</span> <span class="p">();</span>
			<span class="n">dummy</span><span class="o">-&gt;</span><span class="n">hw_token</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>

			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">qh_get</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">qh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">submit_async</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">ehci_hcd</span>		<span class="o">*</span><span class="n">ehci</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">qtd_list</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">mem_flags</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">epnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

	<span class="n">epnum</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>

<span class="cp">#ifdef EHCI_URB_TRACE</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehci_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
		<span class="n">qtd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">qtd_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qtd</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
		<span class="n">ehci_dbg</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span>
			 <span class="s">&quot;%s %s urb %p ep%d%s len %d, qtd %p [qh %p]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span>
			 <span class="n">epnum</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="p">(</span><span class="n">epnum</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;in&quot;</span> <span class="o">:</span> <span class="s">&quot;out&quot;</span><span class="p">,</span>
			 <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">,</span>
			 <span class="n">qtd</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_append_tds</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">,</span> <span class="n">epnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">ehci_to_hcd</span><span class="p">(</span><span class="n">ehci</span><span class="p">),</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Control/bulk operations through TTs don&#39;t need scheduling,</span>
<span class="cm">	 * the HC and TT handle it when the TT has a buffer ready.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_IDLE</span><span class="p">))</span>
		<span class="n">qh_link_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
 <span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">qtd_list_free</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">qtd_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* the async qh for the qtds being reclaimed are now unlinked from the HC */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_unlink_async</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">iaa_watchdog_done</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>qh->hw<em>next = cpu</em>to<em>hc32(qh->qh</em>dma);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_IDLE</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qh_put</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>			<span class="c1">// refcount from reclaim</span>

	<span class="cm">/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">qh_completions</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh_link_async</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* it&#39;s not free to turn the async schedule on/off; leave it</span>
<span class="cm">		 * active but idle for a while once it empties.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">EHCI_RH_RUNNING</span>
				<span class="o">&amp;&amp;</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">timer_action</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_ASYNC_OFF</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>			<span class="cm">/* refcount from async list */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">start_unlink_async</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">has_synopsys_hc_bug</span><span class="p">)</span>
		<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_dma</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">async_next</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* makes sure the async qh will become idle */</span>
<span class="cm">/* caller must own ehci-&gt;lock */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_unlink_async</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehci_qh</span> <span class="o">*</span><span class="n">qh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>	<span class="o">*</span><span class="n">prev</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_LINKED</span>
				<span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">!=</span> <span class="n">QH_STATE_UNLINK_WAIT</span><span class="p">)</span>
			<span class="p">)</span>
		<span class="n">BUG</span> <span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* stop async schedule right now? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">qh</span> <span class="o">==</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t get here without STS_ASS set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_HALTED</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ... and CMD_IAAD clear */</span>
			<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_ASE</span><span class="p">;</span>
			<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
			<span class="n">wmb</span> <span class="p">();</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>handshake later, if we need to</p></td><td class="code"><div class="highlight"><pre>			<span class="n">timer_action_done</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_ASYNC_OFF</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">=</span> <span class="n">QH_STATE_UNLINK</span><span class="p">;</span>
	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">=</span> <span class="n">qh</span> <span class="o">=</span> <span class="n">qh_get</span> <span class="p">(</span><span class="n">qh</span><span class="p">);</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span> <span class="o">!=</span> <span class="n">qh</span><span class="p">)</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>

	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_next</span><span class="p">;</span>
	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">qh_next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">qh_scan_next</span> <span class="o">==</span> <span class="n">qh</span><span class="p">)</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">qh_scan_next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>
	<span class="n">wmb</span> <span class="p">();</span>

	<span class="cm">/* If the controller isn&#39;t running, we don&#39;t have to wait for it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* if (unlikely (qh-&gt;reclaim != 0))</span>
<span class="cm">		 *	this will recurse, probably not much</span>
<span class="cm">		 */</span>
		<span class="n">end_unlink_async</span> <span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehci_writel</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">|</span> <span class="n">CMD_IAAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ehci_readl</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">iaa_watchdog_start</span><span class="p">(</span><span class="n">ehci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_async</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehci_hcd</span> <span class="o">*</span><span class="n">ehci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span>			<span class="n">stopped</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehci_qh</span>		<span class="o">*</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ehci_timer_action</span>	<span class="n">action</span> <span class="o">=</span> <span class="n">TIMER_IO_WATCHDOG</span><span class="p">;</span>

	<span class="n">timer_action_done</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">);</span>
	<span class="n">stopped</span> <span class="o">=</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">EHCI_RH_RUNNING</span><span class="p">);</span>

	<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">qh_scan_next</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">qh_scan_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qh</span> <span class="o">=</span> <span class="n">ehci</span><span class="o">-&gt;</span><span class="n">qh_scan_next</span><span class="p">;</span>
		<span class="n">ehci</span><span class="o">-&gt;</span><span class="n">qh_scan_next</span> <span class="o">=</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_next</span><span class="p">.</span><span class="n">qh</span><span class="p">;</span>
 <span class="nl">rescan:</span>
		<span class="cm">/* clean any finished work for this qh */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Unlinks could happen here; completion reporting</span>
<span class="cm">			 * drops the lock.  That&#39;s why ehci-&gt;qh_scan_next</span>
<span class="cm">			 * always holds the next qh to scan; if the next qh</span>
<span class="cm">			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted</span>
<span class="cm">			 * in start_unlink_async().</span>
<span class="cm">			 */</span>
			<span class="n">qh</span> <span class="o">=</span> <span class="n">qh_get</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">qh_completions</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">needs_rescan</span><span class="p">)</span>
				<span class="n">unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="n">qh</span><span class="o">-&gt;</span><span class="n">unlink_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">EHCI_SHRINK_JIFFIES</span><span class="p">;</span>
			<span class="n">qh_put</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* unlink idle entries, reducing DMA usage as well</span>
<span class="cm">		 * as HCD schedule-scanning costs.  delay for any qh</span>
<span class="cm">		 * we just scanned, there&#39;s a not-unusual case that it</span>
<span class="cm">		 * doesn&#39;t stay idle for long.</span>
<span class="cm">		 * (plus, avoids some kind of re-activation race.)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qh</span><span class="o">-&gt;</span><span class="n">qtd_list</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">qh_state</span> <span class="o">==</span> <span class="n">QH_STATE_LINKED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehci</span><span class="o">-&gt;</span><span class="n">reclaim</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">stopped</span> <span class="o">||</span>
					<span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">qh</span><span class="o">-&gt;</span><span class="n">unlink_time</span><span class="p">)))</span>
				<span class="n">start_unlink_async</span><span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">qh</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">)</span>
		<span class="n">timer_action</span> <span class="p">(</span><span class="n">ehci</span><span class="p">,</span> <span class="n">TIMER_ASYNC_SHRINK</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
