<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › sl811.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sl811.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SL811HS register declarations and HCD data structures</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Psion Teklogix</span>
<span class="cm"> * Copyright (C) 2004 David Brownell</span>
<span class="cm"> * Copyright (C) 2001 Cypress Semiconductor Inc. </span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * SL811HS has transfer registers, and control registers.  In host/master</span>
<span class="cm"> * mode one set of registers is used; in peripheral/slave mode, another.</span>
<span class="cm"> *  - SL11H only has some &quot;A&quot; transfer registers from 0x00-0x04</span>
<span class="cm"> *  - SL811HS also has &quot;B&quot; registers from 0x08-0x0c</span>
<span class="cm"> *  - SL811S (or HS in slave mode) has four A+B sets, at 00, 10, 20, 30</span>
<span class="cm"> */</span>

<span class="cp">#define SL811_EP_A(base)	((base) + 0)</span>
<span class="cp">#define SL811_EP_B(base)	((base) + 8)</span>

<span class="cp">#define SL811_HOST_BUF		0x00</span>
<span class="cp">#define SL811_PERIPH_EP0	0x00</span>
<span class="cp">#define SL811_PERIPH_EP1	0x10</span>
<span class="cp">#define SL811_PERIPH_EP2	0x20</span>
<span class="cp">#define SL811_PERIPH_EP3	0x30</span>


<span class="cm">/* TRANSFER REGISTERS:  host and peripheral sides are similar</span>
<span class="cm"> * except for the control models (master vs slave).</span>
<span class="cm"> */</span>
<span class="cp">#define SL11H_HOSTCTLREG	0</span>
<span class="cp">#	define SL11H_HCTLMASK_ARM	0x01</span>
<span class="cp">#	define SL11H_HCTLMASK_ENABLE	0x02</span>
<span class="cp">#	define SL11H_HCTLMASK_IN	0x00</span>
<span class="cp">#	define SL11H_HCTLMASK_OUT	0x04</span>
<span class="cp">#	define SL11H_HCTLMASK_ISOCH	0x10</span>
<span class="cp">#	define SL11H_HCTLMASK_AFTERSOF	0x20</span>
<span class="cp">#	define SL11H_HCTLMASK_TOGGLE	0x40</span>
<span class="cp">#	define SL11H_HCTLMASK_PREAMBLE	0x80</span>
<span class="cp">#define SL11H_BUFADDRREG	1</span>
<span class="cp">#define SL11H_BUFLNTHREG	2</span>
<span class="cp">#define SL11H_PKTSTATREG	3	</span><span class="cm">/* read */</span><span class="cp"></span>
<span class="cp">#	define SL11H_STATMASK_ACK	0x01</span>
<span class="cp">#	define SL11H_STATMASK_ERROR	0x02</span>
<span class="cp">#	define SL11H_STATMASK_TMOUT	0x04</span>
<span class="cp">#	define SL11H_STATMASK_SEQ	0x08</span>
<span class="cp">#	define SL11H_STATMASK_SETUP	0x10</span>
<span class="cp">#	define SL11H_STATMASK_OVF	0x20</span>
<span class="cp">#	define SL11H_STATMASK_NAK	0x40</span>
<span class="cp">#	define SL11H_STATMASK_STALL	0x80</span>
<span class="cp">#define SL11H_PIDEPREG		3	</span><span class="cm">/* write */</span><span class="cp"></span>
<span class="cp">#	define	SL_SETUP	0xd0</span>
<span class="cp">#	define	SL_IN		0x90</span>
<span class="cp">#	define	SL_OUT		0x10</span>
<span class="cp">#	define	SL_SOF		0x50</span>
<span class="cp">#	define	SL_PREAMBLE	0xc0</span>
<span class="cp">#	define	SL_NAK		0xa0</span>
<span class="cp">#	define	SL_STALL	0xe0</span>
<span class="cp">#	define	SL_DATA0	0x30</span>
<span class="cp">#	define	SL_DATA1	0xb0</span>
<span class="cp">#define SL11H_XFERCNTREG	4	</span><span class="cm">/* read */</span><span class="cp"></span>
<span class="cp">#define SL11H_DEVADDRREG	4	</span><span class="cm">/* write */</span><span class="cp"></span>


<span class="cm">/* CONTROL REGISTERS:  host and peripheral are very different.</span>
<span class="cm"> */</span>
<span class="cp">#define SL11H_CTLREG1		5</span>
<span class="cp">#	define SL11H_CTL1MASK_SOF_ENA	0x01</span>
<span class="cp">#	define SL11H_CTL1MASK_FORCE	0x18</span>
<span class="cp">#		define SL11H_CTL1MASK_NORMAL	0x00</span>
<span class="cp">#		define SL11H_CTL1MASK_SE0	0x08	</span><span class="cm">/* reset */</span><span class="cp"></span>
<span class="cp">#		define SL11H_CTL1MASK_J		0x10</span>
<span class="cp">#		define SL11H_CTL1MASK_K		0x18	</span><span class="cm">/* resume */</span><span class="cp"></span>
<span class="cp">#	define SL11H_CTL1MASK_LSPD	0x20</span>
<span class="cp">#	define SL11H_CTL1MASK_SUSPEND	0x40</span>
<span class="cp">#define SL11H_IRQ_ENABLE	6</span>
<span class="cp">#	define SL11H_INTMASK_DONE_A	0x01</span>
<span class="cp">#	define SL11H_INTMASK_DONE_B	0x02</span>
<span class="cp">#	define SL11H_INTMASK_SOFINTR	0x10</span>
<span class="cp">#	define SL11H_INTMASK_INSRMV	0x20	</span><span class="cm">/* to/from SE0 */</span><span class="cp"></span>
<span class="cp">#	define SL11H_INTMASK_RD		0x40</span>
<span class="cp">#	define SL11H_INTMASK_DP		0x80	</span><span class="cm">/* only in INTSTATREG */</span><span class="cp"></span>
<span class="cp">#define SL11S_ADDRESS		7</span>

<span class="cm">/* 0x08-0x0c are for the B buffer (not in SL11) */</span>

<span class="cp">#define SL11H_IRQ_STATUS	0x0D	</span><span class="cm">/* write to ack */</span><span class="cp"></span>
<span class="cp">#define SL11H_HWREVREG		0x0E	</span><span class="cm">/* read */</span><span class="cp"></span>
<span class="cp">#	define SL11H_HWRMASK_HWREV	0xF0</span>
<span class="cp">#define SL11H_SOFLOWREG		0x0E	</span><span class="cm">/* write */</span><span class="cp"></span>
<span class="cp">#define SL11H_SOFTMRREG		0x0F	</span><span class="cm">/* read */</span><span class="cp"></span>

<span class="cm">/* a write to this register enables SL811HS features.</span>
<span class="cm"> * HOST flag presumably overrides the chip input signal?</span>
<span class="cm"> */</span>
<span class="cp">#define SL811HS_CTLREG2		0x0F</span>
<span class="cp">#	define SL811HS_CTL2MASK_SOF_MASK	0x3F</span>
<span class="cp">#	define SL811HS_CTL2MASK_DSWAP		0x40</span>
<span class="cp">#	define SL811HS_CTL2MASK_HOST		0x80</span>

<span class="cp">#define SL811HS_CTL2_INIT	(SL811HS_CTL2MASK_HOST | 0x2e)</span>


<span class="cm">/* DATA BUFFERS: registers from 0x10..0xff are for data buffers;</span>
<span class="cm"> * that&#39;s 240 bytes, which we&#39;ll split evenly between A and B sides.</span>
<span class="cm"> * Only ISO can use more than 64 bytes per packet.</span>
<span class="cm"> * (The SL11S has 0x40..0xff for buffers.)</span>
<span class="cm"> */</span>
<span class="cp">#define H_MAXPACKET	120		</span><span class="cm">/* bytes in A or B fifos */</span><span class="cp"></span>

<span class="cp">#define SL11H_DATA_START	0x10</span>
<span class="cp">#define	SL811HS_PACKET_BUF(is_a)	((is_a) \</span>
<span class="cp">		? SL11H_DATA_START \</span>
<span class="cp">		: (SL11H_DATA_START + H_MAXPACKET))</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define	LOG2_PERIODIC_SIZE	5	</span><span class="cm">/* arbitrary; this matches OHCI */</span><span class="cp"></span>
<span class="cp">#define	PERIODIC_SIZE		(1 &lt;&lt; LOG2_PERIODIC_SIZE)</span>

<span class="k">struct</span> <span class="n">sl811</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">addr_reg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">data_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sl811_platform_data</span>	<span class="o">*</span><span class="n">board</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span>	<span class="o">*</span><span class="n">pde</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stat_insrmv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stat_wake</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stat_sof</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stat_a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stat_b</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stat_lost</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stat_overrun</span><span class="p">;</span>

	<span class="cm">/* sw model */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sl811h_ep</span>	<span class="o">*</span><span class="n">next_periodic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sl811h_ep</span>	<span class="o">*</span><span class="n">next_async</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sl811h_ep</span>	<span class="o">*</span><span class="n">active_a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">jiffies_a</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sl811h_ep</span>	<span class="o">*</span><span class="n">active_b</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">jiffies_b</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">port1</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ctrl1</span><span class="p">,</span> <span class="n">ctrl2</span><span class="p">,</span> <span class="n">irq_enable</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">frame</span><span class="p">;</span>

	<span class="cm">/* async schedule: control, bulk */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">async</span><span class="p">;</span>

	<span class="cm">/* periodic schedule: interrupt, iso */</span>
	<span class="n">u16</span>			<span class="n">load</span><span class="p">[</span><span class="n">PERIODIC_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sl811h_ep</span>	<span class="o">*</span><span class="n">periodic</span><span class="p">[</span><span class="n">PERIODIC_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span>		<span class="n">periodic_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sl811</span> <span class="o">*</span><span class="nf">hcd_to_sl811</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sl811</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">sl811_to_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sl811</span> <span class="o">*</span><span class="n">sl811</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">sl811</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">hcd_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sl811h_ep</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">hep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">defctrl</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">maxpacket</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">epnum</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">nextpid</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">error_count</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">nak_count</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">length</span><span class="p">;</span>		<span class="cm">/* of current packet */</span>

	<span class="cm">/* periodic schedule */</span>
	<span class="n">u16</span>			<span class="n">period</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">branch</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">load</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sl811h_ep</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* async schedule */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">schedule</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* These register utilities should work for the SL811S register API too</span>
<span class="cm"> * NOTE:  caller must hold sl811-&gt;lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">sl811_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">sl811</span> <span class="o">*</span><span class="n">sl811</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sl811</span><span class="o">-&gt;</span><span class="n">addr_reg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">sl811</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sl811_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">sl811</span> <span class="o">*</span><span class="n">sl811</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">sl811</span><span class="o">-&gt;</span><span class="n">addr_reg</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sl811</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sl811_write_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sl811</span> <span class="o">*</span><span class="n">sl811</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span>	<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">data_reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">sl811</span><span class="o">-&gt;</span><span class="n">addr_reg</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">data_reg</span> <span class="o">=</span> <span class="n">sl811</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">writeb</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">,</span> <span class="n">data_reg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sl811_read_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sl811</span> <span class="o">*</span><span class="n">sl811</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> 		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">data_reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">sl811</span><span class="o">-&gt;</span><span class="n">addr_reg</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">data_reg</span> <span class="o">=</span> <span class="n">sl811</span><span class="o">-&gt;</span><span class="n">data_reg</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">data</span><span class="o">++</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">data_reg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DBG(stuff...)		printk(KERN_DEBUG &quot;sl811: &quot; stuff)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(stuff...)		do{}while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef VERBOSE</span>
<span class="cp">#    define VDBG		DBG</span>
<span class="cp">#else</span>
<span class="cp">#    define VDBG(stuff...)	do{}while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PACKET_TRACE</span>
<span class="cp">#    define PACKET		VDBG</span>
<span class="cp">#else</span>
<span class="cp">#    define PACKET(stuff...)	do{}while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#define ERR(stuff...)		printk(KERN_ERR &quot;sl811: &quot; stuff)</span>
<span class="cp">#define WARNING(stuff...)	printk(KERN_WARNING &quot;sl811: &quot; stuff)</span>
<span class="cp">#define INFO(stuff...)		printk(KERN_INFO &quot;sl811: &quot; stuff)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
