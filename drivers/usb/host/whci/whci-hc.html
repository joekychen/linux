<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › whci › whci-hc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>whci-hc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Wireless Host Controller (WHC) data structures.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Cambridge Silicon Radio Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _WHCI_WHCI_HC_H</span>
<span class="cp">#define _WHCI_WHCI_HC_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * WHCI_PAGE_SIZE - page size use by WHCI</span>
<span class="cm"> *</span>
<span class="cm"> * WHCI assumes that host system uses pages of 4096 octets.</span>
<span class="cm"> */</span>
<span class="cp">#define WHCI_PAGE_SIZE 4096</span>


<span class="cm">/**</span>
<span class="cm"> * QTD_MAX_TXFER_SIZE - max number of bytes to transfer with a single</span>
<span class="cm"> * qtd.</span>
<span class="cm"> *</span>
<span class="cm"> * This is 2^20 - 1.</span>
<span class="cm"> */</span>
<span class="cp">#define QTD_MAX_XFER_SIZE 1048575</span>


<span class="cm">/**</span>
<span class="cm"> * struct whc_qtd - Queue Element Transfer Descriptors (qTD)</span>
<span class="cm"> *</span>
<span class="cm"> * This describes the data for a bulk, control or interrupt transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 3.2.4</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">whc_qtd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">status</span><span class="p">;</span> <span class="cm">/*&lt; remaining transfer len and transfer status */</span>
	<span class="n">__le32</span> <span class="n">options</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">page_list_ptr</span><span class="p">;</span> <span class="cm">/*&lt; physical pointer to data buffer page list*/</span>
	<span class="n">__u8</span>   <span class="n">setup</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>      <span class="cm">/*&lt; setup data for control transfers */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define QTD_STS_ACTIVE     (1 &lt;&lt; 31)  </span><span class="cm">/* enable execution of transaction */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_HALTED     (1 &lt;&lt; 30)  </span><span class="cm">/* transfer halted */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_DBE        (1 &lt;&lt; 29)  </span><span class="cm">/* data buffer error */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_BABBLE     (1 &lt;&lt; 28)  </span><span class="cm">/* babble detected */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_RCE        (1 &lt;&lt; 27)  </span><span class="cm">/* retry count exceeded */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_LAST_PKT   (1 &lt;&lt; 26)  </span><span class="cm">/* set Last Packet Flag in WUSB header */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_INACTIVE   (1 &lt;&lt; 25)  </span><span class="cm">/* queue set is marked inactive */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_IALT_VALID (1 &lt;&lt; 23)                          </span><span class="cm">/* iAlt field is valid */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_IALT(i)    (QTD_STS_IALT_VALID | ((i) &lt;&lt; 20)) </span><span class="cm">/* iAlt field */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_LEN(l)     ((l) &lt;&lt; 0) </span><span class="cm">/* transfer length */</span><span class="cp"></span>
<span class="cp">#define QTD_STS_TO_LEN(s)  ((s) &amp; 0x000fffff)</span>

<span class="cp">#define QTD_OPT_IOC      (1 &lt;&lt; 1) </span><span class="cm">/* page_list_ptr points to buffer directly */</span><span class="cp"></span>
<span class="cp">#define QTD_OPT_SMALL    (1 &lt;&lt; 0) </span><span class="cm">/* interrupt on complete */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct whc_itd - Isochronous Queue Element Transfer Descriptors (iTD)</span>
<span class="cm"> *</span>
<span class="cm"> * This describes the data and other parameters for an isochronous</span>
<span class="cm"> * transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 3.2.5</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">whc_itd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">presentation_time</span><span class="p">;</span>    <span class="cm">/*&lt; presentation time for OUT transfers */</span>
	<span class="n">__u8</span>   <span class="n">num_segments</span><span class="p">;</span>         <span class="cm">/*&lt; number of data segments in segment list */</span>
	<span class="n">__u8</span>   <span class="n">status</span><span class="p">;</span>               <span class="cm">/*&lt; command execution status */</span>
	<span class="n">__le32</span> <span class="n">options</span><span class="p">;</span>              <span class="cm">/*&lt; misc transfer options */</span>
	<span class="n">__le64</span> <span class="n">page_list_ptr</span><span class="p">;</span>        <span class="cm">/*&lt; physical pointer to data buffer page list */</span>
	<span class="n">__le64</span> <span class="n">seg_list_ptr</span><span class="p">;</span>         <span class="cm">/*&lt; physical pointer to segment list */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define ITD_STS_ACTIVE   (1 &lt;&lt; 7) </span><span class="cm">/* enable execution of transaction */</span><span class="cp"></span>
<span class="cp">#define ITD_STS_DBE      (1 &lt;&lt; 5) </span><span class="cm">/* data buffer error */</span><span class="cp"></span>
<span class="cp">#define ITD_STS_BABBLE   (1 &lt;&lt; 4) </span><span class="cm">/* babble detected */</span><span class="cp"></span>
<span class="cp">#define ITD_STS_INACTIVE (1 &lt;&lt; 1) </span><span class="cm">/* queue set is marked inactive */</span><span class="cp"></span>

<span class="cp">#define ITD_OPT_IOC      (1 &lt;&lt; 1) </span><span class="cm">/* interrupt on complete */</span><span class="cp"></span>
<span class="cp">#define ITD_OPT_SMALL    (1 &lt;&lt; 0) </span><span class="cm">/* page_list_ptr points to buffer directly */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * Page list entry.</span>
<span class="cm"> *</span>
<span class="cm"> * A TD&#39;s page list must contain sufficient page list entries for the</span>
<span class="cm"> * total data length in the TD.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 3.2.4.3</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">whc_page_list_entry</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">buf_ptr</span><span class="p">;</span> <span class="cm">/*&lt; physical pointer to buffer */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * struct whc_seg_list_entry - Segment list entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Describes a portion of the data buffer described in the containing</span>
<span class="cm"> * qTD&#39;s page list.</span>
<span class="cm"> *</span>
<span class="cm"> * seg_ptr = qtd-&gt;page_list_ptr[qtd-&gt;seg_list_ptr[seg].idx].buf_ptr</span>
<span class="cm"> *           + qtd-&gt;seg_list_ptr[seg].offset;</span>
<span class="cm"> *</span>
<span class="cm"> * Segments can&#39;t cross page boundries.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 3.2.5.5</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">whc_seg_list_entry</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">len</span><span class="p">;</span>    <span class="cm">/*&lt; segment length */</span>
	<span class="n">__u8</span>   <span class="n">idx</span><span class="p">;</span>    <span class="cm">/*&lt; index into page list */</span>
	<span class="n">__u8</span>   <span class="n">status</span><span class="p">;</span> <span class="cm">/*&lt; segment status */</span>
	<span class="n">__le16</span> <span class="n">offset</span><span class="p">;</span> <span class="cm">/*&lt; 12 bit offset into page */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * struct whc_qhead - endpoint and status information for a qset.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 3.2.6</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">whc_qhead</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">link</span><span class="p">;</span> <span class="cm">/*&lt; next qset in list */</span>
	<span class="n">__le32</span> <span class="n">info1</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">info2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">info3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">err_count</span><span class="p">;</span>  <span class="cm">/*&lt; transaction error count */</span>
	<span class="n">__le32</span> <span class="n">cur_window</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">scratch</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/*&lt; h/w scratch area */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">whc_qtd</span> <span class="n">qtd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">whc_itd</span> <span class="n">itd</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">overlay</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define QH_LINK_PTR_MASK (~0x03Full)</span>
<span class="cp">#define QH_LINK_PTR(ptr) ((ptr) &amp; QH_LINK_PTR_MASK)</span>
<span class="cp">#define QH_LINK_IQS      (1 &lt;&lt; 4) </span><span class="cm">/* isochronous queue set */</span><span class="cp"></span>
<span class="cp">#define QH_LINK_NTDS(n)  (((n) - 1) &lt;&lt; 1) </span><span class="cm">/* number of TDs in queue set */</span><span class="cp"></span>
<span class="cp">#define QH_LINK_T        (1 &lt;&lt; 0) </span><span class="cm">/* last queue set in periodic schedule list */</span><span class="cp"></span>

<span class="cp">#define QH_INFO1_EP(e)           ((e) &lt;&lt; 0)  </span><span class="cm">/* endpoint number */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_DIR_IN          (1 &lt;&lt; 4)    </span><span class="cm">/* IN transfer */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_DIR_OUT         (0 &lt;&lt; 4)    </span><span class="cm">/* OUT transfer */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_TR_TYPE_CTRL    (0x0 &lt;&lt; 5)  </span><span class="cm">/* control transfer */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_TR_TYPE_ISOC    (0x1 &lt;&lt; 5)  </span><span class="cm">/* isochronous transfer */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_TR_TYPE_BULK    (0x2 &lt;&lt; 5)  </span><span class="cm">/* bulk transfer */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_TR_TYPE_INT     (0x3 &lt;&lt; 5)  </span><span class="cm">/* interrupt */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_TR_TYPE_LP_INT  (0x7 &lt;&lt; 5)  </span><span class="cm">/* low power interrupt */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_DEV_INFO_IDX(i) ((i) &lt;&lt; 8)  </span><span class="cm">/* index into device info buffer */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_SET_INACTIVE    (1 &lt;&lt; 15)   </span><span class="cm">/* set inactive after transfer */</span><span class="cp"></span>
<span class="cp">#define QH_INFO1_MAX_PKT_LEN(l)  ((l) &lt;&lt; 16) </span><span class="cm">/* maximum packet length */</span><span class="cp"></span>

<span class="cp">#define QH_INFO2_BURST(b)        ((b) &lt;&lt; 0)  </span><span class="cm">/* maximum burst length */</span><span class="cp"></span>
<span class="cp">#define QH_INFO2_DBP(p)          ((p) &lt;&lt; 5)  </span><span class="cm">/* data burst policy (see [WUSB] table 5-7) */</span><span class="cp"></span>
<span class="cp">#define QH_INFO2_MAX_COUNT(c)    ((c) &lt;&lt; 8)  </span><span class="cm">/* max isoc/int pkts per zone */</span><span class="cp"></span>
<span class="cp">#define QH_INFO2_RQS             (1 &lt;&lt; 15)   </span><span class="cm">/* reactivate queue set */</span><span class="cp"></span>
<span class="cp">#define QH_INFO2_MAX_RETRY(r)    ((r) &lt;&lt; 16) </span><span class="cm">/* maximum transaction retries */</span><span class="cp"></span>
<span class="cp">#define QH_INFO2_MAX_SEQ(s)      ((s) &lt;&lt; 20) </span><span class="cm">/* maximum sequence number */</span><span class="cp"></span>
<span class="cp">#define QH_INFO3_MAX_DELAY(d)    ((d) &lt;&lt; 0)  </span><span class="cm">/* maximum stream delay in 125 us units (isoc only) */</span><span class="cp"></span>
<span class="cp">#define QH_INFO3_INTERVAL(i)     ((i) &lt;&lt; 16) </span><span class="cm">/* segment interval in 125 us units (isoc only) */</span><span class="cp"></span>

<span class="cp">#define QH_INFO3_TX_RATE(r)      ((r) &lt;&lt; 24) </span><span class="cm">/* PHY rate (see [ECMA-368] section 10.3.1.1) */</span><span class="cp"></span>
<span class="cp">#define QH_INFO3_TX_PWR(p)       ((p) &lt;&lt; 29) </span><span class="cm">/* transmit power (see [WUSB] section 5.2.1.2) */</span><span class="cp"></span>

<span class="cp">#define QH_STATUS_FLOW_CTRL      (1 &lt;&lt; 15)</span>
<span class="cp">#define QH_STATUS_ICUR(i)        ((i) &lt;&lt; 5)</span>
<span class="cp">#define QH_STATUS_TO_ICUR(s)     (((s) &gt;&gt; 5) &amp; 0x7)</span>
<span class="cp">#define QH_STATUS_SEQ_MASK       0x1f</span>

<span class="cm">/**</span>
<span class="cm"> * usb_pipe_to_qh_type - USB core pipe type to QH transfer type</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the QH type field for a USB core pipe type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">usb_pipe_to_qh_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">PIPE_ISOCHRONOUS</span><span class="p">]</span> <span class="o">=</span> <span class="n">QH_INFO1_TR_TYPE_ISOC</span><span class="p">,</span>
		<span class="p">[</span><span class="n">PIPE_INTERRUPT</span><span class="p">]</span>   <span class="o">=</span> <span class="n">QH_INFO1_TR_TYPE_INT</span><span class="p">,</span>
		<span class="p">[</span><span class="n">PIPE_CONTROL</span><span class="p">]</span>     <span class="o">=</span> <span class="n">QH_INFO1_TR_TYPE_CTRL</span><span class="p">,</span>
		<span class="p">[</span><span class="n">PIPE_BULK</span><span class="p">]</span>        <span class="o">=</span> <span class="n">QH_INFO1_TR_TYPE_BULK</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">type</span><span class="p">[</span><span class="n">usb_pipetype</span><span class="p">(</span><span class="n">pipe</span><span class="p">)];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Maxiumum number of TDs in a qset.</span>
<span class="cm"> */</span>
<span class="cp">#define WHCI_QSET_TD_MAX 8</span>

<span class="cm">/**</span>
<span class="cm"> * struct whc_qset - WUSB data transfers to a specific endpoint</span>
<span class="cm"> * @qh: the QHead of this qset</span>
<span class="cm"> * @qtd: up to 8 qTDs (for qsets for control, bulk and interrupt</span>
<span class="cm"> * transfers)</span>
<span class="cm"> * @itd: up to 8 iTDs (for qsets for isochronous transfers)</span>
<span class="cm"> * @qset_dma: DMA address for this qset</span>
<span class="cm"> * @whc: WHCI HC this qset is for</span>
<span class="cm"> * @ep: endpoint</span>
<span class="cm"> * @stds: list of sTDs queued to this qset</span>
<span class="cm"> * @ntds: number of qTDs queued (not necessarily the same as nTDs</span>
<span class="cm"> * field in the QH)</span>
<span class="cm"> * @td_start: index of the first qTD in the list</span>
<span class="cm"> * @td_end: index of next free qTD in the list (provided</span>
<span class="cm"> *          ntds &lt; WHCI_QSET_TD_MAX)</span>
<span class="cm"> *</span>
<span class="cm"> * Queue Sets (qsets) are added to the asynchronous schedule list</span>
<span class="cm"> * (ASL) or the periodic zone list (PZL).</span>
<span class="cm"> *</span>
<span class="cm"> * qsets may contain up to 8 TDs (either qTDs or iTDs as appropriate).</span>
<span class="cm"> * Each TD may refer to at most 1 MiB of data. If a single transfer</span>
<span class="cm"> * has &gt; 8MiB of data, TDs can be reused as they are completed since</span>
<span class="cm"> * the TD list is used as a circular buffer.  Similarly, several</span>
<span class="cm"> * (smaller) transfers may be queued in a qset.</span>
<span class="cm"> *</span>
<span class="cm"> * WHCI controllers may cache portions of the qsets in the ASL and</span>
<span class="cm"> * PZL, requiring the WHCD to inform the WHC that the lists have been</span>
<span class="cm"> * updated (fields changed or qsets inserted or removed).  For safe</span>
<span class="cm"> * insertion and removal of qsets from the lists the schedule must be</span>
<span class="cm"> * stopped to avoid races in updating the QH link pointers.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the HC is free to execute qsets in any order, all transfers</span>
<span class="cm"> * to an endpoint should use the same qset to ensure transfers are</span>
<span class="cm"> * executed in the order they&#39;re submitted.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 3.2.3</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">whc_qset</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_qhead</span> <span class="n">qh</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">whc_qtd</span> <span class="n">qtd</span><span class="p">[</span><span class="n">WHCI_QSET_TD_MAX</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">whc_itd</span> <span class="n">itd</span><span class="p">[</span><span class="n">WHCI_QSET_TD_MAX</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="cm">/* private data for WHCD */</span>
	<span class="n">dma_addr_t</span> <span class="n">qset_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">stds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ntds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">td_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">td_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">in_sw_list</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">in_hw_list</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">remove</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">reset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">pause_after_urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">remove_complete</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">max_packet</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">max_burst</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">max_seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">whc_qset_set_link_ptr</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">QH_LINK_PTR_MASK</span> <span class="o">|</span> <span class="n">QH_LINK_T</span><span class="p">))</span> <span class="o">|</span> <span class="n">QH_LINK_PTR</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">QH_LINK_T</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct di_buf_entry - Device Information (DI) buffer entry.</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s one of these per connected device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">di_buf_entry</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">availability_info</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/*&lt; MAS availability information, one MAS per bit */</span>
	<span class="n">__le32</span> <span class="n">addr_sec_info</span><span class="p">;</span>        <span class="cm">/*&lt; addressing and security info */</span>
	<span class="n">__le32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define WHC_DI_SECURE           (1 &lt;&lt; 31)</span>
<span class="cp">#define WHC_DI_DISABLE          (1 &lt;&lt; 30)</span>
<span class="cp">#define WHC_DI_KEY_IDX(k)       ((k) &lt;&lt; 8)</span>
<span class="cp">#define WHC_DI_KEY_IDX_MASK     0x0000ff00</span>
<span class="cp">#define WHC_DI_DEV_ADDR(a)      ((a) &lt;&lt; 0)</span>
<span class="cp">#define WHC_DI_DEV_ADDR_MASK    0x000000ff</span>

<span class="cm">/**</span>
<span class="cm"> * struct dn_buf_entry - Device Notification (DN) buffer entry.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 3.2.8</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dn_buf_entry</span> <span class="p">{</span>
	<span class="n">__u8</span>   <span class="n">msg_size</span><span class="p">;</span>    <span class="cm">/*&lt; number of octets of valid DN data */</span>
	<span class="n">__u8</span>   <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">src_addr</span><span class="p">;</span>    <span class="cm">/*&lt; source address */</span>
	<span class="n">__u8</span>   <span class="n">status</span><span class="p">;</span>      <span class="cm">/*&lt; buffer entry status */</span>
	<span class="n">__le32</span> <span class="n">tkid</span><span class="p">;</span>        <span class="cm">/*&lt; TKID for source device, valid if secure bit is set */</span>
	<span class="n">__u8</span>   <span class="n">dn_data</span><span class="p">[</span><span class="mi">56</span><span class="p">];</span> <span class="cm">/*&lt; up to 56 octets of DN data */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define WHC_DN_STATUS_VALID  (1 &lt;&lt; 7) </span><span class="cm">/* buffer entry is valid */</span><span class="cp"></span>
<span class="cp">#define WHC_DN_STATUS_SECURE (1 &lt;&lt; 6) </span><span class="cm">/* notification received using secure frame */</span><span class="cp"></span>

<span class="cp">#define WHC_N_DN_ENTRIES (4096 / sizeof(struct dn_buf_entry))</span>

<span class="cm">/* The Add MMC IE WUSB Generic Command may take up to 256 bytes of</span>
<span class="cm">   data. [WHCI] section 2.4.7. */</span>
<span class="cp">#define WHC_GEN_CMD_DATA_LEN 256</span>

<span class="cm">/*</span>
<span class="cm"> * HC registers.</span>
<span class="cm"> *</span>
<span class="cm"> * [WHCI] section 2.4</span>
<span class="cm"> */</span>

<span class="cp">#define WHCIVERSION          0x00</span>

<span class="cp">#define WHCSPARAMS           0x04</span>
<span class="cp">#  define WHCSPARAMS_TO_N_MMC_IES(p) (((p) &gt;&gt; 16) &amp; 0xff)</span>
<span class="cp">#  define WHCSPARAMS_TO_N_KEYS(p)    (((p) &gt;&gt; 8) &amp; 0xff)</span>
<span class="cp">#  define WHCSPARAMS_TO_N_DEVICES(p) (((p) &gt;&gt; 0) &amp; 0x7f)</span>

<span class="cp">#define WUSBCMD              0x08</span>
<span class="cp">#  define WUSBCMD_BCID(b)            ((b) &lt;&lt; 16)</span>
<span class="cp">#  define WUSBCMD_BCID_MASK          (0xff &lt;&lt; 16)</span>
<span class="cp">#  define WUSBCMD_ASYNC_QSET_RM      (1 &lt;&lt; 12)</span>
<span class="cp">#  define WUSBCMD_PERIODIC_QSET_RM   (1 &lt;&lt; 11)</span>
<span class="cp">#  define WUSBCMD_WUSBSI(s)          ((s) &lt;&lt; 8)</span>
<span class="cp">#  define WUSBCMD_WUSBSI_MASK        (0x7 &lt;&lt; 8)</span>
<span class="cp">#  define WUSBCMD_ASYNC_SYNCED_DB    (1 &lt;&lt; 7)</span>
<span class="cp">#  define WUSBCMD_PERIODIC_SYNCED_DB (1 &lt;&lt; 6)</span>
<span class="cp">#  define WUSBCMD_ASYNC_UPDATED      (1 &lt;&lt; 5)</span>
<span class="cp">#  define WUSBCMD_PERIODIC_UPDATED   (1 &lt;&lt; 4)</span>
<span class="cp">#  define WUSBCMD_ASYNC_EN           (1 &lt;&lt; 3)</span>
<span class="cp">#  define WUSBCMD_PERIODIC_EN        (1 &lt;&lt; 2)</span>
<span class="cp">#  define WUSBCMD_WHCRESET           (1 &lt;&lt; 1)</span>
<span class="cp">#  define WUSBCMD_RUN                (1 &lt;&lt; 0)</span>

<span class="cp">#define WUSBSTS              0x0c</span>
<span class="cp">#  define WUSBSTS_ASYNC_SCHED             (1 &lt;&lt; 15)</span>
<span class="cp">#  define WUSBSTS_PERIODIC_SCHED          (1 &lt;&lt; 14)</span>
<span class="cp">#  define WUSBSTS_DNTS_SCHED              (1 &lt;&lt; 13)</span>
<span class="cp">#  define WUSBSTS_HCHALTED                (1 &lt;&lt; 12)</span>
<span class="cp">#  define WUSBSTS_GEN_CMD_DONE            (1 &lt;&lt; 9)</span>
<span class="cp">#  define WUSBSTS_CHAN_TIME_ROLLOVER      (1 &lt;&lt; 8)</span>
<span class="cp">#  define WUSBSTS_DNTS_OVERFLOW           (1 &lt;&lt; 7)</span>
<span class="cp">#  define WUSBSTS_BPST_ADJUSTMENT_CHANGED (1 &lt;&lt; 6)</span>
<span class="cp">#  define WUSBSTS_HOST_ERR                (1 &lt;&lt; 5)</span>
<span class="cp">#  define WUSBSTS_ASYNC_SCHED_SYNCED      (1 &lt;&lt; 4)</span>
<span class="cp">#  define WUSBSTS_PERIODIC_SCHED_SYNCED   (1 &lt;&lt; 3)</span>
<span class="cp">#  define WUSBSTS_DNTS_INT                (1 &lt;&lt; 2)</span>
<span class="cp">#  define WUSBSTS_ERR_INT                 (1 &lt;&lt; 1)</span>
<span class="cp">#  define WUSBSTS_INT                     (1 &lt;&lt; 0)</span>
<span class="cp">#  define WUSBSTS_INT_MASK                0x3ff</span>

<span class="cp">#define WUSBINTR             0x10</span>
<span class="cp">#  define WUSBINTR_GEN_CMD_DONE             (1 &lt;&lt; 9)</span>
<span class="cp">#  define WUSBINTR_CHAN_TIME_ROLLOVER       (1 &lt;&lt; 8)</span>
<span class="cp">#  define WUSBINTR_DNTS_OVERFLOW            (1 &lt;&lt; 7)</span>
<span class="cp">#  define WUSBINTR_BPST_ADJUSTMENT_CHANGED  (1 &lt;&lt; 6)</span>
<span class="cp">#  define WUSBINTR_HOST_ERR                 (1 &lt;&lt; 5)</span>
<span class="cp">#  define WUSBINTR_ASYNC_SCHED_SYNCED       (1 &lt;&lt; 4)</span>
<span class="cp">#  define WUSBINTR_PERIODIC_SCHED_SYNCED    (1 &lt;&lt; 3)</span>
<span class="cp">#  define WUSBINTR_DNTS_INT                 (1 &lt;&lt; 2)</span>
<span class="cp">#  define WUSBINTR_ERR_INT                  (1 &lt;&lt; 1)</span>
<span class="cp">#  define WUSBINTR_INT                      (1 &lt;&lt; 0)</span>
<span class="cp">#  define WUSBINTR_ALL 0x3ff</span>

<span class="cp">#define WUSBGENCMDSTS        0x14</span>
<span class="cp">#  define WUSBGENCMDSTS_ACTIVE (1 &lt;&lt; 31)</span>
<span class="cp">#  define WUSBGENCMDSTS_ERROR  (1 &lt;&lt; 24)</span>
<span class="cp">#  define WUSBGENCMDSTS_IOC    (1 &lt;&lt; 23)</span>
<span class="cp">#  define WUSBGENCMDSTS_MMCIE_ADD 0x01</span>
<span class="cp">#  define WUSBGENCMDSTS_MMCIE_RM  0x02</span>
<span class="cp">#  define WUSBGENCMDSTS_SET_MAS   0x03</span>
<span class="cp">#  define WUSBGENCMDSTS_CHAN_STOP 0x04</span>
<span class="cp">#  define WUSBGENCMDSTS_RWP_EN    0x05</span>

<span class="cp">#define WUSBGENCMDPARAMS     0x18</span>
<span class="cp">#define WUSBGENADDR          0x20</span>
<span class="cp">#define WUSBASYNCLISTADDR    0x28</span>
<span class="cp">#define WUSBDNTSBUFADDR      0x30</span>
<span class="cp">#define WUSBDEVICEINFOADDR   0x38</span>

<span class="cp">#define WUSBSETSECKEYCMD     0x40</span>
<span class="cp">#  define WUSBSETSECKEYCMD_SET    (1 &lt;&lt; 31)</span>
<span class="cp">#  define WUSBSETSECKEYCMD_ERASE  (1 &lt;&lt; 30)</span>
<span class="cp">#  define WUSBSETSECKEYCMD_GTK    (1 &lt;&lt; 8)</span>
<span class="cp">#  define WUSBSETSECKEYCMD_IDX(i) ((i) &lt;&lt; 0)</span>

<span class="cp">#define WUSBTKID             0x44</span>
<span class="cp">#define WUSBSECKEY           0x48</span>
<span class="cp">#define WUSBPERIODICLISTBASE 0x58</span>
<span class="cp">#define WUSBMASINDEX         0x60</span>

<span class="cp">#define WUSBDNTSCTRL         0x64</span>
<span class="cp">#  define WUSBDNTSCTRL_ACTIVE      (1 &lt;&lt; 31)</span>
<span class="cp">#  define WUSBDNTSCTRL_INTERVAL(i) ((i) &lt;&lt; 8)</span>
<span class="cp">#  define WUSBDNTSCTRL_SLOTS(s)    ((s) &lt;&lt; 0)</span>

<span class="cp">#define WUSBTIME             0x68</span>
<span class="cp">#  define WUSBTIME_CHANNEL_TIME_MASK 0x00ffffff</span>

<span class="cp">#define WUSBBPST             0x6c</span>
<span class="cp">#define WUSBDIBUPDATED       0x70</span>

<span class="cp">#endif </span><span class="cm">/* #ifndef _WHCI_WHCI_HC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
