<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › whci › qset.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qset.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Wireless Host Controller (WHC) qset management.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Cambridge Silicon Radio Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/uwb/umc.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>

<span class="cp">#include &quot;../../wusbcore/wusbhc.h&quot;</span>

<span class="cp">#include &quot;whcd.h&quot;</span>

<span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="nf">qset_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>

	<span class="n">qset</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">qset_pool</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qset</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">qset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_qset</span><span class="p">));</span>

	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qset_dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">whc</span> <span class="o">=</span> <span class="n">whc</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">qset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_fill_qh - fill the static endpoint state in a qset&#39;s QHead</span>
<span class="cm"> * @qset: the qset whose QH needs initializing with static endpoint</span>
<span class="cm"> *        state</span>
<span class="cm"> * @urb:  an urb for a transfer to this endpoint</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qset_fill_qh</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span> <span class="o">=</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_wireless_ep_comp_descriptor</span> <span class="o">*</span><span class="n">epcd</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_out</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">phy_rate</span><span class="p">;</span>

	<span class="n">is_out</span> <span class="o">=</span> <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>

	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_packet</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">);</span>

	<span class="n">epcd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_wireless_ep_comp_descriptor</span> <span class="o">*</span><span class="p">)</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_seq</span> <span class="o">=</span> <span class="n">epcd</span><span class="o">-&gt;</span><span class="n">bMaxSequence</span><span class="p">;</span>
		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">=</span> <span class="n">epcd</span><span class="o">-&gt;</span><span class="n">bMaxBurst</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_seq</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initial PHY rate is 53.3 Mbit/s for control endpoints or</span>
<span class="cm">	 * the maximum supported by the device for other endpoints</span>
<span class="cm">	 * (unless limited by the user).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">phy_rate</span> <span class="o">=</span> <span class="n">UWB_PHY_RATE_53</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="n">phy_rates</span><span class="p">;</span>

		<span class="n">phy_rates</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">wusb_dev</span><span class="o">-&gt;</span><span class="n">wusb_cap_descr</span><span class="o">-&gt;</span><span class="n">wPHYRates</span><span class="p">);</span>
		<span class="n">phy_rate</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">phy_rates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_rate</span> <span class="o">&gt;</span> <span class="n">whc</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">.</span><span class="n">phy_rate</span><span class="p">)</span>
			<span class="n">phy_rate</span> <span class="o">=</span> <span class="n">whc</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">.</span><span class="n">phy_rate</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">info1</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
		<span class="n">QH_INFO1_EP</span><span class="p">(</span><span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">is_out</span> <span class="o">?</span> <span class="n">QH_INFO1_DIR_OUT</span> <span class="o">:</span> <span class="n">QH_INFO1_DIR_IN</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">usb_pipe_to_qh_type</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">QH_INFO1_DEV_INFO_IDX</span><span class="p">(</span><span class="n">wusb_port_no_to_idx</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">portnum</span><span class="p">))</span>
		<span class="o">|</span> <span class="n">QH_INFO1_MAX_PKT_LEN</span><span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_packet</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">info2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
		<span class="n">QH_INFO2_BURST</span><span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">QH_INFO2_DBP</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">QH_INFO2_MAX_COUNT</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">QH_INFO2_MAX_RETRY</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">QH_INFO2_MAX_SEQ</span><span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_seq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="cm">/* FIXME: where can we obtain these Tx parameters from?  Why</span>
<span class="cm">	 * doesn&#39;t the chip know what Tx power to use? It knows the Rx</span>
<span class="cm">	 * strength and can presumably guess the Tx power required</span>
<span class="cm">	 * from that? */</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">info3</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
		<span class="n">QH_INFO3_TX_RATE</span><span class="p">(</span><span class="n">phy_rate</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">QH_INFO3_TX_PWR</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="cm">/* 0 == max power */</span>
		<span class="p">);</span>

	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">cur_window</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_clear - clear fields in a qset so it may be reinserted into a</span>
<span class="cm"> * schedule.</span>
<span class="cm"> *</span>
<span class="cm"> * The sequence number and current window are not cleared (see</span>
<span class="cm"> * qset_reset()).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qset_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_start</span> <span class="o">=</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_end</span> <span class="o">=</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">ntds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">QH_LINK_NTDS</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">QH_LINK_T</span><span class="p">);</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">QH_STATUS_SEQ_MASK</span><span class="p">;</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">err_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">scratch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">scratch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">scratch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">overlay</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">overlay</span><span class="p">));</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">remove_complete</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_reset - reset endpoint state in a qset.</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the sequence number and current window.  This qset must not</span>
<span class="cm"> * be in the ASL or PZL.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qset_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QH_STATUS_SEQ_MASK</span><span class="p">;</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">cur_window</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_qset - get the qset for an async endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * A new qset is created if one does not already exist.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="nf">get_qset</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">;</span>

	<span class="n">qset</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qset</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qset</span> <span class="o">=</span> <span class="n">qset_alloc</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qset</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">qset</span><span class="p">;</span>
		<span class="n">qset_fill_qh</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">qset</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">qset_remove_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">remove</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">remove_complete</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_add_qtds - add qTDs for an URB to a qset</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the list (ASL/PZL) must be updated because (for a</span>
<span class="cm"> * WHCI 0.95 controller) an activated qTD was pointed to be iCur.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">whc_update</span> <span class="nf">qset_add_qtds</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">whc_update</span> <span class="n">update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">whc_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">ntds</span> <span class="o">&gt;=</span> <span class="n">WHCI_QSET_TD_MAX</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">pause_after_urb</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">!=</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">pause_after_urb</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">qtd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* already has a qTD */</span>

		<span class="n">qtd</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">qtd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">qtd</span><span class="p">[</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_end</span><span class="p">];</span>

		<span class="cm">/* Fill in setup bytes for control transfers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">,</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">QTD_STS_ACTIVE</span> <span class="o">|</span> <span class="n">QTD_STS_LEN</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">whc_std_last</span><span class="p">(</span><span class="n">std</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">QTD_STS_LAST_PKT</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For an IN transfer the iAlt field should be set so</span>
<span class="cm">		 * the h/w will automatically advance to the next</span>
<span class="cm">		 * transfer. However, if there are 8 or more TDs</span>
<span class="cm">		 * remaining in this transfer then iAlt cannot be set</span>
<span class="cm">		 * as it could point to somewhere in this transfer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">&lt;</span> <span class="n">WHCI_QSET_TD_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ialt</span><span class="p">;</span>
			<span class="n">ialt</span> <span class="o">=</span> <span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_end</span> <span class="o">+</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span><span class="p">)</span> <span class="o">%</span> <span class="n">WHCI_QSET_TD_MAX</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">QTD_STS_IALT</span><span class="p">(</span><span class="n">ialt</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">))</span>
			<span class="n">qset</span><span class="o">-&gt;</span><span class="n">pause_after_urb</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span><span class="p">)</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_OPT_IOC</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">QTD_OPT_IOC</span> <span class="o">|</span> <span class="n">QTD_OPT_SMALL</span><span class="p">);</span>
		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">page_list_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>

		<span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">QH_STATUS_TO_ICUR</span><span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">status</span><span class="p">)</span> <span class="o">==</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_end</span><span class="p">)</span>
			<span class="n">update</span> <span class="o">=</span> <span class="n">WHC_UPDATE_UPDATED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_end</span> <span class="o">&gt;=</span> <span class="n">WHCI_QSET_TD_MAX</span><span class="p">)</span>
			<span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">ntds</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">update</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_remove_qtd - remove the first qTD from a qset.</span>
<span class="cm"> *</span>
<span class="cm"> * The qTD might be still active (if it&#39;s part of a IN URB that</span>
<span class="cm"> * resulted in a short read) so ensure it&#39;s deactivated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qset_remove_qtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">qtd</span><span class="p">[</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_start</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_start</span> <span class="o">&gt;=</span> <span class="n">WHCI_QSET_TD_MAX</span><span class="p">)</span>
		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">ntds</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qset_copy_bounce_to_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bounce</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">bounce</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_buf</span><span class="p">;</span>
	<span class="n">remaining</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_sg</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_offset</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">remaining</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bounce</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">bounce</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_free_std - remove an sTD and free it.</span>
<span class="cm"> * @whc: the WHCI host controller</span>
<span class="cm"> * @std: the sTD to remove and free.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qset_free_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">is_out</span> <span class="o">=</span> <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
		<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span><span class="p">)</span>
			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buf_ptr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">;</span>

		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span>
				 <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">is_out</span> <span class="o">?</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_out</span><span class="p">)</span>
			<span class="n">qset_copy_bounce_to_sg</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">std</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">)</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
					 <span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_page_list_entry</span><span class="p">),</span>
					 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">);</span>
		<span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">std</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_remove_qtds - remove an URB&#39;s qTDs (and sTDs).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qset_remove_qtds</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">!=</span> <span class="n">urb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">qtd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">qset_remove_qtd</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">);</span>
		<span class="n">qset_free_std</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">std</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_free_stds - free any remaining sTDs for an URB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qset_free_stds</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">==</span> <span class="n">urb</span><span class="p">)</span>
			<span class="n">qset_free_std</span><span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">whc</span><span class="p">,</span> <span class="n">std</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qset_fill_page_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">pl_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Short buffers don&#39;t need a page list. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">WHCI_PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">dma_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">WHCI_PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">dma_addr</span> <span class="o">+</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">ep</span> <span class="o">-</span> <span class="n">sp</span><span class="p">,</span> <span class="n">WHCI_PAGE_SIZE</span><span class="p">);</span>

	<span class="n">pl_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_page_list_entry</span><span class="p">);</span>
	<span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">pl_len</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">,</span> <span class="n">pl_len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">WHCI_PAGE_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">WHCI_PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * urb_dequeue_work - executes asl/pzl update and gives back the urb to the system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">urb_dequeue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_urb</span> <span class="o">*</span><span class="n">wurb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_urb</span><span class="p">,</span> <span class="n">dequeue_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span> <span class="o">=</span> <span class="n">wurb</span><span class="o">-&gt;</span><span class="n">qset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span> <span class="o">=</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">whc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wurb</span><span class="o">-&gt;</span><span class="n">is_async</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
		<span class="n">asl_update</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">WUSBCMD_ASYNC_UPDATED</span>
			   <span class="o">|</span> <span class="n">WUSBCMD_ASYNC_SYNCED_DB</span>
			   <span class="o">|</span> <span class="n">WUSBCMD_ASYNC_QSET_RM</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pzl_update</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">WUSBCMD_PERIODIC_UPDATED</span>
			   <span class="o">|</span> <span class="n">WUSBCMD_PERIODIC_SYNCED_DB</span>
			   <span class="o">|</span> <span class="n">WUSBCMD_PERIODIC_QSET_RM</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">qset_remove_urb</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">wurb</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">,</span> <span class="n">wurb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="nf">qset_new_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">;</span>

	<span class="n">std</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_std</span><span class="p">),</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">std</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">std</span><span class="o">-&gt;</span><span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">std</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qset_add_urb_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
			   <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ntds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">whc_page_list_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">prev_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">pl_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">remaining</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_mapped_sgs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">dma_remaining</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num_pointers</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">dma_remaining</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="n">remaining</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">dma_remaining</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">size_t</span> <span class="n">dma_len</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * We can use the previous std (if it exists) provided that:</span>
<span class="cm">			 * - the previous one ended on a page boundary.</span>
<span class="cm">			 * - the current one begins on a page boundary.</span>
<span class="cm">			 * - the previous one isn&#39;t full.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If a new std is needed but the previous one</span>
<span class="cm">			 * was not a whole number of packets then this</span>
<span class="cm">			 * sg list cannot be mapped onto multiple</span>
<span class="cm">			 * qTDs.  Return an error and let the caller</span>
<span class="cm">			 * sort it out.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">prev_end</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WHCI_PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WHCI_PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			    <span class="o">||</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">WHCI_PAGE_SIZE</span> <span class="o">&gt;</span> <span class="n">QTD_MAX_XFER_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">std</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">%</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_packet</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">std</span> <span class="o">=</span> <span class="n">qset_new_std</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">std</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ntds</span><span class="o">++</span><span class="p">;</span>
				<span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dma_len</span> <span class="o">=</span> <span class="n">dma_remaining</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the remainder of this element doesn&#39;t</span>
<span class="cm">			 * fit in a single qTD, limit the qTD to a</span>
<span class="cm">			 * whole number of packets.  This allows the</span>
<span class="cm">			 * remainder to go into the next qTD.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">dma_len</span> <span class="o">&gt;</span> <span class="n">QTD_MAX_XFER_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dma_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">QTD_MAX_XFER_SIZE</span> <span class="o">/</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_packet</span><span class="p">)</span>
					<span class="o">*</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_packet</span> <span class="o">-</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">dma_len</span><span class="p">;</span>
			<span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* filled in later */</span>

			<span class="n">sp</span> <span class="o">=</span> <span class="n">dma_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">WHCI_PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">dma_addr</span> <span class="o">+</span> <span class="n">dma_len</span><span class="p">;</span>
			<span class="n">num_pointers</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">ep</span> <span class="o">-</span> <span class="n">sp</span><span class="p">,</span> <span class="n">WHCI_PAGE_SIZE</span><span class="p">);</span>
			<span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span> <span class="o">+=</span> <span class="n">num_pointers</span><span class="p">;</span>

			<span class="n">pl_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_page_list_entry</span><span class="p">);</span>

			<span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">,</span> <span class="n">pl_len</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">for</span> <span class="p">(;</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">);</span>
				<span class="n">dma_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">WHCI_PAGE_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">WHCI_PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">prev_end</span> <span class="o">=</span> <span class="n">dma_addr</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="n">dma_remaining</span> <span class="o">-=</span> <span class="n">dma_len</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">dma_len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Now the number of stds is know, go back and fill in</span>
<span class="cm">	   std-&gt;ntds_remaining. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pl_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">num_pointers</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_page_list_entry</span><span class="p">);</span>
			<span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">=</span> <span class="n">ntds</span><span class="o">--</span><span class="p">;</span>
			<span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">pl_virt</span><span class="p">,</span>
						       <span class="n">pl_len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_add_urb_sg_linearize - add an urb with sg list, copying the data</span>
<span class="cm"> *</span>
<span class="cm"> * If the URB contains an sg list whose elements cannot be directly</span>
<span class="cm"> * mapped to qTDs then the data must be transferred via bounce</span>
<span class="cm"> * buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qset_add_urb_sg_linearize</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">is_out</span> <span class="o">=</span> <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">max_std_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ntds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bounce</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* limit maximum bounce buffer to 16 * 3.5 KiB ~= 28 k */</span>
	<span class="n">max_std_len</span> <span class="o">=</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">*</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">max_packet</span><span class="p">;</span>

	<span class="n">remaining</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_mapped_sgs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">sg_remaining</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">orig</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sg_remaining</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">orig</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sg_remaining</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span> <span class="o">||</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">max_std_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">std</span> <span class="o">=</span> <span class="n">qset_new_std</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">std</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">max_std_len</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_sg</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
				<span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_offset</span> <span class="o">=</span> <span class="n">orig</span> <span class="o">-</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
				<span class="n">bounce</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_buf</span><span class="p">;</span>
				<span class="n">ntds</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sg_remaining</span><span class="p">,</span> <span class="n">max_std_len</span> <span class="o">-</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">is_out</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">bounce</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* filled in later */</span>

			<span class="n">bounce</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">orig</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">sg_remaining</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For each of the new sTDs, map the bounce buffers, create</span>
<span class="cm">	 * page lists (if necessary), and fill in std-&gt;ntds_remaining.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">umc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">bounce_buf</span><span class="p">,</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					       <span class="n">is_out</span> <span class="o">?</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">:</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qset_fill_page_list</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">=</span> <span class="n">ntds</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_add_urb - add an urb to the qset&#39;s queue.</span>
<span class="cm"> *</span>
<span class="cm"> * The URB is chopped into sTDs, one for each qTD that will required.</span>
<span class="cm"> * At least one qTD (and sTD) is required even if the transfer has no</span>
<span class="cm"> * data (e.g., for some control transfers).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qset_add_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_urb</span> <span class="o">*</span><span class="n">wurb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ntds_remaining</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">wurb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc_urb</span><span class="p">),</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wurb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">wurb</span><span class="p">;</span>
	<span class="n">wurb</span><span class="o">-&gt;</span><span class="n">qset</span> <span class="o">=</span> <span class="n">qset</span><span class="p">;</span>
	<span class="n">wurb</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wurb</span><span class="o">-&gt;</span><span class="n">dequeue_work</span><span class="p">,</span> <span class="n">urb_dequeue_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">num_sgs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qset_add_urb_sg</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qset_free_stds</span><span class="p">(</span><span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">qset_add_urb_sg_linearize</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ntds_remaining</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="n">QTD_MAX_XFER_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntds_remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ntds_remaining</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ntds_remaining</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">std_len</span><span class="p">;</span>

		<span class="n">std_len</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std_len</span> <span class="o">&gt;</span> <span class="n">QTD_MAX_XFER_SIZE</span><span class="p">)</span>
			<span class="n">std_len</span> <span class="o">=</span> <span class="n">QTD_MAX_XFER_SIZE</span><span class="p">;</span>

		<span class="n">std</span> <span class="o">=</span> <span class="n">qset_new_std</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">std</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>

		<span class="n">std</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">transfer_dma</span><span class="p">;</span>
		<span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">std_len</span><span class="p">;</span>
		<span class="n">std</span><span class="o">-&gt;</span><span class="n">ntds_remaining</span> <span class="o">=</span> <span class="n">ntds_remaining</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qset_fill_page_list</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>

		<span class="n">ntds_remaining</span><span class="o">--</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">std_len</span><span class="p">;</span>
		<span class="n">transfer_dma</span> <span class="o">+=</span> <span class="n">std_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_no_mem:</span>
	<span class="n">qset_free_stds</span><span class="p">(</span><span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_remove_urb - remove an URB from the urb queue.</span>
<span class="cm"> *</span>
<span class="cm"> * The URB is returned to the USB subsystem.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qset_remove_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wusbhc</span> <span class="o">*</span><span class="n">wusbhc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">wusbhc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">whc_urb</span> <span class="o">*</span><span class="n">wurb</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>

	<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wusbhc</span><span class="o">-&gt;</span><span class="n">usb_hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="cm">/* Drop the lock as urb-&gt;complete() may enqueue another urb. */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">wusbhc_giveback_urb</span><span class="p">(</span><span class="n">wusbhc</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">wurb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_urb_status_from_qtd - get the completed urb status from qTD status</span>
<span class="cm"> * @urb:    completed urb</span>
<span class="cm"> * @status: qTD status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_urb_status_from_qtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">QTD_STS_HALTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">QTD_STS_DBE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOSR</span> <span class="o">:</span> <span class="o">-</span><span class="n">ECOMM</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">QTD_STS_BABBLE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">QTD_STS_RCE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_SHORT_NOT_OK</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EREMOTEIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * process_inactive_qtd - process an inactive (but not halted) qTD.</span>
<span class="cm"> *</span>
<span class="cm"> * Update the urb with the transfer bytes from the qTD, if the urb is</span>
<span class="cm"> * completely transferred or (in the case of an IN only) the LPF is</span>
<span class="cm"> * set, then the transfer is complete and the urb should be returned</span>
<span class="cm"> * to the system.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">process_inactive_qtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">whc_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_std</span><span class="p">,</span> <span class="n">list_node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">complete</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">QTD_STS_TO_LEN</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">QTD_STS_LAST_PKT</span><span class="p">))</span>
		<span class="n">complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">complete</span> <span class="o">=</span> <span class="n">whc_std_last</span><span class="p">(</span><span class="n">std</span><span class="p">);</span>

	<span class="n">qset_remove_qtd</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">);</span>
	<span class="n">qset_free_std</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">std</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transfers for this URB are complete?  Then return it to the</span>
<span class="cm">	 * USB subsystem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qset_remove_qtds</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
		<span class="n">qset_remove_urb</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">get_urb_status_from_qtd</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * If iAlt isn&#39;t valid then the hardware didn&#39;t</span>
<span class="cm">		 * advance iCur. Adjust the start and end pointers to</span>
<span class="cm">		 * match iCur.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">QTD_STS_IALT_VALID</span><span class="p">))</span>
			<span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_start</span> <span class="o">=</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">td_end</span>
				<span class="o">=</span> <span class="n">QH_STATUS_TO_ICUR</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">qh</span><span class="p">.</span><span class="n">status</span><span class="p">));</span>
		<span class="n">qset</span><span class="o">-&gt;</span><span class="n">pause_after_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * process_halted_qtd - process a qset with a halted qtd</span>
<span class="cm"> *</span>
<span class="cm"> * Remove all the qTDs for the failed URB and return the failed URB to</span>
<span class="cm"> * the USB subsystem.  Then remove all other qTDs so the qset can be</span>
<span class="cm"> * removed.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: this is the point where rate adaptation can be done.  If a</span>
<span class="cm"> * transfer failed because it exceeded the maximum number of retries</span>
<span class="cm"> * then it could be reactivated with a slower rate without having to</span>
<span class="cm"> * remove the qset.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">process_halted_qtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">whc_qtd</span> <span class="o">*</span><span class="n">qtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">whc_std</span> <span class="o">*</span><span class="n">std</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_std</span><span class="p">,</span> <span class="n">list_node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">std</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">urb_status</span><span class="p">;</span>

	<span class="n">urb_status</span> <span class="o">=</span> <span class="n">get_urb_status_from_qtd</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">qtd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>

	<span class="n">qset_remove_qtds</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="n">qset_remove_urb</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">urb_status</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">stds</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">ntds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">qset_remove_qtd</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">);</span>
		<span class="n">std</span><span class="o">-&gt;</span><span class="n">qtd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qset</span><span class="o">-&gt;</span><span class="n">remove</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">qset_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">whc</span><span class="o">-&gt;</span><span class="n">qset_pool</span><span class="p">,</span> <span class="n">qset</span><span class="p">,</span> <span class="n">qset</span><span class="o">-&gt;</span><span class="n">qset_dma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qset_delete - wait for a qset to be unused, then free it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qset_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">whc</span> <span class="o">*</span><span class="n">whc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">whc_qset</span> <span class="o">*</span><span class="n">qset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qset</span><span class="o">-&gt;</span><span class="n">remove_complete</span><span class="p">);</span>
	<span class="n">qset_free</span><span class="p">(</span><span class="n">whc</span><span class="p">,</span> <span class="n">qset</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
