<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › xhci-hub.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xhci-hub.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * xHCI host controller driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Sarah Sharp</span>
<span class="cm"> * Some code borrowed from the Linux EHCI driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &quot;xhci.h&quot;</span>

<span class="cp">#define	PORT_WAKE_BITS	(PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E)</span>
<span class="cp">#define	PORT_RWC_BITS	(PORT_CSC | PORT_PEC | PORT_WRC | PORT_OCC | \</span>
<span class="cp">			 PORT_RC | PORT_PLC | PORT_PE)</span>

<span class="cm">/* usb 1.1 root hub device descriptor */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">usb_bos_descriptor</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">USB_DT_BOS_SIZE</span><span class="p">,</span>		<span class="cm">/*  __u8 bLength, 5 bytes */</span>
	<span class="n">USB_DT_BOS</span><span class="p">,</span>			<span class="cm">/*  __u8 bDescriptorType */</span>
	<span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>			<span class="cm">/*  __le16 wTotalLength, 15 bytes */</span>
	<span class="mh">0x1</span><span class="p">,</span>				<span class="cm">/*  __u8 bNumDeviceCaps */</span>
	<span class="cm">/* First device capability */</span>
	<span class="n">USB_DT_USB_SS_CAP_SIZE</span><span class="p">,</span>		<span class="cm">/*  __u8 bLength, 10 bytes */</span>
	<span class="n">USB_DT_DEVICE_CAPABILITY</span><span class="p">,</span>	<span class="cm">/* Device Capability */</span>
	<span class="n">USB_SS_CAP_TYPE</span><span class="p">,</span>		<span class="cm">/* bDevCapabilityType, SUPERSPEED_USB */</span>
	<span class="mh">0x00</span><span class="p">,</span>				<span class="cm">/* bmAttributes, LTM off by default */</span>
	<span class="n">USB_5GBPS_OPERATION</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>	<span class="cm">/* wSpeedsSupported, 5Gbps only */</span>
	<span class="mh">0x03</span><span class="p">,</span>				<span class="cm">/* bFunctionalitySupport,</span>
<span class="cm">					   USB 3.0 speed only */</span>
	<span class="mh">0x00</span><span class="p">,</span>				<span class="cm">/* bU1DevExitLat, set later. */</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>			<span class="cm">/* __le16 bU2DevExitLat, set later. */</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_common_hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ports</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bPwrOn2PwrGood</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>	<span class="cm">/* xhci section 5.4.9 says 20ms max */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bHubContrCurrent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bNbrPorts</span> <span class="o">=</span> <span class="n">ports</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Bits 1:0 - support per-port power switching, or power always on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HCC_PPC</span><span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">hcc_params</span><span class="p">))</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">HUB_CHAR_INDV_PORT_LPSM</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">HUB_CHAR_NO_LPSM</span><span class="p">;</span>
	<span class="cm">/* Bit  2 - root hubs are not part of a compound device */</span>
	<span class="cm">/* Bits 4:3 - individual port over current protection */</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="n">HUB_CHAR_INDV_PORT_OCPM</span><span class="p">;</span>
	<span class="cm">/* Bits 6:5 - no TTs in root ports */</span>
	<span class="cm">/* Bit  7 - no port indicators */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">wHubCharacteristics</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Fill in the USB 2.0 roothub descriptor */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_usb2_hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ports</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">port_removable</span><span class="p">[(</span><span class="n">USB_MAXCHILDREN</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">portsc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ports</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_usb2_ports</span><span class="p">;</span>

	<span class="n">xhci_common_hub_descriptor</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">ports</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="n">USB_DT_HUB</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">ports</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescLength</span> <span class="o">=</span> <span class="n">USB_DT_HUB_NONVAR_SIZE</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* The Device Removable bits are reported on a byte granularity.</span>
<span class="cm">	 * If the port doesn&#39;t exist within that byte, the bit is set to 0.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">port_removable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">port_removable</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">portsc</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb2_ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="cm">/* If a device is removable, PORTSC reports a 0, same as in the</span>
<span class="cm">		 * hub descriptor DeviceRemovable bits.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORT_DEV_REMOVE</span><span class="p">)</span>
			<span class="cm">/* This math is hairy because bit 0 of DeviceRemovable</span>
<span class="cm">			 * is reserved, and bit 1 is for port 1, etc.</span>
<span class="cm">			 */</span>
			<span class="n">port_removable</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ch11.h defines a hub descriptor that has room for USB_MAXCHILDREN</span>
<span class="cm">	 * ports on it.  The USB 2.0 specification says that there are two</span>
<span class="cm">	 * variable length fields at the end of the hub descriptor:</span>
<span class="cm">	 * DeviceRemovable and PortPwrCtrlMask.  But since we can have less than</span>
<span class="cm">	 * USB_MAXCHILDREN ports, we may need to use the DeviceRemovable array</span>
<span class="cm">	 * to set PortPwrCtrlMask bits.  PortPwrCtrlMask must always be set to</span>
<span class="cm">	 * 0xFF, so we initialize the both arrays (DeviceRemovable and</span>
<span class="cm">	 * PortPwrCtrlMask) to 0xFF.  Then we set the DeviceRemovable for each</span>
<span class="cm">	 * set of ports that actually exist.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">PortPwrCtrlMask</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">PortPwrCtrlMask</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ports</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hs</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">port_removable</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">__u8</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Fill in the USB 3.0 roothub descriptor */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_usb3_hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ports</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">port_removable</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">portsc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ports</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_usb3_ports</span><span class="p">;</span>
	<span class="n">xhci_common_hub_descriptor</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">ports</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="n">USB_DT_SS_HUB</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescLength</span> <span class="o">=</span> <span class="n">USB_DT_SS_HUB_SIZE</span><span class="p">;</span>

	<span class="cm">/* header decode latency should be zero for roothubs,</span>
<span class="cm">	 * see section 4.23.5.2.</span>
<span class="cm">	 */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ss</span><span class="p">.</span><span class="n">bHubHdrDecLat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ss</span><span class="p">.</span><span class="n">wHubDelay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">port_removable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* bit 0 is reserved, bit 1 is for port 1, etc. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">portsc</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb3_ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">portsc</span> <span class="o">&amp;</span> <span class="n">PORT_DEV_REMOVE</span><span class="p">)</span>
			<span class="n">port_removable</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ss</span><span class="p">.</span><span class="n">DeviceRemovable</span><span class="p">,</span>
			<span class="p">(</span><span class="n">__force</span> <span class="n">__u16</span><span class="p">)</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">port_removable</span><span class="p">),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_hub_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">)</span>
		<span class="n">xhci_usb3_hub_descriptor</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xhci_usb2_hub_descriptor</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">xhci_port_speed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEV_LOWSPEED</span><span class="p">(</span><span class="n">port_status</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">USB_PORT_STAT_LOW_SPEED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEV_HIGHSPEED</span><span class="p">(</span><span class="n">port_status</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">USB_PORT_STAT_HIGH_SPEED</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Yes, we should check for full speed, but the core uses that as</span>
<span class="cm">	 * a default in portspeed() in usb/core/hub.c (which is the only place</span>
<span class="cm">	 * USB_PORT_STAT_*_SPEED is used).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These bits are Read Only (RO) and should be saved and written to the</span>
<span class="cm"> * registers: 0, 3, 10:13, 30</span>
<span class="cm"> * connect status, over-current status, port speed, and device removable.</span>
<span class="cm"> * connect status and port speed are also sticky - meaning they&#39;re in</span>
<span class="cm"> * the AUX well and they aren&#39;t changed by a hot, warm, or cold reset.</span>
<span class="cm"> */</span>
<span class="cp">#define	XHCI_PORT_RO	((1&lt;&lt;0) | (1&lt;&lt;3) | (0xf&lt;&lt;10) | (1&lt;&lt;30))</span>
<span class="cm">/*</span>
<span class="cm"> * These bits are RW; writing a 0 clears the bit, writing a 1 sets the bit:</span>
<span class="cm"> * bits 5:8, 9, 14:15, 25:27</span>
<span class="cm"> * link state, port power, port indicator state, &quot;wake on&quot; enable state</span>
<span class="cm"> */</span>
<span class="cp">#define XHCI_PORT_RWS	((0xf&lt;&lt;5) | (1&lt;&lt;9) | (0x3&lt;&lt;14) | (0x7&lt;&lt;25))</span>
<span class="cm">/*</span>
<span class="cm"> * These bits are RW; writing a 1 sets the bit, writing a 0 has no effect:</span>
<span class="cm"> * bit 4 (port reset)</span>
<span class="cm"> */</span>
<span class="cp">#define	XHCI_PORT_RW1S	((1&lt;&lt;4))</span>
<span class="cm">/*</span>
<span class="cm"> * These bits are RW; writing a 1 clears the bit, writing a 0 has no effect:</span>
<span class="cm"> * bits 1, 17, 18, 19, 20, 21, 22, 23</span>
<span class="cm"> * port enable/disable, and</span>
<span class="cm"> * change bits: connect, PED, warm port reset changed (reserved zero for USB 2.0 ports),</span>
<span class="cm"> * over-current, reset, link state, and L1 change</span>
<span class="cm"> */</span>
<span class="cp">#define XHCI_PORT_RW1CS	((1&lt;&lt;1) | (0x7f&lt;&lt;17))</span>
<span class="cm">/*</span>
<span class="cm"> * Bit 16 is RW, and writing a &#39;1&#39; to it causes the link state control to be</span>
<span class="cm"> * latched in</span>
<span class="cm"> */</span>
<span class="cp">#define	XHCI_PORT_RW	((1&lt;&lt;16))</span>
<span class="cm">/*</span>
<span class="cm"> * These bits are Reserved Zero (RsvdZ) and zero should be written to them:</span>
<span class="cm"> * bits 2, 24, 28:31</span>
<span class="cm"> */</span>
<span class="cp">#define	XHCI_PORT_RZ	((1&lt;&lt;2) | (1&lt;&lt;24) | (0xf&lt;&lt;28))</span>

<span class="cm">/*</span>
<span class="cm"> * Given a port state, this function returns a value that would result in the</span>
<span class="cm"> * port being in the same state, if the value was written to the port status</span>
<span class="cm"> * control register.</span>
<span class="cm"> * Save Read Only (RO) bits and save read/write bits where</span>
<span class="cm"> * writing a 0 clears the bit and writing a 1 sets the bit (RWS).</span>
<span class="cm"> * For all other types (RW1S, RW1CS, RW, and RZ), writing a &#39;0&#39; has no effect.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">u32</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save read-only status and port state */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">XHCI_PORT_RO</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">XHCI_PORT_RWS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find slot id based on port number.</span>
<span class="cm"> * @port: The one-based port number from one of the two split roothubs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span> <span class="n">speed</span><span class="p">;</span>

	<span class="n">slot_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_HC_SLOTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fake_port</span> <span class="o">==</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">slot_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">slot_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop device</span>
<span class="cm"> * It issues stop endpoint command for EP 0 to 30. And wait the last command</span>
<span class="cm"> * to complete.</span>
<span class="cm"> * suspend will set to 1, if suspend bit need to set in command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_stop_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">suspend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_virt_device</span> <span class="o">*</span><span class="n">virt_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeleft</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">virt_dev</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">xhci_alloc_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t allocate command structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">LAST_EP_INDEX</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ring</span> <span class="o">&amp;&amp;</span> <span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">)</span>
			<span class="n">xhci_queue_stop_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">suspend</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">command_trb</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cmd_ring</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">virt_dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="n">xhci_queue_stop_endpoint</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">suspend</span><span class="p">);</span>
	<span class="n">xhci_ring_cmd_db</span><span class="p">(</span><span class="n">xhci</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Wait for last stop endpoint command to finish */</span>
	<span class="n">timeleft</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">,</span>
			<span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;%s while waiting for stop endpoint command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">timeleft</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Timeout&quot;</span> <span class="o">:</span> <span class="s">&quot;Signal&quot;</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* The timeout might have raced with the event ring handler, so</span>
<span class="cm">		 * only delete from the list if the item isn&#39;t poisoned.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">LIST_POISON1</span><span class="p">)</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">command_cleanup</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">command_cleanup:</span>
	<span class="n">xhci_free_command</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ring device, it rings the all doorbells unconditionally.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xhci_ring_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LAST_EP_INDEX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ring</span> <span class="o">&amp;&amp;</span>
		    <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">devs</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">)</span>
			<span class="n">xhci_ring_ep_doorbell</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_disable_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t allow the USB core to disable SuperSpeed ports. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Ignoring request to disable &quot;</span>
				<span class="s">&quot;SuperSpeed port.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write 1 to disable the port */</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_status</span> <span class="o">|</span> <span class="n">PORT_PE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">port_status</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;disable port, actual port %d status  = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">wIndex</span><span class="p">,</span> <span class="n">port_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xhci_clear_port_change_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">port_change_bit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">PORT_RC</span><span class="p">;</span>
		<span class="n">port_change_bit</span> <span class="o">=</span> <span class="s">&quot;reset&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_BH_PORT_RESET</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">PORT_WRC</span><span class="p">;</span>
		<span class="n">port_change_bit</span> <span class="o">=</span> <span class="s">&quot;warm(BH) reset&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">PORT_CSC</span><span class="p">;</span>
		<span class="n">port_change_bit</span> <span class="o">=</span> <span class="s">&quot;connect&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">PORT_OCC</span><span class="p">;</span>
		<span class="n">port_change_bit</span> <span class="o">=</span> <span class="s">&quot;over-current&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_ENABLE</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">PORT_PEC</span><span class="p">;</span>
		<span class="n">port_change_bit</span> <span class="o">=</span> <span class="s">&quot;enable/disable&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">PORT_PLC</span><span class="p">;</span>
		<span class="n">port_change_bit</span> <span class="o">=</span> <span class="s">&quot;suspend/resume&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_PORT_LINK_STATE</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">PORT_PLC</span><span class="p">;</span>
		<span class="n">port_change_bit</span> <span class="o">=</span> <span class="s">&quot;link state&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Should never happen */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Change bits are all write 1 to clear */</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_status</span> <span class="o">|</span> <span class="n">status</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">port_status</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;clear port %s change, actual port %d status  = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port_change_bit</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">port_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xhci_get_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">***</span><span class="n">port_array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_ports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_ports</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_usb3_ports</span><span class="p">;</span>
		<span class="o">*</span><span class="n">port_array</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb3_ports</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">max_ports</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">num_usb2_ports</span><span class="p">;</span>
		<span class="o">*</span><span class="n">port_array</span> <span class="o">=</span> <span class="n">xhci</span><span class="o">-&gt;</span><span class="n">usb2_ports</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">max_ports</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xhci_set_link_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">link_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_id</span><span class="p">]);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_PLS_MASK</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_LINK_STROBE</span> <span class="o">|</span> <span class="n">link_state</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_id</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xhci_set_remote_wake_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span>
		<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wake_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_id</span><span class="p">]);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake_mask</span> <span class="o">&amp;</span> <span class="n">USB_PORT_FEAT_REMOTE_WAKE_CONNECT</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_WKCONN_E</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_WKCONN_E</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake_mask</span> <span class="o">&amp;</span> <span class="n">USB_PORT_FEAT_REMOTE_WAKE_DISCONNECT</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_WKDISC_E</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_WKDISC_E</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake_mask</span> <span class="o">&amp;</span> <span class="n">USB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_WKOC_E</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_WKOC_E</span><span class="p">;</span>

	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_id</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Test and clear port RWC bit */</span>
<span class="kt">void</span> <span class="nf">xhci_test_and_clear_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">xhci_hcd</span> <span class="o">*</span><span class="n">xhci</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_id</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">port_bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">port_bit</span><span class="p">;</span>
		<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_id</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_hub_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_ports</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_bus_state</span> <span class="o">*</span><span class="n">bus_state</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">link_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">wake_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">max_ports</span> <span class="o">=</span> <span class="n">xhci_get_ports</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_array</span><span class="p">);</span>
	<span class="n">bus_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">hcd_index</span><span class="p">(</span><span class="n">hcd</span><span class="p">)];</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">typeReq</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GetHubStatus</span>:
		<span class="cm">/* No power source, over-current reported per port */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetHubDescriptor</span>:
		<span class="cm">/* Check to make sure userspace is asking for the USB 3.0 hub</span>
<span class="cm">		 * descriptor for the USB 3.0 roothub.  If not, we stall the</span>
<span class="cm">		 * endpoint, like external hubs do.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">wLength</span> <span class="o">&lt;</span> <span class="n">USB_DT_SS_HUB_SIZE</span> <span class="o">||</span>
				 <span class="n">wValue</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DT_SS_HUB</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Wrong hub descriptor type for &quot;</span>
					<span class="s">&quot;USB 3.0 roothub.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xhci_hub_descriptor</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">usb_hub_descriptor</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DeviceRequest</span> <span class="o">|</span> <span class="n">USB_REQ_GET_DESCRIPTOR</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">wValue</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">USB_DT_BOS</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_bos_descriptor</span><span class="p">,</span>
				<span class="n">USB_DT_BOS_SIZE</span> <span class="o">+</span> <span class="n">USB_DT_USB_SS_CAP_SIZE</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">cap_regs</span><span class="o">-&gt;</span><span class="n">hcs_params3</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCS_U1_LATENCY</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
		<span class="n">put_unaligned_le16</span><span class="p">(</span><span class="n">HCS_U2_LATENCY</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_DT_BOS_SIZE</span> <span class="o">+</span> <span class="n">USB_DT_USB_SS_CAP_SIZE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GetPortStatus</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">max_ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;get port status, actual port %d status  = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>

		<span class="cm">/* wPortChange bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CSC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_CONNECTION</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PEC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OCC</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_OVERCURRENT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RC</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="cm">/* USB3.0 only */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLC</span><span class="p">))</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_LINK_STATE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_WRC</span><span class="p">))</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_C_BH_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">XDEV_U3</span>
					<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_POWER</span><span class="p">))</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_SUSPEND</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">XDEV_RESUME</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">DEV_SUPERSPEED</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resume_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Resume USB2 port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resume_done</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">wIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resuming_ports</span><span class="p">);</span>
				<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
							<span class="n">XDEV_U0</span><span class="p">);</span>
				<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;set port %d resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
								 <span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot_id</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;slot_id is zero</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">xhci_ring_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
				<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_c_suspend</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">;</span>
				<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">suspended_ports</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The resume has been signaling for less than</span>
<span class="cm">				 * 20ms. Report the port status as SUSPEND,</span>
<span class="cm">				 * let the usbcore check port status again</span>
<span class="cm">				 * and clear resume signaling later.</span>
<span class="cm">				 */</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_SUSPEND</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">XDEV_U0</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_POWER</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">suspended_ports</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">suspended_ports</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span>
				<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_c_suspend</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">xhci_port_speed</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_ENABLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_OC</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_OVERCURRENT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_RESET</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_POWER</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_SS_PORT_STAT_POWER</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">USB_PORT_STAT_POWER</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Port Link State */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">HCD_USB3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* resume state is a xHCI internal state.</span>
<span class="cm">			 * Do not report it to usb core.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">XDEV_RESUME</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_c_suspend</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span><span class="p">;</span>
		<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Get port status returned 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">put_unaligned</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SetPortFeature</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_PORT_FEAT_LINK_STATE</span><span class="p">)</span>
			<span class="n">link_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wValue</span> <span class="o">==</span> <span class="n">USB_PORT_FEAT_REMOTE_WAKE_MASK</span><span class="p">)</span>
			<span class="n">wake_mask</span> <span class="o">=</span> <span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">;</span>
		<span class="cm">/* The MSB of wIndex is the U1/U2 timeout */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">wIndex</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">wIndex</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">max_ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
		<span class="cm">/* FIXME: What new port features do we need to support? */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">XDEV_U0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Resume the port to U0 first */</span>
				<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
							<span class="n">XDEV_U0</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* In spec software should not attempt to suspend</span>
<span class="cm">			 * a port unless the port reports that it is in the</span>
<span class="cm">			 * enabled (PED = ‘1’,PLS &lt; ‘3’) state.</span>
<span class="cm">			 */</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
				<span class="o">||</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">XDEV_U3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;USB core suspending device &quot;</span>
					  <span class="s">&quot;not in U0/U1/U2.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
					<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;slot_id is zero</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* unlock to execute stop endpoint commands */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">xhci_stop_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">XDEV_U3</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="cm">/* wait device to enter */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">suspended_ports</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_LINK_STATE</span>:
			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="cm">/* Software should not attempt to set</span>
<span class="cm">			 * port link state above &#39;5&#39; (Rx.Detect) and the port</span>
<span class="cm">			 * must be enabled.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">link_state</span> <span class="o">&gt;</span> <span class="n">USB_SS_PORT_LS_RX_DETECT</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xhci_warn</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;Cannot set link state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">USB_SS_PORT_LS_U3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
						<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">slot_id</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* unlock to execute stop endpoint</span>
<span class="cm">					 * commands */</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
								<span class="n">flags</span><span class="p">);</span>
					<span class="n">xhci_stop_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
						<span class="n">link_state</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="cm">/* wait device to enter */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">USB_SS_PORT_LS_U3</span><span class="p">)</span>
				<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">suspended_ports</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_POWER</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Turn on ports, even if there isn&#39;t per-port switching.</span>
<span class="cm">			 * HC will report connect events even before this is set.</span>
<span class="cm">			 * However, khubd will ignore the roothub events until</span>
<span class="cm">			 * the roothub is registered.</span>
<span class="cm">			 */</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_POWER</span><span class="p">,</span>
					<span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>

			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;set port power, actual port %d status  = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_RESET</span>:
			<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">|</span> <span class="n">PORT_RESET</span><span class="p">);</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>

			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;set port reset, actual port %d status  = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_REMOTE_WAKE_MASK</span>:
			<span class="n">xhci_set_remote_wake_mask</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span>
					<span class="n">wIndex</span><span class="p">,</span> <span class="n">wake_mask</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;set port remote wake mask, &quot;</span>
					<span class="s">&quot;actual port %d status  = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">wIndex</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_BH_PORT_RESET</span>:
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_WR</span><span class="p">;</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>

			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_U1_TIMEOUT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_U1_TIMEOUT_MASK</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_U1_TIMEOUT</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_U2_TIMEOUT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_U2_TIMEOUT_MASK</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">|=</span> <span class="n">PORT_U2_TIMEOUT</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* unblock any posted writes */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ClearPortFeature</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wIndex</span> <span class="o">||</span> <span class="n">wIndex</span> <span class="o">&gt;</span> <span class="n">max_ports</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">wIndex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIXME: What new port features do we need to support? */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">wValue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_SUSPEND</span>:
			<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">]);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;clear USB_PORT_FEAT_SUSPEND</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;PORTSC %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_RESET</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">XDEV_U3</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

				<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
							<span class="n">XDEV_RESUME</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
							<span class="n">XDEV_U0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_c_suspend</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">;</span>

			<span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
					<span class="n">wIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;slot_id is zero</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">xhci_ring_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_SUSPEND</span>:
			<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_c_suspend</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wIndex</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_RESET</span>:
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_BH_PORT_RESET</span>:
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_CONNECTION</span>:
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_OVER_CURRENT</span>:
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_ENABLE</span>:
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_C_PORT_LINK_STATE</span>:
			<span class="n">xhci_clear_port_change_bit</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
					<span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">],</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_PORT_FEAT_ENABLE</span>:
			<span class="n">xhci_disable_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span> <span class="n">wIndex</span><span class="p">,</span>
					<span class="n">port_array</span><span class="p">[</span><span class="n">wIndex</span><span class="p">],</span> <span class="n">temp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
<span class="nl">error:</span>
		<span class="cm">/* &quot;stall&quot; on error */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 0 if the status hasn&#39;t changed, or the number of bytes in buf.</span>
<span class="cm"> * Ports are 0-indexed from the HCD point of view,</span>
<span class="cm"> * and 1-indexed from the USB core pointer of view.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the status change bits will be cleared as soon as a port status</span>
<span class="cm"> * change event is generated, so we use the saved status from that event.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xhci_hub_status_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_ports</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_bus_state</span> <span class="o">*</span><span class="n">bus_state</span><span class="p">;</span>

	<span class="n">max_ports</span> <span class="o">=</span> <span class="n">xhci_get_ports</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_array</span><span class="p">);</span>
	<span class="n">bus_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">hcd_index</span><span class="p">(</span><span class="n">hcd</span><span class="p">)];</span>

	<span class="cm">/* Initial status is no changes */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_ports</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Inform the usbcore about resume-in-progress by returning</span>
<span class="cm">	 * a non-zero value even if there are no status changes.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resuming_ports</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">PORT_CSC</span> <span class="o">|</span> <span class="n">PORT_PEC</span> <span class="o">|</span> <span class="n">PORT_OCC</span> <span class="o">|</span> <span class="n">PORT_PLC</span> <span class="o">|</span> <span class="n">PORT_WRC</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* For each port, did anything change?  If so, set that bit in buf. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">port_c_suspend</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resume_done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">time_after_eq</span><span class="p">(</span>
			    <span class="n">jiffies</span><span class="p">,</span> <span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resume_done</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
			<span class="n">buf</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="kt">int</span> <span class="nf">xhci_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_ports</span><span class="p">,</span> <span class="n">port_index</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_bus_state</span> <span class="o">*</span><span class="n">bus_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">max_ports</span> <span class="o">=</span> <span class="n">xhci_get_ports</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_array</span><span class="p">);</span>
	<span class="n">bus_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">hcd_index</span><span class="p">(</span><span class="n">hcd</span><span class="p">)];</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">resuming_ports</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;suspend failed because &quot;</span>
						<span class="s">&quot;a port is resuming</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">port_index</span> <span class="o">=</span> <span class="n">max_ports</span><span class="p">;</span>
	<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">bus_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">port_index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* suspend the port if the port is not suspended */</span>
		<span class="n">u32</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>

		<span class="n">t1</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_index</span><span class="p">]);</span>
		<span class="n">t2</span> <span class="o">=</span> <span class="n">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">t1</span> <span class="o">&amp;</span> <span class="n">PORT_PE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">t1</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xhci_dbg</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="s">&quot;port %d not suspended</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port_index</span><span class="p">);</span>
			<span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">xhci</span><span class="p">,</span>
					<span class="n">port_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slot_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">xhci_stop_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">t2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_PLS_MASK</span><span class="p">;</span>
			<span class="n">t2</span> <span class="o">|=</span> <span class="n">PORT_LINK_STROBE</span> <span class="o">|</span> <span class="n">XDEV_U3</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">port_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">bus_suspended</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* USB core sets remote wake mask for USB 3.0 hubs,</span>
<span class="cm">		 * including the USB 3.0 roothub, but only if CONFIG_USB_SUSPEND</span>
<span class="cm">		 * is enabled, so also enable remote wake here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">root_hub</span><span class="o">-&gt;</span><span class="n">do_remote_wakeup</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">&amp;</span> <span class="n">PORT_CONNECT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">t2</span> <span class="o">|=</span> <span class="n">PORT_WKOC_E</span> <span class="o">|</span> <span class="n">PORT_WKDISC_E</span><span class="p">;</span>
				<span class="n">t2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_WKCONN_E</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">t2</span> <span class="o">|=</span> <span class="n">PORT_WKOC_E</span> <span class="o">|</span> <span class="n">PORT_WKCONN_E</span><span class="p">;</span>
				<span class="n">t2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_WKDISC_E</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">t2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_WAKE_BITS</span><span class="p">;</span>

		<span class="n">t1</span> <span class="o">=</span> <span class="n">xhci_port_state_to_neutral</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">!=</span> <span class="n">t2</span><span class="p">)</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_index</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enable remote wake up for USB 2.0 */</span>
			<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

			<span class="cm">/* Add one to the port status register address to get</span>
<span class="cm">			 * the port power control register address.</span>
<span class="cm">			 */</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_index</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="n">PORT_RWE</span><span class="p">;</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HC_STATE_SUSPENDED</span><span class="p">;</span>
	<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xhci_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xhci_hcd</span>	<span class="o">*</span><span class="n">xhci</span> <span class="o">=</span> <span class="n">hcd_to_xhci</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_ports</span><span class="p">,</span> <span class="n">port_index</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">port_array</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xhci_bus_state</span> <span class="o">*</span><span class="n">bus_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">max_ports</span> <span class="o">=</span> <span class="n">xhci_get_ports</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_array</span><span class="p">);</span>
	<span class="n">bus_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">bus_state</span><span class="p">[</span><span class="n">hcd_index</span><span class="p">(</span><span class="n">hcd</span><span class="p">)];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">next_statechange</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* delay the irqs */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CMD_EIE</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">port_index</span> <span class="o">=</span> <span class="n">max_ports</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">port_index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check whether need resume ports. If needed</span>
<span class="cm">		   resume port and disable remote wakeup */</span>
		<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>

		<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_index</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEV_SUPERSPEED</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_CEC</span> <span class="o">|</span> <span class="n">PORT_WAKE_BITS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PORT_RWC_BITS</span> <span class="o">|</span> <span class="n">PORT_WAKE_BITS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">port_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">bus_suspended</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PORT_PLS_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">DEV_SUPERSPEED</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span>
							<span class="n">port_index</span><span class="p">,</span> <span class="n">XDEV_U0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span>
						<span class="n">port_index</span><span class="p">,</span> <span class="n">XDEV_RESUME</span><span class="p">);</span>

				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

				<span class="n">xhci_set_link_state</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span>
							<span class="n">port_index</span><span class="p">,</span> <span class="n">XDEV_U0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* wait for the port to enter U0 and report port link</span>
<span class="cm">			 * state change.</span>
<span class="cm">			 */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* Clear PLC */</span>
			<span class="n">xhci_test_and_clear_bit</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">port_array</span><span class="p">,</span> <span class="n">port_index</span><span class="p">,</span>
						<span class="n">PORT_PLC</span><span class="p">);</span>

			<span class="n">slot_id</span> <span class="o">=</span> <span class="n">xhci_find_slot_id_by_port</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span>
					<span class="n">xhci</span><span class="p">,</span> <span class="n">port_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slot_id</span><span class="p">)</span>
				<span class="n">xhci_ring_device</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">slot_id</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_index</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">HCD_USB3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* disable remote wake up for USB 2.0 */</span>
			<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

			<span class="cm">/* Add one to the port status register address to get</span>
<span class="cm">			 * the port power control register address.</span>
<span class="cm">			 */</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">port_array</span><span class="p">[</span><span class="n">port_index</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PORT_RWE</span><span class="p">;</span>
			<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">bus_state</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="cm">/* re-enable irqs */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="n">CMD_EIE</span><span class="p">;</span>
	<span class="n">xhci_writel</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">xhci_readl</span><span class="p">(</span><span class="n">xhci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">op_regs</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xhci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
