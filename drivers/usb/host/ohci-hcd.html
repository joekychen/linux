<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › host › ohci-hcd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ohci-hcd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Open Host Controller Interface (OHCI) driver for USB.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintainer: Alan Stern &lt;stern@rowland.harvard.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 1999 Roman Weissgaerber &lt;weissg@vienna.at&gt;</span>
<span class="cm"> * (C) Copyright 2000-2004 David Brownell &lt;dbrownell@users.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * [ Initialisation is based on Linus&#39;  ]</span>
<span class="cm"> * [ uhci code and gregs ohci fragments ]</span>
<span class="cm"> * [ (C) Copyright 1999 Linus Torvalds  ]</span>
<span class="cm"> * [ (C) Copyright 1999 Gregory P. Smith]</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * OHCI is the main &quot;non-Intel/VIA&quot; standard for USB 1.1 host controller</span>
<span class="cm"> * interfaces (though some non-x86 Intel chips use it).  It supports</span>
<span class="cm"> * smarter hardware than UHCI.  A download link for the spec available</span>
<span class="cm"> * through the http://www.usb.org website.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licenced under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/otg.h&gt;</span>
<span class="cp">#include &lt;linux/usb/hcd.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>


<span class="cp">#define DRIVER_AUTHOR &quot;Roman Weissgaerber, David Brownell&quot;</span>
<span class="cp">#define DRIVER_DESC &quot;USB 1.1 &#39;Open&#39; Host Controller (OHCI) Driver&quot;</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#undef OHCI_VERBOSE_DEBUG	</span><span class="cm">/* not always helpful */</span><span class="cp"></span>

<span class="cm">/* For initializing controller (mask in an HCFS mode too) */</span>
<span class="cp">#define	OHCI_CONTROL_INIT	OHCI_CTRL_CBSR</span>
<span class="cp">#define	OHCI_INTR_INIT \</span>
<span class="cp">		(OHCI_INTR_MIE | OHCI_INTR_RHSC | OHCI_INTR_UE \</span>
<span class="cp">		| OHCI_INTR_RD | OHCI_INTR_WDH)</span>

<span class="cp">#ifdef __hppa__</span>
<span class="cm">/* On PA-RISC, PDC can leave IR set incorrectly; ignore it there. */</span>
<span class="cp">#define	IR_DISABLE</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_OMAP</span>
<span class="cm">/* OMAP doesn&#39;t support IR (no SMM; not needed) */</span>
<span class="cp">#define	IR_DISABLE</span>
<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span>	<span class="n">hcd_name</span> <span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ohci_hcd&quot;</span><span class="p">;</span>

<span class="cp">#define	STATECHANGE_DELAY	msecs_to_jiffies(300)</span>

<span class="cp">#include &quot;ohci.h&quot;</span>
<span class="cp">#include &quot;pci-quirks.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ohci_dump</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ohci_init</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ohci_stop</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_PM) || defined(CONFIG_PCI)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ohci_restart</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sb800_prefetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sb800_prefetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cp">#include &quot;ohci-hub.c&quot;</span>
<span class="cp">#include &quot;ohci-dbg.c&quot;</span>
<span class="cp">#include &quot;ohci-mem.c&quot;</span>
<span class="cp">#include &quot;ohci-q.c&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * On architectures with edge-triggered interrupts we must never return</span>
<span class="cm"> * IRQ_NONE.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_SA1111)  </span><span class="cm">/* ... or other edge-triggered systems */</span><span class="cp"></span>
<span class="cp">#define IRQ_NOTMINE	IRQ_HANDLED</span>
<span class="cp">#else</span>
<span class="cp">#define IRQ_NOTMINE	IRQ_NONE</span>
<span class="cp">#endif</span>


<span class="cm">/* Some boards misreport power switching/overcurrent */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">distrust_firmware</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span> <span class="p">(</span><span class="n">distrust_firmware</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span> <span class="p">(</span><span class="n">distrust_firmware</span><span class="p">,</span>
	<span class="s">&quot;true to distrust firmware power/overcurrent setup&quot;</span><span class="p">);</span>

<span class="cm">/* Some boards leave IR set wrongly, since they fail BIOS/SMM handshakes */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">no_handshake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span> <span class="p">(</span><span class="n">no_handshake</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span> <span class="p">(</span><span class="n">no_handshake</span><span class="p">,</span> <span class="s">&quot;true (not default) disables BIOS handshake&quot;</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * queue up an urb for anything except the root hub</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_urb_enqueue</span> <span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>	<span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span><span class="p">,</span>
	<span class="n">gfp_t</span>		<span class="n">mem_flags</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span>	<span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">hcd_to_ohci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ed</span>	<span class="o">*</span><span class="n">ed</span><span class="p">;</span>
	<span class="n">urb_priv_t</span>	<span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">pipe</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef OHCI_VERBOSE_DEBUG</span>
	<span class="n">urb_print</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="s">&quot;SUB&quot;</span><span class="p">,</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* every endpoint has a ed, locate and maybe (re)initialize it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">ed</span> <span class="o">=</span> <span class="n">ed_get</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* for the private part of the URB we need the number of TDs (size) */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PIPE_CONTROL</span>:
			<span class="cm">/* td_submit_urb() doesn&#39;t yet handle these */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

			<span class="cm">/* 1 TD for setup, 1 for ACK, plus ... */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="cm">/* FALLTHROUGH */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>case PIPE<em>INTERRUPT:
case PIPE</em>BULK:</p></td><td class="code"><div class="highlight"><pre>		<span class="nl">default:</span>
			<span class="cm">/* one TD for every 4096 Bytes (can be up to 8K) */</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">/</span> <span class="mi">4096</span><span class="p">;</span>
			<span class="cm">/* ... and for any remaining bytes ... */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">%</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">size</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* ... and maybe a zero length packet to wrap it up */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">size</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_ZERO_PACKET</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span>
					<span class="o">%</span> <span class="n">usb_maxpacket</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
						<span class="n">usb_pipeout</span> <span class="p">(</span><span class="n">pipe</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">size</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PIPE_ISOCHRONOUS</span>: <span class="cm">/* number of packets from URB */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate the private part of the URB */</span>
	<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">kzalloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">urb_priv_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="p">),</span>
			<span class="n">mem_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb_priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
	<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">ed</span> <span class="o">=</span> <span class="n">ed</span><span class="p">;</span>

	<span class="cm">/* allocate the TDs (deferring hash chain updates) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">td_alloc</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">mem_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">td</span> <span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">urb_free_priv</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* don&#39;t submit to a dead HC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HCD_HW_ACCESSIBLE</span><span class="p">(</span><span class="n">hcd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">OHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* schedule the ed if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ED_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ed_schedule</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_ISOCHRONOUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span>	<span class="n">frame</span> <span class="o">=</span> <span class="n">ohci_frame_no</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

			<span class="cm">/* delay a few frames before the first TD */</span>
			<span class="n">frame</span> <span class="o">+=</span> <span class="n">max_t</span> <span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">);</span>
			<span class="n">frame</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">frame</span> <span class="o">|=</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">branch</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>

			<span class="cm">/* yes, only URB_ISO_ASAP is supported, and</span>
<span class="cm">			 * urb-&gt;start_frame is never used as input.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_ISOCHRONOUS</span><span class="p">)</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">=</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">last_iso</span> <span class="o">+</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span>

	<span class="cm">/* fill the TDs and link them to the ed; and</span>
<span class="cm">	 * enable that part of the schedule, if needed</span>
<span class="cm">	 * and update count of queued periodic urbs</span>
<span class="cm">	 */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="n">urb_priv</span><span class="p">;</span>
	<span class="n">td_submit_urb</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">urb_free_priv</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * decouple the URB from the HC queues (TDs, urb_priv).</span>
<span class="cm"> * reporting is always done</span>
<span class="cm"> * asynchronously, and we might be dealing with an urb that&#39;s</span>
<span class="cm"> * partially transferred, or an ED with other urbs being unlinked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_urb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span>		<span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">hcd_to_ohci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rc</span><span class="p">;</span>

<span class="cp">#ifdef OHCI_VERBOSE_DEBUG</span>
	<span class="n">urb_print</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="s">&quot;UNLINK&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="n">hcd</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">;</span>	<span class="cm">/* Do nothing */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">OHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb_priv_t</span>  <span class="o">*</span><span class="n">urb_priv</span><span class="p">;</span>

		<span class="cm">/* Unless an IRQ completed the unlink while it was being</span>
<span class="cm">		 * handed to us, flag it for unlink and giveback, and force</span>
<span class="cm">		 * some upcoming INTR_SF to call finish_unlinks()</span>
<span class="cm">		 */</span>
		<span class="n">urb_priv</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb_priv</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ED_OPER</span><span class="p">)</span>
				<span class="n">start_ed_unlink</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">urb_priv</span><span class="o">-&gt;</span><span class="n">ed</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * with HC dead, we won&#39;t respect hc queue pointers</span>
<span class="cm">		 * any more ... just clean up every urb&#39;s memory.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">)</span>
			<span class="n">finish_urb</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* frees config/altsetting state for endpoints,</span>
<span class="cm"> * including ED memory, dummy TD, and bulk/intr data toggle</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ohci_endpoint_disable</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span>		<span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">hcd_to_ohci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ed</span>		<span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">limit</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="cm">/* ASSERT:  any requests/urbs are being unlinked */</span>
	<span class="cm">/* ASSERT:  nobody can be submitting urbs for this any more */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

<span class="nl">rescan:</span>
	<span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">!=</span> <span class="n">OHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">sanitize:</span>
		<span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ED_IDLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">quirk_zfmicro</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PIPE_INTERRUPT</span><span class="p">)</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">eds_scheduled</span><span class="o">--</span><span class="p">;</span>
		<span class="n">finish_unlinks</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ED_UNLINK</span>:		<span class="cm">/* wait for hw to finish? */</span>
		<span class="cm">/* major IRQ delivery trouble loses INTR_SF too... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ohci_warn</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;ED unlink timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">quirk_zfmicro</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ohci_warn</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;Attempting ZF TD recovery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span> <span class="o">=</span> <span class="n">ed</span><span class="p">;</span>
				<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">zf_delay</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">sanitize</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ED_IDLE</span>:		<span class="cm">/* fully unlinked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">td_free</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">);</span>
			<span class="n">ed_free</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* else FALL THROUGH */</span>
	<span class="nl">default:</span>
		<span class="cm">/* caller was supposed to have unlinked any requests;</span>
<span class="cm">		 * that&#39;s not our job.  can&#39;t recover; must leak ed.</span>
<span class="cm">		 */</span>
		<span class="n">ohci_err</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;leak ed %p (#%02x) state %d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ed</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
			<span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; (has tds)&quot;</span><span class="p">);</span>
		<span class="n">td_free</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">dummy</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">hcpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_get_frame</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span>		<span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">hcd_to_ohci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ohci_frame_no</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_usb_reset</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">=</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">&amp;=</span> <span class="n">OHCI_CTRL_RWC</span><span class="p">;</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">OHCI_RH_HALTED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ohci_shutdown forcibly disables IRQs and DMA, helping kexec and</span>
<span class="cm"> * other cases where the next software may expect clean state from the</span>
<span class="cm"> * &quot;firmware&quot;.  this is bus-neutral, unlike shutdown() methods.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ohci_shutdown</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">;</span>

	<span class="n">ohci</span> <span class="o">=</span> <span class="n">hcd_to_ohci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrdisable</span><span class="p">);</span>

	<span class="cm">/* Software reset, after which the controller goes into SUSPEND */</span>
	<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_HCR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cmdstatus</span><span class="p">);</span>
	<span class="n">ohci_readl</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cmdstatus</span><span class="p">);</span>	<span class="cm">/* flush the writes */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_ed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">hwINFO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ED_IN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">hwHeadP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TD_MASK</span><span class="p">)</span>
			<span class="o">==</span> <span class="p">(</span><span class="n">hc32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">hwTailP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TD_MASK</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ZF Micro watchdog timer callback. The ZF Micro chipset sometimes completes</span>
<span class="cm"> * an interrupt TD but neglects to add it to the donelist.  On systems with</span>
<span class="cm"> * this chipset, we need to periodically check the state of the queues to look</span>
<span class="cm"> * for such &quot;lost&quot; TDs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_watchdog_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">seen_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ed</span>	<span class="o">**</span><span class="n">seen</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span>	<span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="p">)</span> <span class="n">_ohci</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">eds_scheduled</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">seen</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">seen</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_INTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ed</span>	<span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">periodic</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">ed</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span>	<span class="n">temp</span><span class="p">;</span>

			<span class="cm">/* scan this branch of the periodic schedule tree */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="n">seen_count</span><span class="p">;</span> <span class="n">temp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">seen</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">==</span> <span class="n">ed</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* we&#39;ve checked it and what&#39;s after */</span>
					<span class="n">ed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ed</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">seen</span><span class="p">[</span><span class="n">seen_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ed</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_ed</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ed</span> <span class="o">=</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">ed_next</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* HC&#39;s TD list is empty, but HCD sees at least one</span>
<span class="cm">			 * TD that&#39;s not been sent through the donelist.</span>
<span class="cm">			 */</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span> <span class="o">=</span> <span class="n">ed</span><span class="p">;</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">zf_delay</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

			<span class="cm">/* The HC may wait until the next frame to report the</span>
<span class="cm">			 * TD as done through the donelist and INTR_WDH.  (We</span>
<span class="cm">			 * just *assume* it&#39;s not a multi-TD interrupt URB;</span>
<span class="cm">			 * those could defer the IRQ more than one frame, using</span>
<span class="cm">			 * DI...)  Check again after the next INTR_SF.</span>
<span class="cm">			 */</span>
			<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_SF</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrstatus</span><span class="p">);</span>
			<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_SF</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrenable</span><span class="p">);</span>

			<span class="cm">/* flush those writes */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ohci_readl</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">seen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">eds_scheduled</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">unlink_watchdog</span><span class="p">,</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">));</span>
<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*</span>
<span class="cm"> * HC functions</span>
<span class="cm"> *-------------------------------------------------------------------------*/</span>

<span class="cm">/* init memory, and kick BIOS/SMM off */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_init</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">ohci_to_hcd</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">distrust_firmware</span><span class="p">)</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">OHCI_QUIRK_HUB_POWER</span><span class="p">;</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">OHCI_RH_HALTED</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">hcd</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/* REVISIT this BIOS handshake is now moved into PCI &quot;quirks&quot;, and</span>
<span class="cm">	 * was never needed for most non-PCI systems ... remove the code?</span>
<span class="cm">	 */</span>

<span class="cp">#ifndef IR_DISABLE</span>
	<span class="cm">/* SMM owns the HC?  not for long! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_handshake</span> <span class="o">&amp;&amp;</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_IR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

		<span class="n">ohci_dbg</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;USB HC TakeOver from BIOS/SMM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* this timeout is arbitrary.  we make it long, so systems</span>
<span class="cm">		 * depending on usb keyboards may be usable even if the</span>
<span class="cm">		 * BIOS/SMM code seems pretty broken.</span>
<span class="cm">		 */</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>	<span class="cm">/* arbitrary: five seconds */</span>

		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_OC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrenable</span><span class="p">);</span>
		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_OCR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cmdstatus</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_IR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span> <span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">temp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ohci_err</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;USB HC takeover failed!&quot;</span>
					<span class="s">&quot;  (BIOS/SMM bug)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ohci_usb_reset</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Disable HC interrupts */</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_MIE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrdisable</span><span class="p">);</span>

	<span class="cm">/* flush the writes, and save key bits like RWC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_RWC</span><span class="p">)</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">|=</span> <span class="n">OHCI_CTRL_RWC</span><span class="p">;</span>

	<span class="cm">/* Read the number of ports unless overridden */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">num_ports</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">num_ports</span> <span class="o">=</span> <span class="n">roothub_a</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RH_A_NDP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
			<span class="k">sizeof</span> <span class="o">*</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca_dma</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ohci_mem_init</span> <span class="p">(</span><span class="n">ohci</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ohci_stop</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">create_debug_files</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Start an OHCI controller, set the BUS operational</span>
<span class="cm"> * resets USB and controller</span>
<span class="cm"> * enable interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_run</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">mask</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">first</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">ohci_to_hcd</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">OHCI_RH_HALTED</span><span class="p">;</span>

	<span class="cm">/* boot firmware should have set this up (5.1.1.3.1) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">);</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span> <span class="o">!=</span> <span class="n">FI</span><span class="p">)</span>
			<span class="n">ohci_dbg</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;fminterval delta %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span> <span class="o">-</span> <span class="n">FI</span><span class="p">);</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span> <span class="o">|=</span> <span class="n">FSMP</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="cm">/* also: power/overcurrent flags in roothub.a */</span>
	<span class="p">}</span>

	<span class="cm">/* Reset USB nearly &quot;by the book&quot;.  RemoteWakeupConnected has</span>
<span class="cm">	 * to be checked in case boot firmware (BIOS/SMM/...) has set up</span>
<span class="cm">	 * wakeup in a way the bus isn&#39;t aware of (e.g., legacy PCI PM).</span>
<span class="cm">	 * If the bus glue detected wakeup capability then it should</span>
<span class="cm">	 * already be enabled; if so we&#39;ll just enable it again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_RWC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">device_set_wakeup_capable</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">&amp;</span> <span class="n">OHCI_CTRL_HCFS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OHCI_USB_OPER</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OHCI_USB_SUSPEND</span>:
	<span class="k">case</span> <span class="n">OHCI_USB_RESUME</span>:
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">&amp;=</span> <span class="n">OHCI_CTRL_RWC</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">|=</span> <span class="n">OHCI_USB_RESUME</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">10</span> <span class="cm">/* msec wait */</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>case OHCI<em>USB</em>RESET:</p></td><td class="code"><div class="highlight"><pre>	<span class="nl">default:</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">&amp;=</span> <span class="n">OHCI_CTRL_RWC</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">|=</span> <span class="n">OHCI_USB_RESET</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">50</span> <span class="cm">/* msec wait */</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>flush the writes</p></td><td class="code"><div class="highlight"><pre>	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

	<span class="n">memset</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcca</span><span class="p">));</span>

	<span class="cm">/* 2msec timelimit here means no irqs/preempt */</span>
	<span class="n">spin_lock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="cm">/* HC Reset requires max 10 us delay */</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_HCR</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cmdstatus</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>	<span class="cm">/* ... allow extra time */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cmdstatus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OHCI_HCR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ohci_err</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;USB HC reset timed out!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now we&#39;re in the SUSPEND state ... must go OPERATIONAL</span>
<span class="cm">	 * within 2msec else HC enters RESUME</span>
<span class="cm">	 *</span>
<span class="cm">	 * ... but some hardware won&#39;t init fmInterval &quot;by the book&quot;</span>
<span class="cm">	 * (SiS, OPTi ...), so reset again instead.  SiS doesn&#39;t need</span>
<span class="cm">	 * this if we write fmInterval after we&#39;re OPERATIONAL.</span>
<span class="cm">	 * Unclear about ALi, ServerWorks, and others ... this could</span>
<span class="cm">	 * easily be a longstanding bug in chip init on Linux.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_INITRESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>flush those writes</p></td><td class="code"><div class="highlight"><pre>		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the controller where the control and bulk lists are</span>
<span class="cm">	 * The lists are empty now. */</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ed_controlhead</span><span class="p">);</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ed_bulkhead</span><span class="p">);</span>

	<span class="cm">/* a reset clears this */</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">);</span>

	<span class="n">periodic_reinit</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="cm">/* some OHCI implementations are finicky about how they init.</span>
<span class="cm">	 * bogus values here mean not even enumeration could work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fff0000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">periodicstart</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_INITRESET</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">OHCI_QUIRK_INITRESET</span><span class="p">;</span>
			<span class="n">ohci_dbg</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;enabling initreset quirk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ohci_err</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;init err (%08x %04x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">fminterval</span><span class="p">),</span>
			<span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">periodicstart</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* use rhsc irqs after khubd is fully initialized */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">uses_new_polling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* start controller operations */</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">&amp;=</span> <span class="n">OHCI_CTRL_RWC</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span> <span class="o">|=</span> <span class="n">OHCI_CONTROL_INIT</span> <span class="o">|</span> <span class="n">OHCI_USB_OPER</span><span class="p">;</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hc_control</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">OHCI_RH_RUNNING</span><span class="p">;</span>

	<span class="cm">/* wake on ConnectStatusChange, matching external hubs */</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">RH_HS_DRWE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">roothub</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>

	<span class="cm">/* Choose the interrupts we care about now, others later on demand */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">OHCI_INTR_INIT</span><span class="p">;</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrstatus</span><span class="p">);</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrenable</span><span class="p">);</span>

	<span class="cm">/* handle root hub init quirks ... */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">roothub_a</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RH_A_PSM</span> <span class="o">|</span> <span class="n">RH_A_OCPM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_SUPERIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* NSC 87560 and maybe others */</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">RH_A_NOCP</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RH_A_POTPGT</span> <span class="o">|</span> <span class="n">RH_A_NPS</span><span class="p">);</span>
		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">roothub</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_AMD756</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OHCI_QUIRK_HUB_POWER</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* hub power always on; required for AMD-756 and some</span>
<span class="cm">		 * Mac platforms.  ganged overcurrent reporting, if any.</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">RH_A_NPS</span><span class="p">;</span>
		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">roothub</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">RH_HS_LPSC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">roothub</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">RH_A_NPS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">RH_B_PPCM</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">roothub</span><span class="p">.</span><span class="n">b</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>flush those writes</p></td><td class="code"><div class="highlight"><pre>	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">STATECHANGE_DELAY</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>POTPGT delay is bits 24-31, in 2 ms units.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">mdelay</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">23</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1fe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirk_zfmicro</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Create timer to watch for bad queue state on ZF Micro */</span>
		<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">unlink_watchdog</span><span class="p">,</span> <span class="n">unlink_watchdog_func</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ohci</span><span class="p">);</span>

		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">eds_scheduled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ohci_dump</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* an interrupt happens */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ohci_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span>		<span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">hcd_to_ohci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ohci_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ints</span><span class="p">;</span>

	<span class="cm">/* Read interrupt status (and flush pending writes).  We ignore the</span>
<span class="cm">	 * optimization of checking the LSB of hcca-&gt;done_head; it doesn&#39;t</span>
<span class="cm">	 * work on all systems (edge triggering for OHCI can be a factor).</span>
<span class="cm">	 */</span>
	<span class="n">ints</span> <span class="o">=</span> <span class="n">ohci_readl</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrstatus</span><span class="p">);</span>

	<span class="cm">/* Check for an all 1&#39;s result which is a typical consequence</span>
<span class="cm">	 * of dead, unclocked, or unplugged (CardBus...) devices</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">OHCI_RH_HALTED</span><span class="p">;</span>
		<span class="n">ohci_dbg</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;device removed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We only care about interrupts that are enabled */</span>
	<span class="n">ints</span> <span class="o">&amp;=</span> <span class="n">ohci_readl</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrenable</span><span class="p">);</span>

	<span class="cm">/* interrupt for some other device? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">OHCI_RH_HALTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NOTMINE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span> <span class="o">&amp;</span> <span class="n">OHCI_INTR_UE</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>e.g. due to PCI Master/Target Abort</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">quirk_nec</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Workaround for a silicon bug in some NEC chips used</span>
<span class="cm">			 * in Apple&#39;s PowerBooks. Adapted from Darwin code.</span>
<span class="cm">			 */</span>
			<span class="n">ohci_err</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;OHCI Unrecoverable Error, scheduling NEC chip restart</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_UE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrdisable</span><span class="p">);</span>

			<span class="n">schedule_work</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">nec_work</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ohci_err</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;OHCI Unrecoverable Error, disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">OHCI_RH_HALTED</span><span class="p">;</span>
			<span class="n">usb_hc_died</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ohci_dump</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ohci_usb_reset</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span> <span class="o">&amp;</span> <span class="n">OHCI_INTR_RHSC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci_vdbg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;rhsc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_statechange</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">STATECHANGE_DELAY</span><span class="p">;</span>
		<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_RD</span> <span class="o">|</span> <span class="n">OHCI_INTR_RHSC</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrstatus</span><span class="p">);</span>

		<span class="cm">/* NOTE: Vendors didn&#39;t always make the same implementation</span>
<span class="cm">		 * choices for RHSC.  Many followed the spec; RHSC triggers</span>
<span class="cm">		 * on an edge, like setting and maybe clearing a port status</span>
<span class="cm">		 * change bit.  With others it&#39;s level-triggered, active</span>
<span class="cm">		 * until khubd clears all the port status change bits.  We&#39;ll</span>
<span class="cm">		 * always disable it here and rely on polling until khubd</span>
<span class="cm">		 * re-enables it.</span>
<span class="cm">		 */</span>
		<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_RHSC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrdisable</span><span class="p">);</span>
		<span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* For connect and disconnect events, we expect the controller</span>
<span class="cm">	 * to turn on RHSC along with RD.  But for remote wakeup events</span>
<span class="cm">	 * this might not happen.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ints</span> <span class="o">&amp;</span> <span class="n">OHCI_INTR_RD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci_vdbg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;resume detect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ohci_writel</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_RD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrstatus</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">HCD_FLAG_POLL_RH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">autostop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ohci_rh_resume</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
			<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span> <span class="o">&amp;</span> <span class="n">OHCI_INTR_WDH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">dl_done_list</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirk_zfmicro</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ints</span> <span class="o">&amp;</span> <span class="n">OHCI_INTR_SF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ed</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">check_ed</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* HC thinks the TD list is empty; HCD knows</span>
<span class="cm">				 * at least one TD is outstanding</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">zf_delay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">td</span> <span class="o">*</span><span class="n">td</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span>
						<span class="n">ed</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">td</span><span class="p">,</span> <span class="n">td_list</span><span class="p">);</span>
					<span class="n">ohci_warn</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span>
						  <span class="s">&quot;Reclaiming orphan TD %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">td</span><span class="p">);</span>
					<span class="n">takeback_td</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
					<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* could track INTR_SO to reduce available PCI/... bandwidth */</span>

	<span class="cm">/* handle any pending URB/ED unlinks, leaving INTR_SF enabled</span>
<span class="cm">	 * when there&#39;s still unlinking to be done (next frame).</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_rm_list</span><span class="p">)</span>
		<span class="n">finish_unlinks</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ohci_frame_no</span><span class="p">(</span><span class="n">ohci</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ints</span> <span class="o">&amp;</span> <span class="n">OHCI_INTR_SF</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_rm_list</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_to_check</span>
			<span class="o">&amp;&amp;</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">OHCI_RH_RUNNING</span><span class="p">)</span>
		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_SF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrdisable</span><span class="p">);</span>
	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">==</span> <span class="n">OHCI_RH_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrstatus</span><span class="p">);</span>
		<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_MIE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrenable</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>flush those writes</p></td><td class="code"><div class="highlight"><pre>		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ohci_readl</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_stop</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ohci_hcd</span>		<span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">hcd_to_ohci</span> <span class="p">(</span><span class="n">hcd</span><span class="p">);</span>

	<span class="n">ohci_dump</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirk_nec</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span>
		<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">nec_work</span><span class="p">);</span>

	<span class="n">ohci_usb_reset</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">ohci_writel</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI_INTR_MIE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">intrdisable</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">hcd</span><span class="p">);</span>
	<span class="n">hcd</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirk_zfmicro</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">unlink_watchdog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quirk_amdiso</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span>
		<span class="n">usb_amd_dev_put</span><span class="p">();</span>

	<span class="n">remove_debug_files</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">ohci_mem_cleanup</span> <span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span> <span class="p">(</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span>
				<span class="k">sizeof</span> <span class="o">*</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">,</span>
				<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca_dma</span><span class="p">);</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#if defined(CONFIG_PM) || defined(CONFIG_PCI)</span>

<span class="cm">/* must not be called from interrupt context */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_restart</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ohci_hcd</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">rh_state</span> <span class="o">=</span> <span class="n">OHCI_RH_HALTED</span><span class="p">;</span>

	<span class="cm">/* Recycle any &quot;live&quot; eds/tds (and urbs). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">))</span>
		<span class="n">ohci_dbg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;abort schedule...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb</span>	<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ed</span>	<span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ed</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ED_OPER</span>:
			<span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ED_UNLINK</span><span class="p">;</span>
			<span class="n">ed</span><span class="o">-&gt;</span><span class="n">hwINFO</span> <span class="o">|=</span> <span class="n">cpu_to_hc32</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ED_DEQUEUE</span><span class="p">);</span>
			<span class="n">ed_deschedule</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">ed</span><span class="p">);</span>

			<span class="n">ed</span><span class="o">-&gt;</span><span class="n">ed_next</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_rm_list</span><span class="p">;</span>
			<span class="n">ed</span><span class="o">-&gt;</span><span class="n">ed_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_rm_list</span> <span class="o">=</span> <span class="n">ed</span><span class="p">;</span>
			<span class="cm">/* FALLTHROUGH */</span>
		<span class="k">case</span> <span class="n">ED_UNLINK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ohci_dbg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;bogus ed %p state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ed</span><span class="p">,</span> <span class="n">ed</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span><span class="p">)</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">unlinked</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">finish_unlinks</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* paranoia, in case that didn&#39;t work: */</span>

	<span class="cm">/* empty the interrupt branches */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_INTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">load</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_INTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">hcca</span><span class="o">-&gt;</span><span class="n">int_table</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* no EDs to remove */</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_rm_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* empty control and bulk lists */</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_controltail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ed_bulktail</span>    <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="n">ohci_run</span> <span class="p">(</span><span class="n">ohci</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci_err</span> <span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;can&#39;t restart, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ohci_dbg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;restart complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="n">MODULE_AUTHOR</span> <span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span> <span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cp">#include &quot;ohci-pci.c&quot;</span>
<span class="cp">#define PCI_DRIVER		ohci_pci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_ARCH_SA1100) &amp;&amp; defined(CONFIG_SA1111)</span>
<span class="cp">#include &quot;ohci-sa1111.c&quot;</span>
<span class="cp">#define SA1111_DRIVER		ohci_hcd_sa1111_driver</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_ARCH_S3C24XX) || defined(CONFIG_ARCH_S3C64XX)</span>
<span class="cp">#include &quot;ohci-s3c2410.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_s3c2410_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_EXYNOS</span>
<span class="cp">#include &quot;ohci-exynos.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		exynos_ohci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_HCD_OMAP1</span>
<span class="cp">#include &quot;ohci-omap.c&quot;</span>
<span class="cp">#define OMAP1_PLATFORM_DRIVER	ohci_hcd_omap_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_HCD_OMAP3</span>
<span class="cp">#include &quot;ohci-omap3.c&quot;</span>
<span class="cp">#define OMAP3_PLATFORM_DRIVER	ohci_hcd_omap3_driver</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)</span>
<span class="cp">#include &quot;ohci-pxa27x.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_pxa27x_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_EP93XX</span>
<span class="cp">#include &quot;ohci-ep93xx.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_ep93xx_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MIPS_ALCHEMY</span>
<span class="cp">#include &quot;ohci-au1xxx.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_au1xxx_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PNX8550</span>
<span class="cp">#include &quot;ohci-pnx8550.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_pnx8550_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_HCD_PPC_SOC</span>
<span class="cp">#include &quot;ohci-ppc-soc.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_ppc_soc_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_AT91</span>
<span class="cp">#include &quot;ohci-at91.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_at91_driver</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_ARCH_PNX4008) || defined(CONFIG_ARCH_LPC32XX)</span>
<span class="cp">#include &quot;ohci-nxp.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		usb_hcd_nxp_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_DAVINCI_DA8XX</span>
<span class="cp">#include &quot;ohci-da8xx.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_da8xx_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_SH</span>
<span class="cp">#include &quot;ohci-sh.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_sh_driver</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef CONFIG_USB_OHCI_HCD_PPC_OF</span>
<span class="cp">#include &quot;ohci-ppc-of.c&quot;</span>
<span class="cp">#define OF_PLATFORM_DRIVER	ohci_hcd_ppc_of_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PLAT_SPEAR</span>
<span class="cp">#include &quot;ohci-spear.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		spear_ohci_hcd_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC_PS3</span>
<span class="cp">#include &quot;ohci-ps3.c&quot;</span>
<span class="cp">#define PS3_SYSTEM_BUS_DRIVER	ps3_ohci_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MFD_SM501</span>
<span class="cp">#include &quot;ohci-sm501.c&quot;</span>
<span class="cp">#define SM501_OHCI_DRIVER	ohci_hcd_sm501_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MFD_TC6393XB</span>
<span class="cp">#include &quot;ohci-tmio.c&quot;</span>
<span class="cp">#define TMIO_OHCI_DRIVER	ohci_hcd_tmio_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MACH_JZ4740</span>
<span class="cp">#include &quot;ohci-jz4740.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER	ohci_hcd_jz4740_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OCTEON_OHCI</span>
<span class="cp">#include &quot;ohci-octeon.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_octeon_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_CNS3XXX_OHCI</span>
<span class="cp">#include &quot;ohci-cns3xxx.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_hcd_cns3xxx_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CPU_XLR</span>
<span class="cp">#include &quot;ohci-xls.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_xls_driver</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_USB_OHCI_HCD_PLATFORM</span>
<span class="cp">#include &quot;ohci-platform.c&quot;</span>
<span class="cp">#define PLATFORM_DRIVER		ohci_platform_driver</span>
<span class="cp">#endif</span>

<span class="cp">#if	!defined(PCI_DRIVER) &amp;&amp;		\</span>
<span class="cp">	!defined(PLATFORM_DRIVER) &amp;&amp;	\</span>
<span class="cp">	!defined(OMAP1_PLATFORM_DRIVER) &amp;&amp;	\</span>
<span class="cp">	!defined(OMAP3_PLATFORM_DRIVER) &amp;&amp;	\</span>
<span class="cp">	!defined(OF_PLATFORM_DRIVER) &amp;&amp;	\</span>
<span class="cp">	!defined(SA1111_DRIVER) &amp;&amp;	\</span>
<span class="cp">	!defined(PS3_SYSTEM_BUS_DRIVER) &amp;&amp; \</span>
<span class="cp">	!defined(SM501_OHCI_DRIVER) &amp;&amp; \</span>
<span class="cp">	!defined(TMIO_OHCI_DRIVER)</span>
<span class="cp">#error &quot;missing bus glue for ohci-hcd&quot;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ohci_hcd_mod_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: &quot;</span> <span class="n">DRIVER_DESC</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hcd_name</span><span class="p">);</span>
	<span class="n">pr_debug</span> <span class="p">(</span><span class="s">&quot;%s: block sizes: ed %Zd td %Zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hcd_name</span><span class="p">,</span>
		<span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ed</span><span class="p">),</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">td</span><span class="p">));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">USB_OHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">ohci_debug_root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;ohci&quot;</span><span class="p">,</span> <span class="n">usb_debug_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ohci_debug_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_debug</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PS3_SYSTEM_BUS_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ps3_ohci_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PS3_SYSTEM_BUS_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ps3</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PLATFORM_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PLATFORM_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_platform</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef OMAP1_PLATFORM_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OMAP1_PLATFORM_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_omap1_platform</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef OMAP3_PLATFORM_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OMAP3_PLATFORM_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_omap3_platform</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef OF_PLATFORM_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OF_PLATFORM_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_of_platform</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SA1111_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sa1111_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SA1111_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_sa1111</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PCI_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PCI_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_pci</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SM501_OHCI_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SM501_OHCI_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_sm501</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef TMIO_OHCI_DRIVER</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TMIO_OHCI_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_tmio</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Error path */</span>
<span class="cp">#ifdef TMIO_OHCI_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TMIO_OHCI_DRIVER</span><span class="p">);</span>
 <span class="nl">error_tmio:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SM501_OHCI_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SM501_OHCI_DRIVER</span><span class="p">);</span>
 <span class="nl">error_sm501:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PCI_DRIVER</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PCI_DRIVER</span><span class="p">);</span>
 <span class="nl">error_pci:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SA1111_DRIVER</span>
	<span class="n">sa1111_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SA1111_DRIVER</span><span class="p">);</span>
 <span class="nl">error_sa1111:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef OF_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OF_PLATFORM_DRIVER</span><span class="p">);</span>
 <span class="nl">error_of_platform:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PLATFORM_DRIVER</span><span class="p">);</span>
 <span class="nl">error_platform:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef OMAP1_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OMAP1_PLATFORM_DRIVER</span><span class="p">);</span>
 <span class="nl">error_omap1_platform:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef OMAP3_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OMAP3_PLATFORM_DRIVER</span><span class="p">);</span>
 <span class="nl">error_omap3_platform:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PS3_SYSTEM_BUS_DRIVER</span>
	<span class="n">ps3_ohci_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PS3_SYSTEM_BUS_DRIVER</span><span class="p">);</span>
 <span class="nl">error_ps3:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">ohci_debug_root</span><span class="p">);</span>
	<span class="n">ohci_debug_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="nl">error_debug:</span>
<span class="cp">#endif</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">USB_OHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ohci_hcd_mod_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ohci_hcd_mod_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef TMIO_OHCI_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TMIO_OHCI_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SM501_OHCI_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SM501_OHCI_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PCI_DRIVER</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PCI_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SA1111_DRIVER</span>
	<span class="n">sa1111_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SA1111_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef OF_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OF_PLATFORM_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PLATFORM_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef OMAP3_PLATFORM_DRIVER</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OMAP3_PLATFORM_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PS3_SYSTEM_BUS_DRIVER</span>
	<span class="n">ps3_ohci_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PS3_SYSTEM_BUS_DRIVER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">ohci_debug_root</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">USB_OHCI_LOADED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_hcds_loaded</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ohci_hcd_mod_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
