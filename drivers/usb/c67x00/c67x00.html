<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › c67x00 › c67x00.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>c67x00.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * c67x00.h: Cypress C67X00 USB register and field definitions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Barco N.V.</span>
<span class="cm"> *    Derived from the Cypress cy7c67200/300 ezusb linux driver and</span>
<span class="cm"> *    based on multiple host controller drivers inside the linux kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,</span>
<span class="cm"> * MA  02110-1301  USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _USB_C67X00_H</span>
<span class="cp">#define _USB_C67X00_H</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Cypress C67x00 register definitions</span>
<span class="cm"> */</span>

<span class="cm">/* Hardware Revision Register */</span>
<span class="cp">#define HW_REV_REG		0xC004</span>

<span class="cm">/* General USB registers */</span>
<span class="cm">/* ===================== */</span>

<span class="cm">/* USB Control Register */</span>
<span class="cp">#define USB_CTL_REG(x)		((x) ? 0xC0AA : 0xC08A)</span>

<span class="cp">#define LOW_SPEED_PORT(x)	((x) ? 0x0800 : 0x0400)</span>
<span class="cp">#define HOST_MODE		0x0200</span>
<span class="cp">#define PORT_RES_EN(x)		((x) ? 0x0100 : 0x0080)</span>
<span class="cp">#define SOF_EOP_EN(x)		((x) ? 0x0002 : 0x0001)</span>

<span class="cm">/* USB status register - Notice it has different content in hcd/udc mode */</span>
<span class="cp">#define USB_STAT_REG(x)		((x) ? 0xC0B0 : 0xC090)</span>

<span class="cp">#define EP0_IRQ_FLG		0x0001</span>
<span class="cp">#define EP1_IRQ_FLG		0x0002</span>
<span class="cp">#define EP2_IRQ_FLG		0x0004</span>
<span class="cp">#define EP3_IRQ_FLG		0x0008</span>
<span class="cp">#define EP4_IRQ_FLG		0x0010</span>
<span class="cp">#define EP5_IRQ_FLG		0x0020</span>
<span class="cp">#define EP6_IRQ_FLG		0x0040</span>
<span class="cp">#define EP7_IRQ_FLG		0x0080</span>
<span class="cp">#define RESET_IRQ_FLG		0x0100</span>
<span class="cp">#define SOF_EOP_IRQ_FLG		0x0200</span>
<span class="cp">#define ID_IRQ_FLG		0x4000</span>
<span class="cp">#define VBUS_IRQ_FLG		0x8000</span>

<span class="cm">/* USB Host only registers */</span>
<span class="cm">/* ======================= */</span>

<span class="cm">/* Host n Control Register */</span>
<span class="cp">#define HOST_CTL_REG(x)		((x) ? 0xC0A0 : 0xC080)</span>

<span class="cp">#define PREAMBLE_EN		0x0080	</span><span class="cm">/* Preamble enable */</span><span class="cp"></span>
<span class="cp">#define SEQ_SEL			0x0040	</span><span class="cm">/* Data Toggle Sequence Bit Select */</span><span class="cp"></span>
<span class="cp">#define ISO_EN			0x0010	</span><span class="cm">/* Isochronous enable  */</span><span class="cp"></span>
<span class="cp">#define ARM_EN			0x0001	</span><span class="cm">/* Arm operation */</span><span class="cp"></span>

<span class="cm">/* Host n Interrupt Enable Register */</span>
<span class="cp">#define HOST_IRQ_EN_REG(x)	((x) ? 0xC0AC : 0xC08C)</span>

<span class="cp">#define SOF_EOP_IRQ_EN		0x0200	</span><span class="cm">/* SOF/EOP Interrupt Enable  */</span><span class="cp"></span>
<span class="cp">#define SOF_EOP_TMOUT_IRQ_EN	0x0800	</span><span class="cm">/* SOF/EOP Timeout Interrupt Enable  */</span><span class="cp"></span>
<span class="cp">#define ID_IRQ_EN		0x4000	</span><span class="cm">/* ID interrupt enable */</span><span class="cp"></span>
<span class="cp">#define VBUS_IRQ_EN		0x8000	</span><span class="cm">/* VBUS interrupt enable */</span><span class="cp"></span>
<span class="cp">#define DONE_IRQ_EN		0x0001	</span><span class="cm">/* Done Interrupt Enable  */</span><span class="cp"></span>

<span class="cm">/* USB status register */</span>
<span class="cp">#define HOST_STAT_MASK		0x02FD</span>
<span class="cp">#define PORT_CONNECT_CHANGE(x)	((x) ? 0x0020 : 0x0010)</span>
<span class="cp">#define PORT_SE0_STATUS(x)	((x) ? 0x0008 : 0x0004)</span>

<span class="cm">/* Host Frame Register */</span>
<span class="cp">#define HOST_FRAME_REG(x)	((x) ? 0xC0B6 : 0xC096)</span>

<span class="cp">#define HOST_FRAME_MASK		0x07FF</span>

<span class="cm">/* USB Peripheral only registers */</span>
<span class="cm">/* ============================= */</span>

<span class="cm">/* Device n Port Sel reg */</span>
<span class="cp">#define DEVICE_N_PORT_SEL(x)	((x) ? 0xC0A4 : 0xC084)</span>

<span class="cm">/* Device n Interrupt Enable Register */</span>
<span class="cp">#define DEVICE_N_IRQ_EN_REG(x)	((x) ? 0xC0AC : 0xC08C)</span>

<span class="cp">#define DEVICE_N_ENDPOINT_N_CTL_REG(dev, ep)	((dev)  		\</span>
<span class="cp">						 ? (0x0280 + (ep &lt;&lt; 4)) \</span>
<span class="cp">						 : (0x0200 + (ep &lt;&lt; 4)))</span>
<span class="cp">#define DEVICE_N_ENDPOINT_N_STAT_REG(dev, ep)	((dev)			\</span>
<span class="cp">						 ? (0x0286 + (ep &lt;&lt; 4)) \</span>
<span class="cp">						 : (0x0206 + (ep &lt;&lt; 4)))</span>

<span class="cp">#define DEVICE_N_ADDRESS(dev)	((dev) ? (0xC0AE) : (0xC08E))</span>

<span class="cm">/* HPI registers */</span>
<span class="cm">/* ============= */</span>

<span class="cm">/* HPI Status register */</span>
<span class="cp">#define SOFEOP_FLG(x)		(1 &lt;&lt; ((x) ? 12 : 10))</span>
<span class="cp">#define SIEMSG_FLG(x)		(1 &lt;&lt; (4 + (x)))</span>
<span class="cp">#define RESET_FLG(x)		((x) ? 0x0200 : 0x0002)</span>
<span class="cp">#define DONE_FLG(x)		(1 &lt;&lt; (2 + (x)))</span>
<span class="cp">#define RESUME_FLG(x)		(1 &lt;&lt; (6 + (x)))</span>
<span class="cp">#define MBX_OUT_FLG		0x0001	</span><span class="cm">/* Message out available */</span><span class="cp"></span>
<span class="cp">#define MBX_IN_FLG		0x0100</span>
<span class="cp">#define ID_FLG			0x4000</span>
<span class="cp">#define VBUS_FLG		0x8000</span>

<span class="cm">/* Interrupt routing register */</span>
<span class="cp">#define HPI_IRQ_ROUTING_REG	0x0142</span>

<span class="cp">#define HPI_SWAP_ENABLE(x)	((x) ? 0x0100 : 0x0001)</span>
<span class="cp">#define RESET_TO_HPI_ENABLE(x)	((x) ? 0x0200 : 0x0002)</span>
<span class="cp">#define DONE_TO_HPI_ENABLE(x)	((x) ? 0x0008 : 0x0004)</span>
<span class="cp">#define RESUME_TO_HPI_ENABLE(x)	((x) ? 0x0080 : 0x0040)</span>
<span class="cp">#define SOFEOP_TO_HPI_EN(x)	((x) ? 0x2000 : 0x0800)</span>
<span class="cp">#define SOFEOP_TO_CPU_EN(x)	((x) ? 0x1000 : 0x0400)</span>
<span class="cp">#define ID_TO_HPI_ENABLE	0x4000</span>
<span class="cp">#define VBUS_TO_HPI_ENABLE	0x8000</span>

<span class="cm">/* SIE msg registers */</span>
<span class="cp">#define SIEMSG_REG(x)		((x) ? 0x0148 : 0x0144)</span>

<span class="cp">#define HUSB_TDListDone		0x1000</span>

<span class="cp">#define SUSB_EP0_MSG		0x0001</span>
<span class="cp">#define SUSB_EP1_MSG		0x0002</span>
<span class="cp">#define SUSB_EP2_MSG		0x0004</span>
<span class="cp">#define SUSB_EP3_MSG		0x0008</span>
<span class="cp">#define SUSB_EP4_MSG		0x0010</span>
<span class="cp">#define SUSB_EP5_MSG		0x0020</span>
<span class="cp">#define SUSB_EP6_MSG		0x0040</span>
<span class="cp">#define SUSB_EP7_MSG		0x0080</span>
<span class="cp">#define SUSB_RST_MSG		0x0100</span>
<span class="cp">#define SUSB_SOF_MSG		0x0200</span>
<span class="cp">#define SUSB_CFG_MSG		0x0400</span>
<span class="cp">#define SUSB_SUS_MSG		0x0800</span>
<span class="cp">#define SUSB_ID_MSG	       	0x4000</span>
<span class="cp">#define SUSB_VBUS_MSG		0x8000</span>

<span class="cm">/* BIOS interrupt routines */</span>

<span class="cp">#define SUSBx_RECEIVE_INT(x)	((x) ? 97 : 81)</span>
<span class="cp">#define SUSBx_SEND_INT(x)	((x) ? 96 : 80)</span>

<span class="cp">#define SUSBx_DEV_DESC_VEC(x)	((x) ? 0x00D4 : 0x00B4)</span>
<span class="cp">#define SUSBx_CONF_DESC_VEC(x)	((x) ? 0x00D6 : 0x00B6)</span>
<span class="cp">#define SUSBx_STRING_DESC_VEC(x) ((x) ? 0x00D8 : 0x00B8)</span>

<span class="cp">#define CY_HCD_BUF_ADDR		0x500	</span><span class="cm">/* Base address for host */</span><span class="cp"></span>
<span class="cp">#define SIE_TD_SIZE		0x200	</span><span class="cm">/* size of the td list */</span><span class="cp"></span>
<span class="cp">#define SIE_TD_BUF_SIZE		0x400	</span><span class="cm">/* size of the data buffer */</span><span class="cp"></span>

<span class="cp">#define SIE_TD_OFFSET(host)	((host) ? (SIE_TD_SIZE+SIE_TD_BUF_SIZE) : 0)</span>
<span class="cp">#define SIE_BUF_OFFSET(host)	(SIE_TD_OFFSET(host) + SIE_TD_SIZE)</span>

<span class="cm">/* Base address of HCD + 2 x TD_SIZE + 2 x TD_BUF_SIZE */</span>
<span class="cp">#define CY_UDC_REQ_HEADER_BASE	0x1100</span>
<span class="cm">/* 8- byte request headers for IN/OUT transfers */</span>
<span class="cp">#define CY_UDC_REQ_HEADER_SIZE	8</span>

<span class="cp">#define CY_UDC_REQ_HEADER_ADDR(ep_num)	(CY_UDC_REQ_HEADER_BASE + \</span>
<span class="cp">					 ((ep_num) * CY_UDC_REQ_HEADER_SIZE))</span>
<span class="cp">#define CY_UDC_DESC_BASE_ADDRESS	(CY_UDC_REQ_HEADER_ADDR(8))</span>

<span class="cp">#define CY_UDC_BIOS_REPLACE_BASE	0x1800</span>
<span class="cp">#define CY_UDC_REQ_BUFFER_BASE		0x2000</span>
<span class="cp">#define CY_UDC_REQ_BUFFER_SIZE		0x0400</span>
<span class="cp">#define CY_UDC_REQ_BUFFER_ADDR(ep_num)	(CY_UDC_REQ_BUFFER_BASE + \</span>
<span class="cp">					 ((ep_num) * CY_UDC_REQ_BUFFER_SIZE))</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Driver data structures</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">c67x00_device</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct c67x00_sie - Common data associated with a SIE</span>
<span class="cm"> * @lock: lock to protect this struct and the associated chip registers</span>
<span class="cm"> * @private_data: subdriver dependent data</span>
<span class="cm"> * @irq: subdriver dependent irq handler, set NULL when not used</span>
<span class="cm"> * @dev: link to common driver structure</span>
<span class="cm"> * @sie_num: SIE number on chip, starting from 0</span>
<span class="cm"> * @mode: SIE mode (host/peripheral/otg/not used)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="p">{</span>
	<span class="cm">/* Entries to be used by the subdrivers */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* protect this structure */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">,</span> <span class="n">u16</span> <span class="n">int_status</span><span class="p">,</span> <span class="n">u16</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Read only: */</span>
	<span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sie_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define sie_dev(s)	(&amp;(s)-&gt;dev-&gt;pdev-&gt;dev)</span>

<span class="cm">/**</span>
<span class="cm"> * struct c67x00_lcp</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">c67x00_lcp</span> <span class="p">{</span>
	<span class="cm">/* Internal use only */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">msg_received</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">last_msg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct c67x00_hpi</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">c67x00_hpi</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">regstep</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">c67x00_lcp</span> <span class="n">lcp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define C67X00_SIES	2</span>
<span class="cp">#define C67X00_PORTS	2</span>

<span class="cm">/**</span>
<span class="cm"> * struct c67x00_device - Common data associated with a c67x00 instance</span>
<span class="cm"> * @hpi: hpi addresses</span>
<span class="cm"> * @sie: array of sie&#39;s on this chip</span>
<span class="cm"> * @pdev: platform device of instance</span>
<span class="cm"> * @pdata: configuration provided by the platform</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">c67x00_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">c67x00_hpi</span> <span class="n">hpi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="n">sie</span><span class="p">[</span><span class="n">C67X00_SIES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">c67x00_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Low level interface functions</span>
<span class="cm"> */</span>

<span class="cm">/* Host Port Interface (HPI) functions */</span>
<span class="n">u16</span> <span class="n">c67x00_ll_hpi_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_hpi_reg_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_hpi_enable_sofeop</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_hpi_disable_sofeop</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">);</span>

<span class="cm">/* General functions */</span>
<span class="n">u16</span> <span class="n">c67x00_ll_fetch_siemsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sie_num</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">c67x00_ll_get_usb_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_usb_clear_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bits</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">c67x00_ll_usb_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_write_mem_le16</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_read_mem_le16</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Host specific functions */</span>
<span class="kt">void</span> <span class="n">c67x00_ll_set_husb_eot</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_husb_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_husb_set_current_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">c67x00_ll_husb_get_current_td</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">c67x00_ll_husb_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_husb_init_host_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_husb_reset_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_sie</span> <span class="o">*</span><span class="n">sie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">);</span>

<span class="cm">/* Called by c67x00_irq to handle lcp interrupts */</span>
<span class="kt">void</span> <span class="n">c67x00_ll_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">int_status</span><span class="p">);</span>

<span class="cm">/* Setup and teardown */</span>
<span class="kt">void</span> <span class="n">c67x00_ll_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">c67x00_ll_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">c67x00_ll_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">c67x00_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* _USB_C67X00_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
