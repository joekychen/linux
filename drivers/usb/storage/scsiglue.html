<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › storage › scsiglue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>scsiglue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Driver for USB Mass Storage compliant devices</span>
<span class="cm"> * SCSI layer glue code</span>
<span class="cm"> *</span>
<span class="cm"> * Current development and maintenance by:</span>
<span class="cm"> *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)</span>
<span class="cm"> *</span>
<span class="cm"> * Developed with the assistance of:</span>
<span class="cm"> *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)</span>
<span class="cm"> *   (c) 2000 Stephen J. Gowdy (SGowdy@lbl.gov)</span>
<span class="cm"> *</span>
<span class="cm"> * Initial work by:</span>
<span class="cm"> *   (c) 1999 Michael Gee (michael@linuxspecific.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is based on the &#39;USB Mass Storage Class&#39; document. This</span>
<span class="cm"> * describes in detail the protocol used to communicate with such</span>
<span class="cm"> * devices.  Clearly, the designers had SCSI and ATAPI commands in</span>
<span class="cm"> * mind when they created this document.  The commands are all very</span>
<span class="cm"> * similar to commands in the SCSI-II and ATAPI specifications.</span>
<span class="cm"> *</span>
<span class="cm"> * It is important to note that in a number of cases this class</span>
<span class="cm"> * exhibits class-specific exemptions from the USB specification.</span>
<span class="cm"> * Notably the usage of NAK, STALL and ACK differs from the norm, in</span>
<span class="cm"> * that they are used to communicate wait, failed and OK on commands.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, for certain devices, the interrupt endpoint is used to convey</span>
<span class="cm"> * status of a command.</span>
<span class="cm"> *</span>
<span class="cm"> * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more</span>
<span class="cm"> * information about this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_devinfo.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>
<span class="cp">#include &quot;scsiglue.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;transport.h&quot;</span>
<span class="cp">#include &quot;protocol.h&quot;</span>

<span class="cm">/* Vendor IDs for companies that seem to include the READ CAPACITY bug</span>
<span class="cm"> * in all their devices</span>
<span class="cm"> */</span>
<span class="cp">#define VENDOR_ID_NOKIA		0x0421</span>
<span class="cp">#define VENDOR_ID_NIKON		0x04b0</span>
<span class="cp">#define VENDOR_ID_PENTAX	0x0a17</span>
<span class="cp">#define VENDOR_ID_MOTOROLA	0x22b8</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Host functions </span>
<span class="cm"> ***********************************************************************/</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">host_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">scsi_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slave_alloc</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the INQUIRY transfer length to 36.  We don&#39;t use any of</span>
<span class="cm">	 * the extra data and many devices choke if asked for more or</span>
<span class="cm">	 * less than 36 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>

	<span class="cm">/* USB has unusual DMA-alignment requirements: Although the</span>
<span class="cm">	 * starting address of each scatter-gather element doesn&#39;t matter,</span>
<span class="cm">	 * the length of each element except the last must be divisible</span>
<span class="cm">	 * by the Bulk maxpacket value.  There&#39;s currently no way to</span>
<span class="cm">	 * express this by block-layer constraints, so we&#39;ll cop out</span>
<span class="cm">	 * and simply require addresses to be aligned at 512-byte</span>
<span class="cm">	 * boundaries.  This is okay since most block I/O involves</span>
<span class="cm">	 * hardware sectors that are multiples of 512 bytes in length,</span>
<span class="cm">	 * and since host controllers up through USB 2.0 have maxpacket</span>
<span class="cm">	 * values no larger than 512.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But it doesn&#39;t suffice for Wireless USB, where Bulk maxpacket</span>
<span class="cm">	 * values can be as large as 2048.  To make that work properly</span>
<span class="cm">	 * will require changes to the block layer.</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_update_dma_alignment</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="p">(</span><span class="mi">512</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* Many devices have trouble transferring more than 32KB at a time,</span>
<span class="cm">	 * while others have trouble with more than 64K. At this time we</span>
<span class="cm">	 * are limiting both to 32K (64 sectores).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">US_FL_MAX_SECTORS_64</span> <span class="o">|</span> <span class="n">US_FL_MAX_SECTORS_MIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sectors</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_MAX_SECTORS_MIN</span><span class="p">)</span>
			<span class="n">max_sectors</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_sectors</span><span class="p">)</span>
			<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
					      <span class="n">max_sectors</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Tapes need much higher max_sector limits, so just</span>
<span class="cm">		 * raise it to the maximum possible (4 GB / 512) and</span>
<span class="cm">		 * let the queue segment size sort out the real limit.</span>
<span class="cm">		 */</span>
		<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="mh">0x7FFFFF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Some USB host controllers can&#39;t do DMA; they have to use PIO.</span>
<span class="cm">	 * They indicate this by setting their dma_mask to NULL.  For</span>
<span class="cm">	 * such controllers we need to make sure the block layer sets</span>
<span class="cm">	 * up bounce buffers in addressable memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="n">blk_queue_bounce_limit</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">BLK_BOUNCE_HIGH</span><span class="p">);</span>

	<span class="cm">/* We can&#39;t put these settings in slave_alloc() because that gets</span>
<span class="cm">	 * called before the device type is known.  Consequently these</span>
<span class="cm">	 * settings can&#39;t be overridden via the scsi devinfo mechanism. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_DISK</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Some vendors seem to put the READ CAPACITY bug into</span>
<span class="cm">		 * all their devices -- primarily makers of cell phones</span>
<span class="cm">		 * and digital cameras.  Since these devices always use</span>
<span class="cm">		 * flash media and can be expected to have an even number</span>
<span class="cm">		 * of sectors, we will always enable the CAPACITY_HEURISTICS</span>
<span class="cm">		 * flag unless told otherwise. */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">VENDOR_ID_NOKIA</span>:
		<span class="k">case</span> <span class="n">VENDOR_ID_NIKON</span>:
		<span class="k">case</span> <span class="n">VENDOR_ID_PENTAX</span>:
		<span class="k">case</span> <span class="n">VENDOR_ID_MOTOROLA</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">US_FL_FIX_CAPACITY</span> <span class="o">|</span>
					<span class="n">US_FL_CAPACITY_OK</span><span class="p">)))</span>
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">|=</span> <span class="n">US_FL_CAPACITY_HEURISTICS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Disk-type devices use MODE SENSE(6) if the protocol</span>
<span class="cm">		 * (SubClass) is Transparent SCSI, otherwise they use</span>
<span class="cm">		 * MODE SENSE(10). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">!=</span> <span class="n">USB_SC_SCSI</span> <span class="o">&amp;&amp;</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">!=</span> <span class="n">USB_SC_CYP_ATACB</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Many disks only accept MODE SENSE transfer lengths of</span>
<span class="cm">		 * 192 bytes (that&#39;s what Windows uses). */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_192_bytes_for_3f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Some devices don&#39;t like MODE SENSE with page=0x3f,</span>
<span class="cm">		 * which is the command used for checking if a device</span>
<span class="cm">		 * is write-protected.  Now that we tell the sd driver</span>
<span class="cm">		 * to do a 192-byte transfer with this command the</span>
<span class="cm">		 * majority of devices work fine, but a few still can&#39;t</span>
<span class="cm">		 * handle it.  The sd driver will simply assume those</span>
<span class="cm">		 * devices are write-enabled. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_NO_WP_DETECT</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_ms_page_3f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* A number of devices have problems with MODE SENSE for</span>
<span class="cm">		 * page x08, so we will skip it. */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_ms_page_8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Some devices don&#39;t handle VPD pages correctly */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">skip_vpd_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Some disks return the total number of blocks in response</span>
<span class="cm">		 * to READ CAPACITY rather than the highest block number.</span>
<span class="cm">		 * If this device makes that mistake, tell the sd driver. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_FIX_CAPACITY</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">fix_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* A few disks have two indistinguishable version, one of</span>
<span class="cm">		 * which reports the correct capacity and the other does not.</span>
<span class="cm">		 * The sd driver has to guess which is the case. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_CAPACITY_HEURISTICS</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">guess_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Some devices cannot handle READ_CAPACITY_16 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_NO_READ_CAPACITY_16</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">no_read_capacity_16</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Many devices do not respond properly to READ_CAPACITY_16.</span>
<span class="cm">		 * Tell the SCSI layer to try READ_CAPACITY_10 first.</span>
<span class="cm">		 */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">try_rc_10_first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* assume SPC3 or latter devices support sense size &gt; 18 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;</span> <span class="n">SCSI_SPC_2</span><span class="p">)</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">|=</span> <span class="n">US_FL_SANE_SENSE</span><span class="p">;</span>

		<span class="cm">/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable</span>
<span class="cm">		 * Hardware Error) when any low-level error occurs,</span>
<span class="cm">		 * recoverable or not.  Setting this flag tells the SCSI</span>
<span class="cm">		 * midlayer to retry such commands, which frequently will</span>
<span class="cm">		 * succeed and fix the error.  The worst this can lead to</span>
<span class="cm">		 * is an occasional series of retries that will all fail. */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">retry_hwerror</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* USB disks should allow restart.  Some drives spin down</span>
<span class="cm">		 * automatically, requiring a START-STOP UNIT command. */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">allow_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Some USB cardreaders have trouble reading an sdcard&#39;s last</span>
<span class="cm">		 * sector in a larger then 1 sector read, since the performance</span>
<span class="cm">		 * impact is negible we set this flag for all USB disks */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_sector_bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Enable last-sector hacks for single-target devices using</span>
<span class="cm">		 * the Bulk-only transport, unless we already know the</span>
<span class="cm">		 * capacity will be decremented or is correct. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">US_FL_FIX_CAPACITY</span> <span class="o">|</span> <span class="n">US_FL_CAPACITY_OK</span> <span class="o">|</span>
					<span class="n">US_FL_SCM_MULT_TARG</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_BULK</span><span class="p">)</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">use_last_sector_hacks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* Non-disk-type devices don&#39;t need to blacklist any pages</span>
<span class="cm">		 * or to force 192-byte transfer lengths for MODE SENSE.</span>
<span class="cm">		 * But they do need to use MODE SENSE(10). */</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Some (fake) usb cdrom devices don&#39;t like READ_DISC_INFO */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_NO_READ_DISC_INFO</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">no_read_disc_info</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The CB and CBI transports have no way to pass LUN values</span>
<span class="cm">	 * other than the bits in the second byte of a CDB.  But those</span>
<span class="cm">	 * bits don&#39;t get set to the LUN value if the device reports</span>
<span class="cm">	 * scsi_level == 0 (UNKNOWN).  Hence such devices must necessarily</span>
<span class="cm">	 * be single-LUN.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_CB</span> <span class="o">||</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_CBI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">==</span> <span class="n">SCSI_UNKNOWN</span><span class="p">)</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM</span>
<span class="cm">	 * REMOVAL command, so suppress those commands. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_NOT_LOCKABLE</span><span class="p">)</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lockable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* this is to satisfy the compiler, tho I don&#39;t think the </span>
<span class="cm">	 * return code is ever checked anywhere. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">target_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some USB drives don&#39;t support REPORT LUNS, even though they</span>
<span class="cm">	 * report a SCSI revision level above 2.  Tell the SCSI layer</span>
<span class="cm">	 * not to issue that command; it will perform a normal sequential</span>
<span class="cm">	 * scan instead.</span>
<span class="cm">	 */</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">no_report_luns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The UFI spec treats the Peripheral Qualifier bits in an</span>
<span class="cm">	 * INQUIRY result as reserved and requires devices to set them</span>
<span class="cm">	 * to 0.  However the SCSI spec requires these bits to be set</span>
<span class="cm">	 * to 3 to indicate when a LUN is not present.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Let the scanning code know if this target merely sets</span>
<span class="cm">	 * Peripheral Device Type to 0x1f to indicate no LUN.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">USB_SC_UFI</span><span class="p">)</span>
		<span class="n">starget</span><span class="o">-&gt;</span><span class="n">pdt_1f_for_no_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* queue a command */</span>
<span class="cm">/* This is always called with scsi_lock(host) held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">queuecommand_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* check for state-transition errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">USB_STORAGE</span> <span class="s">&quot;Error in %s: us-&gt;srb = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fail the command if we are disconnecting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Fail command during disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">done</span><span class="p">(</span><span class="n">srb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enqueue the command and wake up the control thread */</span>
	<span class="n">srb</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">=</span> <span class="n">srb</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">queuecommand</span><span class="p">)</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Error handling functions</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* Command timeout and abort */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">command_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* us-&gt;srb together with the TIMED_OUT, RESETTING, and ABORTING</span>
<span class="cm">	 * bits are protected by the host lock. */</span>
	<span class="n">scsi_lock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>

	<span class="cm">/* Is this command still active? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">!=</span> <span class="n">srb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
		<span class="n">US_DEBUGP</span> <span class="p">(</span><span class="s">&quot;-- nothing to abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the TIMED_OUT bit.  Also set the ABORTING bit, but only if</span>
<span class="cm">	 * a device reset isn&#39;t already in progress (to avoid interfering</span>
<span class="cm">	 * with the reset).  Note that we must retain the host lock while</span>
<span class="cm">	 * calling usb_stor_stop_transport(); otherwise it might interfere</span>
<span class="cm">	 * with an auto-reset that begins as soon as we release the lock. */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
		<span class="n">usb_stor_stop_transport</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>

	<span class="cm">/* Wait for the aborted command to finish */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This invokes the transport reset mechanism to reset the state of the</span>
<span class="cm"> * device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* lock the device pointers and do the reset */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">));</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">FAILED</span> <span class="o">:</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Simulate a SCSI bus reset by resetting the device&#39;s USB port. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_port_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">FAILED</span> <span class="o">:</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Report a driver-initiated device reset to the SCSI layer.</span>
<span class="cm"> * Calling this for a SCSI-initiated reset is unnecessary but harmless.</span>
<span class="cm"> * The caller must own the SCSI host lock. */</span>
<span class="kt">void</span> <span class="nf">usb_stor_report_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="n">scsi_report_device_reset</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SCM_MULT_TARG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">scsi_report_device_reset</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Report a driver-initiated bus reset to the SCSI layer.</span>
<span class="cm"> * Calling this for a SCSI-initiated reset is unnecessary but harmless.</span>
<span class="cm"> * The caller must not own the SCSI host lock. */</span>
<span class="kt">void</span> <span class="nf">usb_stor_report_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">scsi_report_bus_reset</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * /proc/scsi/ functions</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* we use this macro to help us write into the buffer */</span>
<span class="cp">#undef SPRINTF</span>
<span class="cp">#define SPRINTF(args...) \</span>
<span class="cp">	do { if (pos &lt; buffer+length) pos += sprintf(pos, ## args); } while (0)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_info</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>

	<span class="cm">/* if someone is sending us data, just throw it away */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* print the controller name */</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;   Host scsi%d: usb-storage</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="cm">/* print product, vendor, and serial number strings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">vendorName</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">vendorName</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">string</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;       Vendor: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">productName</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">productName</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">string</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;      Product: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">string</span> <span class="o">=</span> <span class="s">&quot;None&quot;</span><span class="p">;</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Serial Number: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>

	<span class="cm">/* show the protocol and transport */</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;     Protocol: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;    Transport: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span><span class="p">);</span>

	<span class="cm">/* show the device flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="s">&quot;       Quirks:&quot;</span><span class="p">);</span>

<span class="cp">#define US_FLAG(name, value) \</span>
<span class="cp">	if (us-&gt;fflags &amp; value) pos += sprintf(pos, &quot; &quot; #name);</span>
<span class="n">US_DO_ALL_FLAGS</span>
<span class="cp">#undef US_FLAG</span>

		<span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate start of next buffer, and return value.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Sysfs interface</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* Output routine for the sysfs max_sectors file */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_max_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Input routine for the sysfs max_sectors file */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_max_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ms</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%hu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">max_sectors</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">show_max_sectors</span><span class="p">,</span>
		<span class="n">store_max_sectors</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">sysfs_device_attr_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="o">&amp;</span><span class="n">dev_attr_max_sectors</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * this defines our host template, with which we&#39;ll allocate hosts</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">usb_stor_host_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* basic userland interface stuff */</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>				<span class="s">&quot;usb-storage&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span> <span class="o">=</span>			<span class="s">&quot;usb-storage&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_info</span> <span class="o">=</span>			<span class="n">proc_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>				<span class="n">host_info</span><span class="p">,</span>

	<span class="cm">/* command interface -- queued only */</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span>			<span class="n">queuecommand</span><span class="p">,</span>

	<span class="cm">/* error and abort handlers */</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span> <span class="o">=</span>		<span class="n">command_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span>	<span class="n">device_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span> <span class="o">=</span>		<span class="n">bus_reset</span><span class="p">,</span>

	<span class="cm">/* queue commands only, only one command per LUN */</span>
	<span class="p">.</span><span class="n">can_queue</span> <span class="o">=</span>			<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span> <span class="o">=</span>			<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* unknown initiator id */</span>
	<span class="p">.</span><span class="n">this_id</span> <span class="o">=</span>			<span class="o">-</span><span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">slave_alloc</span> <span class="o">=</span>			<span class="n">slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span> <span class="o">=</span>		<span class="n">slave_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">target_alloc</span> <span class="o">=</span>			<span class="n">target_alloc</span><span class="p">,</span>

	<span class="cm">/* lots of sg segments can be handled */</span>
	<span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span>			<span class="n">SCSI_MAX_SG_CHAIN_SEGMENTS</span><span class="p">,</span>

	<span class="cm">/* limit the total size of a transfer to 120 KB */</span>
	<span class="p">.</span><span class="n">max_sectors</span> <span class="o">=</span>                  <span class="mi">240</span><span class="p">,</span>

	<span class="cm">/* merge commands... this seems to help performance, but</span>
<span class="cm">	 * periodically someone should test to see which setting is more</span>
<span class="cm">	 * optimal.</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* emulated HBA */</span>
	<span class="p">.</span><span class="n">emulated</span> <span class="o">=</span>			<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* we do our own delay after a device or bus reset */</span>
	<span class="p">.</span><span class="n">skip_settle_delay</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* sysfs device attributes */</span>
	<span class="p">.</span><span class="n">sdev_attrs</span> <span class="o">=</span>			<span class="n">sysfs_device_attr_list</span><span class="p">,</span>

	<span class="cm">/* module management */</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span>			<span class="n">THIS_MODULE</span>
<span class="p">};</span>

<span class="cm">/* To Report &quot;Illegal Request: Invalid Field in CDB */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">usb_stor_sense_invalidCDB</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x70</span><span class="p">,</span>			    <span class="cm">/* current error */</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span>	    <span class="cm">/* Illegal Request = 0x05 */</span>
	<span class="p">[</span><span class="mi">7</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>			    <span class="cm">/* additional length */</span>
	<span class="p">[</span><span class="mi">12</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x24</span>			    <span class="cm">/* Invalid Field in CDB */</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_sense_invalidCDB</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
