<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › storage › transport.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>transport.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Driver for USB Mass Storage compliant devices</span>
<span class="cm"> *</span>
<span class="cm"> * Current development and maintenance by:</span>
<span class="cm"> *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)</span>
<span class="cm"> *</span>
<span class="cm"> * Developed with the assistance of:</span>
<span class="cm"> *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)</span>
<span class="cm"> *   (c) 2000 Stephen J. Gowdy (SGowdy@lbl.gov)</span>
<span class="cm"> *   (c) 2002 Alan Stern &lt;stern@rowland.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Initial work by:</span>
<span class="cm"> *   (c) 1999 Michael Gee (michael@linuxspecific.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is based on the &#39;USB Mass Storage Class&#39; document. This</span>
<span class="cm"> * describes in detail the protocol used to communicate with such</span>
<span class="cm"> * devices.  Clearly, the designers had SCSI and ATAPI commands in</span>
<span class="cm"> * mind when they created this document.  The commands are all very</span>
<span class="cm"> * similar to commands in the SCSI-II and ATAPI specifications.</span>
<span class="cm"> *</span>
<span class="cm"> * It is important to note that in a number of cases this class</span>
<span class="cm"> * exhibits class-specific exemptions from the USB specification.</span>
<span class="cm"> * Notably the usage of NAK, STALL and ACK differs from the norm, in</span>
<span class="cm"> * that they are used to communicate wait, failed and OK on commands.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, for certain devices, the interrupt endpoint is used to convey</span>
<span class="cm"> * status of a command.</span>
<span class="cm"> *</span>
<span class="cm"> * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more</span>
<span class="cm"> * information about this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;linux/usb/quirks.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>
<span class="cp">#include &quot;transport.h&quot;</span>
<span class="cp">#include &quot;protocol.h&quot;</span>
<span class="cp">#include &quot;scsiglue.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &quot;../../scsi/sd.h&quot;</span>


<span class="cm">/***********************************************************************</span>
<span class="cm"> * Data transfer routines</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * This is subtle, so pay attention:</span>
<span class="cm"> * ---------------------------------</span>
<span class="cm"> * We&#39;re very concerned about races with a command abort.  Hanging this code</span>
<span class="cm"> * is a sure fire way to hang the kernel.  (Note that this discussion applies</span>
<span class="cm"> * only to transactions resulting from a scsi queued-command, since only</span>
<span class="cm"> * these transactions are subject to a scsi abort.  Other transactions, such</span>
<span class="cm"> * as those occurring during device-specific initialization, must be handled</span>
<span class="cm"> * by a separate code path.)</span>
<span class="cm"> *</span>
<span class="cm"> * The abort function (usb_storage_command_abort() in scsiglue.c) first</span>
<span class="cm"> * sets the machine state and the ABORTING bit in us-&gt;dflags to prevent</span>
<span class="cm"> * new URBs from being submitted.  It then calls usb_stor_stop_transport()</span>
<span class="cm"> * below, which atomically tests-and-clears the URB_ACTIVE bit in us-&gt;dflags</span>
<span class="cm"> * to see if the current_urb needs to be stopped.  Likewise, the SG_ACTIVE</span>
<span class="cm"> * bit is tested to see if the current_sg scatter-gather request needs to be</span>
<span class="cm"> * stopped.  The timeout callback routine does much the same thing.</span>
<span class="cm"> *</span>
<span class="cm"> * When a disconnect occurs, the DISCONNECTING bit in us-&gt;dflags is set to</span>
<span class="cm"> * prevent new URBs from being submitted, and usb_stor_stop_transport() is</span>
<span class="cm"> * called to stop any ongoing requests.</span>
<span class="cm"> *</span>
<span class="cm"> * The submit function first verifies that the submitting is allowed</span>
<span class="cm"> * (neither ABORTING nor DISCONNECTING bits are set) and that the submit</span>
<span class="cm"> * completes without errors, and only then sets the URB_ACTIVE bit.  This</span>
<span class="cm"> * prevents the stop_transport() function from trying to cancel the URB</span>
<span class="cm"> * while the submit call is underway.  Next, the submit function must test</span>
<span class="cm"> * the flags to see if an abort or disconnect occurred during the submission</span>
<span class="cm"> * or before the URB_ACTIVE bit was set.  If so, it&#39;s essential to cancel</span>
<span class="cm"> * the URB if it hasn&#39;t been cancelled already (i.e., if the URB_ACTIVE bit</span>
<span class="cm"> * is still set).  Either way, the function must then wait for the URB to</span>
<span class="cm"> * finish.  Note that the URB can still be in progress even after a call to</span>
<span class="cm"> * usb_unlink_urb() returns.</span>
<span class="cm"> *</span>
<span class="cm"> * The idea is that (1) once the ABORTING or DISCONNECTING bit is set,</span>
<span class="cm"> * either the stop_transport() function or the submitting function</span>
<span class="cm"> * is guaranteed to call usb_unlink_urb() for an active URB,</span>
<span class="cm"> * and (2) test_and_clear_bit() prevents usb_unlink_urb() from being</span>
<span class="cm"> * called more than once or from being called during usb_submit_urb().</span>
<span class="cm"> */</span>

<span class="cm">/* This is the completion handler which will wake us up when an URB</span>
<span class="cm"> * completes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_stor_blocking_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">urb_done_ptr</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="n">urb_done_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is the common part of the URB message submission code</span>
<span class="cm"> *</span>
<span class="cm"> * All URBs from the usb-storage driver involved in handling a queued scsi</span>
<span class="cm"> * command _must_ pass through this function (or something like it) for the</span>
<span class="cm"> * abort mechanisms to work properly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_stor_msg_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">urb_done</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeleft</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* don&#39;t submit URBs during abort processing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* set up data structures for the wakeup system */</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urb_done</span><span class="p">);</span>

	<span class="cm">/* fill the common fields in the URB */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">urb_done</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* we assume that if transfer_buffer isn&#39;t us-&gt;iobuf then it</span>
<span class="cm">	 * hasn&#39;t been mapped for DMA.  Yes, this is clunky, but it&#39;s</span>
<span class="cm">	 * easier than always having the caller tell us whether the</span>
<span class="cm">	 * transfer buffer has already been mapped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">==</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">)</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf_dma</span><span class="p">;</span>

	<span class="cm">/* submit the URB */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* something went wrong */</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* since the URB has been submitted successfully, it&#39;s now okay</span>
<span class="cm">	 * to cancel it */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_URB_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>

	<span class="cm">/* did an abort occur during the submission? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* cancel the URB, if it hasn&#39;t been cancelled already */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_URB_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- cancelling URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
 
	<span class="cm">/* wait for the completion of the URB */</span>
	<span class="n">timeleft</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">urb_done</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">?</span> <span class="o">:</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
 
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_URB_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s -- cancelling URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">timeleft</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Timeout&quot;</span> <span class="o">:</span> <span class="s">&quot;Signal&quot;</span><span class="p">);</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* return the URB status */</span>
	<span class="k">return</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer one control message, with timeouts, and allowing early</span>
<span class="cm"> * termination.  Return codes are usual -Exxx, *not* USB_STOR_XFER_xxx.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_control_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		 <span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u8</span> <span class="n">requesttype</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> 
		 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: rq=%02x rqtype=%02x value=%04x index=%02x len=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">requesttype</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* fill in the devrequest structure */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">requesttype</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">request</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* fill and submit the URB */</span>
	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> 
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> 
			 <span class="n">usb_stor_blocking_completion</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usb_stor_msg_common</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="cm">/* return the actual length of the data transferred if no error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_control_msg</span><span class="p">);</span>

<span class="cm">/* This is a version of usb_clear_halt() that allows early termination and</span>
<span class="cm"> * doesn&#39;t read the status from the device -- this is because some devices</span>
<span class="cm"> * crash their internal firmware when the status is requested after a halt.</span>
<span class="cm"> *</span>
<span class="cm"> * A definitive list of these &#39;bad&#39; devices is too difficult to maintain or</span>
<span class="cm"> * make complete enough to be useful.  This problem was first observed on the</span>
<span class="cm"> * Hagiwara FlashGate DUAL unit.  However, bus traces reveal that neither</span>
<span class="cm"> * MacOS nor Windows checks the status after clearing a halt.</span>
<span class="cm"> *</span>
<span class="cm"> * Since many vendors in this space limit their testing to interoperability</span>
<span class="cm"> * with these two OSes, specification violations like this one are common.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_clear_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">endp</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span> <span class="p">(</span><span class="n">pipe</span><span class="p">))</span>
		<span class="n">endp</span> <span class="o">|=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_control_msg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
		<span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">,</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">,</span>
		<span class="n">USB_ENDPOINT_HALT</span><span class="p">,</span> <span class="n">endp</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">usb_reset_endpoint</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">endp</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: result = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_clear_halt</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Interpret the results of a URB transfer</span>
<span class="cm"> *</span>
<span class="cm"> * This function prints appropriate debugging messages, clears halts on</span>
<span class="cm"> * non-control endpoints, and translates the status to the corresponding</span>
<span class="cm"> * USB_STOR_XFER_xxx return code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">interpret_urb_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Status code %d; transferred %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* no error code; did we send all the data? */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">partial</span> <span class="o">!=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- short transfer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">USB_STOR_XFER_SHORT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- transfer complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">;</span>

	<span class="cm">/* stalled */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="cm">/* for control endpoints, (used by CB[I]) a stall indicates</span>
<span class="cm">		 * a failed command */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipecontrol</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- stall on control pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">USB_STOR_XFER_STALLED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* for other sorts of endpoint, clear the stall */</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;clearing endpoint halt for pipe 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_stor_clear_halt</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_XFER_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_STALLED</span><span class="p">;</span>

	<span class="cm">/* babble - the device tried to send more than we wanted to read */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EOVERFLOW</span>:
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- babble</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_LONG</span><span class="p">;</span>

	<span class="cm">/* the transfer was cancelled by abort, disconnect, or timeout */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- transfer cancelled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_ERROR</span><span class="p">;</span>

	<span class="cm">/* short scatter-gather read transfer */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EREMOTEIO</span>:
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- short read transfer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_SHORT</span><span class="p">;</span>

	<span class="cm">/* abort or disconnect in progress */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- abort or disconnect in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_ERROR</span><span class="p">;</span>

	<span class="cm">/* the catch-all error case */</span>
	<span class="nl">default:</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- unknown error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer one control message, without timeouts, but allowing early</span>
<span class="cm"> * termination.  Return codes are USB_STOR_XFER_xxx.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u8</span> <span class="n">requesttype</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: rq=%02x rqtype=%02x value=%04x index=%02x len=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">requesttype</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* fill in the devrequest structure */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">requesttype</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">request</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* fill and submit the URB */</span>
	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> 
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> 
			 <span class="n">usb_stor_blocking_completion</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_msg_common</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">interpret_urb_result</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_ctrl_transfer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Receive one interrupt buffer, without timeouts, but allowing early</span>
<span class="cm"> * termination.  Return codes are USB_STOR_XFER_xxx.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine always uses us-&gt;recv_intr_pipe as the pipe and</span>
<span class="cm"> * us-&gt;ep_bInterval as the interrupt interval.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_stor_intr_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_intr_pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxp</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: xfer %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/* calculate the max packet size */</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxp</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">)</span>
		<span class="n">maxp</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* fill and submit the URB */</span>
	<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
			<span class="n">maxp</span><span class="p">,</span> <span class="n">usb_stor_blocking_completion</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">ep_bInterval</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_msg_common</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">interpret_urb_result</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer one buffer via bulk pipe, without timeouts, but allowing early</span>
<span class="cm"> * termination.  Return codes are USB_STOR_XFER_xxx.  If the bulk pipe</span>
<span class="cm"> * stalls during the transfer, the halt is automatically cleared.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">act_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: xfer %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/* fill and submit the URB */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
		      <span class="n">usb_stor_blocking_completion</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_msg_common</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* store the actual length of the data transferred */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">act_len</span><span class="p">)</span>
		<span class="o">*</span><span class="n">act_len</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">interpret_urb_result</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> 
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_bulk_transfer_buf</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer a scatter-gather list via bulk transfer</span>
<span class="cm"> *</span>
<span class="cm"> * This function does basically the same thing as usb_stor_bulk_transfer_buf()</span>
<span class="cm"> * above, but it uses the usbcore scatter-gather library.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_stor_bulk_transfer_sglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">act_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* don&#39;t submit s-g requests during abort processing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_ERROR</span><span class="p">;</span>

	<span class="cm">/* initialize the scatter-gather request block */</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: xfer %u bytes, %d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">length</span><span class="p">,</span> <span class="n">num_sg</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_sg_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">sg</span><span class="p">,</span> <span class="n">num_sg</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usb_sg_init returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* since the block has been initialized successfully, it&#39;s now</span>
<span class="cm">	 * okay to cancel it */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_SG_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>

	<span class="cm">/* did an abort occur during the submission? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* cancel the request, if it hasn&#39;t been cancelled already */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_SG_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- cancelling sg request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">usb_sg_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* wait for the completion of the transfer */</span>
	<span class="n">usb_sg_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_SG_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">act_len</span><span class="p">)</span>
		<span class="o">*</span><span class="n">act_len</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">.</span><span class="n">bytes</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">interpret_urb_result</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">.</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common used function. Transfer a complete command</span>
<span class="cm"> * via usb_stor_bulk_transfer_sglist() above. Set cmnd resid</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_bulk_srb</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span><span class="o">*</span> <span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">scsi_cmnd</span><span class="o">*</span> <span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partial</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_sglist</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span>
				      <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span>
				      <span class="o">&amp;</span><span class="n">partial</span><span class="p">);</span>

	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_bulk_srb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer an entire SCSI command&#39;s worth of data payload over the bulk</span>
<span class="cm"> * pipe.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this uses usb_stor_bulk_transfer_buf() and</span>
<span class="cm"> * usb_stor_bulk_transfer_sglist() to achieve its goals --</span>
<span class="cm"> * this function simply determines whether we&#39;re going to use</span>
<span class="cm"> * scatter-gather or not, and acts appropriately.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_bulk_transfer_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span><span class="o">*</span> <span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length_left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_sg</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">residual</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partial</span><span class="p">;</span>

	<span class="cm">/* are we scatter-gathering? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* use the usb core scatter-gather primitives */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_sglist</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span>
				<span class="n">length_left</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">partial</span><span class="p">);</span>
		<span class="n">length_left</span> <span class="o">-=</span> <span class="n">partial</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* no scatter-gather, just make the request */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> 
				<span class="n">length_left</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">partial</span><span class="p">);</span>
		<span class="n">length_left</span> <span class="o">-=</span> <span class="n">partial</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* store the residual and return the error code */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">residual</span><span class="p">)</span>
		<span class="o">*</span><span class="n">residual</span> <span class="o">=</span> <span class="n">length_left</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_bulk_transfer_sg</span><span class="p">);</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Transport routines</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* There are so many devices that report the capacity incorrectly,</span>
<span class="cm"> * this routine was written to counteract some of the resulting</span>
<span class="cm"> * problems.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">last_sector_hacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_disk</span> <span class="o">*</span><span class="n">sdkp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sector</span><span class="p">;</span>

	<span class="cm">/* To Report &quot;Medium Error: Record Not Found */</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">record_not_found</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x70</span><span class="p">,</span>			<span class="cm">/* current error */</span>
		<span class="p">[</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span> <span class="n">MEDIUM_ERROR</span><span class="p">,</span>		<span class="cm">/* = 0x03 */</span>
		<span class="p">[</span><span class="mi">7</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>			<span class="cm">/* additional length */</span>
		<span class="p">[</span><span class="mi">12</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0x14</span>			<span class="cm">/* Record Not Found */</span>
	<span class="p">};</span>

	<span class="cm">/* If last-sector problems can&#39;t occur, whether because the</span>
<span class="cm">	 * capacity was already decremented or because the device is</span>
<span class="cm">	 * known to report the correct capacity, then we don&#39;t need</span>
<span class="cm">	 * to do anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">use_last_sector_hacks</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Was this command a READ(10) or a WRITE(10)? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">READ_10</span> <span class="o">&amp;&amp;</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">WRITE_10</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Did this command access the last sector? */</span>
	<span class="n">sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
	<span class="n">disk</span> <span class="o">=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">sdkp</span> <span class="o">=</span> <span class="n">scsi_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdkp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">sdkp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">SAM_STAT_GOOD</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* The command succeeded.  We know this device doesn&#39;t</span>
<span class="cm">		 * have the last-sector bug, so stop checking it.</span>
<span class="cm">		 */</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">use_last_sector_hacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The command failed.  Allow up to 3 retries in case this</span>
<span class="cm">		 * is some normal sort of failure.  After that, assume the</span>
<span class="cm">		 * capacity is wrong and we&#39;re trying to access the sector</span>
<span class="cm">		 * beyond the end.  Replace the result code and sense data</span>
<span class="cm">		 * with values that will cause the SCSI core to fail the</span>
<span class="cm">		 * command immediately, instead of going into an infinite</span>
<span class="cm">		 * (or even just a very long) retry loop.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">last_sector_retries</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">record_not_found</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">record_not_found</span><span class="p">));</span>
	<span class="p">}</span>

 <span class="nl">done:</span>
	<span class="cm">/* Don&#39;t reset the retry counter for TEST UNIT READY commands,</span>
<span class="cm">	 * because they get issued after device resets which might be</span>
<span class="cm">	 * caused by a failed last-sector access.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">TEST_UNIT_READY</span><span class="p">)</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">last_sector_retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Invoke the transport and basic error-handling/recovery methods</span>
<span class="cm"> *</span>
<span class="cm"> * This is used by the protocol layers to actually send the message to</span>
<span class="cm"> * the device and receive the response.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usb_stor_invoke_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">need_auto_sense</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* send the command to the transport layer */</span>
	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="n">us</span><span class="p">);</span>

	<span class="cm">/* if the command gets aborted by the higher layers, we need to</span>
<span class="cm">	 * short-circuit all other processing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- command was aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">Handle_Errors</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if there is a transport error, reset and don&#39;t auto-sense */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- transport indicates error, resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">Handle_Errors</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if the transport provided its own sense data, don&#39;t auto-sense */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_TRANSPORT_NO_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="n">last_sector_hacks</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>

	<span class="cm">/* Determine if we need to auto-sense</span>
<span class="cm">	 *</span>
<span class="cm">	 * I normally don&#39;t use a flag like this, but it&#39;s almost impossible</span>
<span class="cm">	 * to understand what&#39;s going on here if I don&#39;t.</span>
<span class="cm">	 */</span>
	<span class="n">need_auto_sense</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re running the CB transport, which is incapable</span>
<span class="cm">	 * of determining status on its own, we will auto-sense</span>
<span class="cm">	 * unless the operation involved a data-in transfer.  Devices</span>
<span class="cm">	 * can signal most data-in errors by stalling the bulk-in pipe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_CB</span> <span class="o">||</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_DPCM_USB</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">!=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- CB transport device requiring auto-sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">need_auto_sense</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a failure, we&#39;re going to do a REQUEST_SENSE </span>
<span class="cm">	 * automatically.  Note that we differentiate between a command</span>
<span class="cm">	 * &quot;failure&quot; and an &quot;error&quot; in the transport mechanism.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- transport indicates command failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">need_auto_sense</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine if this device is SAT by seeing if the</span>
<span class="cm">	 * command executed successfully.  Otherwise we&#39;ll have</span>
<span class="cm">	 * to wait for at least one CHECK_CONDITION to determine</span>
<span class="cm">	 * SANE_SENSE support</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_16</span> <span class="o">||</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_12</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SANE_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_BAD_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- SAT supported, increasing auto-sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">|=</span> <span class="n">US_FL_SANE_SENSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A short transfer on a command where we don&#39;t expect it</span>
<span class="cm">	 * is unusual, but it doesn&#39;t mean we need to auto-sense.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">((</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MODE_SENSE</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">LOG_SENSE</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MODE_SENSE_10</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- unexpectedly short transfer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now, if we need to do the auto-sense, let&#39;s do it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_auto_sense</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">temp_result</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scsi_eh_save</span> <span class="n">ses</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">sense_size</span> <span class="o">=</span> <span class="n">US_SENSE_SIZE</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">scdd</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">fm_ili</span><span class="p">;</span>

		<span class="cm">/* device supports and needs bigger sense buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SANE_SENSE</span><span class="p">)</span>
			<span class="n">sense_size</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
<span class="nl">Retry_Sense:</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Issuing auto-REQUEST_SENSE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">scsi_eh_prep_cmnd</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ses</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sense_size</span><span class="p">);</span>

		<span class="cm">/* FIXME: we must do the protocol translation here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">USB_SC_RBC</span> <span class="o">||</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">USB_SC_SCSI</span> <span class="o">||</span>
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">USB_SC_CYP_ATACB</span><span class="p">)</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

		<span class="cm">/* issue the auto-sense command */</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">temp_result</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">,</span> <span class="n">us</span><span class="p">);</span>

		<span class="cm">/* let&#39;s clean up right away */</span>
		<span class="n">scsi_eh_restore_cmnd</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ses</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- auto-sense aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

			<span class="cm">/* If SANE_SENSE caused this problem, disable it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sense_size</span> <span class="o">!=</span> <span class="n">US_SENSE_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">US_FL_SANE_SENSE</span><span class="p">;</span>
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">|=</span> <span class="n">US_FL_BAD_SENSE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">Handle_Errors</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Some devices claim to support larger sense but fail when</span>
<span class="cm">		 * trying to request it. When a transport failure happens</span>
<span class="cm">		 * using US_FS_SANE_SENSE, we always retry with a standard</span>
<span class="cm">		 * (small) sense request. This fixes some USB GSM modems</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp_result</span> <span class="o">==</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span> <span class="o">&amp;&amp;</span>
				<span class="n">sense_size</span> <span class="o">!=</span> <span class="n">US_SENSE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- auto-sense failure, retry small sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sense_size</span> <span class="o">=</span> <span class="n">US_SENSE_SIZE</span><span class="p">;</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">US_FL_SANE_SENSE</span><span class="p">;</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">|=</span> <span class="n">US_FL_BAD_SENSE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">Retry_Sense</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Other failures */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp_result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- auto-sense failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/* we skip the reset if this happens to be a</span>
<span class="cm">			 * multi-target device, since failure of an</span>
<span class="cm">			 * auto-sense is perfectly valid</span>
<span class="cm">			 */</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SCM_MULT_TARG</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">Handle_Errors</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If the sense data returned is larger than 18-bytes then we</span>
<span class="cm">		 * assume this device supports requesting more in the future.</span>
<span class="cm">		 * The response code must be 70h through 73h inclusive.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">US_SENSE_SIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SANE_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_BAD_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7C</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x70</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- SANE_SENSE support enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">|=</span> <span class="n">US_FL_SANE_SENSE</span><span class="p">;</span>

			<span class="cm">/* Indicate to the user that we truncated their sense</span>
<span class="cm">			 * because we didn&#39;t know it supported larger sense.</span>
<span class="cm">			 */</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- Sense data truncated to %i from %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			          <span class="n">US_SENSE_SIZE</span><span class="p">,</span>
			          <span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">US_SENSE_SIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">scsi_normalize_sense</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- Result from auto-sense is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp_result</span><span class="p">);</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- code: 0x%x, key: 0x%x, ASC: 0x%x, ASCQ: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sshdr</span><span class="p">.</span><span class="n">response_code</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span><span class="p">,</span>
			  <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_USB_STORAGE_DEBUG</span>
		<span class="n">usb_stor_show_sense</span><span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span><span class="p">,</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/* set the result so the higher layers expect this data */</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>

		<span class="n">scdd</span> <span class="o">=</span> <span class="n">scsi_sense_desc_find</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
					    <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">fm_ili</span> <span class="o">=</span> <span class="p">(</span><span class="n">scdd</span> <span class="o">?</span> <span class="n">scdd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xA0</span><span class="p">;</span>

		<span class="cm">/* We often get empty sense data.  This could indicate that</span>
<span class="cm">		 * everything worked or that there was an unspecified</span>
<span class="cm">		 * problem.  We have to decide which.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fm_ili</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If things are really okay, then let&#39;s show that.</span>
<span class="cm">			 * Zero out the sense buffer so the higher layers</span>
<span class="cm">			 * won&#39;t realize we did an unsolicited auto-sense.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
				<span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

			<span class="cm">/* If there was a problem, report an unspecified</span>
<span class="cm">			 * hardware error to prevent the higher layers from</span>
<span class="cm">			 * entering an infinite retry loop.</span>
<span class="cm">			 */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">sshdr</span><span class="p">.</span><span class="n">response_code</span> <span class="o">&amp;</span> <span class="mh">0x72</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x72</span><span class="p">)</span>
					<span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">HARDWARE_ERROR</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">HARDWARE_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some devices don&#39;t work or return incorrect data the first</span>
<span class="cm">	 * time they get a READ(10) command, or for the first READ(10)</span>
<span class="cm">	 * after a media change.  If the INITIAL_READ10 flag is set,</span>
<span class="cm">	 * keep track of whether READ(10) commands succeed.  If the</span>
<span class="cm">	 * previous one succeeded and this one failed, set the REDO_READ10</span>
<span class="cm">	 * flag to force a retry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_INITIAL_READ10</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">SAM_STAT_GOOD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_READ10_WORKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_READ10_WORKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_READ10_WORKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_REDO_READ10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Next, if the REDO_READ10 flag is set, return a result</span>
<span class="cm">		 * code that will cause the SCSI core to retry the READ(10)</span>
<span class="cm">		 * command immediately.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_REDO_READ10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_REDO_READ10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_IMM_RETRY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Did we transfer less than the minimum amount required? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">SAM_STAT_GOOD</span> <span class="o">||</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">-</span> <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">underflow</span><span class="p">)</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">last_sector_hacks</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Error and abort processing: try to resynchronize with the device</span>
<span class="cm">	 * by issuing a port reset.  If that fails, try a class-specific</span>
<span class="cm">	 * device reset. */</span>
  <span class="nl">Handle_Errors:</span>

	<span class="cm">/* Set the RESETTING bit, and clear the ABORTING bit so that</span>
<span class="cm">	 * the reset may proceed. */</span>
	<span class="n">scsi_lock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
	<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>

	<span class="cm">/* We must release the device lock because the pre_reset routine</span>
<span class="cm">	 * will want to acquire it. */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_port_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_lock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
		<span class="n">usb_stor_report_device_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
		<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
	<span class="n">last_sector_hacks</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Stop the current URB transfer */</span>
<span class="kt">void</span> <span class="nf">usb_stor_stop_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* If the state machine is blocked waiting for an URB,</span>
<span class="cm">	 * let&#39;s wake it up.  The test_and_clear_bit() call</span>
<span class="cm">	 * guarantees that if a URB has just been submitted,</span>
<span class="cm">	 * it won&#39;t be cancelled more than once. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_URB_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- cancelling URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If we are waiting for a scatter-gather operation, cancel it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_SG_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- cancelling sg request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_sg_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Control/Bulk and Control/Bulk/Interrupt transport</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">usb_stor_CB_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">transfer_length</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* COMMAND STAGE */</span>
	<span class="cm">/* let&#39;s send the command via the control pipe */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
				      <span class="n">US_CBI_ADSC</span><span class="p">,</span> 
				      <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
				      <span class="n">us</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">,</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="cm">/* check the return code for the command */</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Call to usb_stor_ctrl_transfer() returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

	<span class="cm">/* if we stalled the command, it means command failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_STALLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Uh oh... serious problem here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* DATA STAGE */</span>
	<span class="cm">/* transfer the data payload for this command, if one exists*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transfer_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">?</span> 
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span> <span class="o">:</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_srb</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;CBI data stage result is 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

		<span class="cm">/* if we stalled the data transfer it means command failed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_STALLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="n">USB_STOR_XFER_STALLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* STATUS STAGE */</span>

	<span class="cm">/* NOTE: CB does not have a status stage.  Silly, I know.  So</span>
<span class="cm">	 * we have to catch this at a higher level.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">USB_PR_CBI</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_intr_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Got interrupt data (0x%x, 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* UFI gives us ASC and ASCQ, like a request sense</span>
<span class="cm">	 *</span>
<span class="cm">	 * REQUEST_SENSE and INQUIRY don&#39;t affect the sense data on UFI</span>
<span class="cm">	 * devices, so we ignore the information for those commands.  Note</span>
<span class="cm">	 * that this means we could be ignoring a real error on these</span>
<span class="cm">	 * commands, but that can&#39;t be helped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">USB_SC_UFI</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span> <span class="o">||</span>
		    <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">Failed</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If not UFI, we interpret the data as a result code </span>
<span class="cm">	 * The first byte should always be a 0x0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some bogus devices don&#39;t follow that rule.  They stuff the ASC</span>
<span class="cm">	 * into the first byte -- so if it&#39;s non-zero, call it a failure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;CBI IRQ data showed reserved bType 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">Failed</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/* The second byte &amp; 0x0F should be 0x0 for good, otherwise error */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x00</span>: 
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x01</span>: 
			<span class="k">goto</span> <span class="n">Failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* the CBI spec requires that the bulk pipe must be cleared</span>
<span class="cm">	 * following any data-in/out command failure (section 2.4.3.1.3)</span>
<span class="cm">	 */</span>
  <span class="nl">Failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
		<span class="n">usb_stor_clear_halt</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_CB_transport</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Bulk only transport</span>
<span class="cm"> */</span>

<span class="cm">/* Determine what the maximum LUN supported is */</span>
<span class="kt">int</span> <span class="nf">usb_stor_Bulk_max_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* issue the command */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_control_msg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span><span class="p">,</span>
				 <span class="n">US_BULK_GET_MAX_LUN</span><span class="p">,</span> 
				 <span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> 
				 <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;GetMaxLUN command result is %d, data is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		  <span class="n">result</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* if we have a successful request, return the result */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some devices don&#39;t like GetMaxLUN.  They may STALL the control</span>
<span class="cm">	 * pipe, they may return a zero-length result, they may do nothing at</span>
<span class="cm">	 * all and timeout, or they may fail in even more bizarrely creative</span>
<span class="cm">	 * ways.  In these cases the best approach is to use the default</span>
<span class="cm">	 * value: only one LUN.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">usb_stor_Bulk_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bulk_cb_wrap</span> <span class="o">*</span><span class="n">bcb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bulk_cb_wrap</span> <span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bulk_cs_wrap</span> <span class="o">*</span><span class="n">bcs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bulk_cs_wrap</span> <span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">transfer_length</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">residue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fake_sense</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cswlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cbwlen</span> <span class="o">=</span> <span class="n">US_BULK_CB_WRAP_LEN</span><span class="p">;</span>

	<span class="cm">/* Take care of BULK32 devices; set extra byte to 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_BULK32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cbwlen</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set up the command wrapper */</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">US_BULK_CB_SIGN</span><span class="p">);</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">DataTransferLength</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">transfer_length</span><span class="p">);</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">?</span>
		<span class="n">US_BULK_FLAG_IN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Tag</span> <span class="o">=</span> <span class="o">++</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Lun</span> <span class="o">=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SCM_MULT_TARG</span><span class="p">)</span>
		<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Lun</span> <span class="o">|=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>

	<span class="cm">/* copy the command payload */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">CDB</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">CDB</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">CDB</span><span class="p">,</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>

	<span class="cm">/* send it to out endpoint */</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bulk Command S 0x%x T 0x%x L %d F %d Trg %d LUN %d CL %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">),</span> <span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Tag</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">DataTransferLength</span><span class="p">),</span> <span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Flags</span><span class="p">,</span>
			<span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Lun</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Lun</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">),</span> 
			<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">,</span>
				<span class="n">bcb</span><span class="p">,</span> <span class="n">cbwlen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bulk command transfer result=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* DATA STAGE */</span>
	<span class="cm">/* send/receive data payload, if there is any */</span>

	<span class="cm">/* Some USB-IDE converter chips need a 100us delay between the</span>
<span class="cm">	 * command phase and the data phase.  Some devices need a little</span>
<span class="cm">	 * more than that, probably because of clock rate inaccuracies. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_GO_SLOW</span><span class="p">))</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">125</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transfer_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span> <span class="o">=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">?</span> 
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span> <span class="o">:</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_srb</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bulk data transfer result 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_ERROR</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="cm">/* If the device tried to send back more data than the</span>
<span class="cm">		 * amount requested, the spec requires us to transfer</span>
<span class="cm">		 * the CSW anyway.  Since there&#39;s no point retrying the</span>
<span class="cm">		 * the command, we&#39;ll return fake sense data indicating</span>
<span class="cm">		 * Illegal Request, Invalid Field in CDB.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_LONG</span><span class="p">)</span>
			<span class="n">fake_sense</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* See flow chart on pg 15 of the Bulk Only Transport spec for</span>
<span class="cm">	 * an explanation of how this code works.</span>
<span class="cm">	 */</span>

	<span class="cm">/* get CSW for device status */</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Attempting to get CSW...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
				<span class="n">bcs</span><span class="p">,</span> <span class="n">US_BULK_CS_WRAP_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cswlen</span><span class="p">);</span>

	<span class="cm">/* Some broken devices add unnecessary zero-length packets to the</span>
<span class="cm">	 * end of their data transfers.  Such packets show up as 0-length</span>
<span class="cm">	 * CSWs.  If we encounter such a thing, try to read the CSW again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_SHORT</span> <span class="o">&amp;&amp;</span> <span class="n">cswlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Received 0-length CSW; retrying...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
				<span class="n">bcs</span><span class="p">,</span> <span class="n">US_BULK_CS_WRAP_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cswlen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* did the attempt to read the CSW fail? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_STALLED</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* get the status again */</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Attempting to get CSW (2nd try)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
				<span class="n">bcs</span><span class="p">,</span> <span class="n">US_BULK_CS_WRAP_LEN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if we still have a failure at this point, we&#39;re in trouble */</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bulk status result = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* check bulk status */</span>
	<span class="n">residue</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Residue</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bulk Status S 0x%x T 0x%x R %u Stat 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">),</span> <span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Tag</span><span class="p">,</span> 
			<span class="n">residue</span><span class="p">,</span> <span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Tag</span> <span class="o">==</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">||</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_BULK_IGNORE_TAG</span><span class="p">))</span> <span class="o">||</span>
		<span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Status</span> <span class="o">&gt;</span> <span class="n">US_BULK_STAT_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bulk logical error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Some broken devices report odd signatures, so we do not check them</span>
<span class="cm">	 * for validity against the spec. We store the first one we see,</span>
<span class="cm">	 * and check subsequent transfers for validity against this signature.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">bcs_signature</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">bcs_signature</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">bcs_signature</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">US_BULK_CS_SIGN</span><span class="p">))</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Learnt BCS signature 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">bcs_signature</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">!=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">bcs_signature</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Signature mismatch: got %08X, expecting %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">),</span>
			  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">bcs_signature</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* try to compute the actual residue, based on how much data</span>
<span class="cm">	 * was really transferred and what the device tells us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">residue</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_IGNORE_RESIDUE</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Heuristically detect devices that generate bogus residues</span>
<span class="cm">		 * by seeing what happens with INQUIRY and READ CAPACITY</span>
<span class="cm">		 * commands.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Status</span> <span class="o">==</span> <span class="n">US_BULK_STAT_OK</span> <span class="o">&amp;&amp;</span>
				<span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
					<span class="p">((</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span> <span class="o">&amp;&amp;</span>
						<span class="n">transfer_length</span> <span class="o">==</span> <span class="mi">36</span><span class="p">)</span> <span class="o">||</span>
					<span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_CAPACITY</span> <span class="o">&amp;&amp;</span>
						<span class="n">transfer_length</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">|=</span> <span class="n">US_FL_IGNORE_RESIDUE</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">residue</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">transfer_length</span><span class="p">);</span>
			<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span>
			                                       <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">residue</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* based on the status code, we report good or bad */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">US_BULK_STAT_OK</span>:
			<span class="cm">/* device babbled -- return fake sense data */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fake_sense</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> 
				       <span class="n">usb_stor_sense_invalidCDB</span><span class="p">,</span> 
				       <span class="k">sizeof</span><span class="p">(</span><span class="n">usb_stor_sense_invalidCDB</span><span class="p">));</span>
				<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_NO_SENSE</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* command good -- note that data could be short */</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">US_BULK_STAT_FAIL</span>:
			<span class="cm">/* command failed */</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">US_BULK_STAT_PHASE</span>:
			<span class="cm">/* phase error -- note that a transport reset will be</span>
<span class="cm">			 * invoked by the invoke_transport() function</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we should never get here, but if we do, we&#39;re in trouble */</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_Bulk_transport</span><span class="p">);</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Reset routines</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* This is the common part of the device reset code.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s handy that every transport mechanism uses the control endpoint for</span>
<span class="cm"> * resets.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically, we send a reset with a 5-second timeout, so we don&#39;t get</span>
<span class="cm"> * jammed attempting to do the reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_stor_reset_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u8</span> <span class="n">requesttype</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;No reset during disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_control_msg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
			<span class="n">request</span><span class="p">,</span> <span class="n">requesttype</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Soft reset failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Give the device some time to recover from the reset,</span>
<span class="cm">	 * but don&#39;t delay disconnect processing. */</span>
	<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">delay_wait</span><span class="p">,</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">),</span>
			<span class="n">HZ</span><span class="o">*</span><span class="mi">6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Reset interrupted by disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Soft reset: clearing bulk-in endpoint halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_clear_halt</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Soft reset: clearing bulk-out endpoint halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">result2</span> <span class="o">=</span> <span class="n">usb_stor_clear_halt</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">);</span>

	<span class="cm">/* return a result code based on the result of the clear-halts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">result2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Soft reset failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Soft reset done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This issues a CB[I] Reset to the device in question</span>
<span class="cm"> */</span>
<span class="cp">#define CB_RESET_CMD_SIZE	12</span>

<span class="kt">int</span> <span class="nf">usb_stor_CB_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">CB_RESET_CMD_SIZE</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SEND_DIAGNOSTIC</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usb_stor_reset_common</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">US_CBI_ADSC</span><span class="p">,</span> 
				 <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">,</span> <span class="n">CB_RESET_CMD_SIZE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_CB_reset</span><span class="p">);</span>

<span class="cm">/* This issues a Bulk-only Reset to the device in question, including</span>
<span class="cm"> * clearing the subsequent endpoint halts that may occur.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_Bulk_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usb_stor_reset_common</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">US_BULK_RESET_REQUEST</span><span class="p">,</span> 
				 <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">ifnum</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_Bulk_reset</span><span class="p">);</span>

<span class="cm">/* Issue a USB port reset to the device.  The caller must not hold</span>
<span class="cm"> * us-&gt;dev_mutex.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">usb_stor_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*for these devices we must use the class specific method */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">USB_QUIRK_RESET_MORPHS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_lock_device_for_reset</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;unable to lock device for reset: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Were we disconnected while waiting for the lock? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;No reset during disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">usb_reset_device</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">);</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usb_reset_device returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">result</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
