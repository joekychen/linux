<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › storage › sddr09.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sddr09.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Driver for SanDisk SDDR-09 SmartMedia reader</span>
<span class="cm"> *</span>
<span class="cm"> *   (c) 2000, 2001 Robert Baruch (autophile@starband.net)</span>
<span class="cm"> *   (c) 2002 Andries Brouwer (aeb@cwi.nl)</span>
<span class="cm"> * Developed with the assistance of:</span>
<span class="cm"> *   (c) 2002 Alan Stern &lt;stern@rowland.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * The SanDisk SDDR-09 SmartMedia reader uses the Shuttle EUSB-01 chip.</span>
<span class="cm"> * This chip is a programmable USB controller. In the SDDR-09, it has</span>
<span class="cm"> * been programmed to obey a certain limited set of SCSI commands.</span>
<span class="cm"> * This driver translates the &quot;real&quot; SCSI commands to the SDDR-09 SCSI</span>
<span class="cm"> * commands.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Known vendor commands: 12 bytes, first byte is opcode</span>
<span class="cm"> *</span>
<span class="cm"> * E7: read scatter gather</span>
<span class="cm"> * E8: read</span>
<span class="cm"> * E9: write</span>
<span class="cm"> * EA: erase</span>
<span class="cm"> * EB: reset</span>
<span class="cm"> * EC: read status</span>
<span class="cm"> * ED: read ID</span>
<span class="cm"> * EE: write CIS (?)</span>
<span class="cm"> * EF: compute checksum (?)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>
<span class="cp">#include &quot;transport.h&quot;</span>
<span class="cp">#include &quot;protocol.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for SanDisk SDDR-09 SmartMedia reader&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Andries Brouwer &lt;aeb@cwi.nl&gt;, Robert Baruch &lt;autophile@starband.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">usb_stor_sddr09_dpcm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sddr09_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usb_stor_sddr09_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * The table of devices</span>
<span class="cm"> */</span>
<span class="cp">#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \</span>
<span class="cp">		    vendorName, productName, useProtocol, useTransport, \</span>
<span class="cp">		    initFunction, flags) \</span>
<span class="cp">{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \</span>
<span class="cp">  .driver_info = (flags)|(USB_US_TYPE_STOR&lt;&lt;24) }</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">sddr09_usb_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#	include &quot;unusual_sddr09.h&quot;</span>
	<span class="p">{</span> <span class="p">}</span>		<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">sddr09_usb_ids</span><span class="p">);</span>

<span class="cp">#undef UNUSUAL_DEV</span>

<span class="cm">/*</span>
<span class="cm"> * The flags table</span>
<span class="cm"> */</span>
<span class="cp">#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \</span>
<span class="cp">		    vendor_name, product_name, use_protocol, use_transport, \</span>
<span class="cp">		    init_function, Flags) \</span>
<span class="cp">{ \</span>
<span class="cp">	.vendorName = vendor_name,	\</span>
<span class="cp">	.productName = product_name,	\</span>
<span class="cp">	.useProtocol = use_protocol,	\</span>
<span class="cp">	.useTransport = use_transport,	\</span>
<span class="cp">	.initFunction = init_function,	\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">us_unusual_dev</span> <span class="n">sddr09_unusual_dev_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#	include &quot;unusual_sddr09.h&quot;</span>
	<span class="p">{</span> <span class="p">}</span>		<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>

<span class="cp">#undef UNUSUAL_DEV</span>


<span class="cp">#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))&lt;&lt;8 ) )</span>
<span class="cp">#define LSB_of(s) ((s)&amp;0xFF)</span>
<span class="cp">#define MSB_of(s) ((s)&gt;&gt;8)</span>

<span class="cm">/* #define US_DEBUGP printk */</span>

<span class="cm">/*</span>
<span class="cm"> * First some stuff that does not belong here:</span>
<span class="cm"> * data on SmartMedia and other cards, completely</span>
<span class="cm"> * unrelated to this driver.</span>
<span class="cm"> * Similar stuff occurs in &lt;linux/mtd/nand_ids.h&gt;.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">model_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipshift</span><span class="p">;</span>		<span class="cm">/* 1&lt;&lt;cs bytes total capacity */</span>
	<span class="kt">char</span> <span class="n">pageshift</span><span class="p">;</span>		<span class="cm">/* 1&lt;&lt;ps bytes in a page */</span>
	<span class="kt">char</span> <span class="n">blockshift</span><span class="p">;</span>	<span class="cm">/* 1&lt;&lt;bs pages in an erase block */</span>
	<span class="kt">char</span> <span class="n">zoneshift</span><span class="p">;</span>		<span class="cm">/* 1&lt;&lt;zs blocks in a zone */</span>
				<span class="cm">/* # of logical blocks is 125/128 of this */</span>
	<span class="kt">char</span> <span class="n">pageadrlen</span><span class="p">;</span>	<span class="cm">/* length of an address in bytes - 1 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * NAND Flash Manufacturer ID Codes</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_MFR_AMD		0x01</span>
<span class="cp">#define NAND_MFR_NATSEMI	0x8f</span>
<span class="cp">#define NAND_MFR_TOSHIBA	0x98</span>
<span class="cp">#define NAND_MFR_SAMSUNG	0xec</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">nand_flash_manufacturer</span><span class="p">(</span><span class="kt">int</span> <span class="n">manuf_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">manuf_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NAND_MFR_AMD</span>:
		<span class="k">return</span> <span class="s">&quot;AMD&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_MFR_NATSEMI</span>:
		<span class="k">return</span> <span class="s">&quot;NATSEMI&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_MFR_TOSHIBA</span>:
		<span class="k">return</span> <span class="s">&quot;Toshiba&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_MFR_SAMSUNG</span>:
		<span class="k">return</span> <span class="s">&quot;Samsung&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * It looks like it is unnecessary to attach manufacturer to the</span>
<span class="cm"> * remaining data: SSFDC prescribes manufacturer-independent id codes.</span>
<span class="cm"> *</span>
<span class="cm"> * 256 MB NAND flash has a 5-byte ID with 2nd byte 0xaa, 0xba, 0xca or 0xda.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="n">nand_flash_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* NAND flash */</span>
	<span class="p">{</span> <span class="mh">0x6e</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 1 MB */</span>
	<span class="p">{</span> <span class="mh">0xe8</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 1 MB */</span>
	<span class="p">{</span> <span class="mh">0xec</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 1 MB */</span>
	<span class="p">{</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> 	<span class="cm">/* 2 MB */</span>
	<span class="p">{</span> <span class="mh">0xea</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 2 MB */</span>
	<span class="p">{</span> <span class="mh">0x6b</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 4 MB */</span>
	<span class="p">{</span> <span class="mh">0xe3</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 4 MB */</span>
	<span class="p">{</span> <span class="mh">0xe5</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 4 MB */</span>
	<span class="p">{</span> <span class="mh">0xe6</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 8 MB */</span>
	<span class="p">{</span> <span class="mh">0x73</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 16 MB */</span>
	<span class="p">{</span> <span class="mh">0x75</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 32 MB */</span>
	<span class="p">{</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>	<span class="cm">/* 64 MB */</span>
	<span class="p">{</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>	<span class="cm">/* 128 MB */</span>

	<span class="cm">/* MASK ROM */</span>
	<span class="p">{</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 2 MB */</span>
	<span class="p">{</span> <span class="mh">0xd5</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 4 MB */</span>
	<span class="p">{</span> <span class="mh">0xd6</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 8 MB */</span>
	<span class="p">{</span> <span class="mh">0x57</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 16 MB */</span>
	<span class="p">{</span> <span class="mh">0x58</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>	<span class="cm">/* 32 MB */</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="o">*</span>
<span class="nf">nand_find_id</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nand_flash_ids</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">model_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ECC computation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">parity</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ecc2</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_init_ecc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>

	<span class="n">parity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">parity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">parity</span><span class="p">[</span><span class="n">i</span><span class="o">&amp;</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">^</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">a</span> <span class="o">^=</span> <span class="mh">0x04</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">a</span> <span class="o">^=</span> <span class="mh">0x10</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">a</span> <span class="o">^=</span> <span class="mh">0x40</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ecc2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="p">(</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">parity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="mh">0xa8</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* compute 3-byte ecc on 256 bytes */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_compute_ecc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ecc</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">par</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">bits</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">par</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* collect 16 checksum bits */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">par</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">parity</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">bits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* put 4+4+4 = 12 bits in the ecc */</span>
	<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ecc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="p">(</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">parity</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">?</span> <span class="mh">0xaa</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">ecc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="p">(</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">parity</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">?</span> <span class="mh">0xaa</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">ecc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ecc2</span><span class="p">[</span><span class="n">par</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_compare_ecc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ecc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ecc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ecc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">ecc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_store_ecc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ecc</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ecc</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The actual driver starts here.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">capacity</span><span class="p">;</span>	<span class="cm">/* Size of card in bytes */</span>
	<span class="kt">int</span>		<span class="n">pagesize</span><span class="p">;</span>	<span class="cm">/* Size of page in bytes */</span>
	<span class="kt">int</span>		<span class="n">pageshift</span><span class="p">;</span>	<span class="cm">/* log2 of pagesize */</span>
	<span class="kt">int</span>		<span class="n">blocksize</span><span class="p">;</span>	<span class="cm">/* Size of block in pages */</span>
	<span class="kt">int</span>		<span class="n">blockshift</span><span class="p">;</span>	<span class="cm">/* log2 of blocksize */</span>
	<span class="kt">int</span>		<span class="n">blockmask</span><span class="p">;</span>	<span class="cm">/* 2^blockshift - 1 */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">lba_to_pba</span><span class="p">;</span>	<span class="cm">/* logical to physical map */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">pba_to_lba</span><span class="p">;</span>	<span class="cm">/* physical to logical map */</span>
	<span class="kt">int</span>		<span class="n">lbact</span><span class="p">;</span>		<span class="cm">/* number of available pages */</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define	SDDR09_WP	1		</span><span class="cm">/* write protected */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On my 16MB card, control blocks have size 64 (16 real control bytes,</span>
<span class="cm"> * and 48 junk bytes). In reality of course the card uses 16 control bytes,</span>
<span class="cm"> * so the reader makes up the remaining 48. Don&#39;t know whether these numbers</span>
<span class="cm"> * depend on the card. For now a constant.</span>
<span class="cm"> */</span>
<span class="cp">#define CONTROL_SHIFT 6</span>

<span class="cm">/*</span>
<span class="cm"> * On my Combo CF/SM reader, the SM reader has LUN 1.</span>
<span class="cm"> * (and things fail with LUN 0).</span>
<span class="cm"> * It seems LUN is irrelevant for others.</span>
<span class="cm"> */</span>
<span class="cp">#define LUN	1</span>
<span class="cp">#define	LUNBITS	(LUN &lt;&lt; 5)</span>

<span class="cm">/*</span>
<span class="cm"> * LBA and PBA are unsigned ints. Special values.</span>
<span class="cm"> */</span>
<span class="cp">#define UNDEF    0xffffffff</span>
<span class="cp">#define SPARE    0xfffffffe</span>
<span class="cp">#define UNUSABLE 0xfffffffd</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">erase_bad_lba_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* send vendor interface command (0x41) */</span>
<span class="cm">/* called for requests 0, 1, 8 */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_send_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">request</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">direction</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xfer_data</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xfer_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">requesttype</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x41</span> <span class="o">|</span> <span class="n">direction</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Get the receive or send control pipe number</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">requesttype</span><span class="p">,</span>
				   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xfer_data</span><span class="p">,</span> <span class="n">xfer_len</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">USB_STOR_XFER_GOOD</span>:	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">USB_STOR_XFER_STALLED</span>:	<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="nl">default:</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_send_scsi_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">sddr09_send_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USB_DIR_OUT</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">command_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Test Unit Ready Command: 12 bytes.</span>
<span class="c"> * byte 0: opcode: 00</span>
<span class="c"> */</span>
<span class="c">static int</span>
<span class="c">sddr09_test_unit_ready(struct us_data *us) {</span>
<span class="c">	unsigned char *command = us-&gt;iobuf;</span>
<span class="c">	int result;</span>

<span class="c">	memset(command, 0, 6);</span>
<span class="c">	command[1] = LUNBITS;</span>

<span class="c">	result = sddr09_send_scsi_command(us, command, 6);</span>

<span class="c">	US_DEBUGP(&quot;sddr09_test_unit_ready returns %d\n&quot;, result);</span>

<span class="c">	return result;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Request Sense Command: 12 bytes.</span>
<span class="cm"> * byte 0: opcode: 03</span>
<span class="cm"> * byte 4: data length</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_request_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sensebuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LUNBITS</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">buflen</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_scsi_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
			<span class="n">sensebuf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_GOOD</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read Command: 12 bytes.</span>
<span class="cm"> * byte 0: opcode: E8</span>
<span class="cm"> * byte 1: last two bits: 00: read data, 01: read blockwise control,</span>
<span class="cm"> *			10: read both, 11: read pagewise control.</span>
<span class="cm"> *	 It turns out we need values 20, 21, 22, 23 here (LUN 1).</span>
<span class="cm"> * bytes 2-5: address (interpretation depends on byte 1, see below)</span>
<span class="cm"> * bytes 10-11: count (idem)</span>
<span class="cm"> *</span>
<span class="cm"> * A page has 512 data bytes and 64 control bytes (16 control and 48 junk).</span>
<span class="cm"> * A read data command gets data in 512-byte pages.</span>
<span class="cm"> * A read control command gets control in 64-byte chunks.</span>
<span class="cm"> * A read both command gets data+control in 576-byte chunks.</span>
<span class="cm"> *</span>
<span class="cm"> * Blocks are groups of 32 pages, and read blockwise control jumps to the</span>
<span class="cm"> * next block, while read pagewise control jumps to the next page after</span>
<span class="cm"> * reading a group of 64 control bytes.</span>
<span class="cm"> * [Here 512 = 1&lt;&lt;pageshift, 32 = 1&lt;&lt;blockshift, 64 is constant?]</span>
<span class="cm"> *</span>
<span class="cm"> * (1 MB and 2 MB cards are a bit different, but I have only a 16 MB card.)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_readX</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fromaddress</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bulklen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xE8</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LUNBITS</span> <span class="o">|</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">fromaddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">fromaddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span> 
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">fromaddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">fromaddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span> 
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">nr_of_pages</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">nr_of_pages</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_scsi_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Result for send_control in sddr09_read2%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">x</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_sg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
				       <span class="n">buf</span><span class="p">,</span> <span class="n">bulklen</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Result for bulk_transfer in sddr09_read2%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">x</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read Data</span>
<span class="cm"> *</span>
<span class="cm"> * fromaddress counts data shorts:</span>
<span class="cm"> * increasing it by 256 shifts the bytestream by 512 bytes;</span>
<span class="cm"> * the last 8 bits are ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * nr_of_pages counts pages of size (1 &lt;&lt; pageshift).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read20</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fromaddress</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pageshift</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">bulklen</span> <span class="o">=</span> <span class="n">nr_of_pages</span> <span class="o">&lt;&lt;</span> <span class="n">pageshift</span><span class="p">;</span>

	<span class="cm">/* The last 8 bits of fromaddress are ignored. */</span>
	<span class="k">return</span> <span class="n">sddr09_readX</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fromaddress</span><span class="p">,</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="n">bulklen</span><span class="p">,</span>
			    <span class="n">buf</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read Blockwise Control</span>
<span class="cm"> *</span>
<span class="cm"> * fromaddress gives the starting position (as in read data;</span>
<span class="cm"> * the last 8 bits are ignored); increasing it by 32*256 shifts</span>
<span class="cm"> * the output stream by 64 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * count counts control groups of size (1 &lt;&lt; controlshift).</span>
<span class="cm"> * For me, controlshift = 6. Is this constant?</span>
<span class="cm"> *</span>
<span class="cm"> * After getting one control group, jump to the next block</span>
<span class="cm"> * (fromaddress += 8192).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read21</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fromaddress</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">controlshift</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">bulklen</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">controlshift</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sddr09_readX</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fromaddress</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">bulklen</span><span class="p">,</span>
			    <span class="n">buf</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read both Data and Control</span>
<span class="cm"> *</span>
<span class="cm"> * fromaddress counts data shorts, ignoring control:</span>
<span class="cm"> * increasing it by 256 shifts the bytestream by 576 = 512+64 bytes;</span>
<span class="cm"> * the last 8 bits are ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * nr_of_pages counts pages of size (1 &lt;&lt; pageshift) + (1 &lt;&lt; controlshift).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read22</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fromaddress</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pageshift</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">bulklen</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr_of_pages</span> <span class="o">&lt;&lt;</span> <span class="n">pageshift</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr_of_pages</span> <span class="o">&lt;&lt;</span> <span class="n">CONTROL_SHIFT</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_read22: reading %d pages, %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">nr_of_pages</span><span class="p">,</span> <span class="n">bulklen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sddr09_readX</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fromaddress</span><span class="p">,</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="n">bulklen</span><span class="p">,</span>
			    <span class="n">buf</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Read Pagewise Control</span>
<span class="c"> *</span>
<span class="c"> * fromaddress gives the starting position (as in read data;</span>
<span class="c"> * the last 8 bits are ignored); increasing it by 256 shifts</span>
<span class="c"> * the output stream by 64 bytes.</span>
<span class="c"> *</span>
<span class="c"> * count counts control groups of size (1 &lt;&lt; controlshift).</span>
<span class="c"> * For me, controlshift = 6. Is this constant?</span>
<span class="c"> *</span>
<span class="c"> * After getting one control group, jump to the next page</span>
<span class="c"> * (fromaddress += 256).</span>
<span class="c"> */</span>
<span class="c">static int</span>
<span class="c">sddr09_read23(struct us_data *us, unsigned long fromaddress,</span>
<span class="c">	      int count, int controlshift, unsigned char *buf, int use_sg) {</span>

<span class="c">	int bulklen = (count &lt;&lt; controlshift);</span>
<span class="c">	return sddr09_readX(us, 3, fromaddress, count, bulklen,</span>
<span class="c">			    buf, use_sg);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Erase Command: 12 bytes.</span>
<span class="cm"> * byte 0: opcode: EA</span>
<span class="cm"> * bytes 6-9: erase address (big-endian, counting shorts, sector aligned).</span>
<span class="cm"> * </span>
<span class="cm"> * Always precisely one block is erased; bytes 2-5 and 10-11 are ignored.</span>
<span class="cm"> * The byte address being erased is 2*Eaddress.</span>
<span class="cm"> * The CIS cannot be erased.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Eaddress</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_erase: erase address %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Eaddress</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xEA</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LUNBITS</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">Eaddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">Eaddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">Eaddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">Eaddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_scsi_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Result for send_control in sddr09_erase %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">result</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write CIS Command: 12 bytes.</span>
<span class="cm"> * byte 0: opcode: EE</span>
<span class="cm"> * bytes 2-5: write address in shorts</span>
<span class="cm"> * bytes 10-11: sector count</span>
<span class="cm"> *</span>
<span class="cm"> * This writes at the indicated address. Don&#39;t know how it differs</span>
<span class="cm"> * from E9. Maybe it does not erase? However, it will also write to</span>
<span class="cm"> * the CIS.</span>
<span class="cm"> *</span>
<span class="cm"> * When two such commands on the same page follow each other directly,</span>
<span class="cm"> * the second one is not done.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Write Command: 12 bytes.</span>
<span class="cm"> * byte 0: opcode: E9</span>
<span class="cm"> * bytes 2-5: write address (big-endian, counting shorts, sector aligned).</span>
<span class="cm"> * bytes 6-9: erase address (big-endian, counting shorts, sector aligned).</span>
<span class="cm"> * bytes 10-11: sector count (big-endian, in 512-byte sectors).</span>
<span class="cm"> *</span>
<span class="cm"> * If write address equals erase address, the erase is done first,</span>
<span class="cm"> * otherwise the write is done first. When erase address equals zero</span>
<span class="cm"> * no erase is done?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_writeX</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Waddress</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Eaddress</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bulklen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xE9</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LUNBITS</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">Waddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">Waddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">Waddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">Waddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">Eaddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">Eaddress</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">Eaddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">Eaddress</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">nr_of_pages</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">nr_of_pages</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_scsi_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Result for send_control in sddr09_writeX %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_sg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">,</span>
				       <span class="n">buf</span><span class="p">,</span> <span class="n">bulklen</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Result for bulk_transfer in sddr09_writeX %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* erase address, write same address */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_write_inplace</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pageshift</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">bulklen</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr_of_pages</span> <span class="o">&lt;&lt;</span> <span class="n">pageshift</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr_of_pages</span> <span class="o">&lt;&lt;</span> <span class="n">CONTROL_SHIFT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sddr09_writeX</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">nr_of_pages</span><span class="p">,</span> <span class="n">bulklen</span><span class="p">,</span>
			     <span class="n">buf</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Read Scatter Gather Command: 3+4n bytes.</span>
<span class="c"> * byte 0: opcode E7</span>
<span class="c"> * byte 2: n</span>
<span class="c"> * bytes 4i-1,4i,4i+1: page address</span>
<span class="c"> * byte 4i+2: page count</span>
<span class="c"> * (i=1..n)</span>
<span class="c"> *</span>
<span class="c"> * This reads several pages from the card to a single memory buffer.</span>
<span class="c"> * The last two bits of byte 1 have the same meaning as for E8.</span>
<span class="c"> */</span>
<span class="c">static int</span>
<span class="c">sddr09_read_sg_test_only(struct us_data *us) {</span>
<span class="c">	unsigned char *command = us-&gt;iobuf;</span>
<span class="c">	int result, bulklen, nsg, ct;</span>
<span class="c">	unsigned char *buf;</span>
<span class="c">	unsigned long address;</span>

<span class="c">	nsg = bulklen = 0;</span>
<span class="c">	command[0] = 0xE7;</span>
<span class="c">	command[1] = LUNBITS;</span>
<span class="c">	command[2] = 0;</span>
<span class="c">	address = 040000; ct = 1;</span>
<span class="c">	nsg++;</span>
<span class="c">	bulklen += (ct &lt;&lt; 9);</span>
<span class="c">	command[4*nsg+2] = ct;</span>
<span class="c">	command[4*nsg+1] = ((address &gt;&gt; 9) &amp; 0xFF);</span>
<span class="c">	command[4*nsg+0] = ((address &gt;&gt; 17) &amp; 0xFF);</span>
<span class="c">	command[4*nsg-1] = ((address &gt;&gt; 25) &amp; 0xFF);</span>

<span class="c">	address = 0340000; ct = 1;</span>
<span class="c">	nsg++;</span>
<span class="c">	bulklen += (ct &lt;&lt; 9);</span>
<span class="c">	command[4*nsg+2] = ct;</span>
<span class="c">	command[4*nsg+1] = ((address &gt;&gt; 9) &amp; 0xFF);</span>
<span class="c">	command[4*nsg+0] = ((address &gt;&gt; 17) &amp; 0xFF);</span>
<span class="c">	command[4*nsg-1] = ((address &gt;&gt; 25) &amp; 0xFF);</span>

<span class="c">	address = 01000000; ct = 2;</span>
<span class="c">	nsg++;</span>
<span class="c">	bulklen += (ct &lt;&lt; 9);</span>
<span class="c">	command[4*nsg+2] = ct;</span>
<span class="c">	command[4*nsg+1] = ((address &gt;&gt; 9) &amp; 0xFF);</span>
<span class="c">	command[4*nsg+0] = ((address &gt;&gt; 17) &amp; 0xFF);</span>
<span class="c">	command[4*nsg-1] = ((address &gt;&gt; 25) &amp; 0xFF);</span>

<span class="c">	command[2] = nsg;</span>

<span class="c">	result = sddr09_send_scsi_command(us, command, 4*nsg+3);</span>

<span class="c">	if (result) {</span>
<span class="c">		US_DEBUGP(&quot;Result for send_control in sddr09_read_sg %d\n&quot;,</span>
<span class="c">			  result);</span>
<span class="c">		return result;</span>
<span class="c">	}</span>

<span class="c">	buf = kmalloc(bulklen, GFP_NOIO);</span>
<span class="c">	if (!buf)</span>
<span class="c">		return -ENOMEM;</span>

<span class="c">	result = usb_stor_bulk_transfer_buf(us, us-&gt;recv_bulk_pipe,</span>
<span class="c">				       buf, bulklen, NULL);</span>
<span class="c">	kfree(buf);</span>
<span class="c">	if (result != USB_STOR_XFER_GOOD) {</span>
<span class="c">		US_DEBUGP(&quot;Result for bulk_transfer in sddr09_read_sg %d\n&quot;,</span>
<span class="c">			  result);</span>
<span class="c">		return -EIO;</span>
<span class="c">	}</span>

<span class="c">	return 0;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Read Status Command: 12 bytes.</span>
<span class="cm"> * byte 0: opcode: EC</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 64 bytes, all zero except for the first.</span>
<span class="cm"> * bit 0: 1: Error</span>
<span class="cm"> * bit 5: 1: Suspended</span>
<span class="cm"> * bit 6: 1: Ready</span>
<span class="cm"> * bit 7: 1: Not write-protected</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Reading status...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xEC</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LUNBITS</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_scsi_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
				       <span class="n">data</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_GOOD</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lba</span><span class="p">,</span> <span class="n">maxlba</span><span class="p">,</span> <span class="n">pba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Figure out the initial LBA and page</p></td><td class="code"><div class="highlight"><pre>	<span class="n">lba</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockmask</span><span class="p">);</span>
	<span class="n">maxlba</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">maxlba</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Since we only read in one block at a time, we have to create
a bounce buffer and move the data a piece at a time between the
bounce buffer and the actual transfer buffer.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">)</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09_read_data: Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>This could be made much more efficient by checking for
contiguous LBA's. Another exercise left to the student.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sectors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Find number of pages we can read in this block */</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">pages</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">;</span>

		<span class="cm">/* Not overflowing capacity? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">maxlba</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Error: Requested lba %u exceeds &quot;</span>
				  <span class="s">&quot;maximum %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lba</span><span class="p">,</span> <span class="n">maxlba</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Find where this lba lives on disk */</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">[</span><span class="n">lba</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pba</span> <span class="o">==</span> <span class="n">UNDEF</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* this lba was never written */</span>

			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Read %d zero pages (LBA %d) page %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">pages</span><span class="p">,</span> <span class="n">lba</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

			<span class="cm">/* This is not really an error. It just means</span>
<span class="cm">			   that the block has never been written.</span>
<span class="cm">			   Instead of returning an error</span>
<span class="cm">			   it is better to return all zero data. */</span>

			<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Read %d pages, from PBA %d&quot;</span>
				  <span class="s">&quot; (LBA %d) page %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">pages</span><span class="p">,</span> <span class="n">pba</span><span class="p">,</span> <span class="n">lba</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

			<span class="n">address</span> <span class="o">=</span> <span class="p">((</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">)</span> <span class="o">+</span> <span class="n">page</span><span class="p">)</span> <span class="o">&lt;&lt;</span> 
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">;</span>

			<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_read20</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">address</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span>
					<span class="n">pages</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>Store the data in the transfer buffer</p></td><td class="code"><div class="highlight"><pre>		<span class="n">usb_stor_access_xfer_buf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">TO_XFER_BUF</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lba</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sectors</span> <span class="o">-=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">sddr09_find_unused_pba</span><span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lba</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lastpba</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">zonestart</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">zonestart</span> <span class="o">=</span> <span class="p">(</span><span class="n">lba</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">-=</span> <span class="n">zonestart</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">lastpba</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">zonestart</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNDEF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lastpba</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">zonestart</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lastpba</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">zonestart</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNDEF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lastpba</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">zonestart</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_write_lba</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lba</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">blockbuffer</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pba</span><span class="p">,</span> <span class="n">lbap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pagelen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bptr</span><span class="p">,</span> <span class="o">*</span><span class="n">cptr</span><span class="p">,</span> <span class="o">*</span><span class="n">xptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ecc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">isnew</span><span class="p">;</span>

	<span class="n">lbap</span> <span class="o">=</span> <span class="p">((</span><span class="n">lba</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x1000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parity</span><span class="p">[</span><span class="n">MSB_of</span><span class="p">(</span><span class="n">lbap</span><span class="p">)</span> <span class="o">^</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">lbap</span><span class="p">)])</span>
		<span class="n">lbap</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pba</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">[</span><span class="n">lba</span><span class="p">];</span>
	<span class="n">isnew</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pba</span> <span class="o">==</span> <span class="n">UNDEF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">sddr09_find_unused_pba</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">lba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pba</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;sddr09_write_lba: Out of unused blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">pba</span><span class="p">]</span> <span class="o">=</span> <span class="n">lba</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">[</span><span class="n">lba</span><span class="p">]</span> <span class="o">=</span> <span class="n">pba</span><span class="p">;</span>
		<span class="n">isnew</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pba</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Maybe it is impossible to write to PBA 1.</span>
<span class="cm">		   Fake success, but don&#39;t do anything. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09: avoid writing to pba 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pagelen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CONTROL_SHIFT</span><span class="p">);</span>

	<span class="cm">/* read old contents */</span>
	<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">));</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_read22</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">address</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">,</span>
			       <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">,</span> <span class="n">blockbuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* check old contents and fill lba */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bptr</span> <span class="o">=</span> <span class="n">blockbuffer</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">pagelen</span><span class="p">;</span>
		<span class="n">cptr</span> <span class="o">=</span> <span class="n">bptr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">;</span>
		<span class="n">nand_compute_ecc</span><span class="p">(</span><span class="n">bptr</span><span class="p">,</span> <span class="n">ecc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nand_compare_ecc</span><span class="p">(</span><span class="n">cptr</span><span class="o">+</span><span class="mi">13</span><span class="p">,</span> <span class="n">ecc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Warning: bad ecc in page %d- of pba %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">i</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
			<span class="n">nand_store_ecc</span><span class="p">(</span><span class="n">cptr</span><span class="o">+</span><span class="mi">13</span><span class="p">,</span> <span class="n">ecc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nand_compute_ecc</span><span class="p">(</span><span class="n">bptr</span><span class="o">+</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ecc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nand_compare_ecc</span><span class="p">(</span><span class="n">cptr</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">ecc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Warning: bad ecc in page %d+ of pba %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">i</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
			<span class="n">nand_store_ecc</span><span class="p">(</span><span class="n">cptr</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">ecc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cptr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">cptr</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">lbap</span><span class="p">);</span>
		<span class="n">cptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">cptr</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">lbap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* copy in new stuff and compute ECC */</span>
	<span class="n">xptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">page</span><span class="o">+</span><span class="n">pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bptr</span> <span class="o">=</span> <span class="n">blockbuffer</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">pagelen</span><span class="p">;</span>
		<span class="n">cptr</span> <span class="o">=</span> <span class="n">bptr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">bptr</span><span class="p">,</span> <span class="n">xptr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">);</span>
		<span class="n">xptr</span> <span class="o">+=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">;</span>
		<span class="n">nand_compute_ecc</span><span class="p">(</span><span class="n">bptr</span><span class="p">,</span> <span class="n">ecc</span><span class="p">);</span>
		<span class="n">nand_store_ecc</span><span class="p">(</span><span class="n">cptr</span><span class="o">+</span><span class="mi">13</span><span class="p">,</span> <span class="n">ecc</span><span class="p">);</span>
		<span class="n">nand_compute_ecc</span><span class="p">(</span><span class="n">bptr</span><span class="o">+</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ecc</span><span class="p">);</span>
		<span class="n">nand_store_ecc</span><span class="p">(</span><span class="n">cptr</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">ecc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Rewrite PBA %d (LBA %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pba</span><span class="p">,</span> <span class="n">lba</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_write_inplace</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">address</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">,</span>
				      <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">,</span> <span class="n">blockbuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_write_inplace returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	{</span>
<span class="c">		unsigned char status = 0;</span>
<span class="c">		int result2 = sddr09_read_status(us, &amp;status);</span>
<span class="c">		if (result2)</span>
<span class="c">			US_DEBUGP(&quot;sddr09_write_inplace: cannot read status\n&quot;);</span>
<span class="c">		else if (status != 0xc0)</span>
<span class="c">			US_DEBUGP(&quot;sddr09_write_inplace: status after write: 0x%x\n&quot;,</span>
<span class="c">				  status);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	{</span>
<span class="c">		int result2 = sddr09_test_unit_ready(us);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lba</span><span class="p">,</span> <span class="n">maxlba</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pagelen</span><span class="p">,</span> <span class="n">blocklen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">blockbuffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Figure out the initial LBA and page</p></td><td class="code"><div class="highlight"><pre>	<span class="n">lba</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockmask</span><span class="p">);</span>
	<span class="n">maxlba</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">maxlba</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>blockbuffer is used for reading in the old data, overwriting
with the new data, and performing ECC calculations</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* TODO: instead of doing kmalloc/kfree for each write,</span>
<span class="cm">	   add a bufferpointer to the info structure */</span>

	<span class="n">pagelen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CONTROL_SHIFT</span><span class="p">);</span>
	<span class="n">blocklen</span> <span class="o">=</span> <span class="p">(</span><span class="n">pagelen</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">);</span>
	<span class="n">blockbuffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">blocklen</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blockbuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09_write_data: Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Since we don't write the user data directly to the device,
we have to create a bounce buffer and move the data a piece
at a time between the bounce buffer and the actual transfer buffer.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">)</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09_write_data: Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">blockbuffer</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sectors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Write as many sectors as possible in this block</p></td><td class="code"><div class="highlight"><pre>		<span class="n">pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">);</span>

		<span class="cm">/* Not overflowing capacity? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="n">maxlba</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Error: Requested lba %u exceeds &quot;</span>
				  <span class="s">&quot;maximum %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lba</span><span class="p">,</span> <span class="n">maxlba</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>Get the data from the transfer buffer</p></td><td class="code"><div class="highlight"><pre>		<span class="n">usb_stor_access_xfer_buf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">FROM_XFER_BUF</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_write_lba</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">lba</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span>
				<span class="n">buffer</span><span class="p">,</span> <span class="n">blockbuffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lba</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sectors</span> <span class="o">-=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">blockbuffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocks</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Read control address %lu, blocks %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">address</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sddr09_read21</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span>
			     <span class="n">CONTROL_SHIFT</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read Device ID Command: 12 bytes.</span>
<span class="cm"> * byte 0: opcode: ED</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 2 bytes: Manufacturer ID and Device ID.</span>
<span class="cm"> * On more recent cards 3 bytes: the third byte is an option code A5</span>
<span class="cm"> * signifying that the secret command to read an 128-bit ID is available.</span>
<span class="cm"> * On still more recent cards 4 bytes: the fourth byte C0 means that</span>
<span class="cm"> * a second read ID cmd is available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read_deviceID</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">deviceID</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xED</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LUNBITS</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_scsi_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_buf</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
			<span class="n">content</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">deviceID</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_GOOD</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_get_wp</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_read_status</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_get_wp: read_status fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_get_wp: status 0x%02X&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SDDR09_WP</span><span class="p">;</span>	<span class="cm">/* write protected */</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot; WP&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot; Ready&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LUNBITS</span><span class="p">)</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot; Suspended&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot; Error&quot;</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Reset Command: 12 bytes.</span>
<span class="c"> * byte 0: opcode: EB</span>
<span class="c"> */</span>
<span class="c">static int</span>
<span class="c">sddr09_reset(struct us_data *us) {</span>

<span class="c">	unsigned char *command = us-&gt;iobuf;</span>

<span class="c">	memset(command, 0, 12);</span>
<span class="c">	command[0] = 0xEB;</span>
<span class="c">	command[1] = LUNBITS;</span>

<span class="c">	return sddr09_send_scsi_command(us, command, 12);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="o">*</span>
<span class="nf">sddr09_get_cardinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="o">*</span><span class="n">cardinfo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">deviceID</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">blurbtxt</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Reading capacity...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_read_deviceID</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">deviceID</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Result of read_deviceID is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09: could not read card info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">blurbtxt</span><span class="p">,</span> <span class="s">&quot;sddr09: Found Flash card, ID = %02X %02X %02X %02X&quot;</span><span class="p">,</span>
		<span class="n">deviceID</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deviceID</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">deviceID</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">deviceID</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="cm">/* Byte 0 is the manufacturer */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">blurbtxt</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">blurbtxt</span><span class="p">),</span>
		<span class="s">&quot;: Manuf. %s&quot;</span><span class="p">,</span>
		<span class="n">nand_flash_manufacturer</span><span class="p">(</span><span class="n">deviceID</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

	<span class="cm">/* Byte 1 is the device type */</span>
	<span class="n">cardinfo</span> <span class="o">=</span> <span class="n">nand_find_id</span><span class="p">(</span><span class="n">deviceID</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cardinfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* MB or MiB? It is neither. A 16 MB card has</span>
<span class="cm">		   17301504 raw bytes, of which 16384000 are</span>
<span class="cm">		   usable for user data. */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">blurbtxt</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">blurbtxt</span><span class="p">),</span>
			<span class="s">&quot;, %d MB&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">cardinfo</span><span class="o">-&gt;</span><span class="n">chipshift</span> <span class="o">-</span> <span class="mi">20</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">blurbtxt</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">blurbtxt</span><span class="p">),</span>
			<span class="s">&quot;, type unrecognized&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Byte 2 is code to signal availability of 128-bit ID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">deviceID</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xa5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">blurbtxt</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">blurbtxt</span><span class="p">),</span>
			<span class="s">&quot;, 128-bit ID&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Byte 3 announces the availability of another read ID command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">deviceID</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">blurbtxt</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">blurbtxt</span><span class="p">),</span>
			<span class="s">&quot;, extra cmd&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SDDR09_WP</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">blurbtxt</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">blurbtxt</span><span class="p">),</span>
			<span class="s">&quot;, WP&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">blurbtxt</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cardinfo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_read_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numblocks</span><span class="p">,</span> <span class="n">alloc_len</span><span class="p">,</span> <span class="n">alloc_blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer_end</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lba</span><span class="p">,</span> <span class="n">lbact</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>size of a block is 1 &lt;&lt; (blockshift + pageshift) bytes
divide into the total capacity to get the number of blocks</p></td><td class="code"><div class="highlight"><pre>	<span class="n">numblocks</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>read 64 bytes for every block (actually 1 &lt;&lt; CONTROL<em>SHIFT)
but only use a 64 KB buffer
buffer size used must be a multiple of (1 &lt;&lt; CONTROL</em>SHIFT)</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define SDDR09_READ_MAP_BUFSZ 65536</span>

	<span class="n">alloc_blocks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">numblocks</span><span class="p">,</span> <span class="n">SDDR09_READ_MAP_BUFSZ</span> <span class="o">&gt;&gt;</span> <span class="n">CONTROL_SHIFT</span><span class="p">);</span>
	<span class="n">alloc_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">alloc_blocks</span> <span class="o">&lt;&lt;</span> <span class="n">CONTROL_SHIFT</span><span class="p">);</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">alloc_len</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09_read_map: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buffer_end</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">alloc_len</span><span class="p">;</span>

<span class="cp">#undef SDDR09_READ_MAP_BUFSZ</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">numblocks</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">numblocks</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09_read_map: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numblocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNDEF</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Define lba-pba translation table</span>
<span class="cm">	 */</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">buffer_end</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numblocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CONTROL_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;=</span> <span class="n">buffer_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>

			<span class="n">address</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_read_control</span><span class="p">(</span>
				<span class="n">us</span><span class="p">,</span> <span class="n">address</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span>
				<span class="n">min</span><span class="p">(</span><span class="n">alloc_blocks</span><span class="p">,</span> <span class="n">numblocks</span> <span class="o">-</span> <span class="n">i</span><span class="p">),</span>
				<span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNUSABLE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* special PBAs have control field 0^16 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nonz</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNUSABLE</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sddr09: PBA %d has no logical mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="p">);</span>
		<span class="k">continue</span><span class="p">;</span>

	<span class="nl">nonz:</span>
		<span class="cm">/* unwritten PBAs have control field FF^16 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nonff</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>

	<span class="nl">nonff:</span>
		<span class="cm">/* normal PBAs start with six FFs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;sddr09: PBA %d has no logical mapping: &quot;</span>
			       <span class="s">&quot;reserved area = %02X%02X%02X%02X &quot;</span>
			       <span class="s">&quot;data status %02X block status %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			       <span class="n">ptr</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNUSABLE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ptr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;sddr09: PBA %d has invalid address field &quot;</span>
			       <span class="s">&quot;%02X%02X/%02X%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNUSABLE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* check even parity */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parity</span><span class="p">[</span><span class="n">ptr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;sddr09: Bad parity in LBA for block %d&quot;</span>
			       <span class="s">&quot; (%02X %02X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNUSABLE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lba</span> <span class="o">=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
		<span class="n">lba</span> <span class="o">=</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&amp;</span> <span class="mh">0x07FF</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Every 1024 physical blocks (&quot;zone&quot;), the LBA numbers</span>
<span class="cm">		 * go back to zero, but are within a higher block of LBA&#39;s.</span>
<span class="cm">		 * Also, there is a maximum of 1000 LBA&#39;s per zone.</span>
<span class="cm">		 * In other words, in PBA 1024-2047 you will find LBA 0-999</span>
<span class="cm">		 * which are really LBA 1000-1999. This allows for 24 bad</span>
<span class="cm">		 * or special physical blocks per zone.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lba</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;sddr09: Bad low LBA %d for block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">lba</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">possibly_erase</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lba</span> <span class="o">+=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mh">0x400</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">[</span><span class="n">lba</span><span class="p">]</span> <span class="o">!=</span> <span class="n">UNDEF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;sddr09: LBA %d seen for PBA %d and %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">lba</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">[</span><span class="n">lba</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">possibly_erase</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lba</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">[</span><span class="n">lba</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>

	<span class="nl">possibly_erase:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">erase_bad_lba_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>

			<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">));</span>
			<span class="n">sddr09_erase</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">address</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNDEF</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNUSABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Approximate capacity. This is not entirely correct yet,</span>
<span class="cm">	 * since a zone with less than 1000 usable pages leads to</span>
<span class="cm">	 * missing LBAs. Especially if it is the last zone, some</span>
<span class="cm">	 * LBAs can be past capacity.</span>
<span class="cm">	 */</span>
	<span class="n">lbact</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numblocks</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">numblocks</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">UNUSABLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ct</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPARE</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">ct</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">lbact</span> <span class="o">+=</span> <span class="n">ct</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lbact</span> <span class="o">=</span> <span class="n">lbact</span><span class="p">;</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Found %d LBA&#39;s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lbact</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sddr09_card_info_destructor</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">extra</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="p">)</span><span class="n">extra</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lba_to_pba</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pba_to_lba</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sddr09_common_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* set the configuration -- STALL is an acceptable response here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;active config #%d != 1 ??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span>
				<span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_reset_configuration</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Result of usb_reset_configuration is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- stall on control interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* it&#39;s not a stall, but another error -- time to bail */</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- Unknown error.  Rejecting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">extra_destructor</span> <span class="o">=</span> <span class="n">sddr09_card_info_destructor</span><span class="p">;</span>

	<span class="n">nand_init_ecc</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This is needed at a very early stage. If this is not listed in the</span>
<span class="cm"> * unusual devices list but called from here then LUN 0 of the combo reader</span>
<span class="cm"> * is not recognized. But I do not know what precisely these calls do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">usb_stor_sddr09_dpcm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_common_init</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_init: send_command fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;SDDR09init: %02X %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>get 07 02</p></td><td class="code"><div class="highlight"><pre>	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="n">USB_DIR_IN</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_init: 2nd send_command fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;SDDR09init: %02X %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>get 07 00</p></td><td class="code"><div class="highlight"><pre>	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_request_sense</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">18</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %02X&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>get 70 00 00 00 00 00 00 * 00 00 00 00 00 00
70: current command
sense key 0, sense code 0, extd sense code 0
additional transfer length * = sizeof(data) - 7
Or: 70 00 06 00 00 00 00 0b 00 00 00 00 28 00 00 00 00 00
sense key 06, sense code 28: unit attention,
not ready to ready transition</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>test unit ready</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* not result */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transport for the Microtech DPCM-USB</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dpcm_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;dpcm_transport: LUN=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:

		<span class="cm">/*</span>
<span class="cm">		 * LUN 0 corresponds to the CompactFlash card reader.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_stor_CB_transport</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="n">us</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>:

		<span class="cm">/*</span>
<span class="cm">		 * LUN 1 corresponds to the SmartMedia card reader.</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set the LUN to 0 (just in case).</span>
<span class="cm">		 */</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sddr09_transport</span><span class="p">(</span><span class="n">srb</span><span class="p">,</span> <span class="n">us</span><span class="p">);</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;dpcm_transport: Invalid LUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Transport for the Sandisk SDDR-09</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sddr09_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sensekey</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sensecode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">havefakesense</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capacity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">inquiry_response</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>
	<span class="p">};</span>

	<span class="cm">/* note: no block descriptor support */</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mode_page_01</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
		<span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x0A</span><span class="p">,</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>
	<span class="p">};</span>

	<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sddr09_card_info</span> <span class="o">*</span><span class="p">)</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span> <span class="o">&amp;&amp;</span> <span class="n">havefakesense</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* for a faked command, we have to follow with a faked sense */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensekey</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensecode</span><span class="p">;</span>
		<span class="n">usb_stor_set_xfer_buf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>
		<span class="n">sensekey</span> <span class="o">=</span> <span class="n">sensecode</span> <span class="o">=</span> <span class="n">havefakesense</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">havefakesense</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Dummy up a response for INQUIRY since SDDR09 doesn&#39;t</span>
<span class="cm">	   respond to INQUIRY commands */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">inquiry_response</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">fill_inquiry_response</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_CAPACITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="o">*</span><span class="n">cardinfo</span><span class="p">;</span>

		<span class="n">sddr09_get_wp</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>	<span class="cm">/* read WP bit */</span>

		<span class="n">cardinfo</span> <span class="o">=</span> <span class="n">sddr09_get_cardinfo</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cardinfo</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* probably no media */</span>
		<span class="nl">init_error:</span>
			<span class="n">sensekey</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>	<span class="cm">/* not ready */</span>
			<span class="n">sensecode</span> <span class="o">=</span> <span class="mh">0x3a</span><span class="p">;</span>	<span class="cm">/* medium not present */</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cardinfo</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span> <span class="o">=</span> <span class="n">cardinfo</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pageshift</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span> <span class="o">=</span> <span class="n">cardinfo</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">blockmask</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>map initialization, must follow get_cardinfo()</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">sddr09_read_map</span><span class="p">(</span><span class="n">us</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* probably out of memory */</span>
			<span class="k">goto</span> <span class="n">init_error</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>Report capacity</p></td><td class="code"><div class="highlight"><pre>		<span class="n">capacity</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lbact</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">blockshift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">capacity</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Report page size</p></td><td class="code"><div class="highlight"><pre>		<span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">);</span>
		<span class="n">usb_stor_set_xfer_buf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MODE_SENSE_10</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">modepage</span> <span class="o">=</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">);</span>

		<span class="cm">/* They ask for the Read/Write error recovery page,</span>
<span class="cm">		   or for all pages. */</span>
		<span class="cm">/* %% We should check DBD %% */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">modepage</span> <span class="o">==</span> <span class="mh">0x01</span> <span class="o">||</span> <span class="n">modepage</span> <span class="o">==</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;SDDR09: Dummy up request for &quot;</span>
				  <span class="s">&quot;mode page 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">modepage</span><span class="p">);</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">mode_page_01</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mode_page_01</span><span class="p">));</span>
			<span class="p">((</span><span class="n">__be16</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mode_page_01</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SDDR09_WP</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">usb_stor_set_xfer_buf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mode_page_01</span><span class="p">),</span> <span class="n">srb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sensekey</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">;</span>	<span class="cm">/* illegal request */</span>
		<span class="n">sensecode</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">;</span>	<span class="cm">/* invalid field in CDB */</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ALLOW_MEDIUM_REMOVAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

	<span class="n">havefakesense</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">page</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">|=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;READ_10: read page %d pagect %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_read_data</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span> <span class="o">:</span>
				<span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">page</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">|=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;WRITE_10: write page %d pagect %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_write_data</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span> <span class="o">:</span>
				<span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* catch-all for all other commands, except</span>
<span class="cm">	 * pass TEST_UNIT_READY and REQUEST_SENSE through</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">TEST_UNIT_READY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sensekey</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">;</span>	<span class="cm">/* illegal request */</span>
		<span class="n">sensecode</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>	<span class="cm">/* invalid command */</span>
		<span class="n">havefakesense</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">;</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="o">++</span><span class="p">)</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LUNBITS</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="s">&quot;%02X &quot;</span><span class="p">,</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;SDDR09: Send control for command %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sddr09_send_scsi_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;sddr09_transport: sddr09_send_scsi_command &quot;</span>
			  <span class="s">&quot;returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">||</span>
	    <span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span> <span class="o">=</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span> <span class="o">:</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">;</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;SDDR09: %s %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="o">?</span>
			  <span class="s">&quot;sending&quot;</span> <span class="o">:</span> <span class="s">&quot;receiving&quot;</span><span class="p">,</span>
			  <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">));</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_srb</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>

		<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_GOOD</span> <span class="o">?</span>
			<span class="n">USB_STOR_TRANSPORT_GOOD</span> <span class="o">:</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">);</span>
	<span class="p">}</span> 

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialization routine for the sddr09 subdriver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">usb_stor_sddr09_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">sddr09_common_init</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sddr09_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_probe1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span>
			<span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">sddr09_usb_ids</span><span class="p">)</span> <span class="o">+</span> <span class="n">sddr09_unusual_dev_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_DPCM_USB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Control/Bulk-EUSB/SDDR09&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">dpcm_transport</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span> <span class="o">=</span> <span class="n">usb_stor_CB_reset</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;EUSB/SDDR09&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">sddr09_transport</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span> <span class="o">=</span> <span class="n">usb_stor_CB_reset</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_probe2</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">sddr09_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;ums-sddr09&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">sddr09_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">usb_stor_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">usb_stor_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">usb_stor_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_resume</span> <span class="o">=</span>	<span class="n">usb_stor_reset_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span>	<span class="n">usb_stor_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span>	<span class="n">usb_stor_post_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">sddr09_usb_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">soft_unbind</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">no_dynamic_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">sddr09_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
