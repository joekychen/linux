<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › storage › shuttle_usbat.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>shuttle_usbat.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Driver for SCM Microsystems (a.k.a. Shuttle) USB-ATAPI cable</span>
<span class="cm"> *</span>
<span class="cm"> * Current development and maintenance by:</span>
<span class="cm"> *   (c) 2000, 2001 Robert Baruch (autophile@starband.net)</span>
<span class="cm"> *   (c) 2004, 2005 Daniel Drake &lt;dsd@gentoo.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Developed with the assistance of:</span>
<span class="cm"> *   (c) 2002 Alan Stern &lt;stern@rowland.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Flash support based on earlier work by:</span>
<span class="cm"> *   (c) 2002 Thomas Kreiling &lt;usbdev@sm04.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Many originally ATAPI devices were slightly modified to meet the USB</span>
<span class="cm"> * market by using some kind of translation from ATAPI to USB on the host,</span>
<span class="cm"> * and the peripheral would translate from USB back to ATAPI.</span>
<span class="cm"> *</span>
<span class="cm"> * SCM Microsystems (www.scmmicro.com) makes a device, sold to OEM&#39;s only, </span>
<span class="cm"> * which does the USB-to-ATAPI conversion.  By obtaining the data sheet on</span>
<span class="cm"> * their device under nondisclosure agreement, I have been able to write</span>
<span class="cm"> * this driver for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * The chip used in the device can also be used for EPP and ISA translation</span>
<span class="cm"> * as well. This driver is only guaranteed to work with the ATAPI</span>
<span class="cm"> * translation.</span>
<span class="cm"> *</span>
<span class="cm"> * See the Kconfig help text for a list of devices known to be supported by</span>
<span class="cm"> * this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>
<span class="cp">#include &quot;transport.h&quot;</span>
<span class="cp">#include &quot;protocol.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for SCM Microsystems (a.k.a. Shuttle) USB-ATAPI cable&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Daniel Drake &lt;dsd@gentoo.org&gt;, Robert Baruch &lt;autophile@starband.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* Supported device types */</span>
<span class="cp">#define USBAT_DEV_HP8200	0x01</span>
<span class="cp">#define USBAT_DEV_FLASH		0x02</span>

<span class="cp">#define USBAT_EPP_PORT		0x10</span>
<span class="cp">#define USBAT_EPP_REGISTER	0x30</span>
<span class="cp">#define USBAT_ATA		0x40</span>
<span class="cp">#define USBAT_ISA		0x50</span>

<span class="cm">/* Commands (need to be logically OR&#39;d with an access type */</span>
<span class="cp">#define USBAT_CMD_READ_REG		0x00</span>
<span class="cp">#define USBAT_CMD_WRITE_REG		0x01</span>
<span class="cp">#define USBAT_CMD_READ_BLOCK	0x02</span>
<span class="cp">#define USBAT_CMD_WRITE_BLOCK	0x03</span>
<span class="cp">#define USBAT_CMD_COND_READ_BLOCK	0x04</span>
<span class="cp">#define USBAT_CMD_COND_WRITE_BLOCK	0x05</span>
<span class="cp">#define USBAT_CMD_WRITE_REGS	0x07</span>

<span class="cm">/* Commands (these don&#39;t need an access type) */</span>
<span class="cp">#define USBAT_CMD_EXEC_CMD	0x80</span>
<span class="cp">#define USBAT_CMD_SET_FEAT	0x81</span>
<span class="cp">#define USBAT_CMD_UIO		0x82</span>

<span class="cm">/* Methods of accessing UIO register */</span>
<span class="cp">#define USBAT_UIO_READ	1</span>
<span class="cp">#define USBAT_UIO_WRITE	0</span>

<span class="cm">/* Qualifier bits */</span>
<span class="cp">#define USBAT_QUAL_FCQ	0x20	</span><span class="cm">/* full compare */</span><span class="cp"></span>
<span class="cp">#define USBAT_QUAL_ALQ	0x10	</span><span class="cm">/* auto load subcount */</span><span class="cp"></span>

<span class="cm">/* USBAT Flash Media status types */</span>
<span class="cp">#define USBAT_FLASH_MEDIA_NONE	0</span>
<span class="cp">#define USBAT_FLASH_MEDIA_CF	1</span>

<span class="cm">/* USBAT Flash Media change types */</span>
<span class="cp">#define USBAT_FLASH_MEDIA_SAME	0</span>
<span class="cp">#define USBAT_FLASH_MEDIA_CHANGED	1</span>

<span class="cm">/* USBAT ATA registers */</span>
<span class="cp">#define USBAT_ATA_DATA      0x10  </span><span class="cm">/* read/write data (R/W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_FEATURES  0x11  </span><span class="cm">/* set features (W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_ERROR     0x11  </span><span class="cm">/* error (R) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_SECCNT    0x12  </span><span class="cm">/* sector count (R/W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_SECNUM    0x13  </span><span class="cm">/* sector number (R/W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_LBA_ME    0x14  </span><span class="cm">/* cylinder low (R/W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_LBA_HI    0x15  </span><span class="cm">/* cylinder high (R/W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_DEVICE    0x16  </span><span class="cm">/* head/device selection (R/W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_STATUS    0x17  </span><span class="cm">/* device status (R) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_CMD       0x17  </span><span class="cm">/* device command (W) */</span><span class="cp"></span>
<span class="cp">#define USBAT_ATA_ALTSTATUS 0x0E  </span><span class="cm">/* status (no clear IRQ) (R) */</span><span class="cp"></span>

<span class="cm">/* USBAT User I/O Data registers */</span>
<span class="cp">#define USBAT_UIO_EPAD		0x80 </span><span class="cm">/* Enable Peripheral Control Signals */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_CDT		0x40 </span><span class="cm">/* Card Detect (Read Only) */</span><span class="cp"></span>
				     <span class="cm">/* CDT = ACKD &amp; !UI1 &amp; !UI0 */</span>
<span class="cp">#define USBAT_UIO_1		0x20 </span><span class="cm">/* I/O 1 */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_0		0x10 </span><span class="cm">/* I/O 0 */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_EPP_ATA	0x08 </span><span class="cm">/* 1=EPP mode, 0=ATA mode */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_UI1		0x04 </span><span class="cm">/* Input 1 */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_UI0		0x02 </span><span class="cm">/* Input 0 */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_INTR_ACK	0x01 </span><span class="cm">/* Interrupt (ATA/ISA)/Acknowledge (EPP) */</span><span class="cp"></span>

<span class="cm">/* USBAT User I/O Enable registers */</span>
<span class="cp">#define USBAT_UIO_DRVRST	0x80 </span><span class="cm">/* Reset Peripheral */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_ACKD		0x40 </span><span class="cm">/* Enable Card Detect */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_OE1		0x20 </span><span class="cm">/* I/O 1 set=output/clr=input */</span><span class="cp"></span>
				     <span class="cm">/* If ACKD=1, set OE1 to 1 also. */</span>
<span class="cp">#define USBAT_UIO_OE0		0x10 </span><span class="cm">/* I/O 0 set=output/clr=input */</span><span class="cp"></span>
<span class="cp">#define USBAT_UIO_ADPRST	0x01 </span><span class="cm">/* Reset SCM chip */</span><span class="cp"></span>

<span class="cm">/* USBAT Features */</span>
<span class="cp">#define USBAT_FEAT_ETEN	0x80	</span><span class="cm">/* External trigger enable */</span><span class="cp"></span>
<span class="cp">#define USBAT_FEAT_U1	0x08</span>
<span class="cp">#define USBAT_FEAT_U0	0x04</span>
<span class="cp">#define USBAT_FEAT_ET1	0x02</span>
<span class="cp">#define USBAT_FEAT_ET2	0x01</span>

<span class="k">struct</span> <span class="n">usbat_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">devicetype</span><span class="p">;</span>

	<span class="cm">/* Used for Flash readers only */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sectors</span><span class="p">;</span>     <span class="cm">/* total sector count */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ssize</span><span class="p">;</span>       <span class="cm">/* sector size in bytes */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sense_key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sense_asc</span><span class="p">;</span>   <span class="cm">/* additional sense code */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sense_ascq</span><span class="p">;</span>  <span class="cm">/* additional sense code qualifier */</span>
<span class="p">};</span>

<span class="cp">#define short_pack(LSB,MSB) ( ((u16)(LSB)) | ( ((u16)(MSB))&lt;&lt;8 ) )</span>
<span class="cp">#define LSB_of(s) ((s)&amp;0xFF)</span>
<span class="cp">#define MSB_of(s) ((s)&gt;&gt;8)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">transferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">usbat_flash_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span> <span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usbat_hp8200e_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">init_usbat_cd</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">init_usbat_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * The table of devices</span>
<span class="cm"> */</span>
<span class="cp">#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \</span>
<span class="cp">		    vendorName, productName, useProtocol, useTransport, \</span>
<span class="cp">		    initFunction, flags) \</span>
<span class="cp">{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \</span>
<span class="cp">  .driver_info = (flags)|(USB_US_TYPE_STOR&lt;&lt;24) }</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">usbat_usb_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#	include &quot;unusual_usbat.h&quot;</span>
	<span class="p">{</span> <span class="p">}</span>		<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">usbat_usb_ids</span><span class="p">);</span>

<span class="cp">#undef UNUSUAL_DEV</span>

<span class="cm">/*</span>
<span class="cm"> * The flags table</span>
<span class="cm"> */</span>
<span class="cp">#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \</span>
<span class="cp">		    vendor_name, product_name, use_protocol, use_transport, \</span>
<span class="cp">		    init_function, Flags) \</span>
<span class="cp">{ \</span>
<span class="cp">	.vendorName = vendor_name,	\</span>
<span class="cp">	.productName = product_name,	\</span>
<span class="cp">	.useProtocol = use_protocol,	\</span>
<span class="cp">	.useTransport = use_transport,	\</span>
<span class="cp">	.initFunction = init_function,	\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">us_unusual_dev</span> <span class="n">usbat_unusual_dev_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#	include &quot;unusual_usbat.h&quot;</span>
	<span class="p">{</span> <span class="p">}</span>		<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>

<span class="cp">#undef UNUSUAL_DEV</span>

<span class="cm">/*</span>
<span class="cm"> * Convenience function to produce an ATA read/write sectors command</span>
<span class="cm"> * Use cmd=0x20 for read, cmd=0x30 for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usbat_pack_ata_sector_cmd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">thistime</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">thistime</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xE0</span> <span class="o">|</span> <span class="p">((</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convenience function to get the device type (flash or hp8200)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_get_device_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">usbat_info</span><span class="o">*</span><span class="p">)</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">devicetype</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read a register from the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">access</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span><span class="p">,</span>
		<span class="n">access</span> <span class="o">|</span> <span class="n">USBAT_CMD_READ_REG</span><span class="p">,</span>
		<span class="mh">0xC0</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">reg</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">content</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write to a register on the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">access</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">content</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
		<span class="n">access</span> <span class="o">|</span> <span class="n">USBAT_CMD_WRITE_REG</span><span class="p">,</span>
		<span class="mh">0x40</span><span class="p">,</span>
		<span class="n">short_pack</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">content</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convenience function to perform a bulk read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			   <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_bulk_read: len = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">usb_stor_bulk_transfer_sg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convenience function to perform a bulk write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_bulk_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_bulk_write:  len = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">usb_stor_bulk_transfer_sg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some USBAT-specific commands can only be executed over a command transport</span>
<span class="cm"> * This transport allows one (len=8) or two (len=16) vendor-specific commands</span>
<span class="cm"> * to be executed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_execute_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
								 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
								 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
								  <span class="n">USBAT_CMD_EXEC_CMD</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
								  <span class="n">commands</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the status register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_STATUS</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_get_status: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check the device status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_get_status</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

	<span class="cm">/* error/check condition (0x51 is ok) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">reply</span> <span class="o">&amp;</span> <span class="mh">0x01</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">reply</span> <span class="o">!=</span> <span class="mh">0x51</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

	<span class="cm">/* device fault */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">reply</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stores critical information in internal registers in preparation for the execution</span>
<span class="cm"> * of a conditional usbat_read_blocks or usbat_write_blocks call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_set_shuttle_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">external_trigger</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">epp_control</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask_byte</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">test_pattern</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">subcountH</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">subcountL</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_CMD_SET_FEAT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The only bit relevant to ATA access is bit 6</span>
<span class="cm">	 * which defines 8 bit data access (set) or 16 bit (unset)</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">epp_control</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If FCQ is set in the qualifier (defined in R/W cmd), then bits U0, U1,</span>
<span class="cm">	 * ET1 and ET2 define an external event to be checked for on event of a</span>
<span class="cm">	 * _read_blocks or _write_blocks operation. The read/write will not take</span>
<span class="cm">	 * place unless the defined trigger signal is active.</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">external_trigger</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The resultant byte of the mask operation (see mask_byte) is compared for</span>
<span class="cm">	 * equivalence with this test pattern. If equal, the read/write will take</span>
<span class="cm">	 * place.</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_pattern</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This value is logically ANDed with the status register field specified</span>
<span class="cm">	 * in the read/write command.</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_byte</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If ALQ is set in the qualifier, this field contains the address of the</span>
<span class="cm">	 * registers where the byte count should be read for transferring the data.</span>
<span class="cm">	 * If ALQ is not set, then this field contains the number of bytes to be</span>
<span class="cm">	 * transferred.</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">subcountL</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">subcountH</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">usbat_execute_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Block, waiting for an ATA device to become not busy or to report</span>
<span class="cm"> * an error condition.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_wait_not_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="cm">/* Synchronizing cache on a CDR could take a heck of a long time,</span>
<span class="cm">	 * but probably not more than 10 minutes or so. On the other hand,</span>
<span class="cm">	 * doing a full blank on a CDRW at speed 1 will take about 75</span>
<span class="cm">	 * minutes!</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1200</span><span class="o">+</span><span class="n">minutes</span><span class="o">*</span><span class="mi">60</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

 		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_get_status</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">!=</span><span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* check condition */</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="cm">/* device fault */</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span><span class="o">==</span><span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* not busy */</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Waited not busy for %d steps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">500</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="cm">/* 5 seconds */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">700</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span> <span class="cm">/* 10 seconds */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1200</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="cm">/* 50 seconds */</span>
		<span class="k">else</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="cm">/* X minutes */</span>
	<span class="p">}</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Waited not busy for %d minutes, timing out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">minutes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read block data from the data register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_read_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">len</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xC0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA</span> <span class="o">|</span> <span class="n">USBAT_CMD_READ_BLOCK</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_DATA</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_execute_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_bulk_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_GOOD</span> <span class="o">?</span>
			<span class="n">USB_STOR_TRANSPORT_GOOD</span> <span class="o">:</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write block data via the data register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_write_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">access</span><span class="p">,</span>
			     <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">len</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">access</span> <span class="o">|</span> <span class="n">USBAT_CMD_WRITE_BLOCK</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_DATA</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_execute_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_bulk_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">usbat_wait_not_busy</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">minutes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process read and write requests</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_hp8200e_rw_block_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">access</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">registers</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data_out</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num_registers</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data_reg</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status_reg</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">timeout</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">qualifier</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">len</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">use_sg</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">minutes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span> <span class="o">:</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmdlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_registers</span> <span class="o">&gt;</span> <span class="n">US_IOBUF_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * The first time we send the full command, which consists</span>
<span class="cm">		 * of downloading the SCSI command followed by downloading</span>
<span class="cm">		 * the data via a write-and-test.  Any other time we only</span>
<span class="cm">		 * send the command to download the data -- the SCSI command</span>
<span class="cm">		 * is still &#39;active&#39; in some sense in the device.</span>
<span class="cm">		 * </span>
<span class="cm">		 * We&#39;re only going to try sending the data 10 times. After</span>
<span class="cm">		 * that, we just return a failure.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmdlen</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Write to multiple registers</span>
<span class="cm">			 * Not really sure the 0x07, 0x17, 0xfc, 0xe7 is</span>
<span class="cm">			 * necessary here, but that&#39;s what came out of the</span>
<span class="cm">			 * trace every single time.</span>
<span class="cm">			 */</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">access</span> <span class="o">|</span> <span class="n">USBAT_CMD_WRITE_REGS</span><span class="p">;</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">;</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x17</span><span class="p">;</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFC</span><span class="p">;</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xE7</span><span class="p">;</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">num_registers</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
			<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">num_registers</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cmdlen</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

		<span class="cm">/* Conditionally read or write blocks */</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction</span><span class="o">==</span><span class="n">DMA_TO_DEVICE</span> <span class="o">?</span> <span class="mh">0x40</span> <span class="o">:</span> <span class="mh">0xC0</span><span class="p">);</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">access</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">direction</span><span class="o">==</span><span class="n">DMA_TO_DEVICE</span> <span class="o">?</span>
				 <span class="n">USBAT_CMD_COND_WRITE_BLOCK</span> <span class="o">:</span> <span class="n">USBAT_CMD_COND_READ_BLOCK</span><span class="p">);</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_reg</span><span class="p">;</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">status_reg</span><span class="p">;</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">qualifier</span><span class="p">;</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
		<span class="n">command</span><span class="p">[</span><span class="n">cmdlen</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_execute_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">cmdlen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">num_registers</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">registers</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_out</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_bulk_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_registers</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_bulk_transfer_sg</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
			<span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we get a stall on the bulk download, we&#39;ll retry</span>
<span class="cm">		 * the bulk download -- but not the SCSI command because</span>
<span class="cm">		 * in some sense the SCSI command is still &#39;active&#39; and</span>
<span class="cm">		 * waiting for the data. Don&#39;t ask me why this should be;</span>
<span class="cm">		 * I&#39;m only following what the Windoze driver did.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that a stall for the test-and-read/write command means</span>
<span class="cm">		 * that the test failed. In this case we&#39;re testing to make</span>
<span class="cm">		 * sure that the device is error-free</span>
<span class="cm">		 * (i.e. bit 0 -- CHK -- of status is 0). The most likely</span>
<span class="cm">		 * hypothesis is that the USBAT chip somehow knows what</span>
<span class="cm">		 * the device will accept, but doesn&#39;t give the device any</span>
<span class="cm">		 * data until all data is received. Thus, the device would</span>
<span class="cm">		 * still be waiting for the first byte of data if a stall</span>
<span class="cm">		 * occurs, even if the stall implies that some data was</span>
<span class="cm">		 * transferred.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_SHORT</span> <span class="o">||</span>
				<span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_XFER_STALLED</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;re reading and we stalled, then clear</span>
<span class="cm">			 * the bulk output pipe only the first time.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">direction</span><span class="o">==</span><span class="n">DMA_FROM_DEVICE</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">usb_stor_clear_halt</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
						<span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Read status: is the device angry, or just busy?</span>
<span class="cm">			 */</span>

 			<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> 
				<span class="n">direction</span><span class="o">==</span><span class="n">DMA_TO_DEVICE</span> <span class="o">?</span>
					<span class="n">USBAT_ATA_STATUS</span> <span class="o">:</span> <span class="n">USBAT_ATA_ALTSTATUS</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">!=</span><span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="cm">/* check condition */</span>
				<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="cm">/* device fault */</span>
				<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Redoing %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">direction</span><span class="o">==</span><span class="n">DMA_TO_DEVICE</span> <span class="o">?</span> <span class="s">&quot;write&quot;</span> <span class="o">:</span> <span class="s">&quot;read&quot;</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">usbat_wait_not_busy</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">minutes</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bummer! %s bulk data 20 times failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">direction</span><span class="o">==</span><span class="n">DMA_TO_DEVICE</span> <span class="o">?</span> <span class="s">&quot;Writing&quot;</span> <span class="o">:</span> <span class="s">&quot;Reading&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write to multiple registers:</span>
<span class="cm"> * Allows us to write specific data to any registers. The data to be written</span>
<span class="cm"> * gets packed in this sequence: reg0, data0, reg1, data1, ..., regN, dataN</span>
<span class="cm"> * which gets sent through bulk out.</span>
<span class="cm"> * Not designed for large transfers of data!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_multiple_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">registers</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data_out</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num_registers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_registers</span> <span class="o">&gt;</span> <span class="n">US_IOBUF_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Write to multiple registers, ATA access */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA</span> <span class="o">|</span> <span class="n">USBAT_CMD_WRITE_REGS</span><span class="p">;</span>

	<span class="cm">/* No relevance */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Number of bytes to be transferred (incl. addresses and data) */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">num_registers</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">num_registers</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* The setup command */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_execute_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* Create the reg/data, reg/data sequence */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num_registers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">registers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_out</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* Send the data */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_bulk_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_registers</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbat_get_device_type</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="o">==</span> <span class="n">USBAT_DEV_HP8200</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">usbat_wait_not_busy</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conditionally read blocks from device:</span>
<span class="cm"> * Allows us to read blocks from a specific data register, based upon the</span>
<span class="cm"> * condition that a status register can be successfully masked with a status</span>
<span class="cm"> * qualifier. If this condition is not initially met, the read will wait</span>
<span class="cm"> * up until a maximum amount of time has elapsed, as specified by timeout.</span>
<span class="cm"> * The read will start when the condition is met, otherwise the command aborts.</span>
<span class="cm"> *</span>
<span class="cm"> * The qualifier defined here is not the value that is masked, it defines</span>
<span class="cm"> * conditions for the write to take place. The actual masked qualifier (and</span>
<span class="cm"> * other related details) are defined beforehand with _set_shuttle_features().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_read_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			     <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xC0</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA</span> <span class="o">|</span> <span class="n">USBAT_CMD_COND_READ_BLOCK</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_DATA</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_STATUS</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFD</span><span class="p">;</span> <span class="cm">/* Timeout (ms); */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_QUAL_FCQ</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Multiple block read setup command */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_execute_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	
	<span class="cm">/* Read the blocks we just asked for */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_bulk_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conditionally write blocks to device:</span>
<span class="cm"> * Allows us to write blocks to a specific data register, based upon the</span>
<span class="cm"> * condition that a status register can be successfully masked with a status</span>
<span class="cm"> * qualifier. If this condition is not initially met, the write will wait</span>
<span class="cm"> * up until a maximum amount of time has elapsed, as specified by timeout.</span>
<span class="cm"> * The read will start when the condition is met, otherwise the command aborts.</span>
<span class="cm"> *</span>
<span class="cm"> * The qualifier defined here is not the value that is masked, it defines</span>
<span class="cm"> * conditions for the write to take place. The actual masked qualifier (and</span>
<span class="cm"> * other related details) are defined beforehand with _set_shuttle_features().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_write_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			      <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">use_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA</span> <span class="o">|</span> <span class="n">USBAT_CMD_COND_WRITE_BLOCK</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_DATA</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_STATUS</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFD</span><span class="p">;</span> <span class="cm">/* Timeout (ms) */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_QUAL_FCQ</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Multiple block write setup command */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_execute_command</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	
	<span class="cm">/* Write the data */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_bulk_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the User IO register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_read_user_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span><span class="p">,</span>
		<span class="n">USBAT_CMD_UIO</span><span class="p">,</span>
		<span class="mh">0xC0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">data_flags</span><span class="p">,</span>
		<span class="n">USBAT_UIO_READ</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_read_user_io: UIO register reads %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">data_flags</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write to the User IO register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_write_user_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">enable_flags</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">usb_stor_ctrl_transfer</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
		<span class="n">USBAT_CMD_UIO</span><span class="p">,</span>
		<span class="mh">0x40</span><span class="p">,</span>
		<span class="n">short_pack</span><span class="p">(</span><span class="n">enable_flags</span><span class="p">,</span> <span class="n">data_flags</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">USBAT_UIO_WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset the device</span>
<span class="cm"> * Often needed on media change.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset peripheral, enable peripheral control signals</span>
<span class="cm">	 * (bring reset signal up)</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_write_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
							 <span class="n">USBAT_UIO_DRVRST</span> <span class="o">|</span> <span class="n">USBAT_UIO_OE1</span> <span class="o">|</span> <span class="n">USBAT_UIO_OE0</span><span class="p">,</span>
							 <span class="n">USBAT_UIO_EPAD</span> <span class="o">|</span> <span class="n">USBAT_UIO_1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
			
	<span class="cm">/*</span>
<span class="cm">	 * Enable peripheral control signals</span>
<span class="cm">	 * (bring reset signal down)</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_write_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
							 <span class="n">USBAT_UIO_OE1</span>  <span class="o">|</span> <span class="n">USBAT_UIO_OE0</span><span class="p">,</span>
							 <span class="n">USBAT_UIO_EPAD</span> <span class="o">|</span> <span class="n">USBAT_UIO_1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable card detect</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_device_enable_cdt</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Enable peripheral control signals and card detect */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_write_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
							 <span class="n">USBAT_UIO_ACKD</span> <span class="o">|</span> <span class="n">USBAT_UIO_OE1</span>  <span class="o">|</span> <span class="n">USBAT_UIO_OE0</span><span class="p">,</span>
							 <span class="n">USBAT_UIO_EPAD</span> <span class="o">|</span> <span class="n">USBAT_UIO_1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if media is present.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_flash_check_media_present</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">uio</span> <span class="o">&amp;</span> <span class="n">USBAT_UIO_UI0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_check_media_present: no media detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USBAT_FLASH_MEDIA_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">USBAT_FLASH_MEDIA_CF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if media has changed since last operation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_flash_check_media_changed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">uio</span> <span class="o">&amp;</span> <span class="n">USBAT_UIO_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_check_media_changed: media change detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USBAT_FLASH_MEDIA_CHANGED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">USBAT_FLASH_MEDIA_SAME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for media change / no media and handle the situation appropriately</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_flash_check_media</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uio</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">uio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* Check for media existence */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_flash_check_media_present</span><span class="p">(</span><span class="n">uio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">USBAT_FLASH_MEDIA_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_asc</span> <span class="o">=</span> <span class="mh">0x3A</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_ascq</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for media change */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_flash_check_media_changed</span><span class="p">(</span><span class="n">uio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">USBAT_FLASH_MEDIA_CHANGED</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Reset and re-enable card detect */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_device_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_device_enable_cdt</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">uio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
		
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">=</span> <span class="n">UNIT_ATTENTION</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_asc</span> <span class="o">=</span> <span class="mh">0x28</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_ascq</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine whether we are controlling a flash-based reader/writer,</span>
<span class="cm"> * or a HP8200-based CD drive.</span>
<span class="cm"> * Sets transport functions as appropriate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_identify_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_device_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In attempt to distinguish between HP CDRW&#39;s and Flash readers, we now</span>
<span class="cm">	 * execute the IDENTIFY PACKET DEVICE command. On ATA devices (i.e. flash</span>
<span class="cm">	 * readers), this command should fail with error. On ATAPI devices (i.e.</span>
<span class="cm">	 * CDROM drives), it should succeed.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_CMD</span><span class="p">,</span> <span class="mh">0xA1</span><span class="p">);</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
 		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_get_status</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
 		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* Check for error bit, or if the command &#39;fell through&#39; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0xA1</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Device is HP 8200 */</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_identify_device: Detected HP8200 CDRW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">devicetype</span> <span class="o">=</span> <span class="n">USBAT_DEV_HP8200</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Device is a CompactFlash reader/writer */</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_identify_device: Detected Flash reader/writer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">devicetype</span> <span class="o">=</span> <span class="n">USBAT_DEV_FLASH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the transport function based on the device type</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_set_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">devicetype</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">devicetype</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">devicetype</span> <span class="o">=</span> <span class="n">devicetype</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">devicetype</span><span class="p">)</span>
		<span class="n">usbat_identify_device</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">devicetype</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="k">case</span>  <span class="n">USBAT_DEV_HP8200</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">usbat_hp8200e_transport</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USBAT_DEV_FLASH</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">usbat_flash_transport</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the media capacity</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_flash_get_sector_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">registers</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">USBAT_ATA_SECCNT</span><span class="p">,</span>
		<span class="n">USBAT_ATA_DEVICE</span><span class="p">,</span>
		<span class="n">USBAT_ATA_CMD</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xA0</span><span class="p">,</span> <span class="mh">0xEC</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">reply</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* ATA command : IDENTIFY DEVICE */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_multiple_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">registers</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_get_sector_count: Gah! identify_device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read device status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbat_get_status</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">)</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* Read the device identification data */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_block</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">reply</span><span class="p">[</span><span class="mi">117</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">reply</span><span class="p">[</span><span class="mi">116</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">reply</span><span class="p">[</span><span class="mi">115</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">reply</span><span class="p">[</span><span class="mi">114</span><span class="p">])</span>      <span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

 <span class="nl">leave:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read data from device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_flash_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
								 <span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
								 <span class="n">u32</span> <span class="n">sector</span><span class="p">,</span>
								 <span class="n">u32</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">registers</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">USBAT_ATA_FEATURES</span><span class="p">,</span>
		<span class="n">USBAT_ATA_SECCNT</span><span class="p">,</span>
		<span class="n">USBAT_ATA_SECNUM</span><span class="p">,</span>
		<span class="n">USBAT_ATA_LBA_ME</span><span class="p">,</span>
		<span class="n">USBAT_ATA_LBA_HI</span><span class="p">,</span>
		<span class="n">USBAT_ATA_DEVICE</span><span class="p">,</span>
		<span class="n">USBAT_ATA_STATUS</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">thistime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">totallen</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_flash_check_media</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we&#39;re working in LBA mode.  according to the ATA spec,</span>
<span class="cm">	 * we can support up to 28-bit addressing.  I don&#39;t know if Jumpshot</span>
<span class="cm">	 * supports beyond 24-bit addressing.  It&#39;s kind of hard to test</span>
<span class="cm">	 * since it requires &gt; 8GB CF card.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;</span> <span class="mh">0x0FFFFFFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">totallen</span> <span class="o">=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we don&#39;t read more than 64 KB at a time, we have to create</span>
<span class="cm">	 * a bounce buffer and move the data a piece at a time between the</span>
<span class="cm">	 * bounce buffer and the actual transfer buffer.</span>
<span class="cm">	 */</span>

	<span class="n">alloclen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">totallen</span><span class="p">,</span> <span class="mi">65536u</span><span class="p">);</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">alloclen</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * loop, never allocate or transfer more than 64k at once</span>
<span class="cm">		 * (min(128k, 255*info-&gt;ssize) is the real limit)</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">totallen</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">);</span>
		<span class="n">thistime</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
 
		<span class="cm">/* ATA command 0x20 (READ SECTORS) */</span>
		<span class="n">usbat_pack_ata_sector_cmd</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">thistime</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>

		<span class="cm">/* Write/execute ATA read command */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_multiple_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">registers</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

		<span class="cm">/* Read the data we just requested */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_read_blocks</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
  	 
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_read_data:  %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	
		<span class="cm">/* Store the data in the transfer buffer */</span>
		<span class="n">usb_stor_access_xfer_buf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_offset</span><span class="p">,</span> <span class="n">TO_XFER_BUF</span><span class="p">);</span>

		<span class="n">sector</span> <span class="o">+=</span> <span class="n">thistime</span><span class="p">;</span>
		<span class="n">totallen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">totallen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>

<span class="nl">leave:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write data to device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_flash_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
								  <span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
								  <span class="n">u32</span> <span class="n">sector</span><span class="p">,</span>
								  <span class="n">u32</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">registers</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">USBAT_ATA_FEATURES</span><span class="p">,</span>
		<span class="n">USBAT_ATA_SECCNT</span><span class="p">,</span>
		<span class="n">USBAT_ATA_SECNUM</span><span class="p">,</span>
		<span class="n">USBAT_ATA_LBA_ME</span><span class="p">,</span>
		<span class="n">USBAT_ATA_LBA_HI</span><span class="p">,</span>
		<span class="n">USBAT_ATA_DEVICE</span><span class="p">,</span>
		<span class="n">USBAT_ATA_STATUS</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">thistime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">totallen</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_flash_check_media</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we&#39;re working in LBA mode.  according to the ATA spec,</span>
<span class="cm">	 * we can support up to 28-bit addressing.  I don&#39;t know if the device</span>
<span class="cm">	 * supports beyond 24-bit addressing.  It&#39;s kind of hard to test</span>
<span class="cm">	 * since it requires &gt; 8GB media.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;</span> <span class="mh">0x0FFFFFFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">totallen</span> <span class="o">=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we don&#39;t write more than 64 KB at a time, we have to create</span>
<span class="cm">	 * a bounce buffer and move the data a piece at a time between the</span>
<span class="cm">	 * bounce buffer and the actual transfer buffer.</span>
<span class="cm">	 */</span>

	<span class="n">alloclen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">totallen</span><span class="p">,</span> <span class="mi">65536u</span><span class="p">);</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">alloclen</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * loop, never allocate or transfer more than 64k at once</span>
<span class="cm">		 * (min(128k, 255*info-&gt;ssize) is the real limit)</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">totallen</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">);</span>
		<span class="n">thistime</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="cm">/* Get the data from the transfer buffer */</span>
		<span class="n">usb_stor_access_xfer_buf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_offset</span><span class="p">,</span> <span class="n">FROM_XFER_BUF</span><span class="p">);</span>

		<span class="cm">/* ATA command 0x30 (WRITE SECTORS) */</span>
		<span class="n">usbat_pack_ata_sector_cmd</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">thistime</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">);</span>

		<span class="cm">/* Write/execute ATA write command */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_multiple_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">registers</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

		<span class="cm">/* Write the data */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_write_blocks</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

		<span class="n">sector</span> <span class="o">+=</span> <span class="n">thistime</span><span class="p">;</span>
		<span class="n">totallen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">totallen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="nl">leave:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Squeeze a potentially huge (&gt; 65535 byte) read10 command into</span>
<span class="cm"> * a little ( &lt;= 65535 byte) ATAPI pipe</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_hp8200e_handle_read10</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">registers</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;handle_read10: transfersize %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_hp8200e_rw_block_test</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> 
			<span class="n">registers</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span>
			<span class="n">USBAT_ATA_DATA</span><span class="p">,</span> <span class="n">USBAT_ATA_STATUS</span><span class="p">,</span> <span class="mh">0xFD</span><span class="p">,</span>
			<span class="p">(</span><span class="n">USBAT_QUAL_FCQ</span> <span class="o">|</span> <span class="n">USBAT_QUAL_ALQ</span><span class="p">),</span>
			<span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
			<span class="n">scsi_sglist</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span>
			<span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we&#39;re requesting more data than we can handle in</span>
<span class="cm">	 * a single read command (max is 64k-1), we will perform</span>
<span class="cm">	 * multiple reads, but each read must be in multiples of</span>
<span class="cm">	 * a sector.  Luckily the sector size is in srb-&gt;transfersize</span>
<span class="cm">	 * (see linux/drivers/scsi/sr.c).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">GPCMD_READ_CD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">9</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="p">]);</span>
		<span class="n">len</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">7</span><span class="p">];</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;handle_read10: GPCMD_READ_CD: len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span><span class="o">/</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span> <span class="cm">/* A guess */</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;handle_read10: transfersize 0, forcing %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we only read in one block at a time, we have to create</span>
<span class="cm">	 * a bounce buffer and move the data a piece at a time between the</span>
<span class="cm">	 * bounce buffer and the actual transfer buffer.</span>
<span class="cm">	 */</span>

	<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="mi">65535</span><span class="o">/</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">)</span> <span class="o">*</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">;</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Max read is %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">));</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="cm">/* bloody hell! */</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
	<span class="n">sector</span> <span class="o">=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">3</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">sector</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">sector</span> <span class="o">|=</span> <span class="n">short_pack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">5</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">4</span><span class="p">]);</span>
	<span class="n">transferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">transferred</span> <span class="o">!=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">-</span> <span class="n">transferred</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">)</span> <span class="o">-</span> <span class="n">transferred</span><span class="p">;</span>

		<span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">;</span> 	  <span class="cm">/* (cylL) = expected length (L) */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">;</span>  <span class="cm">/* (cylH) = expected length (H) */</span>

		<span class="cm">/* Fix up the SCSI command sector and num sectors */</span>

		<span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">sector</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span> <span class="cm">/* SCSI command sector */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">sector</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">sector</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">sector</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">GPCMD_READ_CD</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSB_of</span><span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">);</span> <span class="cm">/* SCSI command */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSB_of</span><span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">);</span> <span class="cm">/* num sectors */</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_hp8200e_rw_block_test</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> 
			<span class="n">registers</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span>
			<span class="n">USBAT_ATA_DATA</span><span class="p">,</span> <span class="n">USBAT_ATA_STATUS</span><span class="p">,</span> <span class="mh">0xFD</span><span class="p">,</span> 
			<span class="p">(</span><span class="n">USBAT_QUAL_FCQ</span> <span class="o">|</span> <span class="n">USBAT_QUAL_ALQ</span><span class="p">),</span>
			<span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
			<span class="n">buffer</span><span class="p">,</span>
			<span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Store the data in the transfer buffer */</span>
		<span class="n">usb_stor_access_xfer_buf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">srb</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_offset</span><span class="p">,</span> <span class="n">TO_XFER_BUF</span><span class="p">);</span>

		<span class="cm">/* Update the amount transferred and the sector number */</span>

		<span class="n">transferred</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">sector</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">;</span>

	<span class="p">}</span> <span class="cm">/* while transferred != scsi_bufflen(srb) */</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_select_and_test_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">selector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="cm">/* try device = master, then device = slave. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">selector</span> <span class="o">=</span> <span class="mh">0xA0</span><span class="p">;</span> <span class="n">selector</span> <span class="o">&lt;=</span> <span class="mh">0xB0</span><span class="p">;</span> <span class="n">selector</span> <span class="o">+=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_DEVICE</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span> <span class="o">!=</span>
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_STATUS</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_DEVICE</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_ME</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_HI</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_ME</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_HI</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_ME</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_ME</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span> 
				<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the USBAT processor and the storage device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_usbat</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devicetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">subcountH</span> <span class="o">=</span> <span class="n">USBAT_ATA_LBA_HI</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">subcountL</span> <span class="o">=</span> <span class="n">USBAT_ATA_LBA_ME</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>

	<span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbat_info</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;init_usbat: Gah! Can&#39;t allocate storage for usbat info struct!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>

	<span class="cm">/* Enable peripheral control signals */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_write_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span>
				 <span class="n">USBAT_UIO_OE1</span> <span class="o">|</span> <span class="n">USBAT_UIO_OE0</span><span class="p">,</span>
				 <span class="n">USBAT_UIO_EPAD</span> <span class="o">|</span> <span class="n">USBAT_UIO_1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_select_and_test_registers</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Enable peripheral control signals and card detect */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_device_enable_cdt</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 7</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">1400</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_read_user_io</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 8</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_select_and_test_registers</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 9</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* At this point, we need to detect which device we are using */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usbat_set_transport</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">devicetype</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 10</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usbat_get_device_type</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="o">==</span> <span class="n">USBAT_DEV_FLASH</span><span class="p">)</span> <span class="p">{</span> 
		<span class="n">subcountH</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>
		<span class="n">subcountL</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_set_shuttle_features</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="p">(</span><span class="n">USBAT_FEAT_ETEN</span> <span class="o">|</span> <span class="n">USBAT_FEAT_ET2</span> <span class="o">|</span> <span class="n">USBAT_FEAT_ET1</span><span class="p">),</span>
									<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="n">subcountH</span><span class="p">,</span> <span class="n">subcountL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;INIT 11</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transport for the HP 8200e</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_hp8200e_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">registers</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">srb</span><span class="p">);</span>

	<span class="cm">/* Send A0 (ATA PACKET COMMAND).</span>
<span class="cm">	   Note: I guess we&#39;re never going to get any of the ATA</span>
<span class="cm">	   commands... just ATA Packet Commands.</span>
<span class="cm"> 	 */</span>

	<span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_FEATURES</span><span class="p">;</span>
	<span class="n">registers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_SECCNT</span><span class="p">;</span>
	<span class="n">registers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_SECNUM</span><span class="p">;</span>
	<span class="n">registers</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_LBA_ME</span><span class="p">;</span>
	<span class="n">registers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_LBA_HI</span><span class="p">;</span>
	<span class="n">registers</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_DEVICE</span><span class="p">;</span>
	<span class="n">registers</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">USBAT_ATA_CMD</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">;</span> 		<span class="cm">/* (cylL) = expected length (L) */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFF</span><span class="p">;</span> 	<span class="cm">/* (cylH) = expected length (H) */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xB0</span><span class="p">;</span> 		<span class="cm">/* (device sel) = slave */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xA0</span><span class="p">;</span> 		<span class="cm">/* (command) = ATA PACKET COMMAND */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">19</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">registers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">7</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_get_status</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Status = %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEST_UNIT_READY</span><span class="p">)</span>
		<span class="n">transferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_hp8200e_rw_block_test</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> 
			<span class="n">registers</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span>
			<span class="n">USBAT_ATA_DATA</span><span class="p">,</span> <span class="n">USBAT_ATA_STATUS</span><span class="p">,</span> <span class="mh">0xFD</span><span class="p">,</span>
			<span class="p">(</span><span class="n">USBAT_QUAL_FCQ</span> <span class="o">|</span> <span class="n">USBAT_QUAL_ALQ</span><span class="p">),</span>
			<span class="n">DMA_TO_DEVICE</span><span class="p">,</span>
			<span class="n">scsi_sglist</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span>
			<span class="n">len</span><span class="p">,</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span> <span class="mi">10</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">transferred</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Wrote %08X bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">transferred</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span> <span class="o">||</span>
		   <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">GPCMD_READ_CD</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">return</span> <span class="n">usbat_hp8200e_handle_read10</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">registers</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Error: len = %08X... what do I do now?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_multiple_write</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">registers</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write the 12-byte command header.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the command is BLANK then set the timer for 75 minutes.</span>
<span class="cm">	 * Otherwise set it for 10 minutes.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: THE 8200 DOCUMENTATION STATES THAT BLANKING A CDRW</span>
<span class="cm">	 * AT SPEED 4 IS UNRELIABLE!!!</span>
<span class="cm">	 */</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_write_block</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
				   <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">GPCMD_BLANK</span> <span class="o">?</span> <span class="mi">75</span> <span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* If there is response data to be read in then do it here. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* How many bytes to read in? Check cylL register */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_ME</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span> 
		    	<span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* need to read cylH also */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usbat_read</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_ATA</span><span class="p">,</span> <span class="n">USBAT_ATA_LBA_HI</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">!=</span>
				    <span class="n">USB_STOR_XFER_GOOD</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>


		<span class="n">result</span> <span class="o">=</span> <span class="n">usbat_read_block</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">srb</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
			                                   <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">srb</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transport for USBAT02-based CompactFlash and similar storage devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_flash_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span> <span class="n">srb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbat_info</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">inquiry_response</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: INQUIRY. Returning bogus response.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">inquiry_response</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inquiry_response</span><span class="p">));</span>
		<span class="n">fill_inquiry_response</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_CAPACITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_flash_check_media</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_flash_get_sector_count</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* hard coded 512 byte sectors as per ATA spec */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: READ_CAPACITY: %ld sectors, %ld bytes per sector</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">info</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * build the reply</span>
<span class="cm">		 * note: must return the sector number of the last sector,</span>
<span class="cm">		 * *not* the total number of sectors</span>
<span class="cm">		 */</span>
		<span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">);</span>
		<span class="n">usb_stor_set_xfer_buf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MODE_SELECT_10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport:  Gah! MODE_SELECT_10.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]));</span>

		<span class="n">blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]));</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport:  READ_10: read block 0x%04lx  count %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">usbat_flash_read_data</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_12</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * I don&#39;t think we&#39;ll ever see a READ_12 but support it anyway</span>
<span class="cm">		 */</span>
		<span class="n">block</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		        <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]));</span>

		<span class="n">blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		         <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">]));</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: READ_12: read block 0x%04lx  count %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">usbat_flash_read_data</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		        <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]));</span>

		<span class="n">blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]));</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: WRITE_10: write block 0x%04lx  count %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">usbat_flash_write_data</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_12</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * I don&#39;t think we&#39;ll ever see a WRITE_12 but support it anyway</span>
<span class="cm">		 */</span>
		<span class="n">block</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		        <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">]));</span>

		<span class="n">blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		         <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">]));</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: WRITE_12: write block 0x%04lx  count %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">usbat_flash_write_data</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEST_UNIT_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: TEST_UNIT_READY.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">usbat_flash_check_media</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">usbat_check_status</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: REQUEST_SENSE.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xF0</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_key</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_asc</span><span class="p">;</span>
		<span class="n">ptr</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_ascq</span><span class="p">;</span>
		<span class="n">usb_stor_set_xfer_buf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="n">srb</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ALLOW_MEDIUM_REMOVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * sure.  whatever.  not like we can stop the user from popping</span>
<span class="cm">		 * the media out of the device (no locking doors, etc)</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usbat_flash_transport: Gah! Unknown command: %d (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_key</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_asc</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sense_ascq</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">USB_STOR_TRANSPORT_FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_usbat_cd</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">init_usbat</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_DEV_HP8200</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_usbat_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">init_usbat</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">USBAT_DEV_FLASH</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbat_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_probe1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span>
			<span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">usbat_usb_ids</span><span class="p">)</span> <span class="o">+</span> <span class="n">usbat_unusual_dev_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* The actual transport will be determined later by the</span>
<span class="cm">	 * initialization routine; this is just a placeholder.</span>
<span class="cm">	 */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Shuttle USBAT&quot;</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">usbat_flash_transport</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span> <span class="o">=</span> <span class="n">usb_stor_CB_reset</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_probe2</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">usbat_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;ums-usbat&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">usbat_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">usb_stor_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">usb_stor_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">usb_stor_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_resume</span> <span class="o">=</span>	<span class="n">usb_stor_reset_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span>	<span class="n">usb_stor_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span>	<span class="n">usb_stor_post_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">usbat_usb_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">soft_unbind</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">no_dynamic_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">usbat_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
