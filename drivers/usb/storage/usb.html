<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › usb › storage › usb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>usb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Driver for USB Mass Storage compliant devices</span>
<span class="cm"> *</span>
<span class="cm"> * Current development and maintenance by:</span>
<span class="cm"> *   (c) 1999-2003 Matthew Dharm (mdharm-usb@one-eyed-alien.net)</span>
<span class="cm"> *</span>
<span class="cm"> * Developed with the assistance of:</span>
<span class="cm"> *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)</span>
<span class="cm"> *   (c) 2003-2009 Alan Stern (stern@rowland.harvard.edu)</span>
<span class="cm"> *</span>
<span class="cm"> * Initial work by:</span>
<span class="cm"> *   (c) 1999 Michael Gee (michael@linuxspecific.com)</span>
<span class="cm"> *</span>
<span class="cm"> * usb_device_id support by Adam J. Richter (adam@yggdrasil.com):</span>
<span class="cm"> *   (c) 2000 Yggdrasil Computing, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is based on the &#39;USB Mass Storage Class&#39; document. This</span>
<span class="cm"> * describes in detail the protocol used to communicate with such</span>
<span class="cm"> * devices.  Clearly, the designers had SCSI and ATAPI commands in</span>
<span class="cm"> * mind when they created this document.  The commands are all very</span>
<span class="cm"> * similar to commands in the SCSI-II and ATAPI specifications.</span>
<span class="cm"> *</span>
<span class="cm"> * It is important to note that in a number of cases this class</span>
<span class="cm"> * exhibits class-specific exemptions from the USB specification.</span>
<span class="cm"> * Notably the usage of NAK, STALL and ACK differs from the norm, in</span>
<span class="cm"> * that they are used to communicate wait, failed and OK on commands.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, for certain devices, the interrupt endpoint is used to convey</span>
<span class="cm"> * status of a command.</span>
<span class="cm"> *</span>
<span class="cm"> * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more</span>
<span class="cm"> * information about this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_USB_STORAGE_DEBUG</span>
<span class="cp">#define DEBUG</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>

<span class="cp">#include &quot;usb.h&quot;</span>
<span class="cp">#include &quot;scsiglue.h&quot;</span>
<span class="cp">#include &quot;transport.h&quot;</span>
<span class="cp">#include &quot;protocol.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;initializers.h&quot;</span>

<span class="cp">#include &quot;sierra_ms.h&quot;</span>
<span class="cp">#include &quot;option_ms.h&quot;</span>

<span class="cm">/* Some informational data */</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;USB Mass Storage driver for Linux&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">delay_use</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">delay_use</span><span class="p">,</span> <span class="s">&quot;seconds to delay before using a new device&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">quirks</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">quirks</span><span class="p">,</span> <span class="n">quirks</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">quirks</span><span class="p">),</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">quirks</span><span class="p">,</span> <span class="s">&quot;supplemental list of device IDs and their quirks&quot;</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * The entries in this table correspond, line for line,</span>
<span class="cm"> * with the entries in usb_storage_usb_ids[], defined in usual-tables.c.</span>
<span class="cm"> */</span>

<span class="cm">/* The vendor name should be kept at eight characters or less, and</span>
<span class="cm"> * the product name should be kept at 16 characters or less. If a device</span>
<span class="cm"> * has the US_FL_FIX_INQUIRY flag, then the vendor and product names</span>
<span class="cm"> * normally generated by a device thorugh the INQUIRY response will be</span>
<span class="cm"> * taken from this list, and this is the reason for the above size</span>
<span class="cm"> * restriction. However, if the flag is not present, then you</span>
<span class="cm"> * are free to use as many characters as you like.</span>
<span class="cm"> */</span>

<span class="cp">#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \</span>
<span class="cp">		    vendor_name, product_name, use_protocol, use_transport, \</span>
<span class="cp">		    init_function, Flags) \</span>
<span class="cp">{ \</span>
<span class="cp">	.vendorName = vendor_name,	\</span>
<span class="cp">	.productName = product_name,	\</span>
<span class="cp">	.useProtocol = use_protocol,	\</span>
<span class="cp">	.useTransport = use_transport,	\</span>
<span class="cp">	.initFunction = init_function,	\</span>
<span class="cp">}</span>

<span class="cp">#define COMPLIANT_DEV	UNUSUAL_DEV</span>

<span class="cp">#define USUAL_DEV(use_protocol, use_transport, use_type) \</span>
<span class="cp">{ \</span>
<span class="cp">	.useProtocol = use_protocol,	\</span>
<span class="cp">	.useTransport = use_transport,	\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">us_unusual_dev</span> <span class="n">us_unusual_dev_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#	include &quot;unusual_devs.h&quot;</span>
	<span class="p">{</span> <span class="p">}</span>		<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">us_unusual_dev</span> <span class="n">for_dynamic_ids</span> <span class="o">=</span>
		<span class="n">USUAL_DEV</span><span class="p">(</span><span class="n">USB_SC_SCSI</span><span class="p">,</span> <span class="n">USB_PR_BULK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#undef UNUSUAL_DEV</span>
<span class="cp">#undef COMPLIANT_DEV</span>
<span class="cp">#undef USUAL_DEV</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">us_interface_key</span><span class="p">[</span><span class="n">USB_MAXINTERFACES</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">us_set_lock_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">intf</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">);</span>

	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us_interface_key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">us_set_lock_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM	</span><span class="cm">/* Minimal support for suspend and resume */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">usb_stor_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="cm">/* Wait until no command is running */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">suspend_resume_hook</span><span class="p">)</span>
		<span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">suspend_resume_hook</span><span class="p">)(</span><span class="n">us</span><span class="p">,</span> <span class="n">US_SUSPEND</span><span class="p">);</span>

	<span class="cm">/* When runtime PM is working, we&#39;ll set a flag to indicate</span>
<span class="cm">	 * whether we should autoresume when a SCSI request arrives. */</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_suspend</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usb_stor_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">suspend_resume_hook</span><span class="p">)</span>
		<span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">suspend_resume_hook</span><span class="p">)(</span><span class="n">us</span><span class="p">,</span> <span class="n">US_RESUME</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_resume</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usb_stor_reset_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Report the reset to the SCSI core */</span>
	<span class="n">usb_stor_report_bus_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="cm">/* FIXME: Notify the subdrivers that they need to reinitialize</span>
<span class="cm">	 * the device */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_reset_resume</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The next two routines get called just before and just after</span>
<span class="cm"> * a USB port reset, whether from this driver or a different one.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">usb_stor_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Make sure no command runs during the reset */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_pre_reset</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">usb_stor_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Report the reset to the SCSI core */</span>
	<span class="n">usb_stor_report_bus_reset</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="cm">/* FIXME: Notify the subdrivers that they need to reinitialize</span>
<span class="cm">	 * the device */</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_post_reset</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * fill_inquiry_response takes an unsigned char array (which must</span>
<span class="cm"> * be at least 36 characters) and populates the vendor name,</span>
<span class="cm"> * product name, and revision fields. Then the array is copied</span>
<span class="cm"> * into the SCSI command&#39;s response buffer (oddly enough</span>
<span class="cm"> * called request_buffer). data_len contains the length of the</span>
<span class="cm"> * data array, which again must be at least 36.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">fill_inquiry_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">)</span> <span class="cm">/* You lose. */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0x20</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* USB device currently not connected. Return</span>
<span class="cm">			      peripheral qualifier 001b (&quot;...however, the</span>
<span class="cm">			      physical device is not currently connected</span>
<span class="cm">			      to this logical unit&quot;) and leave vendor and</span>
<span class="cm">			      product identification empty. (&quot;If the target</span>
<span class="cm">			      does store some of the INQUIRY data on the</span>
<span class="cm">			      device, it may return zeros or ASCII spaces</span>
<span class="cm">			      (20h) in those fields until the data is</span>
<span class="cm">			      available from the device.&quot;). */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">bcdDevice</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">vendorName</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">vendorName</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">productName</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="o">+</span><span class="mi">16</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">productName</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>

		<span class="n">data</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="p">((</span><span class="n">bcdDevice</span><span class="o">&gt;&gt;</span><span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="p">((</span><span class="n">bcdDevice</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">34</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="p">((</span><span class="n">bcdDevice</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">35</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="p">((</span><span class="n">bcdDevice</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usb_stor_set_xfer_buf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fill_inquiry_response</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_stor_control_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">__us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="p">)</span><span class="n">__us</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;*** thread sleeping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;*** thread awakened.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* lock the device pointers */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">));</span>

		<span class="cm">/* lock access to the state */</span>
		<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* When we are called with no command pending, we&#39;re done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* has the command timed out *already* ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">SkipForAbort</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* reject the command if the direction indicator</span>
<span class="cm">		 * is UNKNOWN</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;UNKNOWN data direction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* reject if target != 0 or if LUN is higher than</span>
<span class="cm">		 * the maximum known LUN</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SCM_MULT_TARG</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bad target number (%d:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&gt;</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Bad LUN (%d:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Handle those devices which need us to fake</span>
<span class="cm">		 * their inquiry data */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_FIX_INQUIRY</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data_ptr</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span>
			    <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">};</span>

			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Faking INQUIRY command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">fill_inquiry_response</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">data_ptr</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we&#39;ve got a command, let&#39;s do it! */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">US_DEBUG</span><span class="p">(</span><span class="n">usb_stor_show_command</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">));</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">,</span> <span class="n">us</span><span class="p">);</span>
			<span class="n">usb_mark_last_busy</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* lock access to the state */</span>
		<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* indicate that the command is done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">!=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;scsi cmd done, result=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">SkipForAbort:</span>
			<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;scsi command aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* If an abort request was received we need to signal that</span>
<span class="cm">		 * the abort has finished.  The proper test for this is</span>
<span class="cm">		 * the TIMED_OUT flag, not srb-&gt;result == DID_ABORT, because</span>
<span class="cm">		 * the timeout might have occurred after the command had</span>
<span class="cm">		 * already completed with a different result code. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">));</span>

			<span class="cm">/* Allow USB transfers to resume */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_TIMED_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* finished working on this command */</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">srb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* unlock the device pointers */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* for (;;) */</span>

	<span class="cm">/* Wait until we are told to stop */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Device probing and disconnecting</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/* Associate our private data with the USB device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">associate_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Fill in the device-related fields */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">ifnum</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">),</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">));</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Interface Subclass: 0x%02x, Protocol: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span><span class="p">,</span>
			<span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">);</span>

	<span class="cm">/* Store our private data in the interface */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">us</span><span class="p">);</span>

	<span class="cm">/* Allocate the control/setup and DMA-mapped buffers */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usb_ctrlrequest allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">US_IOBUF_SIZE</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;I/O buffer allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Works only for digits and letters, but small and fast */</span>
<span class="cp">#define TOLOWER(x) ((x) | 0x20)</span>

<span class="cm">/* Adjust device flags based on the &quot;quirks=&quot; module parameter */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">adjust_quirks</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">US_FL_SANE_SENSE</span> <span class="o">|</span> <span class="n">US_FL_BAD_SENSE</span> <span class="o">|</span>
			<span class="n">US_FL_FIX_CAPACITY</span> <span class="o">|</span>
			<span class="n">US_FL_CAPACITY_HEURISTICS</span> <span class="o">|</span> <span class="n">US_FL_IGNORE_DEVICE</span> <span class="o">|</span>
			<span class="n">US_FL_NOT_LOCKABLE</span> <span class="o">|</span> <span class="n">US_FL_MAX_SECTORS_64</span> <span class="o">|</span>
			<span class="n">US_FL_CAPACITY_OK</span> <span class="o">|</span> <span class="n">US_FL_IGNORE_RESIDUE</span> <span class="o">|</span>
			<span class="n">US_FL_SINGLE_LUN</span> <span class="o">|</span> <span class="n">US_FL_NO_WP_DETECT</span> <span class="o">|</span>
			<span class="n">US_FL_NO_READ_DISC_INFO</span> <span class="o">|</span> <span class="n">US_FL_NO_READ_CAPACITY_16</span> <span class="o">|</span>
			<span class="n">US_FL_INITIAL_READ10</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Each entry consists of VID:PID:flags */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vid</span> <span class="o">==</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">&amp;&amp;</span>
				<span class="n">pid</span> <span class="o">==</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Move forward to the next entry */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p</span><span class="p">)</span>	<span class="cm">/* No match */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Collect the flags */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*++</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">TOLOWER</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;a&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_SANE_SENSE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;b&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_BAD_SENSE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_FIX_CAPACITY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;d&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_NO_READ_DISC_INFO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;e&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_NO_READ_CAPACITY_16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;h&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_CAPACITY_HEURISTICS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;i&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_IGNORE_DEVICE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;l&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_NOT_LOCKABLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;m&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_MAX_SECTORS_64</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;n&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_INITIAL_READ10</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;o&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_CAPACITY_OK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;r&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_IGNORE_RESIDUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;s&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_SINGLE_LUN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;w&#39;</span>:
			<span class="n">f</span> <span class="o">|=</span> <span class="n">US_FL_NO_WP_DETECT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Ignore unrecognized flag characters */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the unusual_devs entries and the string descriptors */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">us_unusual_dev</span> <span class="o">*</span><span class="n">unusual_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface_descriptor</span> <span class="o">*</span><span class="n">idesc</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Store the entries */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span> <span class="o">=</span> <span class="n">unusual_dev</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">=</span> <span class="p">(</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">useProtocol</span> <span class="o">==</span> <span class="n">USB_SC_DEVICE</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">idesc</span><span class="o">-&gt;</span><span class="n">bInterfaceSubClass</span> <span class="o">:</span>
			<span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">useProtocol</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="p">(</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">useTransport</span> <span class="o">==</span> <span class="n">USB_PR_DEVICE</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">idesc</span><span class="o">-&gt;</span><span class="n">bInterfaceProtocol</span> <span class="o">:</span>
			<span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">useTransport</span><span class="p">;</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">=</span> <span class="n">USB_US_ORIG_FLAGS</span><span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">);</span>
	<span class="n">adjust_quirks</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_IGNORE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;device ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This flag is only needed when we&#39;re in high-speed, so let&#39;s</span>
<span class="cm">	 * disable it if we&#39;re in full-speed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">US_FL_GO_SLOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;Quirks match for vid %04x pid %04x: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">),</span>
				<span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span><span class="p">);</span>

	<span class="cm">/* Log a message if a non-generic unusual_dev entry contains an</span>
<span class="cm">	 * unnecessary subclass or protocol override.  This may stimulate</span>
<span class="cm">	 * reports from users that will help us remove unneeded entries</span>
<span class="cm">	 * from the unusual_devs.h table.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msgs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s">&quot;an unneeded SubClass entry&quot;</span><span class="p">,</span>
			<span class="s">&quot;an unneeded Protocol entry&quot;</span><span class="p">,</span>
			<span class="s">&quot;unneeded SubClass and Protocol entries&quot;</span><span class="p">};</span>
		<span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="o">*</span><span class="n">ddesc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">msg</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">useProtocol</span> <span class="o">!=</span> <span class="n">USB_SC_DEVICE</span> <span class="o">&amp;&amp;</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">idesc</span><span class="o">-&gt;</span><span class="n">bInterfaceSubClass</span><span class="p">)</span>
			<span class="n">msg</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">useTransport</span> <span class="o">!=</span> <span class="n">USB_PR_DEVICE</span> <span class="o">&amp;&amp;</span>
			<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">idesc</span><span class="o">-&gt;</span><span class="n">bInterfaceProtocol</span><span class="p">)</span>
			<span class="n">msg</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_NEED_OVERRIDE</span><span class="p">))</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;This device &quot;</span>
					<span class="s">&quot;(%04x,%04x,%04x S %02x P %02x)&quot;</span>
					<span class="s">&quot; has %s in unusual_devs.h (kernel&quot;</span>
					<span class="s">&quot; %s)</span><span class="se">\n</span><span class="s">&quot;</span>
					<span class="s">&quot;   Please send a copy of this message to &quot;</span>
					<span class="s">&quot;&lt;linux-usb@vger.kernel.org&gt; and &quot;</span>
					<span class="s">&quot;&lt;usb-storage@lists.one-eyed-alien.net&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ddesc</span><span class="o">-&gt;</span><span class="n">idVendor</span><span class="p">),</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ddesc</span><span class="o">-&gt;</span><span class="n">idProduct</span><span class="p">),</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ddesc</span><span class="o">-&gt;</span><span class="n">bcdDevice</span><span class="p">),</span>
					<span class="n">idesc</span><span class="o">-&gt;</span><span class="n">bInterfaceSubClass</span><span class="p">,</span>
					<span class="n">idesc</span><span class="o">-&gt;</span><span class="n">bInterfaceProtocol</span><span class="p">,</span>
					<span class="n">msgs</span><span class="p">[</span><span class="n">msg</span><span class="p">],</span>
					<span class="n">utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the transport settings */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_PR_CB</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Control/Bulk&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">usb_stor_CB_transport</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span> <span class="o">=</span> <span class="n">usb_stor_CB_reset</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_PR_CBI</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Control/Bulk/Interrupt&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">usb_stor_CB_transport</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span> <span class="o">=</span> <span class="n">usb_stor_CB_reset</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_PR_BULK</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span> <span class="o">=</span> <span class="s">&quot;Bulk&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">usb_stor_Bulk_transport</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_reset</span> <span class="o">=</span> <span class="n">usb_stor_Bulk_reset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Get the protocol settings */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_protocol</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">subclass</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_SC_RBC</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;Reduced Block Commands (RBC)&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span> <span class="o">=</span> <span class="n">usb_stor_transparent_scsi_command</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_SC_8020</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;8020i&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span> <span class="o">=</span> <span class="n">usb_stor_pad12_command</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_SC_QIC</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;QIC-157&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span> <span class="o">=</span> <span class="n">usb_stor_pad12_command</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_SC_8070</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;8070i&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span> <span class="o">=</span> <span class="n">usb_stor_pad12_command</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_SC_SCSI</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;Transparent SCSI&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span> <span class="o">=</span> <span class="n">usb_stor_transparent_scsi_command</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">USB_SC_UFI</span>:
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span> <span class="o">=</span> <span class="s">&quot;Uniform Floppy Interface (UFI)&quot;</span><span class="p">;</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span> <span class="o">=</span> <span class="n">usb_stor_ufi_command</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Get the pipe settings */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_pipes</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">altsetting</span> <span class="o">=</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_int</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the first endpoint of each type we need.</span>
<span class="cm">	 * We are expecting a minimum of 2 endpoints - in and out (bulk).</span>
<span class="cm">	 * An optional interrupt-in is OK (necessary for CBI protocol).</span>
<span class="cm">	 * We will ignore any others.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_bulk</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_in</span><span class="p">)</span>
					<span class="n">ep_in</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_out</span><span class="p">)</span>
					<span class="n">ep_out</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_is_int_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_int</span><span class="p">)</span>
				<span class="n">ep_int</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_in</span> <span class="o">||</span> <span class="o">!</span><span class="n">ep_out</span> <span class="o">||</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_CBI</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_int</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Endpoint sanity check failed! Rejecting dev.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate and store the pipe values */</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span> <span class="o">=</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span> <span class="o">=</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span>
		<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">ep_out</span><span class="p">));</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span>
		<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">ep_in</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">recv_intr_pipe</span> <span class="o">=</span> <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span>
			<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">ep_int</span><span class="p">));</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">ep_bInterval</span> <span class="o">=</span> <span class="n">ep_int</span><span class="o">-&gt;</span><span class="n">bInterval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize all the dynamic resources we need */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_stor_acquire_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>

	<span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;URB allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Just before we start our control thread, initialize</span>
<span class="cm">	 * the device if it needs initialization */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">initFunction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">unusual_dev</span><span class="o">-&gt;</span><span class="n">initFunction</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start up our control thread */</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">usb_stor_control_thread</span><span class="p">,</span> <span class="n">us</span><span class="p">,</span> <span class="s">&quot;usb-storage&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">th</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Unable to start control thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">us</span><span class="o">-&gt;</span><span class="n">ctl_thread</span> <span class="o">=</span> <span class="n">th</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release all our dynamic resources */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_stor_release_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Tell the control thread to exit.  The SCSI host must</span>
<span class="cm">	 * already have been removed and the DISCONNECTING flag set</span>
<span class="cm">	 * so that we won&#39;t accept any more commands.</span>
<span class="cm">	 */</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- sending exit command to thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">ctl_thread</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">ctl_thread</span><span class="p">);</span>

	<span class="cm">/* Call the destructor routine, if it exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra_destructor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- calling extra_destructor()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">extra_destructor</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free the extra data and the URB */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">current_urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Dissociate from the USB device */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dissociate_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Free the buffers */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">);</span>
	<span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="p">,</span> <span class="n">US_IOBUF_SIZE</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">iobuf_dma</span><span class="p">);</span>

	<span class="cm">/* Remove our private data from the interface */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* First stage of disconnect processing: stop SCSI scanning,</span>
<span class="cm"> * remove the host, and stop accepting new commands</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quiesce_and_remove_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="cm">/* If the device is really gone, cut short reset delays */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">USB_STATE_NOTATTACHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">delay_wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Prevent SCSI scanning (if it hasn&#39;t started yet)</span>
<span class="cm">	 * or wait for the SCSI-scanning routine to stop.</span>
<span class="cm">	 */</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">scan_dwork</span><span class="p">);</span>

	<span class="cm">/* Balance autopm calls if scanning was cancelled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">US_FLIDX_SCAN_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">))</span>
		<span class="n">usb_autopm_put_interface_no_suspend</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="p">);</span>

	<span class="cm">/* Removing the host will perform an orderly shutdown: caches</span>
<span class="cm">	 * synchronized, disks spun down, etc.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* Prevent any new commands from being accepted and cut short</span>
<span class="cm">	 * reset delays.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_lock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_DISCONNECTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
	<span class="n">scsi_unlock</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">delay_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Second stage of disconnect processing: deallocate all resources */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_everything</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_stor_release_resources</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="n">dissociate_dev</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="cm">/* Drop our reference to the host; the SCSI core will free it</span>
<span class="cm">	 * (and &quot;us&quot; along with it) when the refcount becomes 0. */</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Delayed-work routine to carry out SCSI-device scanning */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_stor_scan_dwork</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">us_data</span><span class="p">,</span>
			<span class="n">scan_dwork</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;starting scan</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* For bulk-only devices, determine the max LUN value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">USB_PR_BULK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SINGLE_LUN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">usb_stor_Bulk_max_lun</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">));</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;scan complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Should we unbind if no devices were detected? */</span>

	<span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">US_FLIDX_SCAN_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">usb_stor_sg_tablesize</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SG_ALL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* First part of general USB mass-storage probing */</span>
<span class="kt">int</span> <span class="nf">usb_stor_probe1</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">**</span><span class="n">pus</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">us_unusual_dev</span> <span class="o">*</span><span class="n">unusual_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;USB Mass Storage device detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ask the SCSI layer to allocate a host structure, with extra</span>
<span class="cm">	 * space at the end for our private us_data structure.</span>
<span class="cm">	 */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_stor_host_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">us</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Unable to allocate the scsi host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow 16-byte CDBs and thus &gt; 2TB</span>
<span class="cm">	 */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">usb_stor_sg_tablesize</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pus</span> <span class="o">=</span> <span class="n">us</span> <span class="o">=</span> <span class="n">host_to_us</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">));</span>
	<span class="n">us_set_lock_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dev_mutex</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">cmnd_ready</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">));</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">delay_wait</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">scan_dwork</span><span class="p">,</span> <span class="n">usb_stor_scan_dwork</span><span class="p">);</span>

	<span class="cm">/* Associate the us_data structure with the USB device */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">associate_dev</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">intf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>

	<span class="cm">/* Get the unusual_devs entries and the descriptors */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">get_device_info</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">unusual_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>

	<span class="cm">/* Get standard transport and protocol settings */</span>
	<span class="n">get_transport</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="n">get_protocol</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>

	<span class="cm">/* Give the caller a chance to fill in specialized transport</span>
<span class="cm">	 * or protocol settings.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">BadDevice:</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;storage_probe() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">release_everything</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_probe1</span><span class="p">);</span>

<span class="cm">/* Second part of general USB mass-storage probing */</span>
<span class="kt">int</span> <span class="nf">usb_stor_probe2</span><span class="p">(</span><span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Make sure the transport and protocol have both been set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">||</span> <span class="o">!</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">proto_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Transport: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">transport_name</span><span class="p">);</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;Protocol: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">us</span><span class="o">-&gt;</span><span class="n">protocol_name</span><span class="p">);</span>

	<span class="cm">/* fix for single-lun devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_SINGLE_LUN</span><span class="p">)</span>
		<span class="n">us</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find the endpoints and calculate pipe values */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">get_pipes</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device returns invalid data for the first READ(10)</span>
<span class="cm">	 * command, indicate the command should be retried.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">fflags</span> <span class="o">&amp;</span> <span class="n">US_FL_INITIAL_READ10</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_REDO_READ10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>

	<span class="cm">/* Acquire all the other resources and add the host */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_acquire_resources</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">scsi_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">scsi_name</span><span class="p">),</span> <span class="s">&quot;usb-storage %s&quot;</span><span class="p">,</span>
					<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">us_to_host</span><span class="p">(</span><span class="n">us</span><span class="p">),</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Unable to add the scsi host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">BadDevice</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Submit the delayed_work for SCSI-device scanning */</span>
	<span class="n">usb_autopm_get_interface_no_resume</span><span class="p">(</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">pusb_intf</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">US_FLIDX_SCAN_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">dflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delay_use</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;waiting for device to settle before scanning</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_freezable_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">us</span><span class="o">-&gt;</span><span class="n">scan_dwork</span><span class="p">,</span>
			<span class="n">delay_use</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We come here if there are any problems */</span>
<span class="nl">BadDevice:</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;storage_probe() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">release_everything</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_probe2</span><span class="p">);</span>

<span class="cm">/* Handle a USB mass-storage disconnect */</span>
<span class="kt">void</span> <span class="nf">usb_stor_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;storage_disconnect() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">quiesce_and_remove_host</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="n">release_everything</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">usb_stor_disconnect</span><span class="p">);</span>

<span class="cm">/* The main probe routine for standard devices */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">storage_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">us_unusual_dev</span> <span class="o">*</span><span class="n">unusual_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">us_data</span> <span class="o">*</span><span class="n">us</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If libusual is configured, let it decide whether a standard</span>
<span class="cm">	 * device should be handled by usb-storage or by ub.</span>
<span class="cm">	 * If the device isn&#39;t standard (is handled by a subdriver</span>
<span class="cm">	 * module) then don&#39;t accept it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_usual_check_type</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">USB_US_TYPE_STOR</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">usb_usual_ignore_device</span><span class="p">(</span><span class="n">intf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the general probe procedures.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The unusual_dev_list array is parallel to the usb_storage_usb_ids</span>
<span class="cm">	 * table, so we use the index of the id entry to find the</span>
<span class="cm">	 * corresponding unusual_devs entry.</span>
<span class="cm">	 */</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">us_unusual_dev_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">usb_storage_usb_ids</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">usb_storage_usb_ids</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unusual_dev</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">usb_storage_usb_ids</span><span class="p">)</span> <span class="o">+</span> <span class="n">us_unusual_dev_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">unusual_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">for_dynamic_ids</span><span class="p">;</span>

		<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;%s %s 0x%04x 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Use Bulk-Only transport&quot;</span><span class="p">,</span>
			<span class="s">&quot;with the Transparent SCSI protocol for dynamic id:&quot;</span><span class="p">,</span>
			<span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span><span class="p">,</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_probe1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">us</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">unusual_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* No special transport or protocol settings in the main module */</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_stor_probe2</span><span class="p">(</span><span class="n">us</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * Initialization and registration</span>
<span class="cm"> ***********************************************************************/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">usb_storage_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;usb-storage&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">storage_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">usb_stor_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>	<span class="n">usb_stor_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>	<span class="n">usb_stor_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_resume</span> <span class="o">=</span>	<span class="n">usb_stor_reset_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span>	<span class="n">usb_stor_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span>	<span class="n">usb_stor_post_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">usb_storage_usb_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">supports_autosuspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">soft_unbind</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">usb_stor_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Initializing USB Mass Storage driver...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* register the driver, return usb_register return code if error */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_storage_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;USB Mass Storage support registered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_usual_set_present</span><span class="p">(</span><span class="n">USB_US_TYPE_STOR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">usb_stor_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;usb_stor_exit() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Deregister the driver</span>
<span class="cm">	 * This will cause disconnect() to be called for each</span>
<span class="cm">	 * attached unit</span>
<span class="cm">	 */</span>
	<span class="n">US_DEBUGP</span><span class="p">(</span><span class="s">&quot;-- calling usb_deregister()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_storage_driver</span><span class="p">)</span> <span class="p">;</span>

	<span class="n">usb_usual_clear_present</span><span class="p">(</span><span class="n">USB_US_TYPE_STOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">usb_stor_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">usb_stor_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
