<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › xsysace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xsysace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Xilinx SystemACE device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2007 Secret Lab Technologies Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The SystemACE chip is designed to configure FPGAs by loading an FPGA</span>
<span class="cm"> * bitstream from a file on a CF card and squirting it into FPGAs connected</span>
<span class="cm"> * to the SystemACE JTAG chain.  It also has the advantage of providing an</span>
<span class="cm"> * MPU interface which can be used to control the FPGA configuration process</span>
<span class="cm"> * and to use the attached CF card for general purpose storage.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is a block device driver for the SystemACE.</span>
<span class="cm"> *</span>
<span class="cm"> * Initialization:</span>
<span class="cm"> *    The driver registers itself as a platform_device driver at module</span>
<span class="cm"> *    load time.  The platform bus will take care of calling the</span>
<span class="cm"> *    ace_probe() method for all SystemACE instances in the system.  Any</span>
<span class="cm"> *    number of SystemACE instances are supported.  ace_probe() calls</span>
<span class="cm"> *    ace_setup() which initialized all data structures, reads the CF</span>
<span class="cm"> *    id structure and registers the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Processing:</span>
<span class="cm"> *    Just about all of the heavy lifting in this driver is performed by</span>
<span class="cm"> *    a Finite State Machine (FSM).  The driver needs to wait on a number</span>
<span class="cm"> *    of events; some raised by interrupts, some which need to be polled</span>
<span class="cm"> *    for.  Describing all of the behaviour in a FSM seems to be the</span>
<span class="cm"> *    easiest way to keep the complexity low and make it easy to</span>
<span class="cm"> *    understand what the driver is doing.  If the block ops or the</span>
<span class="cm"> *    request function need to interact with the hardware, then they</span>
<span class="cm"> *    simply need to flag the request and kick of FSM processing.</span>
<span class="cm"> *</span>
<span class="cm"> *    The FSM itself is atomic-safe code which can be run from any</span>
<span class="cm"> *    context.  The general process flow is:</span>
<span class="cm"> *    1. obtain the ace-&gt;lock spinlock.</span>
<span class="cm"> *    2. loop on ace_fsm_dostate() until the ace-&gt;fsm_continue flag is</span>
<span class="cm"> *       cleared.</span>
<span class="cm"> *    3. release the lock.</span>
<span class="cm"> *</span>
<span class="cm"> *    Individual states do not sleep in any way.  If a condition needs to</span>
<span class="cm"> *    be waited for then the state much clear the fsm_continue flag and</span>
<span class="cm"> *    either schedule the FSM to be run again at a later time, or expect</span>
<span class="cm"> *    an interrupt to call the FSM when the desired condition is met.</span>
<span class="cm"> *</span>
<span class="cm"> *    In normal operation, the FSM is processed at interrupt context</span>
<span class="cm"> *    either when the driver&#39;s tasklet is scheduled, or when an irq is</span>
<span class="cm"> *    raised by the hardware.  The tasklet can be scheduled at any time.</span>
<span class="cm"> *    The request method in particular schedules the tasklet when a new</span>
<span class="cm"> *    request has been indicated by the block layer.  Once started, the</span>
<span class="cm"> *    FSM proceeds as far as it can processing the request until it</span>
<span class="cm"> *    needs on a hardware event.  At this point, it must yield execution.</span>
<span class="cm"> *</span>
<span class="cm"> *    A state has two options when yielding execution:</span>
<span class="cm"> *    1. ace_fsm_yield()</span>
<span class="cm"> *       - Call if need to poll for event.</span>
<span class="cm"> *       - clears the fsm_continue flag to exit the processing loop</span>
<span class="cm"> *       - reschedules the tasklet to run again as soon as possible</span>
<span class="cm"> *    2. ace_fsm_yieldirq()</span>
<span class="cm"> *       - Call if an irq is expected from the HW</span>
<span class="cm"> *       - clears the fsm_continue flag to exit the processing loop</span>
<span class="cm"> *       - does not reschedule the tasklet so the FSM will not be processed</span>
<span class="cm"> *         again until an irq is received.</span>
<span class="cm"> *    After calling a yield function, the state must return control back</span>
<span class="cm"> *    to the FSM main loop.</span>
<span class="cm"> *</span>
<span class="cm"> *    Additionally, the driver maintains a kernel timer which can process</span>
<span class="cm"> *    the FSM.  If the FSM gets stalled, typically due to a missed</span>
<span class="cm"> *    interrupt, then the kernel timer will expire and the driver can</span>
<span class="cm"> *    continue where it left off.</span>
<span class="cm"> *</span>
<span class="cm"> * To Do:</span>
<span class="cm"> *    - Add FPGA configuration control interface.</span>
<span class="cm"> *    - Request major number from lanana</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/ata.h&gt;</span>
<span class="cp">#include &lt;linux/hdreg.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#if defined(CONFIG_OF)</span>
<span class="cp">#include &lt;linux/of_address.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#endif</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Grant Likely &lt;grant.likely@secretlab.ca&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Xilinx SystemACE device driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* SystemACE register definitions */</span>
<span class="cp">#define ACE_BUSMODE (0x00)</span>

<span class="cp">#define ACE_STATUS (0x04)</span>
<span class="cp">#define ACE_STATUS_CFGLOCK      (0x00000001)</span>
<span class="cp">#define ACE_STATUS_MPULOCK      (0x00000002)</span>
<span class="cp">#define ACE_STATUS_CFGERROR     (0x00000004)	</span><span class="cm">/* config controller error */</span><span class="cp"></span>
<span class="cp">#define ACE_STATUS_CFCERROR     (0x00000008)	</span><span class="cm">/* CF controller error */</span><span class="cp"></span>
<span class="cp">#define ACE_STATUS_CFDETECT     (0x00000010)</span>
<span class="cp">#define ACE_STATUS_DATABUFRDY   (0x00000020)</span>
<span class="cp">#define ACE_STATUS_DATABUFMODE  (0x00000040)</span>
<span class="cp">#define ACE_STATUS_CFGDONE      (0x00000080)</span>
<span class="cp">#define ACE_STATUS_RDYFORCFCMD  (0x00000100)</span>
<span class="cp">#define ACE_STATUS_CFGMODEPIN   (0x00000200)</span>
<span class="cp">#define ACE_STATUS_CFGADDR_MASK (0x0000e000)</span>
<span class="cp">#define ACE_STATUS_CFBSY        (0x00020000)</span>
<span class="cp">#define ACE_STATUS_CFRDY        (0x00040000)</span>
<span class="cp">#define ACE_STATUS_CFDWF        (0x00080000)</span>
<span class="cp">#define ACE_STATUS_CFDSC        (0x00100000)</span>
<span class="cp">#define ACE_STATUS_CFDRQ        (0x00200000)</span>
<span class="cp">#define ACE_STATUS_CFCORR       (0x00400000)</span>
<span class="cp">#define ACE_STATUS_CFERR        (0x00800000)</span>

<span class="cp">#define ACE_ERROR (0x08)</span>
<span class="cp">#define ACE_CFGLBA (0x0c)</span>
<span class="cp">#define ACE_MPULBA (0x10)</span>

<span class="cp">#define ACE_SECCNTCMD (0x14)</span>
<span class="cp">#define ACE_SECCNTCMD_RESET      (0x0100)</span>
<span class="cp">#define ACE_SECCNTCMD_IDENTIFY   (0x0200)</span>
<span class="cp">#define ACE_SECCNTCMD_READ_DATA  (0x0300)</span>
<span class="cp">#define ACE_SECCNTCMD_WRITE_DATA (0x0400)</span>
<span class="cp">#define ACE_SECCNTCMD_ABORT      (0x0600)</span>

<span class="cp">#define ACE_VERSION (0x16)</span>
<span class="cp">#define ACE_VERSION_REVISION_MASK (0x00FF)</span>
<span class="cp">#define ACE_VERSION_MINOR_MASK    (0x0F00)</span>
<span class="cp">#define ACE_VERSION_MAJOR_MASK    (0xF000)</span>

<span class="cp">#define ACE_CTRL (0x18)</span>
<span class="cp">#define ACE_CTRL_FORCELOCKREQ   (0x0001)</span>
<span class="cp">#define ACE_CTRL_LOCKREQ        (0x0002)</span>
<span class="cp">#define ACE_CTRL_FORCECFGADDR   (0x0004)</span>
<span class="cp">#define ACE_CTRL_FORCECFGMODE   (0x0008)</span>
<span class="cp">#define ACE_CTRL_CFGMODE        (0x0010)</span>
<span class="cp">#define ACE_CTRL_CFGSTART       (0x0020)</span>
<span class="cp">#define ACE_CTRL_CFGSEL         (0x0040)</span>
<span class="cp">#define ACE_CTRL_CFGRESET       (0x0080)</span>
<span class="cp">#define ACE_CTRL_DATABUFRDYIRQ  (0x0100)</span>
<span class="cp">#define ACE_CTRL_ERRORIRQ       (0x0200)</span>
<span class="cp">#define ACE_CTRL_CFGDONEIRQ     (0x0400)</span>
<span class="cp">#define ACE_CTRL_RESETIRQ       (0x0800)</span>
<span class="cp">#define ACE_CTRL_CFGPROG        (0x1000)</span>
<span class="cp">#define ACE_CTRL_CFGADDR_MASK   (0xe000)</span>

<span class="cp">#define ACE_FATSTAT (0x1c)</span>

<span class="cp">#define ACE_NUM_MINORS 16</span>
<span class="cp">#define ACE_SECTOR_SIZE (512)</span>
<span class="cp">#define ACE_FIFO_SIZE (32)</span>
<span class="cp">#define ACE_BUF_PER_SECTOR (ACE_SECTOR_SIZE / ACE_FIFO_SIZE)</span>

<span class="cp">#define ACE_BUS_WIDTH_8  0</span>
<span class="cp">#define ACE_BUS_WIDTH_16 1</span>

<span class="k">struct</span> <span class="n">ace_reg_ops</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ace_device</span> <span class="p">{</span>
	<span class="cm">/* driver state data */</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">media_change</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">users</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* finite state machine data */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">fsm_tasklet</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">fsm_task</span><span class="p">;</span>		<span class="cm">/* Current activity (ACE_TASK_*) */</span>
	<span class="n">uint</span> <span class="n">fsm_state</span><span class="p">;</span>		<span class="cm">/* Current state (ACE_FSM_STATE_*) */</span>
	<span class="n">uint</span> <span class="n">fsm_continue_flag</span><span class="p">;</span>	<span class="cm">/* cleared to exit FSM mainloop */</span>
	<span class="n">uint</span> <span class="n">fsm_iter_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">stall_timer</span><span class="p">;</span>

	<span class="cm">/* Transfer state/result, use for both id and block request */</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>	<span class="cm">/* request being processed */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data_ptr</span><span class="p">;</span>		<span class="cm">/* pointer to I/O buffer */</span>
	<span class="kt">int</span> <span class="n">data_count</span><span class="p">;</span>		<span class="cm">/* number of buffers remaining */</span>
	<span class="kt">int</span> <span class="n">data_result</span><span class="p">;</span>	<span class="cm">/* Result of transfer; 0 := success */</span>

	<span class="kt">int</span> <span class="n">id_req_count</span><span class="p">;</span>	<span class="cm">/* count of id requests */</span>
	<span class="kt">int</span> <span class="n">id_result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">id_completion</span><span class="p">;</span>	<span class="cm">/* used when id req finishes */</span>
	<span class="kt">int</span> <span class="n">in_irq</span><span class="p">;</span>

	<span class="cm">/* Details of hardware device */</span>
	<span class="n">resource_size_t</span> <span class="n">physaddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">baseaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bus_width</span><span class="p">;</span>		<span class="cm">/* 0 := 8 bit; 1 := 16 bit */</span>
	<span class="k">struct</span> <span class="n">ace_reg_ops</span> <span class="o">*</span><span class="n">reg_ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lock_count</span><span class="p">;</span>

	<span class="cm">/* Block device data structures */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>

	<span class="cm">/* Inserted CF card parameters */</span>
	<span class="n">u16</span> <span class="n">cf_id</span><span class="p">[</span><span class="n">ATA_ID_WORDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">xsysace_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ace_major</span><span class="p">;</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Low level register access</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ace_reg_ops</span> <span class="p">{</span>
	<span class="n">u16</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span> <span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">out</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span> <span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">datain</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span> <span class="n">ace</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dataout</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span> <span class="n">ace</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* 8 Bit bus width */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">ace_in_8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">in_8</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">in_8</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_out_8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">out_8</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">out_8</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_datain_8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ACE_FIFO_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="n">in_8</span><span class="p">(</span><span class="n">r</span><span class="o">++</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_dataout_8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ACE_FIFO_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">out_8</span><span class="p">(</span><span class="n">r</span><span class="o">++</span><span class="p">,</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ace_reg_ops</span> <span class="n">ace_reg_8_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">in</span> <span class="o">=</span> <span class="n">ace_in_8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">out</span> <span class="o">=</span> <span class="n">ace_out_8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">datain</span> <span class="o">=</span> <span class="n">ace_datain_8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dataout</span> <span class="o">=</span> <span class="n">ace_dataout_8</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* 16 bit big endian bus attachment */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">ace_in_be16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_be16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_out_be16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_datain_be16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ACE_FIFO_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="n">in_le16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_dataout_be16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ACE_FIFO_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">out_le16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 16 bit little endian bus attachment */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">ace_in_le16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_le16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_out_le16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_le16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_datain_le16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ACE_FIFO_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="n">in_be16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_dataout_le16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ACE_FIFO_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ace_reg_ops</span> <span class="n">ace_reg_be16_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">in</span> <span class="o">=</span> <span class="n">ace_in_be16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">out</span> <span class="o">=</span> <span class="n">ace_out_be16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">datain</span> <span class="o">=</span> <span class="n">ace_datain_be16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dataout</span> <span class="o">=</span> <span class="n">ace_dataout_be16</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ace_reg_ops</span> <span class="n">ace_reg_le16_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">in</span> <span class="o">=</span> <span class="n">ace_in_le16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">out</span> <span class="o">=</span> <span class="n">ace_out_le16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">datain</span> <span class="o">=</span> <span class="n">ace_datain_le16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dataout</span> <span class="o">=</span> <span class="n">ace_dataout_le16</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ace_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ace_in32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ace_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ace_out32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Debug support functions</span>
<span class="cm"> */</span>

<span class="cp">#if defined(DEBUG)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_dump_mem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%.8x:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%.2x&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">isprint</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span> <span class="o">?</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">:</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ace_dump_mem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_dump_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		 <span class="s">&quot;    ctrl:  %.8x  seccnt/cmd: %.4x      ver:%.4x</span><span class="se">\n</span><span class="s">&quot;</span>
		 <span class="s">&quot;    status:%.8x  mpu_lba:%.8x  busmode:%4x</span><span class="se">\n</span><span class="s">&quot;</span>
		 <span class="s">&quot;    error: %.8x  cfg_lba:%.8x  fatstat:%.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">),</span>
		 <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_SECCNTCMD</span><span class="p">),</span>
		 <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_VERSION</span><span class="p">),</span>
		 <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">),</span>
		 <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_MPULBA</span><span class="p">),</span>
		 <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_BUSMODE</span><span class="p">),</span>
		 <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_ERROR</span><span class="p">),</span>
		 <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CFGLBA</span><span class="p">),</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_FATSTAT</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ace_fix_driveid</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(__BIG_ENDIAN)</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* All half words have wrong byte order; swap the bytes */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATA_ID_WORDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Finite State Machine (FSM) implementation</span>
<span class="cm"> */</span>

<span class="cm">/* FSM tasks; used to direct state transitions */</span>
<span class="cp">#define ACE_TASK_IDLE      0</span>
<span class="cp">#define ACE_TASK_IDENTIFY  1</span>
<span class="cp">#define ACE_TASK_READ      2</span>
<span class="cp">#define ACE_TASK_WRITE     3</span>
<span class="cp">#define ACE_FSM_NUM_TASKS  4</span>

<span class="cm">/* FSM state definitions */</span>
<span class="cp">#define ACE_FSM_STATE_IDLE               0</span>
<span class="cp">#define ACE_FSM_STATE_REQ_LOCK           1</span>
<span class="cp">#define ACE_FSM_STATE_WAIT_LOCK          2</span>
<span class="cp">#define ACE_FSM_STATE_WAIT_CFREADY       3</span>
<span class="cp">#define ACE_FSM_STATE_IDENTIFY_PREPARE   4</span>
<span class="cp">#define ACE_FSM_STATE_IDENTIFY_TRANSFER  5</span>
<span class="cp">#define ACE_FSM_STATE_IDENTIFY_COMPLETE  6</span>
<span class="cp">#define ACE_FSM_STATE_REQ_PREPARE        7</span>
<span class="cp">#define ACE_FSM_STATE_REQ_TRANSFER       8</span>
<span class="cp">#define ACE_FSM_STATE_REQ_COMPLETE       9</span>
<span class="cp">#define ACE_FSM_STATE_ERROR             10</span>
<span class="cp">#define ACE_FSM_NUM_STATES              11</span>

<span class="cm">/* Set flag to exit FSM loop and reschedule tasklet */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ace_fsm_yield</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_fsm_yield()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_tasklet</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set flag to exit FSM loop and wait for IRQ to reschedule tasklet */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ace_fsm_yieldirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_fsm_yieldirq()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="cm">/* No IRQ assigned, so need to poll */</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_tasklet</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the next read/write request; ending requests that we don&#39;t handle */</span>
<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">ace_get_next_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">req</span> <span class="o">=</span> <span class="n">blk_peek_request</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">blk_start_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_fsm_dostate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

<span class="cp">#if defined(DEBUG)</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fsm_state=%i, id_req_count=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Verify that there is actually a CF in the slot. If not, then</span>
<span class="cm">	 * bail out back to the idle state and wake up all the waiters */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_CFDETECT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDLE</span><span class="p">;</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">media_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">set_capacity</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No CF in slot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Drop all in-flight and pending requests */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">req</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>

		<span class="cm">/* Drop back to IDLE state and notify waiters */</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDLE</span><span class="p">;</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_completion</span><span class="p">);</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ACE_FSM_STATE_IDLE</span>:
		<span class="cm">/* See if there is anything to do */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span> <span class="o">||</span> <span class="n">ace_get_next_request</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_iter_num</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_REQ_LOCK</span><span class="p">;</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">stall_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">stall_timer</span><span class="p">))</span>
				<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">stall_timer</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">stall_timer</span><span class="p">);</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_REQ_LOCK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_MPULOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Already have the lock, jump to next state */</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_WAIT_CFREADY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Request the lock */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">);</span>
		<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">val</span> <span class="o">|</span> <span class="n">ACE_CTRL_LOCKREQ</span><span class="p">);</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_WAIT_LOCK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_WAIT_LOCK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_MPULOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* got the lock; move to next state */</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_WAIT_CFREADY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* wait a bit for the lock */</span>
		<span class="n">ace_fsm_yield</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_WAIT_CFREADY</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_RDYFORCFCMD</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_CFBSY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* CF card isn&#39;t ready; it needs to be polled */</span>
			<span class="n">ace_fsm_yield</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Device is ready for command; determine what to do next */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span><span class="p">)</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDENTIFY_PREPARE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_REQ_PREPARE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_IDENTIFY_PREPARE</span>:
		<span class="cm">/* Send identify command */</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span> <span class="o">=</span> <span class="n">ACE_TASK_IDENTIFY</span><span class="p">;</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">cf_id</span><span class="p">;</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">ACE_BUF_PER_SECTOR</span><span class="p">;</span>
		<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_SECCNTCMD</span><span class="p">,</span> <span class="n">ACE_SECCNTCMD_IDENTIFY</span><span class="p">);</span>

		<span class="cm">/* As per datasheet, put config controller in reset */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">);</span>
		<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">val</span> <span class="o">|</span> <span class="n">ACE_CTRL_CFGRESET</span><span class="p">);</span>

		<span class="cm">/* irq handler takes over from this point; wait for the</span>
<span class="cm">		 * transfer to complete */</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDENTIFY_TRANSFER</span><span class="p">;</span>
		<span class="n">ace_fsm_yieldirq</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_IDENTIFY_TRANSFER</span>:
		<span class="cm">/* Check that the sysace is ready to receive data */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_CFBSY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CFBSY set; t=%i iter=%i dc=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_iter_num</span><span class="p">,</span>
				<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="p">);</span>
			<span class="n">ace_fsm_yield</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_DATABUFRDY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ace_fsm_yield</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Transfer the next buffer */</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span><span class="o">-&gt;</span><span class="n">datain</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* If there are still buffers to be transfers; jump out here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ace_fsm_yieldirq</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* transfer finished; kick state machine */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;identify finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDENTIFY_COMPLETE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_IDENTIFY_COMPLETE</span>:
		<span class="n">ace_fix_driveid</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">cf_id</span><span class="p">);</span>
		<span class="n">ace_dump_mem</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">cf_id</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>	<span class="cm">/* Debug: Dump out disk ID */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_result</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Error occurred, disable the disk */</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">media_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">set_capacity</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error fetching CF id (%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_result</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">media_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Record disk parameters */</span>
			<span class="n">set_capacity</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">,</span>
				<span class="n">ata_id_u32</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">cf_id</span><span class="p">,</span> <span class="n">ATA_ID_LBA_CAPACITY</span><span class="p">));</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;capacity: %i sectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ata_id_u32</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">cf_id</span><span class="p">,</span> <span class="n">ATA_ID_LBA_CAPACITY</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* We&#39;re done, drop to IDLE state and notify waiters */</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDLE</span><span class="p">;</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_result</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_result</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_completion</span><span class="p">);</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_REQ_PREPARE</span>:
		<span class="n">req</span> <span class="o">=</span> <span class="n">ace_get_next_request</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">blk_start_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

		<span class="cm">/* Okay, it&#39;s a data request, set it up for transfer */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;request: sec=%llx hcnt=%x, ccnt=%x, dir=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">req</span><span class="p">),</span>
			<span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">req</span><span class="p">),</span>
			<span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">*</span> <span class="n">ACE_BUF_PER_SECTOR</span><span class="p">;</span>
		<span class="n">ace_out32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_MPULBA</span><span class="p">,</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0FFFFFFF</span><span class="p">);</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Kick off write request */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;write data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span> <span class="o">=</span> <span class="n">ACE_TASK_WRITE</span><span class="p">;</span>
			<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_SECCNTCMD</span><span class="p">,</span>
				<span class="n">count</span> <span class="o">|</span> <span class="n">ACE_SECCNTCMD_WRITE_DATA</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Kick off read request */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;read data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span> <span class="o">=</span> <span class="n">ACE_TASK_READ</span><span class="p">;</span>
			<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_SECCNTCMD</span><span class="p">,</span>
				<span class="n">count</span> <span class="o">|</span> <span class="n">ACE_SECCNTCMD_READ_DATA</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* As per datasheet, put config controller in reset */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">);</span>
		<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">val</span> <span class="o">|</span> <span class="n">ACE_CTRL_CFGRESET</span><span class="p">);</span>

		<span class="cm">/* Move to the transfer state.  The systemace will raise</span>
<span class="cm">		 * an interrupt once there is something to do</span>
<span class="cm">		 */</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_REQ_TRANSFER</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span> <span class="o">==</span> <span class="n">ACE_TASK_READ</span><span class="p">)</span>
			<span class="n">ace_fsm_yieldirq</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>	<span class="cm">/* wait for data ready */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_REQ_TRANSFER</span>:
		<span class="cm">/* Check that the sysace is ready to receive data */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_CFBSY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;CFBSY set; t=%i iter=%i c=%i dc=%i irq=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_iter_num</span><span class="p">,</span>
				<span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span>
				<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">in_irq</span><span class="p">);</span>
			<span class="n">ace_fsm_yield</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>	<span class="cm">/* need to poll CFBSY bit */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ACE_STATUS_DATABUFRDY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;DATABUF not set; t=%i iter=%i c=%i dc=%i irq=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_iter_num</span><span class="p">,</span>
				<span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span>
				<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">in_irq</span><span class="p">);</span>
			<span class="n">ace_fsm_yieldirq</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Transfer the next buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span> <span class="o">==</span> <span class="n">ACE_TASK_WRITE</span><span class="p">)</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span><span class="o">-&gt;</span><span class="n">dataout</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span><span class="o">-&gt;</span><span class="n">datain</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* If there are still buffers to be transfers; jump out here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ace_fsm_yieldirq</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* bio finished; is there another one? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__blk_end_request_cur</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* dev_dbg(ace-&gt;dev, &quot;next block; h=%u c=%u\n&quot;,</span>
<span class="cm">			 *      blk_rq_sectors(ace-&gt;req),</span>
<span class="cm">			 *      blk_rq_cur_sectors(ace-&gt;req));</span>
<span class="cm">			 */</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">ace_fsm_yieldirq</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_REQ_COMPLETE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACE_FSM_STATE_REQ_COMPLETE</span>:
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Finished request; go to idle state */</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span> <span class="o">=</span> <span class="n">ACE_FSM_STATE_IDLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_fsm_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Loop over state machine until told to stop */</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span><span class="p">)</span>
		<span class="n">ace_fsm_dostate</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_stall_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		 <span class="s">&quot;kicking stalled fsm; state=%i task=%i iter=%i dc=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_iter_num</span><span class="p">,</span>
		 <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Rearm the stall timer *before* entering FSM (which may then</span>
<span class="cm">	 * delete the timer) */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">stall_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="cm">/* Loop over state machine until told to stop */</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span><span class="p">)</span>
		<span class="n">ace_fsm_dostate</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Interrupt handling routines</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ace_interrupt_checkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sreg</span> <span class="o">=</span> <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">creg</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">);</span>

	<span class="cm">/* Check for error occurrence */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sreg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ACE_STATUS_CFGERROR</span> <span class="o">|</span> <span class="n">ACE_STATUS_CFCERROR</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">creg</span> <span class="o">&amp;</span> <span class="n">ACE_CTRL_ERRORIRQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;transfer failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ace_dump_regs</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ace_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">creg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="cm">/* be safe and get the lock */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">in_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* clear the interrupt */</span>
	<span class="n">creg</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">);</span>
	<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">creg</span> <span class="o">|</span> <span class="n">ACE_CTRL_RESETIRQ</span><span class="p">);</span>
	<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">creg</span><span class="p">);</span>

	<span class="cm">/* check for IO failures */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ace_interrupt_checkstate</span><span class="p">(</span><span class="n">ace</span><span class="p">))</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;spurious irq; stat=%.8x ctrl=%.8x cmd=%.4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_STATUS</span><span class="p">),</span> <span class="n">ace_in32</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">),</span>
			<span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_SECCNTCMD</span><span class="p">));</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fsm_task=%i fsm_state=%i data_count=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_task</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_state</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">data_count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Loop over state machine until told to stop */</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_continue_flag</span><span class="p">)</span>
		<span class="n">ace_fsm_dostate</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>

	<span class="cm">/* done with interrupt; drop the lock */</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">in_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Block ops</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ace_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">ace_get_next_request</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ace</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_tasklet</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ace_check_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clearing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_check_events(): %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">media_change</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">media_change</span> <span class="o">?</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ace_revalidate_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_revalidate_disk()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">media_change</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;requesting cf id and scheduling tasklet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_req_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_tasklet</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_completion</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;revalidate complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ace_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_open() users=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xsysace_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">users</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">check_disk_change</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xsysace_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ace_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_release() users=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xsysace_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">users</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">);</span>
		<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ACE_CTRL_LOCKREQ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xsysace_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ace_getgeo</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="n">geo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cf_id</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">cf_id</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_getgeo()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">heads</span>	<span class="o">=</span> <span class="n">cf_id</span><span class="p">[</span><span class="n">ATA_ID_HEADS</span><span class="p">];</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">sectors</span>	<span class="o">=</span> <span class="n">cf_id</span><span class="p">[</span><span class="n">ATA_ID_SECTORS</span><span class="p">];</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">cylinders</span>	<span class="o">=</span> <span class="n">cf_id</span><span class="p">[</span><span class="n">ATA_ID_CYLS</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">ace_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ace_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">ace_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_events</span> <span class="o">=</span> <span class="n">ace_check_events</span><span class="p">,</span>
	<span class="p">.</span><span class="n">revalidate_disk</span> <span class="o">=</span> <span class="n">ace_revalidate_disk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getgeo</span> <span class="o">=</span> <span class="n">ace_getgeo</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* --------------------------------------------------------------------</span>
<span class="cm"> * SystemACE device setup/teardown code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ace_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_setup(ace=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ace</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;physaddr=0x%llx irq=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">id_completion</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map the device</span>
<span class="cm">	 */</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the state machine tasklet and stall timer</span>
<span class="cm">	 */</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_tasklet</span><span class="p">,</span> <span class="n">ace_fsm_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ace</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">stall_timer</span><span class="p">,</span> <span class="n">ace_stall_timer</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ace</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the request queue</span>
<span class="cm">	 */</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">blk_init_queue</span><span class="p">(</span><span class="n">ace_request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_blk_initq</span><span class="p">;</span>
	<span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize GD structure</span>
<span class="cm">	 */</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">ACE_NUM_MINORS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_disk</span><span class="p">;</span>

	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">ace_major</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">*</span> <span class="n">ACE_NUM_MINORS</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ace_fops</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ace</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;xs%c&quot;</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>

	<span class="cm">/* set bus width */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">==</span> <span class="n">ACE_BUS_WIDTH_16</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 0x0101 should work regardless of endianess */</span>
		<span class="n">ace_out_le16</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_BUSMODE</span><span class="p">,</span> <span class="mh">0x0101</span><span class="p">);</span>

		<span class="cm">/* read it back to determine endianess */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ace_in_le16</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_BUSMODE</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0001</span><span class="p">)</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ace_reg_le16_ops</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ace_reg_be16_ops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ace_out_8</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_BUSMODE</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
		<span class="n">ace</span><span class="o">-&gt;</span><span class="n">reg_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ace_reg_8_ops</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure version register is sane */</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_VERSION</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_read</span><span class="p">;</span>

	<span class="cm">/* Put sysace in a sane state by clearing most control reg bits */</span>
	<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">ACE_CTRL_FORCECFGMODE</span> <span class="o">|</span>
		<span class="n">ACE_CTRL_DATABUFRDYIRQ</span> <span class="o">|</span> <span class="n">ACE_CTRL_ERRORIRQ</span><span class="p">);</span>

	<span class="cm">/* Now we can hook up the irq handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ace_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;systemace&quot;</span><span class="p">,</span> <span class="n">ace</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Failure - fall back to polled mode */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_irq failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Enable interrupts */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">ace_in</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">ACE_CTRL_DATABUFRDYIRQ</span> <span class="o">|</span> <span class="n">ACE_CTRL_ERRORIRQ</span><span class="p">;</span>
	<span class="n">ace_out</span><span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">ACE_CTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Print the identification */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Xilinx SystemACE revision %i.%i.%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">version</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span> <span class="p">(</span><span class="n">version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;physaddr 0x%llx, mapped to 0x%p, irq=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span><span class="p">,</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">media_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ace_revalidate_disk</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>

	<span class="cm">/* Make the sysace device &#39;live&#39; */</span>
	<span class="n">add_disk</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_read:</span>
	<span class="n">put_disk</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
<span class="nl">err_alloc_disk:</span>
	<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
<span class="nl">err_blk_initq:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span><span class="p">);</span>
<span class="nl">err_ioremap:</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;xsysace: error initializing device at 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ace</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">ace_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_gendisk</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
		<span class="n">put_disk</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">fsm_tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ace</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">ace</span><span class="o">-&gt;</span><span class="n">baseaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">ace_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">physaddr</span><span class="p">,</span>
	  <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_alloc(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">physaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_noreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate and initialize the ace device structure */</span>
	<span class="n">ace</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ace_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">physaddr</span> <span class="o">=</span> <span class="n">physaddr</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">ace</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">bus_width</span><span class="p">;</span>

	<span class="cm">/* Call the setup code */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ace_setup</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ace</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_setup:</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
<span class="nl">err_alloc:</span>
<span class="nl">err_noreg:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not initialize device, err=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">ace_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ace_device</span> <span class="o">*</span><span class="n">ace</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_free(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ace_teardown</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
		<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ace</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Platform Bus Support</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ace_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resource_size_t</span> <span class="n">physaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bus_width</span> <span class="o">=</span> <span class="n">ACE_BUS_WIDTH_16</span><span class="p">;</span> <span class="cm">/* FIXME: should not be hard coded */</span>
	<span class="n">u32</span> <span class="n">id</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ace_probe(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* device id and bus width */</span>
	<span class="n">of_property_read_u32</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;port-number&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_find_property</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;8-bit&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">bus_width</span> <span class="o">=</span> <span class="n">ACE_BUS_WIDTH_8</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_resources</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span>
			<span class="n">physaddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IRQ</span><span class="p">)</span>
			<span class="n">irq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Call the bus-independent setup code */</span>
	<span class="k">return</span> <span class="n">ace_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">physaddr</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">bus_width</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Platform bus remove() method</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">ace_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ace_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_OF)</span>
<span class="cm">/* Match table for of_platform binding */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ace_of_match</span><span class="p">[]</span> <span class="n">__devinitconst</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,opb-sysace-1.00.b&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,opb-sysace-1.00.c&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,xps-sysace-1.00.a&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;xlnx,sysace&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">ace_of_match</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_OF */</span><span class="cp"></span>
<span class="cp">#define ace_of_match NULL</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_OF */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ace_platform_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ace_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ace_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;xsysace&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">ace_of_match</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* ---------------------------------------------------------------------</span>
<span class="cm"> * Module init/exit routines</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ace_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ace_major</span> <span class="o">=</span> <span class="n">register_blkdev</span><span class="p">(</span><span class="n">ace_major</span><span class="p">,</span> <span class="s">&quot;xsysace&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ace_major</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_blk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace_platform_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_plat</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Xilinx SystemACE device driver, major=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ace_major</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_plat:</span>
	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">ace_major</span><span class="p">,</span> <span class="s">&quot;xsysace&quot;</span><span class="p">);</span>
<span class="nl">err_blk:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;xsysace: registration failed; err=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ace_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ace_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Unregistering Xilinx SystemACE driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ace_platform_driver</span><span class="p">);</span>
	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">ace_major</span><span class="p">,</span> <span class="s">&quot;xsysace&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ace_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
