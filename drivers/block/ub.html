<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › ub.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ub.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * The low performance USB storage driver (ub).</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)</span>
<span class="cm"> * Copyright (C) 2004 Pete Zaitcev (zaitcev@yahoo.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This work is a part of Linux kernel, is derived from it,</span>
<span class="cm"> * and is not licensed separately. See file COPYING for details.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO (sorted by decreasing priority)</span>
<span class="cm"> *  -- Return sense now that rq allows it (we always auto-sense anyway).</span>
<span class="cm"> *  -- set readonly flag for CDs, set removable flag for CF readers</span>
<span class="cm"> *  -- do inquiry and verify we got a disk and not a tape (for LUN mismatch)</span>
<span class="cm"> *  -- verify the 13 conditions and do bulk resets</span>
<span class="cm"> *  -- highmem</span>
<span class="cm"> *  -- move top_sense and work_bcs into separate allocations (if they survive)</span>
<span class="cm"> *     for cache purists and esoteric architectures.</span>
<span class="cm"> *  -- Allocate structure for LUN 0 before the first ub_sync_tur, avoid NULL. ?</span>
<span class="cm"> *  -- prune comments, they are too volumnous</span>
<span class="cm"> *  -- Resove XXX&#39;s</span>
<span class="cm"> *  -- CLEAR, CLR2STS, CLRRS seem to be ripe for refactoring.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb_usual.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>

<span class="cp">#define DRV_NAME &quot;ub&quot;</span>

<span class="cp">#define UB_MAJOR 180</span>

<span class="cm">/*</span>
<span class="cm"> * The command state machine is the key model for understanding of this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * The general rule is that all transitions are done towards the bottom</span>
<span class="cm"> * of the diagram, thus preventing any loops.</span>
<span class="cm"> *</span>
<span class="cm"> * An exception to that is how the STAT state is handled. A counter allows it</span>
<span class="cm"> * to be re-entered along the path marked with [C].</span>
<span class="cm"> *</span>
<span class="cm"> *       +--------+</span>
<span class="cm"> *       ! INIT   !</span>
<span class="cm"> *       +--------+</span>
<span class="cm"> *           !</span>
<span class="cm"> *        ub_scsi_cmd_start fails -&gt;--------------------------------------\</span>
<span class="cm"> *           !                                                            !</span>
<span class="cm"> *           V                                                            !</span>
<span class="cm"> *       +--------+                                                       !</span>
<span class="cm"> *       ! CMD    !                                                       !</span>
<span class="cm"> *       +--------+                                                       !</span>
<span class="cm"> *           !                                            +--------+      !</span>
<span class="cm"> *         was -EPIPE --&gt;--------------------------------&gt;! CLEAR  !      !</span>
<span class="cm"> *           !                                            +--------+      !</span>
<span class="cm"> *           !                                                !           !</span>
<span class="cm"> *         was error --&gt;------------------------------------- ! ---------&gt;\</span>
<span class="cm"> *           !                                                !           !</span>
<span class="cm"> *  /--&lt;-- cmd-&gt;dir == NONE ?                                 !           !</span>
<span class="cm"> *  !        !                                                !           !</span>
<span class="cm"> *  !        V                                                !           !</span>
<span class="cm"> *  !    +--------+                                           !           !</span>
<span class="cm"> *  !    ! DATA   !                                           !           !</span>
<span class="cm"> *  !    +--------+                                           !           !</span>
<span class="cm"> *  !        !                           +---------+          !           !</span>
<span class="cm"> *  !      was -EPIPE --&gt;---------------&gt;! CLR2STS !          !           !</span>
<span class="cm"> *  !        !                           +---------+          !           !</span>
<span class="cm"> *  !        !                                !               !           !</span>
<span class="cm"> *  !        !                              was error --&gt;---- ! ---------&gt;\</span>
<span class="cm"> *  !      was error --&gt;--------------------- ! ------------- ! ---------&gt;\</span>
<span class="cm"> *  !        !                                !               !           !</span>
<span class="cm"> *  !        V                                !               !           !</span>
<span class="cm"> *  \---&gt;+--------+                           !               !           !</span>
<span class="cm"> *       ! STAT   !&lt;--------------------------/               !           !</span>
<span class="cm"> *  /---&gt;+--------+                                           !           !</span>
<span class="cm"> *  !        !                                                !           !</span>
<span class="cm"> * [C]     was -EPIPE --&gt;-----------\                         !           !</span>
<span class="cm"> *  !        !                      !                         !           !</span>
<span class="cm"> *  +&lt;---- len == 0                 !                         !           !</span>
<span class="cm"> *  !        !                      !                         !           !</span>
<span class="cm"> *  !      was error --&gt;--------------------------------------!----------&gt;\</span>
<span class="cm"> *  !        !                      !                         !           !</span>
<span class="cm"> *  +&lt;---- bad CSW                  !                         !           !</span>
<span class="cm"> *  +&lt;---- bad tag                  !                         !           !</span>
<span class="cm"> *  !        !                      V                         !           !</span>
<span class="cm"> *  !        !                 +--------+                     !           !</span>
<span class="cm"> *  !        !                 ! CLRRS  !                     !           !</span>
<span class="cm"> *  !        !                 +--------+                     !           !</span>
<span class="cm"> *  !        !                      !                         !           !</span>
<span class="cm"> *  \------- ! --------------------[C]--------\               !           !</span>
<span class="cm"> *           !                                !               !           !</span>
<span class="cm"> *         cmd-&gt;error---\                +--------+           !           !</span>
<span class="cm"> *           !          +---------------&gt;! SENSE  !&lt;----------/           !</span>
<span class="cm"> *         STAT_FAIL----/                +--------+                       !</span>
<span class="cm"> *           !                                !                           V</span>
<span class="cm"> *           !                                V                      +--------+</span>
<span class="cm"> *           \--------------------------------\---------------------&gt;! DONE   !</span>
<span class="cm"> *                                                                   +--------+</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This many LUNs per USB device.</span>
<span class="cm"> * Every one of them takes a host, see UB_MAX_HOSTS.</span>
<span class="cm"> */</span>
<span class="cp">#define UB_MAX_LUNS   9</span>

<span class="cm">/*</span>
<span class="cm"> */</span>

<span class="cp">#define UB_PARTS_PER_LUN      8</span>

<span class="cp">#define UB_MAX_CDB_SIZE      16		</span><span class="cm">/* Corresponds to Bulk */</span><span class="cp"></span>

<span class="cp">#define UB_SENSE_SIZE  18</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ub_dev</span><span class="p">;</span>

<span class="cp">#define UB_MAX_REQ_SG	9	</span><span class="cm">/* cdrecord requires 32KB and maybe a header */</span><span class="cp"></span>
<span class="cp">#define UB_MAX_SECTORS 64</span>

<span class="cm">/*</span>
<span class="cm"> * A second is more than enough for a 32K transfer (UB_MAX_SECTORS)</span>
<span class="cm"> * even if a webcam hogs the bus, but some devices need time to spin up.</span>
<span class="cm"> */</span>
<span class="cp">#define UB_URB_TIMEOUT	(HZ*2)</span>
<span class="cp">#define UB_DATA_TIMEOUT	(HZ*5)	</span><span class="cm">/* ZIP does spin-ups in the data phase */</span><span class="cp"></span>
<span class="cp">#define UB_STAT_TIMEOUT	(HZ*5)	</span><span class="cm">/* Same spinups and eject for a dataless cmd. */</span><span class="cp"></span>
<span class="cp">#define UB_CTRL_TIMEOUT	(HZ/2)	</span><span class="cm">/* 500ms ought to be enough to clear a stall */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * An instance of a SCSI command in transit.</span>
<span class="cm"> */</span>
<span class="cp">#define UB_DIR_NONE	0</span>
<span class="cp">#define UB_DIR_READ	1</span>
<span class="cp">#define UB_DIR_ILLEGAL2	2</span>
<span class="cp">#define UB_DIR_WRITE	3</span>

<span class="cp">#define UB_DIR_CHAR(c)  (((c)==UB_DIR_WRITE)? &#39;w&#39;: \</span>
<span class="cp">			 (((c)==UB_DIR_READ)? &#39;r&#39;: &#39;n&#39;))</span>

<span class="k">enum</span> <span class="n">ub_scsi_cmd_state</span> <span class="p">{</span>
	<span class="n">UB_CMDST_INIT</span><span class="p">,</span>			<span class="cm">/* Initial state */</span>
	<span class="n">UB_CMDST_CMD</span><span class="p">,</span>			<span class="cm">/* Command submitted */</span>
	<span class="n">UB_CMDST_DATA</span><span class="p">,</span>			<span class="cm">/* Data phase */</span>
	<span class="n">UB_CMDST_CLR2STS</span><span class="p">,</span>		<span class="cm">/* Clearing before requesting status */</span>
	<span class="n">UB_CMDST_STAT</span><span class="p">,</span>			<span class="cm">/* Status phase */</span>
	<span class="n">UB_CMDST_CLEAR</span><span class="p">,</span>			<span class="cm">/* Clearing a stall (halt, actually) */</span>
	<span class="n">UB_CMDST_CLRRS</span><span class="p">,</span>			<span class="cm">/* Clearing before retrying status */</span>
	<span class="n">UB_CMDST_SENSE</span><span class="p">,</span>			<span class="cm">/* Sending Request Sense */</span>
	<span class="n">UB_CMDST_DONE</span>			<span class="cm">/* Final state */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cdb</span><span class="p">[</span><span class="n">UB_MAX_CDB_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cdb_len</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dir</span><span class="p">;</span>		<span class="cm">/* 0 - none, 1 - read, 3 - write. */</span>
	<span class="k">enum</span> <span class="n">ub_scsi_cmd_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>			<span class="cm">/* Return code - valid upon done */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">act_len</span><span class="p">;</span>		<span class="cm">/* Return size */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">key</span><span class="p">,</span> <span class="n">asc</span><span class="p">,</span> <span class="n">ascq</span><span class="p">;</span>	<span class="cm">/* May be valid if error==-EIO */</span>

	<span class="kt">int</span> <span class="n">stat_count</span><span class="p">;</span>			<span class="cm">/* Retries getting status. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeo</span><span class="p">;</span>		<span class="cm">/* jiffies until rq-&gt;timeout changes */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>		<span class="cm">/* Requested length */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nsg</span><span class="p">;</span>		<span class="cm">/* sgv[nsg] */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sgv</span><span class="p">[</span><span class="n">UB_MAX_REQ_SG</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">back</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ub_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_try</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nsg</span><span class="p">;</span>		<span class="cm">/* sgv[nsg] */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sgv</span><span class="p">[</span><span class="n">UB_MAX_REQ_SG</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ub_capacity</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsec</span><span class="p">;</span>		<span class="cm">/* Linux size - 512 byte sectors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bsize</span><span class="p">;</span>		<span class="cm">/* Linux hardsect_size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bshift</span><span class="p">;</span>		<span class="cm">/* Shift between 512 and hard sects */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is a direct take-off from linux/include/completion.h</span>
<span class="cm"> * The difference is that I do not wait on this thing, just poll.</span>
<span class="cm"> * When I want to wait (ub_probe), I just use the stock completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that INIT_COMPLETION takes no lock. It is correct. But why</span>
<span class="cm"> * in the bloody hell that thing takes struct instead of pointer to struct</span>
<span class="cm"> * is quite beyond me. I just copied it from the stock completion.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ub_completion</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ub_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ub_init_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define UB_INIT_COMPLETION(x)	((x).done = 0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_is_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ub_scsi_cmd_queue</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">qlen</span><span class="p">,</span> <span class="n">qmax</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The block device instance (one per LUN).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ub_lun</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>				<span class="cm">/* Host index */</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>			<span class="cm">/* LUN number */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">changed</span><span class="p">;</span>			<span class="cm">/* Media was changed */</span>
	<span class="kt">int</span> <span class="n">removable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">readonly</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ub_request</span> <span class="n">urq</span><span class="p">;</span>

	<span class="cm">/* Use Ingo&#39;s mempool if or when we have more than one command. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Currently we never need more than one command for the whole device.</span>
<span class="cm">	 * However, giving every LUN a command is a cheap and automatic way</span>
<span class="cm">	 * to enforce fairness between them.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">cmda</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="n">cmdv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">ub_capacity</span> <span class="n">capacity</span><span class="p">;</span> 
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The USB device instance.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ub_dev</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">poison</span><span class="p">;</span>		<span class="cm">/* The USB device is disconnected */</span>
	<span class="kt">int</span> <span class="n">openc</span><span class="p">;</span>			<span class="cm">/* protected by ub_lock! */</span>
					<span class="cm">/* kref is too implicit for our taste */</span>
	<span class="kt">int</span> <span class="n">reset</span><span class="p">;</span>			<span class="cm">/* Reset is running */</span>
	<span class="kt">int</span> <span class="n">bad_resid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tagcnt</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">luns</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">send_bulk_pipe</span><span class="p">;</span>	<span class="cm">/* cached pipe values */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recv_bulk_pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">send_ctrl_pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recv_ctrl_pipe</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ub_scsi_cmd_queue</span> <span class="n">cmd_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="n">top_rqs_cmd</span><span class="p">;</span>	<span class="cm">/* REQUEST SENSE */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">top_sense</span><span class="p">[</span><span class="n">UB_SENSE_SIZE</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">ub_completion</span> <span class="n">work_done</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="n">work_urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">work_timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_pipe</span><span class="p">;</span>			<span class="cm">/* What might need clearing */</span>
	<span class="n">__le32</span> <span class="n">signature</span><span class="p">;</span>		<span class="cm">/* Learned signature */</span>
	<span class="k">struct</span> <span class="n">bulk_cb_wrap</span> <span class="n">work_bcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bulk_cs_wrap</span> <span class="n">work_bcs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="n">work_cr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_work</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">reset_wait</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_request_fn_1</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_cmd_build_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_cmd_build_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_rw_cmd_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_end_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_rw_cmd_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_submit_scsi</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_urb_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_scsi_action</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_scsi_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_scsi_urb_compl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_data_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_state_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__ub_state_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_state_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_state_stat_counted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_state_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_submit_clear_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">stalled_pipe</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_top_sense_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_reset_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">try</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ub_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_sync_tur</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_sync_read_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_capacity</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_sync_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_probe_clear_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stalled_pipe</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_probe_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_USB_LIBUSUAL</span>

<span class="cp">#define ub_usb_ids  usb_storage_usb_ids</span>
<span class="cp">#else</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">ub_usb_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">USB_INTERFACE_INFO</span><span class="p">(</span><span class="n">USB_CLASS_MASS_STORAGE</span><span class="p">,</span> <span class="n">USB_SC_SCSI</span><span class="p">,</span> <span class="n">USB_PR_BULK</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">ub_usb_ids</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_LIBUSUAL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Find me a way to identify &quot;next free minor&quot; for add_disk(),</span>
<span class="cm"> * and the array disappears the next day. However, the number of</span>
<span class="cm"> * hosts has something to do with the naming and /proc/partitions.</span>
<span class="cm"> * This has to be thought out in detail before changing.</span>
<span class="cm"> * If UB_MAX_HOST was 1000, we&#39;d use a bitmap. Or a better data structure.</span>
<span class="cm"> */</span>
<span class="cp">#define UB_MAX_HOSTS  26</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">ub_hostv</span><span class="p">[</span><span class="n">UB_MAX_HOSTS</span><span class="p">];</span>

<span class="cp">#define UB_QLOCK_NUM 5</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">ub_qlockv</span><span class="p">[</span><span class="n">UB_QLOCK_NUM</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ub_qlock_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ub_lock</span><span class="p">);</span>	<span class="cm">/* Locks globals and -&gt;openc */</span>

<span class="cm">/*</span>
<span class="cm"> * The id allocator.</span>
<span class="cm"> *</span>
<span class="cm"> * This also stores the host for indexing by minor, which is somewhat dirty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_id_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UB_MAX_HOSTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ub_hostv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ub_hostv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_id_put</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&gt;=</span> <span class="n">UB_MAX_HOSTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: bad host ID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ub_hostv</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: freeing free host ID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ub_hostv</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is necessitated by the fact that blk_cleanup_queue does not</span>
<span class="cm"> * necesserily destroy the queue. Instead, it may merely decrease q-&gt;refcnt.</span>
<span class="cm"> * Since our blk_init_queue() passes a spinlock common with ub_dev,</span>
<span class="cm"> * we have life time issues when ub_cleanup frees ub_dev.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="nf">ub_next_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ub_qlockv</span><span class="p">[</span><span class="n">ub_qlock_next</span><span class="p">];</span>
	<span class="n">ub_qlock_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ub_qlock_next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">UB_QLOCK_NUM</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Downcount for deallocation. This rides on two assumptions:</span>
<span class="cm"> *  - once something is poisoned, its refcount cannot grow</span>
<span class="cm"> *  - opens cannot happen at this time (del_gendisk was done)</span>
<span class="cm"> * If the above is true, we can drop the lock, which we need for</span>
<span class="cm"> * blk_cleanup_queue(): the silly thing may attempt to sleep.</span>
<span class="cm"> * [Actually, it never needs to sleep for us, but it calls might_sleep()]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">--</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">openc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">openc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ub_cleanup</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Final cleanup and deallocation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="cm">/* I don&#39;t think queue can be NULL. But... Stolen from sx8.c */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we zero disk-&gt;private_data BEFORE put_disk, we have</span>
<span class="cm">		 * to check for NULL all over the place in open, release,</span>
<span class="cm">		 * check_media and revalidate, because the block level</span>
<span class="cm">		 * semaphore is well inside the put_disk.</span>
<span class="cm">		 * But we cannot zero after the call, because *disk is gone.</span>
<span class="cm">		 * The sd.c is blatantly racy in this area.</span>
<span class="cm">		 */</span>
		<span class="cm">/* disk-&gt;private_data = NULL; */</span>
		<span class="n">put_disk</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>
		<span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">ub_id_put</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;command allocator&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="nf">ub_get_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">cmda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">cmdv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">cmda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_put_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">cmdv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: releasing a foreign cmd %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">lun</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">cmda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: releasing a free cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">cmda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The command queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_cmdq_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd_queue</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">qmax</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">qmax</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_cmdq_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd_queue</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">qmax</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">qmax</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="nf">ub_cmdq_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd_queue</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmd_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ub_cmdq_peek(sc)  ((sc)-&gt;cmd_queue.head)</span>

<span class="cm">/*</span>
<span class="cm"> * The request function is our main entry point</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_request_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">rq</span> <span class="o">=</span> <span class="n">blk_peek_request</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ub_request_fn_1</span><span class="p">(</span><span class="n">lun</span><span class="p">,</span> <span class="n">rq</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blk_stop_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_request_fn_1</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_elem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">blk_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">ub_end_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">!=</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">ub_end_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">urq</span><span class="p">.</span><span class="n">rq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ub_get_cmd</span><span class="p">(</span><span class="n">lun</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_scsi_cmd</span><span class="p">));</span>

	<span class="n">blk_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">urq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">urq</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">urq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_request</span><span class="p">));</span>
	<span class="n">urq</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * get scatterlist from block layer</span>
<span class="cm">	 */</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urq</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">UB_MAX_REQ_SG</span><span class="p">);</span>
	<span class="n">n_elem</span> <span class="o">=</span> <span class="n">blk_rq_map_sg</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">urq</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_elem</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Impossible, because blk_rq_map_sg should not hit ENOMEM. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: failed request map (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">lun</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">n_elem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_elem</span> <span class="o">&gt;</span> <span class="n">UB_MAX_REQ_SG</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Paranoia */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: request with %d segments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">lun</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">n_elem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">urq</span><span class="o">-&gt;</span><span class="n">nsg</span> <span class="o">=</span> <span class="n">n_elem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ub_cmd_build_packet</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">urq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ub_cmd_build_block</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">urq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_INIT</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">ub_rw_cmd_done</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">urq</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">tagcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ub_submit_scsi</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="n">ub_put_cmd</span><span class="p">(</span><span class="n">lun</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">ub_end_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_cmd_build_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">nblks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_WRITE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_READ</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nsg</span> <span class="o">=</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">nsg</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">,</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">)</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nsg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * build the command</span>
<span class="cm">	 *</span>
<span class="cm">	 * The call to blk_queue_logical_block_size() guarantees that request</span>
<span class="cm">	 * is aligned, but it is given in terms of 512 byte units, always.</span>
<span class="cm">	 */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bshift</span><span class="p">;</span>
	<span class="n">nblks</span> <span class="o">=</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bshift</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="n">UB_DIR_READ</span><span class="p">)</span><span class="o">?</span> <span class="n">READ_10</span><span class="o">:</span> <span class="n">WRITE_10</span><span class="p">;</span>
	<span class="cm">/* 10-byte uses 4 bytes of LBA: 2147483648KB, 2097152MB, 2048GB */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">nblks</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">nblks</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_cmd_build_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_WRITE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_READ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nsg</span> <span class="o">=</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">nsg</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">,</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">)</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nsg</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * To reapply this to every URB is not as incorrect as it looks.</span>
<span class="cm">	 * In return, we avoid any complicated tracking calculations.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timeo</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_rw_cmd_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scsi_status</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span> <span class="o">&gt;=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">resid_len</span><span class="p">)</span>
				<span class="n">rq</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">rq</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">-=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span><span class="p">;</span>
			<span class="n">scsi_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">scsi_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* UB_SENSE_SIZE is smaller than SCSI_SENSE_BUFFERSIZE */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">top_sense</span><span class="p">,</span> <span class="n">UB_SENSE_SIZE</span><span class="p">);</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="n">UB_SENSE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">top_sense</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">MEDIUM_ERROR</span> <span class="o">||</span>
			     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ub_rw_cmd_retry</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">urq</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">urq</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ub_put_cmd</span><span class="p">(</span><span class="n">lun</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">ub_end_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">scsi_status</span><span class="p">);</span>
	<span class="n">blk_start_queue</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_end_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scsi_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">scsi_status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_rw_cmd_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_request</span> <span class="o">*</span><span class="n">urq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">ub_reset_enter</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">current_try</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urq</span><span class="o">-&gt;</span><span class="n">current_try</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">urq</span><span class="o">-&gt;</span><span class="n">current_try</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Remove this if anyone complains of flooding. */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: dir %c len/act %d/%d &quot;</span>
	    <span class="s">&quot;[sense %x %02x %02x] retry %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">UB_DIR_CHAR</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span><span class="p">,</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">asc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ascq</span><span class="p">,</span> <span class="n">urq</span><span class="o">-&gt;</span><span class="n">current_try</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_scsi_cmd</span><span class="p">));</span>
	<span class="n">ub_cmd_build_block</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">urq</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_INIT</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">ub_rw_cmd_done</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">urq</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">tagcnt</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"> /* Wasteful */</span>
<span class="c">	return ub_submit_scsi(sc, cmd);</span>
<span class="cp">#else</span>
	<span class="n">ub_cmdq_add</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Submit a regular SCSI operation (not an auto-sense).</span>
<span class="cm"> *</span>
<span class="cm"> * The Iron Law of Good Submit Routine is:</span>
<span class="cm"> * Zero return - callback is done, Nonzero return - callback is not done.</span>
<span class="cm"> * No exceptions.</span>
<span class="cm"> *</span>
<span class="cm"> * Host is assumed locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_submit_scsi</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UB_CMDST_INIT</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">!=</span> <span class="n">UB_DIR_NONE</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ub_cmdq_add</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can call ub_scsi_dispatch(sc) right away here, but it&#39;s a little</span>
<span class="cm">	 * safer to jump to a tasklet, in case upper layers do something silly.</span>
<span class="cm">	 */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Submit the first URB for the queued command.</span>
<span class="cm"> * This function does not deal with queueing in any way.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_scsi_cmd_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bulk_cb_wrap</span> <span class="o">*</span><span class="n">bcb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">bcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_bcb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ``If the allocation length is eighteen or greater, and a device</span>
<span class="cm">	 * server returns less than eithteen bytes of data, the application</span>
<span class="cm">	 * client should assume that the bytes not transferred would have been</span>
<span class="cm">	 * zeroes had the device server returned those bytes.&#39;&#39;</span>
<span class="cm">	 *</span>
<span class="cm">	 * We zero sense for all commands so that when a packet request</span>
<span class="cm">	 * fails it does not return a stale sense.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">top_sense</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UB_SENSE_SIZE</span><span class="p">);</span>

	<span class="cm">/* set up the command wrapper */</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">US_BULK_CB_SIGN</span><span class="p">);</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>		<span class="cm">/* Endianness is not important */</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">DataTransferLength</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="n">UB_DIR_READ</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Lun</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bcb</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">;</span>

	<span class="cm">/* copy the command payload */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bcb</span><span class="o">-&gt;</span><span class="n">CDB</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">UB_MAX_CDB_SIZE</span><span class="p">);</span>

	<span class="n">UB_INIT_COMPLETION</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">;</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">,</span>
	    <span class="n">bcb</span><span class="p">,</span> <span class="n">US_BULK_CB_WRAP_LEN</span><span class="p">,</span> <span class="n">ub_urb_complete</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX Clear stalls */</span>
		<span class="n">ub_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">UB_URB_TIMEOUT</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_CMD</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Timeout handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_urb_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ub_is_completed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">))</span>
		<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Completion routine for the work URB.</span>
<span class="cm"> *</span>
<span class="cm"> * This can be called directly from usb_submit_urb (while we have</span>
<span class="cm"> * the sc-&gt;lock taken) and from an interrupt (while we do NOT have</span>
<span class="cm"> * the sc-&gt;lock taken). Therefore, bounce this off to a tasklet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_urb_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">ub_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_scsi_action</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="p">)</span> <span class="n">_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ub_scsi_dispatch</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_scsi_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ub_cmdq_peek</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ub_cmdq_pop</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_INIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">ub_scsi_cmd_start</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_DONE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ub_is_completed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">);</span>
			<span class="n">ub_scsi_urb_compl</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_scsi_urb_compl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bulk_cs_wrap</span> <span class="o">*</span><span class="n">bcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">endp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">endp</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span><span class="p">))</span>
		<span class="n">endp</span> <span class="o">|=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_CLEAR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * STALL while clearning STALL.</span>
<span class="cm">			 * The control pipe clears itself - nothing to do.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: stall on control pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We ignore the result for the halt clear.</span>
<span class="cm">		 */</span>

		<span class="n">usb_reset_endpoint</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">endp</span><span class="p">);</span>

		<span class="n">ub_state_sense</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_CLR2STS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: stall on control pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We ignore the result for the halt clear.</span>
<span class="cm">		 */</span>

		<span class="n">usb_reset_endpoint</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">endp</span><span class="p">);</span>

		<span class="n">ub_state_stat</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_CLRRS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: stall on control pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We ignore the result for the halt clear.</span>
<span class="cm">		 */</span>

		<span class="n">usb_reset_endpoint</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">endp</span><span class="p">);</span>

		<span class="n">ub_state_stat_counted</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_CMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EOVERFLOW</span>:
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ub_submit_clear_stall</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: &quot;</span>
				    <span class="s">&quot;unable to submit clear (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * This is typically ENOMEM or some other such shit.</span>
<span class="cm">				 * Retrying is pointless. Just do Bad End on it...</span>
<span class="cm">				 */</span>
				<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_CLEAR</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* unplug */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EILSEQ</span>:		<span class="cm">/* unplug timeout on uhci */</span>
			<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">!=</span> <span class="n">US_BULK_CB_WRAP_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="n">UB_DIR_NONE</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nsg</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ub_state_stat</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>udelay(125);        // usb-storage has this</p></td><td class="code"><div class="highlight"><pre>		<span class="n">ub_data_start</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ub_submit_clear_stall</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: &quot;</span>
				    <span class="s">&quot;unable to submit clear (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_CLR2STS</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * A babble? Failure, but we must transfer CSW now.</span>
<span class="cm">			 */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>	<span class="cm">/* A cheap trick... */</span>
			<span class="n">ub_state_stat</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="n">UB_DIR_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Do not continue writes in case of a failure.</span>
<span class="cm">			 * Doing so would cause sectors to be mixed up,</span>
<span class="cm">			 * which is worse than sectors lost.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We must try to read the CSW, or many devices</span>
<span class="cm">			 * get confused.</span>
<span class="cm">			 */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="n">len</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="n">ub_state_stat</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If an error occurs on read, we record it, and</span>
<span class="cm">			 * continue to fetch data in order to avoid bubble.</span>
<span class="cm">			 *</span>
<span class="cm">			 * As a small shortcut, we stop if we detect that</span>
<span class="cm">			 * a CSW mixed into data.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="n">len</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span><span class="p">)</span> <span class="o">==</span> <span class="n">US_BULK_CS_WRAP_LEN</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span> <span class="o">+=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">current_sg</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nsg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ub_data_start</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ub_state_stat</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_STAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ub_submit_clear_stall</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: &quot;</span>
				    <span class="s">&quot;unable to submit clear (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Having a stall when getting CSW is an error, so</span>
<span class="cm">			 * make sure uppper levels are not oblivious to it.</span>
<span class="cm">			 */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>		<span class="cm">/* A cheap trick... */</span>

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_CLRRS</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Catch everything, including -EOVERFLOW and other nasties. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ub_state_stat_counted</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check the returned Bulk protocol status.</span>
<span class="cm">		 * The status block has to be validated first.</span>
<span class="cm">		 */</span>

		<span class="n">bcs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_bcs</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">signature</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is the first reply, so do not perform the check.</span>
<span class="cm">			 * Instead, remember the signature the device uses</span>
<span class="cm">			 * for future checks. But do not allow a nul.</span>
<span class="cm">			 */</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">signature</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Signature</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">signature</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ub_state_stat_counted</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Signature</span> <span class="o">!=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ub_state_stat_counted</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Tag</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This usually happens when we disagree with the</span>
<span class="cm">			 * device&#39;s microcode about something. For instance,</span>
<span class="cm">			 * a few of them throw this after timeouts. They buffer</span>
<span class="cm">			 * commands and reply at commands we timed out before.</span>
<span class="cm">			 * Without flushing these replies we loop forever.</span>
<span class="cm">			 */</span>
			<span class="n">ub_state_stat_counted</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">bad_resid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Residue</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Only start ignoring if this cmd ended well.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: &quot;</span>
					    <span class="s">&quot;bad residual %d of %d, ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
					<span class="n">sc</span><span class="o">-&gt;</span><span class="n">bad_resid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">US_BULK_STAT_OK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">US_BULK_STAT_FAIL</span>:
			<span class="n">ub_state_sense</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">US_BULK_STAT_PHASE</span>:
			<span class="k">goto</span> <span class="n">Bad_End</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: unknown CSW status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bcs</span><span class="o">-&gt;</span><span class="n">Status</span><span class="p">);</span>
			<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Not zeroing error to preserve a babble indicator */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ub_state_sense</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_DONE</span><span class="p">;</span>
		<span class="n">ub_cmdq_pop</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UB_CMDST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: wrong command state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">Bad_End:</span> <span class="cm">/* Little Excel is dead */</span>
	<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Factorization helper for the command state machine:</span>
<span class="cm"> * Initiate a data segment transfer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_data_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">current_sg</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">UB_INIT_COMPLETION</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="n">UB_DIR_READ</span><span class="p">)</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span>
	    <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">ub_urb_complete</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX Clear stalls */</span>
		<span class="n">ub_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>
		<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timeo</span><span class="p">)</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timeo</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">UB_DATA_TIMEOUT</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_DATA</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Factorization helper for the command state machine:</span>
<span class="cm"> * Finish the command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_state_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_DONE</span><span class="p">;</span>
	<span class="n">ub_cmdq_pop</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Factorization helper for the command state machine:</span>
<span class="cm"> * Submit a CSW read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ub_state_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">UB_INIT_COMPLETION</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">last_pipe</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">;</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">,</span>
	    <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_bcs</span><span class="p">,</span> <span class="n">US_BULK_CS_WRAP_LEN</span><span class="p">,</span> <span class="n">ub_urb_complete</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX Clear stalls */</span>
		<span class="n">ub_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>
		<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timeo</span><span class="p">)</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timeo</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">UB_STAT_TIMEOUT</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Factorization helper for the command state machine:</span>
<span class="cm"> * Submit a CSW read and go to STAT state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_state_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ub_state_stat</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stat_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_STAT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Factorization helper for the command state machine:</span>
<span class="cm"> * Submit a CSW read and go to STAT state with counter (along [C] path).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_state_stat_counted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stat_count</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ub_state_sense</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ub_state_stat</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_STAT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Factorization helper for the command state machine:</span>
<span class="cm"> * Submit a REQUEST SENSE and go to SENSE state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_state_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">top_rqs_cmd</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_scsi_cmd</span><span class="p">));</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">REQUEST_SENSE</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">UB_SENSE_SIZE</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_READ</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_INIT</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">nsg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">UB_MAX_REQ_SG</span><span class="p">);</span>
	<span class="n">sg_set_page</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">top_sense</span><span class="p">),</span> <span class="n">UB_SENSE_SIZE</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">top_sense</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">UB_SENSE_SIZE</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">ub_top_sense_done</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">tagcnt</span><span class="o">++</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_SENSE</span><span class="p">;</span>

	<span class="n">ub_cmdq_insert</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scmd</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">ub_state_done</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A helper for the command&#39;s state machine:</span>
<span class="cm"> * Submit a stall clear.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_submit_clear_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">stalled_pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">endp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">cr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">endp</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">stalled_pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span> <span class="p">(</span><span class="n">stalled_pipe</span><span class="p">))</span>
		<span class="n">endp</span> <span class="o">|=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>

	<span class="n">cr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_cr</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USB_ENDPOINT_HALT</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">endp</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">UB_INIT_COMPLETION</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>

	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">cr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ub_urb_complete</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ub_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">UB_CTRL_TIMEOUT</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_top_sense_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sense</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">top_sense</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the command which triggered the unit attention or a check,</span>
<span class="cm">	 * save the sense into it, and advance its state machine.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ub_cmdq_peek</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: sense done while idle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: &quot;</span>
		    <span class="s">&quot;sense done for wrong command 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UB_CMDST_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: sense done with bad cmd state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ignoring scmd-&gt;act_len, because the buffer was pre-zeroed.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">sense</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">asc</span> <span class="o">=</span> <span class="n">sense</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ascq</span> <span class="o">=</span> <span class="n">sense</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>

	<span class="n">ub_scsi_urb_compl</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset management</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_reset_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">try</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This happens often on multi-LUN devices. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">=</span> <span class="n">try</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"> /* Not needed because the disconnect waits for us. */</span>
<span class="c">	unsigned long flags;</span>
<span class="c">	spin_lock_irqsave(&amp;ub_lock, flags);</span>
<span class="c">	sc-&gt;openc++;</span>
<span class="c">	spin_unlock_irqrestore(&amp;ub_lock, flags);</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"> /* We let them stop themselves. */</span>
<span class="c">	struct ub_lun *lun;</span>
<span class="c">	list_for_each_entry(lun, &amp;sc-&gt;luns, link) {</span>
<span class="c">		blk_stop_queue(lun-&gt;disk-&gt;queue);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_dev</span><span class="p">,</span> <span class="n">reset_work</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Running reset unrequested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">))</span> <span class="p">{</span>
		<span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ub_sync_reset</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">700</span><span class="p">);</span>	<span class="cm">/* usb-storage sleeps 6s (!) */</span>
		<span class="n">ub_probe_clear_stall</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span><span class="p">);</span>
		<span class="n">ub_probe_clear_stall</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_lock_device_for_reset</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
			    <span class="s">&quot;%s: usb_lock_device_for_reset failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">usb_reset_device</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: &quot;</span>
				    <span class="s">&quot;usb_lock_device_for_reset failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">usb_unlock_device</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In theory, no commands can be running while reset is active,</span>
<span class="cm">	 * so nobody can ask for another reset, and so we do not need any</span>
<span class="cm">	 * queues of resets or anything. We do need a spinlock though,</span>
<span class="cm">	 * to interact with block layer.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk_start_queue</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset_wait</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * XXX Reset brackets are too much hassle to implement, so just stub them</span>
<span class="cm"> * in order to prevent forced unbinding (which deadlocks solid when our</span>
<span class="cm"> * -&gt;disconnect method waits for the reset to complete and this kills keventd).</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Tell Alan to move usb_unlock_device inside of usb_reset_device,</span>
<span class="cm"> * or else the post_reset is invoked, and restats I/O on a locked device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called from a process context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">readonly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* XXX Query this from the device */</span>

	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bsize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ub_sync_tur</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>			<span class="cm">/* Not ready */</span>
	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ub_sync_read_cap</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The retry here means something is wrong, either with the</span>
<span class="cm">		 * device, with the transport, or with our code.</span>
<span class="cm">		 * We keep this because sd.c has retries for capacity.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ub_sync_read_cap</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bsize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
			<span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The open funcion.</span>
<span class="cm"> * This is mostly needed to keep refcounting, but also to support</span>
<span class="cm"> * media checks on removable media drives.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_bd_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">openc</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">||</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">readonly</span><span class="p">)</span>
		<span class="n">check_disk_change</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The sd.c considers -&gt;media_present and -&gt;changed not equivalent,</span>
<span class="cm">	 * under some pretty murky conditions (a failure of READ CAPACITY).</span>
<span class="cm">	 * We may need it one day.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">&amp;&amp;</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NDELAY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEDIUM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_open</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">readonly</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_open</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_open:</span>
	<span class="n">ub_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_bd_unlocked_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ub_bd_open</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_bd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_mutex</span><span class="p">);</span>
	<span class="n">ub_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The ioctl interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_bd_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">usermem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scsi_cmd_blk_ioctl</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">usermem</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called by check_disk_change if we reported a media change.</span>
<span class="cm"> * The main onjective here is to discover the features of the media such as</span>
<span class="cm"> * the capacity, read-only status, etc. USB storage generally does not</span>
<span class="cm"> * need to be spun up, but if we needed it, this would be the place.</span>
<span class="cm"> *</span>
<span class="cm"> * This call can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The return code is not used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_bd_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">ub_revalidate</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>

	<span class="cm">/* XXX Support sector size switching like in sr.c */</span>
	<span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bsize</span><span class="p">);</span>
	<span class="n">set_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">nsec</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>set<em>disk</em>ro(sdkp->disk, lun->readonly);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The check is called by the block layer to verify if the media</span>
<span class="cm"> * is still available. It is supposed to be harmless, lightweight and</span>
<span class="cm"> * non-intrusive in case the media was not changed.</span>
<span class="cm"> *</span>
<span class="cm"> * This call can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The return code is bool!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ub_bd_check_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clearing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We clean checks always after every command, so this is not</span>
<span class="cm">	 * as dangerous as it looks. If the TEST_UNIT_READY fails here,</span>
<span class="cm">	 * the device is actually not ready with operator or software</span>
<span class="cm">	 * intervention required. One dangerous item might be a drive which</span>
<span class="cm">	 * spins itself down, and come the time to write dirty pages, this</span>
<span class="cm">	 * will fail, then block layer discards the data. Since we never</span>
<span class="cm">	 * spin drives up, such devices simply cannot be used with ub anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ub_sync_tur</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">lun</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lun</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">?</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">ub_bd_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ub_bd_unlocked_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">ub_bd_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">ub_bd_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_events</span>	<span class="o">=</span> <span class="n">ub_bd_check_events</span><span class="p">,</span>
	<span class="p">.</span><span class="n">revalidate_disk</span> <span class="o">=</span> <span class="n">ub_bd_revalidate</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Common -&gt;done routine for commands executed synchronously.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_probe_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">cop</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">cop</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test if the device has a check condition on it, synchronously.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_sync_tur</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">ALLOC_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_scsi_cmd</span><span class="p">)</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">compl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ALLOC_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEST_UNIT_READY</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_NONE</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_INIT</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>			<span class="cm">/* This may be NULL, but that&#39;s ok */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">ub_probe_done</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">tagcnt</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ub_submit_scsi</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_submit</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* Retries for benh&#39;s key */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>

<span class="nl">err_submit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="nl">err_alloc:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the SCSI capacity synchronously (for probing).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_sync_read_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">ub_capacity</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">ALLOC_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_scsi_cmd</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">compl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ALLOC_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_scsi_cmd</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x25</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">UB_DIR_READ</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_INIT</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">nsg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sgv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">UB_MAX_REQ_SG</span><span class="p">);</span>
	<span class="n">sg_set_page</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">ub_probe_done</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">tagcnt</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ub_submit_scsi</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_submit</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_read</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">act_len</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_read</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* sd.c special-cases sector size of 0 to mean 512. Needed? Safe? */</span>
	<span class="n">nsec</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bsize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bsize</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">512</span>:	<span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1024</span>:	<span class="n">shift</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2048</span>:	<span class="n">shift</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4096</span>:	<span class="n">shift</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_inv_bsize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span><span class="o">-&gt;</span><span class="n">bsize</span> <span class="o">=</span> <span class="n">bsize</span><span class="p">;</span>
	<span class="n">ret</span><span class="o">-&gt;</span><span class="n">bshift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">ret</span><span class="o">-&gt;</span><span class="n">nsec</span> <span class="o">=</span> <span class="n">nsec</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_inv_bsize:</span>
<span class="nl">err_read:</span>
<span class="nl">err_submit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="nl">err_alloc:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_probe_urb_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">cop</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">cop</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_probe_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">cop</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">cop</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset with a Bulk reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_sync_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ifnum</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">cr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">compl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">cr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_cr</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">US_BULK_RESET_REQUEST</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ifnum</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">cr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ub_probe_urb_complete</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		     <span class="s">&quot;%s: Unable to submit a bulk reset (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ub_probe_timeout</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">UB_CTRL_TIMEOUT</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get number of LUNs by the way of Bulk GetMaxLUN command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_sync_getmaxlun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ifnum</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">ALLOC_SIZE</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">cr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">compl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nluns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ALLOC_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">55</span><span class="p">;</span>

	<span class="n">cr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_cr</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">US_BULK_GET_MAX_LUN</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ifnum</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span><span class="p">,</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">cr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ub_probe_urb_complete</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_submit</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ub_probe_timeout</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">UB_CTRL_TIMEOUT</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">.</span><span class="n">status</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_io</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">.</span><span class="n">actual_length</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nluns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nluns</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">55</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nluns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  			<span class="cm">/* GetMaxLUN returns the maximum LUN number */</span>
			<span class="n">nluns</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nluns</span> <span class="o">&gt;</span> <span class="n">UB_MAX_LUNS</span><span class="p">)</span>
				<span class="n">nluns</span> <span class="o">=</span> <span class="n">UB_MAX_LUNS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nluns</span><span class="p">;</span>

<span class="nl">err_io:</span>
<span class="nl">err_submit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">err_alloc:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear initial stalls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_probe_clear_stall</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stalled_pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">endp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="n">cr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">compl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">endp</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">stalled_pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pipein</span> <span class="p">(</span><span class="n">stalled_pipe</span><span class="p">))</span>
		<span class="n">endp</span> <span class="o">|=</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>

	<span class="n">cr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_cr</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="n">USB_REQ_CLEAR_FEATURE</span><span class="p">;</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USB_ENDPOINT_HALT</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">endp</span><span class="p">);</span>
	<span class="n">cr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span><span class="p">,</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">cr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ub_probe_urb_complete</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		     <span class="s">&quot;%s: Unable to submit a probe clear (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ub_probe_timeout</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">compl</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">UB_CTRL_TIMEOUT</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compl</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">);</span>

	<span class="n">usb_reset_endpoint</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">endp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the pipe settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_get_pipes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">altsetting</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep_out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the endpoints we need.</span>
<span class="cm">	 * We are expecting a minimum of 2 endpoints - in and out (bulk).</span>
<span class="cm">	 * We will ignore any others.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

		<span class="cm">/* Is it a BULK endpoint? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_xfer_bulk</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* BULK in or out? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ep_in</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="n">ep_in</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ep_out</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="n">ep_out</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep_in</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ep_out</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: failed endpoint check</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate and store the pipe values */</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_ctrl_pipe</span> <span class="o">=</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">recv_ctrl_pipe</span> <span class="o">=</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">send_bulk_pipe</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">ep_out</span><span class="p">));</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">recv_bulk_pipe</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> 
		<span class="n">usb_endpoint_num</span><span class="p">(</span><span class="n">ep_in</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probing is done in the process context, which allows us to cheat</span>
<span class="cm"> * and not to build a state machine for the discovery.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nluns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_usual_check_type</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">USB_US_TYPE_UB</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_core</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">ub_next_lock</span><span class="p">();</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">);</span>
	<span class="n">usb_init_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">ub_scsi_action</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset_work</span><span class="p">,</span> <span class="n">ub_reset_task</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset_wait</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sc</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ub_urb_timeout</span><span class="p">;</span>

	<span class="n">ub_init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_done</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* A little yuk, but oh well... */</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>sc->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">usb_get_dev</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since we give the interface struct to the block level through</span>
<span class="cm">	 * disk-&gt;driverfs_dev, we have to pin it. Otherwise, block_uevent</span>
<span class="cm">	 * oopses on close after a disconnect (kernels 2.6.16 and up).</span>
<span class="cm">	 */</span>
	<span class="n">usb_get_intf</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot;(%d.%d)&quot;</span><span class="p">,</span>
	    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>

	<span class="cm">/* XXX Verify that we can handle the device (from descriptors) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ub_get_pipes</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_dev_desc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, all USB initialization is done, do upper layer.</span>
<span class="cm">	 * We really hate halfway initialized structures, so from the</span>
<span class="cm">	 * invariants perspective, this ub_dev is fully constructed at</span>
<span class="cm">	 * this point.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is needed to clear toggles. It is a problem only if we do</span>
<span class="cm">	 * `rmmod ub &amp;&amp; modprobe ub` without disconnects, but we like that.</span>
<span class="cm">	 */</span>
<span class="cp">#if 0</span><span class="c"> /* iPod Mini fails if we do this (big white iPod works) */</span>
<span class="c">	ub_probe_clear_stall(sc, sc-&gt;recv_bulk_pipe);</span>
<span class="c">	ub_probe_clear_stall(sc, sc-&gt;send_bulk_pipe);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The way this is used by the startup code is a little specific.</span>
<span class="cm">	 * A SCSI check causes a USB stall. Our common case code sees it</span>
<span class="cm">	 * and clears the check, after which the device is ready for use.</span>
<span class="cm">	 * But if a check was not present, any command other than</span>
<span class="cm">	 * TEST_UNIT_READY ends with a lockup (including REQUEST_SENSE).</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we neglect to clear the SCSI check, the first real command fails</span>
<span class="cm">	 * (which is the capacity readout). We clear that and retry, but why</span>
<span class="cm">	 * causing spurious retries for no reason.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Revalidation may start with its own TEST_UNIT_READY, but that one</span>
<span class="cm">	 * has to succeed, so we clear checks with an additional one here.</span>
<span class="cm">	 * In any case it&#39;s not our business how revaliadation is implemented.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* Retries for the schwag key from KS&#39;04 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">ub_sync_tur</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mh">0x6</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nluns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">ub_sync_getmaxlun</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nluns</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nluns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ub_probe_lun</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_dev_desc:</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="nl">err_core:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ub_probe_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lun</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ub_lun</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">ub_id_get</span><span class="p">())</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_id</span><span class="p">;</span>

	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot;%c(%d.%d.%d)&quot;</span><span class="p">,</span>
	    <span class="n">lun</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>

	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">removable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* XXX Query this from the device */</span>
	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* ub_revalidate clears only */</span>
	<span class="n">ub_revalidate</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">disk</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">UB_PARTS_PER_LUN</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_diskalloc</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="n">DRV_NAME</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">UB_MAJOR</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">*</span> <span class="n">UB_PARTS_PER_LUN</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ub_bd_fops</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">blk_init_queue</span><span class="p">(</span><span class="n">ub_request_fn</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_blkqinit</span><span class="p">;</span>

	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

	<span class="n">blk_queue_bounce_limit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">BLK_BOUNCE_HIGH</span><span class="p">);</span>
	<span class="n">blk_queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">UB_MAX_REQ_SG</span><span class="p">);</span>
	<span class="n">blk_queue_segment_boundary</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>	<span class="cm">/* Dubious. */</span>
	<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">UB_MAX_SECTORS</span><span class="p">);</span>
	<span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">bsize</span><span class="p">);</span>

	<span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">=</span> <span class="n">disk</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">);</span>

	<span class="n">set_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">lun</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">.</span><span class="n">nsec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span>
		<span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GENHD_FL_REMOVABLE</span><span class="p">;</span>

	<span class="n">add_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_blkqinit:</span>
	<span class="n">put_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
<span class="nl">err_diskalloc:</span>
	<span class="n">ub_id_put</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="nl">err_id:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lun</span><span class="p">);</span>
<span class="nl">err_alloc:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ub_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ub_dev</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ub_lun</span> <span class="o">*</span><span class="n">lun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent ub_bd_release from pulling the rug from under us.</span>
<span class="cm">	 * XXX This is starting to look like a kref.</span>
<span class="cm">	 * XXX Why not to take this ref at probe time?</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">openc</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fence stall clearings, operations triggered by unlinkings and so on.</span>
<span class="cm">	 * We do not attempt to unlink any URBs, because we do not trust the</span>
<span class="cm">	 * unlink paths in HC drivers. Also, we get -84 upon disconnect anyway.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">poison</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for reset to end, if any.</span>
<span class="cm">	 */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Blow away queued commands.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Actually, this never works, because before we get here</span>
<span class="cm">	 * the HCD terminates outstanding URB(s). It causes our</span>
<span class="cm">	 * SCSI command queue to advance, commands fail to submit,</span>
<span class="cm">	 * and the whole queue drains. So, we just use this code to</span>
<span class="cm">	 * print warnings.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ub_scsi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ub_cmdq_peek</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UB_CMDST_DONE</span><span class="p">;</span>
			<span class="n">ub_cmdq_pop</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: &quot;</span>
			    <span class="s">&quot;%d was queued after shutdown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unregister the upper layer.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">luns</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_gendisk</span><span class="p">(</span><span class="n">lun</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * I wish I could do:</span>
<span class="cm">		 *    queue_flag_set(QUEUE_FLAG_DEAD, q);</span>
<span class="cm">		 * As it is, we rely on our internal poisoning and let</span>
<span class="cm">		 * the upper levels to spin furiously failing all the I/O.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Testing for -EINPROGRESS is always a bug, so we are bending</span>
<span class="cm">	 * the rules a little.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_urb</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* janitors: ignore */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: &quot;</span>
		    <span class="s">&quot;URB is active after disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is virtually no chance that other CPU runs a timeout so long</span>
<span class="cm">	 * after ub_urb_complete should have called del_timer, but only if HCD</span>
<span class="cm">	 * didn&#39;t forget to deliver a callback on unlink.</span>
<span class="cm">	 */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">work_timer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point there must be no commands coming from anyone</span>
<span class="cm">	 * and no URBs left in transit.</span>
<span class="cm">	 */</span>

	<span class="n">ub_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">ub_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;ub&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">ub_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">ub_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">ub_usb_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span>	<span class="n">ub_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span>	<span class="n">ub_post_reset</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ub_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;&#39;Low Performance USB Block&#39; driver is deprecated. &quot;</span>
			<span class="s">&quot;Please switch to usb-storage</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UB_QLOCK_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_qlockv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">register_blkdev</span><span class="p">(</span><span class="n">UB_MAJOR</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_regblkdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">usb_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_driver</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>

	<span class="n">usb_usual_set_present</span><span class="p">(</span><span class="n">USB_US_TYPE_UB</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">UB_MAJOR</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
<span class="nl">err_regblkdev:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ub_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub_driver</span><span class="p">);</span>

	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">UB_MAJOR</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="n">usb_usual_clear_present</span><span class="p">(</span><span class="n">USB_US_TYPE_UB</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ub_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ub_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
