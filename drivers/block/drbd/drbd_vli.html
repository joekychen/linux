<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › drbd › drbd_vli.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>drbd_vli.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">-*- linux-c -*-</span>
<span class="cm">   drbd_receiver.c</span>
<span class="cm">   This file is part of DRBD by Philipp Reisner and Lars Ellenberg.</span>

<span class="cm">   Copyright (C) 2001-2008, LINBIT Information Technologies GmbH.</span>
<span class="cm">   Copyright (C) 1999-2008, Philipp Reisner &lt;philipp.reisner@linbit.com&gt;.</span>
<span class="cm">   Copyright (C) 2002-2008, Lars Ellenberg &lt;lars.ellenberg@linbit.com&gt;.</span>

<span class="cm">   drbd is free software; you can redistribute it and/or modify</span>
<span class="cm">   it under the terms of the GNU General Public License as published by</span>
<span class="cm">   the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm">   any later version.</span>

<span class="cm">   drbd is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">   GNU General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU General Public License</span>
<span class="cm">   along with drbd; see the file COPYING.  If not, write to</span>
<span class="cm">   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DRBD_VLI_H</span>
<span class="cp">#define _DRBD_VLI_H</span>

<span class="cm">/*</span>
<span class="cm"> * At a granularity of 4KiB storage represented per bit,</span>
<span class="cm"> * and stroage sizes of several TiB,</span>
<span class="cm"> * and possibly small-bandwidth replication,</span>
<span class="cm"> * the bitmap transfer time can take much too long,</span>
<span class="cm"> * if transmitted in plain text.</span>
<span class="cm"> *</span>
<span class="cm"> * We try to reduce the transferred bitmap information</span>
<span class="cm"> * by encoding runlengths of bit polarity.</span>
<span class="cm"> *</span>
<span class="cm"> * We never actually need to encode a &quot;zero&quot; (runlengths are positive).</span>
<span class="cm"> * But then we have to store the value of the first bit.</span>
<span class="cm"> * The first bit of information thus shall encode if the first runlength</span>
<span class="cm"> * gives the number of set or unset bits.</span>
<span class="cm"> *</span>
<span class="cm"> * We assume that large areas are either completely set or unset,</span>
<span class="cm"> * which gives good compression with any runlength method,</span>
<span class="cm"> * even when encoding the runlength as fixed size 32bit/64bit integers.</span>
<span class="cm"> *</span>
<span class="cm"> * Still, there may be areas where the polarity flips every few bits,</span>
<span class="cm"> * and encoding the runlength sequence of those areas with fix size</span>
<span class="cm"> * integers would be much worse than plaintext.</span>
<span class="cm"> *</span>
<span class="cm"> * We want to encode small runlength values with minimum code length,</span>
<span class="cm"> * while still being able to encode a Huge run of all zeros.</span>
<span class="cm"> *</span>
<span class="cm"> * Thus we need a Variable Length Integer encoding, VLI.</span>
<span class="cm"> *</span>
<span class="cm"> * For some cases, we produce more code bits than plaintext input.</span>
<span class="cm"> * We need to send incompressible chunks as plaintext, skip over them</span>
<span class="cm"> * and then see if the next chunk compresses better.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t care too much about &quot;excellent&quot; compression ratio for large</span>
<span class="cm"> * runlengths (all set/all clear): whether we achieve a factor of 100</span>
<span class="cm"> * or 1000 is not that much of an issue.</span>
<span class="cm"> * We do not want to waste too much on short runlengths in the &quot;noisy&quot;</span>
<span class="cm"> * parts of the bitmap, though.</span>
<span class="cm"> *</span>
<span class="cm"> * There are endless variants of VLI, we experimented with:</span>
<span class="cm"> *  * simple byte-based</span>
<span class="cm"> *  * various bit based with different code word length.</span>
<span class="cm"> *</span>
<span class="cm"> * To avoid yet an other configuration parameter (choice of bitmap compression</span>
<span class="cm"> * algorithm) which was difficult to explain and tune, we just chose the one</span>
<span class="cm"> * variant that turned out best in all test cases.</span>
<span class="cm"> * Based on real world usage patterns, with device sizes ranging from a few GiB</span>
<span class="cm"> * to several TiB, file server/mailserver/webserver/mysql/postgress,</span>
<span class="cm"> * mostly idle to really busy, the all time winner (though sometimes only</span>
<span class="cm"> * marginally better) is:</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * encoding is &quot;visualised&quot; as</span>
<span class="cm"> * __little endian__ bitstream, least significant bit first (left most)</span>
<span class="cm"> *</span>
<span class="cm"> * this particular encoding is chosen so that the prefix code</span>
<span class="cm"> * starts as unary encoding the level, then modified so that</span>
<span class="cm"> * 10 levels can be described in 8bit, with minimal overhead</span>
<span class="cm"> * for the smaller levels.</span>
<span class="cm"> *</span>
<span class="cm"> * Number of data bits follow fibonacci sequence, with the exception of the</span>
<span class="cm"> * last level (+1 data bit, so it makes 64bit total).  The only worse code when</span>
<span class="cm"> * encoding bit polarity runlength is 1 plain bits =&gt; 2 code bits.</span>
<span class="cm">prefix    data bits                                    max val  Nº data bits</span>
<span class="cm">0 x                                                         0x2            1</span>
<span class="cm">10 x                                                        0x4            1</span>
<span class="cm">110 xx                                                      0x8            2</span>
<span class="cm">1110 xxx                                                   0x10            3</span>
<span class="cm">11110 xxx xx                                               0x30            5</span>
<span class="cm">111110 xx xxxxxx                                          0x130            8</span>
<span class="cm">11111100  xxxxxxxx xxxxx                                 0x2130           13</span>
<span class="cm">11111110  xxxxxxxx xxxxxxxx xxxxx                      0x202130           21</span>
<span class="cm">11111101  xxxxxxxx xxxxxxxx xxxxxxxx  xxxxxxxx xx   0x400202130           34</span>
<span class="cm">11111111  xxxxxxxx xxxxxxxx xxxxxxxx  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 56</span>
<span class="cm"> * maximum encodable value: 0x100000400202130 == 2**56 + some */</span>

<span class="cm">/* compression &quot;table&quot;:</span>
<span class="cm"> transmitted   x                                0.29</span>
<span class="cm"> as plaintext x                                  ........................</span>
<span class="cm">             x                                   ........................</span>
<span class="cm">            x                                    ........................</span>
<span class="cm">           x    0.59                         0.21........................</span>
<span class="cm">          x      ........................................................</span>
<span class="cm">         x       .. c ...................................................</span>
<span class="cm">        x    0.44.. o ...................................................</span>
<span class="cm">       x .......... d ...................................................</span>
<span class="cm">      x  .......... e ...................................................</span>
<span class="cm">     X.............   ...................................................</span>
<span class="cm">    x.............. b ...................................................</span>
<span class="cm">2.0x............... i ...................................................</span>
<span class="cm"> #X................ t ...................................................</span>
<span class="cm"> #................. s ...........................  plain bits  ..........</span>
<span class="cm">-+-----------------------------------------------------------------------</span>
<span class="cm"> 1             16              32                              64</span>
<span class="cm">*/</span>

<span class="cm">/* LEVEL: (total bits, prefix bits, prefix value),</span>
<span class="cm"> * sorted ascending by number of total bits.</span>
<span class="cm"> * The rest of the code table is calculated at compiletime from this. */</span>

<span class="cm">/* fibonacci data 1, 1, ... */</span>
<span class="cp">#define VLI_L_1_1() do { \</span>
<span class="cp">	LEVEL( 2, 1, 0x00); \</span>
<span class="cp">	LEVEL( 3, 2, 0x01); \</span>
<span class="cp">	LEVEL( 5, 3, 0x03); \</span>
<span class="cp">	LEVEL( 7, 4, 0x07); \</span>
<span class="cp">	LEVEL(10, 5, 0x0f); \</span>
<span class="cp">	LEVEL(14, 6, 0x1f); \</span>
<span class="cp">	LEVEL(21, 8, 0x3f); \</span>
<span class="cp">	LEVEL(29, 8, 0x7f); \</span>
<span class="cp">	LEVEL(42, 8, 0xbf); \</span>
<span class="cp">	LEVEL(64, 8, 0xff); \</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* finds a suitable level to decode the least significant part of in.</span>
<span class="cm"> * returns number of bits consumed.</span>
<span class="cm"> *</span>
<span class="cm"> * BUG() for bad input, as that would mean a buggy code table. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vli_decode_bits</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">adj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#define LEVEL(t,b,v)					\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if ((in &amp; ((1 &lt;&lt; b) -1)) == v) {	\</span>
<span class="cp">			*out = ((in &amp; ((~0ULL) &gt;&gt; (64-t))) &gt;&gt; b) + adj;	\</span>
<span class="cp">			return t;			\</span>
<span class="cp">		}					\</span>
<span class="cp">		adj += 1ULL &lt;&lt; (t - b);			\</span>
<span class="cp">	} while (0)</span>

	<span class="n">VLI_L_1_1</span><span class="p">();</span>

	<span class="cm">/* NOT REACHED, if VLI_LEVELS code table is defined properly */</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#undef LEVEL</span>
<span class="p">}</span>

<span class="cm">/* return number of code bits needed,</span>
<span class="cm"> * or negative error number */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__vli_encode_bits</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">adj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="cp">#define LEVEL(t,b,v) do {		\</span>
<span class="cp">		max += 1ULL &lt;&lt; (t - b);	\</span>
<span class="cp">		if (in &lt;= max) {	\</span>
<span class="cp">			if (out)	\</span>
<span class="cp">				*out = ((in - adj) &lt;&lt; b) | v;	\</span>
<span class="cp">			return t;	\</span>
<span class="cp">		}			\</span>
<span class="cp">		adj = max + 1;		\</span>
<span class="cp">	} while (0)</span>

	<span class="n">VLI_L_1_1</span><span class="p">();</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
<span class="cp">#undef LEVEL</span>
<span class="p">}</span>

<span class="cp">#undef VLI_L_1_1</span>

<span class="cm">/* code from here down is independend of actually used bit code */</span>

<span class="cm">/*</span>
<span class="cm"> * Code length is determined by some unique (e.g. unary) prefix.</span>
<span class="cm"> * This encodes arbitrary bit length, not whole bytes: we have a bit-stream,</span>
<span class="cm"> * not a byte stream.</span>
<span class="cm"> */</span>

<span class="cm">/* for the bitstream, we need a cursor */</span>
<span class="k">struct</span> <span class="n">bitstream_cursor</span> <span class="p">{</span>
	<span class="cm">/* the current byte */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="cm">/* the current bit within *b, nomalized: 0..7 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* initialize cursor to point to first bit of stream */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bitstream_cursor_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bitstream_cursor</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* advance cursor by that many bits; maximum expected input value: 64,</span>
<span class="cm"> * but depending on VLI implementation, it may be more. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bitstream_cursor_advance</span><span class="p">(</span><span class="k">struct</span> <span class="n">bitstream_cursor</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bits</span> <span class="o">+=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bit</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the bitstream itself knows its length */</span>
<span class="k">struct</span> <span class="n">bitstream</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bitstream_cursor</span> <span class="n">cur</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">;</span>		<span class="cm">/* in bytes */</span>

	<span class="cm">/* for input stream:</span>
<span class="cm">	 * number of trailing 0 bits for padding</span>
<span class="cm">	 * total number of valid bits in stream: buf_len * 8 - pad_bits */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pad_bits</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bitstream_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bitstream</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pad_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">pad_bits</span> <span class="o">=</span> <span class="n">pad_bits</span><span class="p">;</span>
	<span class="n">bitstream_cursor_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bitstream_rewind</span><span class="p">(</span><span class="k">struct</span> <span class="n">bitstream</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitstream_cursor_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Put (at most 64) least significant bits of val into bitstream, and advance cursor.</span>
<span class="cm"> * Ignores &quot;pad_bits&quot;.</span>
<span class="cm"> * Returns zero if bits == 0 (nothing to do).</span>
<span class="cm"> * Returns number of bits used if successful.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is not enough room left in bitstream,</span>
<span class="cm"> * leaves bitstream unchanged and returns -ENOBUFS.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bitstream_put_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bitstream</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">b</span> <span class="o">+</span> <span class="p">((</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span> <span class="o">+</span> <span class="n">bits</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">-</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">&gt;=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="cm">/* paranoia: strip off hi bits; they should not be set anyways. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">0ULL</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>

	<span class="o">*</span><span class="n">b</span><span class="o">++</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">bits</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="o">*</span><span class="n">b</span><span class="o">++</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">bitstream_cursor_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fetch (at most 64) bits from bitstream into *out, and advance cursor.</span>
<span class="cm"> *</span>
<span class="cm"> * If more than 64 bits are requested, returns -EINVAL and leave *out unchanged.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are less than the requested number of valid bits left in the</span>
<span class="cm"> * bitstream, still fetches all available bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of actually fetched bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bitstream_get_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bitstream</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">b</span> <span class="o">+</span> <span class="p">((</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span> <span class="o">+</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">pad_bits</span> <span class="o">+</span> <span class="n">bits</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">&gt;=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">-</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">b</span> <span class="o">-</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="o">-</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span> <span class="o">-</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">pad_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the high bits */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span> <span class="o">+</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* n may be at most 9, if cur.bit + bits &gt; 64 */</span>
	<span class="cm">/* which means this copies at most 8 byte */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* we still need the low bits */</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">bit</span><span class="p">;</span>

	<span class="cm">/* and mask out bits we don&#39;t want */</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">0ULL</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>

	<span class="n">bitstream_cursor_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* encodes @in as vli into @bs;</span>

<span class="cm"> * return values</span>
<span class="cm"> *  &gt; 0: number of bits successfully stored in bitstream</span>
<span class="cm"> * -ENOBUFS @bs is full</span>
<span class="cm"> * -EINVAL input zero (invalid)</span>
<span class="cm"> * -EOVERFLOW input too large for this vli code (invalid)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vli_encode_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bitstream</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="n">u64</span> <span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">__vli_encode_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">code</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bitstream_put_bits</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
