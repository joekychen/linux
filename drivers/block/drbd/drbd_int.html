<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › drbd › drbd_int.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>drbd_int.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  drbd_int.h</span>

<span class="cm">  This file is part of DRBD by Philipp Reisner and Lars Ellenberg.</span>

<span class="cm">  Copyright (C) 2001-2008, LINBIT Information Technologies GmbH.</span>
<span class="cm">  Copyright (C) 1999-2008, Philipp Reisner &lt;philipp.reisner@linbit.com&gt;.</span>
<span class="cm">  Copyright (C) 2002-2008, Lars Ellenberg &lt;lars.ellenberg@linbit.com&gt;.</span>

<span class="cm">  drbd is free software; you can redistribute it and/or modify</span>
<span class="cm">  it under the terms of the GNU General Public License as published by</span>
<span class="cm">  the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm">  any later version.</span>

<span class="cm">  drbd is distributed in the hope that it will be useful,</span>
<span class="cm">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the</span>
<span class="cm">  GNU General Public License for more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License</span>
<span class="cm">  along with drbd; see the file COPYING.  If not, write to</span>
<span class="cm">  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm">*/</span>

<span class="cp">#ifndef _DRBD_INT_H</span>
<span class="cp">#define _DRBD_INT_H</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/lru_cache.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#ifdef __CHECKER__</span>
<span class="cp"># define __protected_by(x)       __attribute__((require_context(x,1,999,&quot;rdwr&quot;)))</span>
<span class="cp"># define __protected_read_by(x)  __attribute__((require_context(x,1,999,&quot;read&quot;)))</span>
<span class="cp"># define __protected_write_by(x) __attribute__((require_context(x,1,999,&quot;write&quot;)))</span>
<span class="cp"># define __must_hold(x)       __attribute__((context(x,1,1), require_context(x,1,999,&quot;call&quot;)))</span>
<span class="cp">#else</span>
<span class="cp"># define __protected_by(x)</span>
<span class="cp"># define __protected_read_by(x)</span>
<span class="cp"># define __protected_write_by(x)</span>
<span class="cp"># define __must_hold(x)</span>
<span class="cp">#endif</span>

<span class="cp">#define __no_warn(lock, stmt) do { __acquire(lock); stmt; __release(lock); } while (0)</span>

<span class="cm">/* module parameter, defined in drbd_main.c */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">minor_count</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">disable_sendpage</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">allow_oos</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cn_idx</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DRBD_FAULT_INJECTION</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">enable_faults</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fault_rate</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fault_devs</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="n">usermode_helper</span><span class="p">[];</span>


<span class="cm">/* I don&#39;t remember why XCPU ...</span>
<span class="cm"> * This is used to wake the asender,</span>
<span class="cm"> * and to interrupt sending the sending task</span>
<span class="cm"> * on disconnect.</span>
<span class="cm"> */</span>
<span class="cp">#define DRBD_SIG SIGXCPU</span>

<span class="cm">/* This is used to stop/restart our threads.</span>
<span class="cm"> * Cannot use SIGTERM nor SIGKILL, since these</span>
<span class="cm"> * are sent out by init on runlevel changes</span>
<span class="cm"> * I choose SIGHUP for now.</span>
<span class="cm"> */</span>
<span class="cp">#define DRBD_SIGKILL SIGHUP</span>

<span class="cm">/* All EEs on the free list should have ID_VACANT (== 0)</span>
<span class="cm"> * freshly allocated EEs get !ID_VACANT (== 1)</span>
<span class="cm"> * so if it says &quot;cannot dereference null pointer at address 0x00000001&quot;,</span>
<span class="cm"> * it is most likely one of these :( */</span>

<span class="cp">#define ID_IN_SYNC      (4711ULL)</span>
<span class="cp">#define ID_OUT_OF_SYNC  (4712ULL)</span>

<span class="cp">#define ID_SYNCER (-1ULL)</span>
<span class="cp">#define ID_VACANT 0</span>
<span class="cp">#define is_syncer_block_id(id) ((id) == ID_SYNCER)</span>
<span class="cp">#define UUID_NEW_BM_OFFSET ((u64)0x0001000000000000ULL)</span>

<span class="k">struct</span> <span class="n">drbd_conf</span><span class="p">;</span>


<span class="cm">/* to shorten dev_warn(DEV, &quot;msg&quot;); and relatives statements */</span>
<span class="cp">#define DEV (disk_to_dev(mdev-&gt;vdisk))</span>

<span class="cp">#define D_ASSERT(exp)	if (!(exp)) \</span>
<span class="cp">	 dev_err(DEV, &quot;ASSERT( &quot; #exp &quot; ) in %s:%d\n&quot;, __FILE__, __LINE__)</span>

<span class="cp">#define ERR_IF(exp) if (({						\</span>
<span class="cp">	int _b = (exp) != 0;						\</span>
<span class="cp">	if (_b) dev_err(DEV, &quot;ASSERT FAILED: %s: (%s) in %s:%d\n&quot;,	\</span>
<span class="cp">			__func__, #exp, __FILE__, __LINE__);		\</span>
<span class="cp">	_b;								\</span>
<span class="cp">	}))</span>

<span class="cm">/* Defines to control fault insertion */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DRBD_FAULT_MD_WR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* meta data write */</span>
	<span class="n">DRBD_FAULT_MD_RD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/*           read  */</span>
	<span class="n">DRBD_FAULT_RS_WR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* resync          */</span>
	<span class="n">DRBD_FAULT_RS_RD</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">DRBD_FAULT_DT_WR</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* data            */</span>
	<span class="n">DRBD_FAULT_DT_RD</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">DRBD_FAULT_DT_RA</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* data read ahead */</span>
	<span class="n">DRBD_FAULT_BM_ALLOC</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* bitmap allocation */</span>
	<span class="n">DRBD_FAULT_AL_EE</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>	<span class="cm">/* alloc ee */</span>
	<span class="n">DRBD_FAULT_RECEIVE</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="cm">/* Changes some bytes upon receiving a [rs]data block */</span>

	<span class="n">DRBD_FAULT_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">_drbd_insert_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">drbd_insert_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_DRBD_FAULT_INJECTION</span>
	<span class="k">return</span> <span class="n">fault_rate</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">enable_faults</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">type</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="n">_drbd_insert_fault</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* integer division, round _UP_ to the next integer */</span>
<span class="cp">#define div_ceil(A, B) ((A)/(B) + ((A)%(B) ? 1 : 0))</span>
<span class="cm">/* usual integer division */</span>
<span class="cp">#define div_floor(A, B) ((A)/(B))</span>

<span class="cm">/* drbd_meta-data.c (still in drbd_main.c) */</span>
<span class="cm">/* 4th incarnation of the disk layout. */</span>
<span class="cp">#define DRBD_MD_MAGIC (DRBD_MAGIC+4)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">**</span><span class="n">minor_table</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ratelimit_state</span> <span class="n">drbd_ratelimit_state</span><span class="p">;</span>

<span class="cm">/* on the wire */</span>
<span class="k">enum</span> <span class="n">drbd_packets</span> <span class="p">{</span>
	<span class="cm">/* receiver (data socket) */</span>
	<span class="n">P_DATA</span>		      <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">P_DATA_REPLY</span>	      <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span> <span class="cm">/* Response to P_DATA_REQUEST */</span>
	<span class="n">P_RS_DATA_REPLY</span>	      <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span> <span class="cm">/* Response to P_RS_DATA_REQUEST */</span>
	<span class="n">P_BARRIER</span>	      <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">P_BITMAP</span>	      <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">P_BECOME_SYNC_TARGET</span>  <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
	<span class="n">P_BECOME_SYNC_SOURCE</span>  <span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
	<span class="n">P_UNPLUG_REMOTE</span>	      <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span> <span class="cm">/* Used at various times to hint the peer */</span>
	<span class="n">P_DATA_REQUEST</span>	      <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span> <span class="cm">/* Used to ask for a data block */</span>
	<span class="n">P_RS_DATA_REQUEST</span>     <span class="o">=</span> <span class="mh">0x09</span><span class="p">,</span> <span class="cm">/* Used to ask for a data block for resync */</span>
	<span class="n">P_SYNC_PARAM</span>	      <span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>
	<span class="n">P_PROTOCOL</span>	      <span class="o">=</span> <span class="mh">0x0b</span><span class="p">,</span>
	<span class="n">P_UUIDS</span>		      <span class="o">=</span> <span class="mh">0x0c</span><span class="p">,</span>
	<span class="n">P_SIZES</span>		      <span class="o">=</span> <span class="mh">0x0d</span><span class="p">,</span>
	<span class="n">P_STATE</span>		      <span class="o">=</span> <span class="mh">0x0e</span><span class="p">,</span>
	<span class="n">P_SYNC_UUID</span>	      <span class="o">=</span> <span class="mh">0x0f</span><span class="p">,</span>
	<span class="n">P_AUTH_CHALLENGE</span>      <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">P_AUTH_RESPONSE</span>	      <span class="o">=</span> <span class="mh">0x11</span><span class="p">,</span>
	<span class="n">P_STATE_CHG_REQ</span>	      <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>

	<span class="cm">/* asender (meta socket */</span>
	<span class="n">P_PING</span>		      <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">P_PING_ACK</span>	      <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">P_RECV_ACK</span>	      <span class="o">=</span> <span class="mh">0x15</span><span class="p">,</span> <span class="cm">/* Used in protocol B */</span>
	<span class="n">P_WRITE_ACK</span>	      <span class="o">=</span> <span class="mh">0x16</span><span class="p">,</span> <span class="cm">/* Used in protocol C */</span>
	<span class="n">P_RS_WRITE_ACK</span>	      <span class="o">=</span> <span class="mh">0x17</span><span class="p">,</span> <span class="cm">/* Is a P_WRITE_ACK, additionally call set_in_sync(). */</span>
	<span class="n">P_DISCARD_ACK</span>	      <span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span> <span class="cm">/* Used in proto C, two-primaries conflict detection */</span>
	<span class="n">P_NEG_ACK</span>	      <span class="o">=</span> <span class="mh">0x19</span><span class="p">,</span> <span class="cm">/* Sent if local disk is unusable */</span>
	<span class="n">P_NEG_DREPLY</span>	      <span class="o">=</span> <span class="mh">0x1a</span><span class="p">,</span> <span class="cm">/* Local disk is broken... */</span>
	<span class="n">P_NEG_RS_DREPLY</span>	      <span class="o">=</span> <span class="mh">0x1b</span><span class="p">,</span> <span class="cm">/* Local disk is broken... */</span>
	<span class="n">P_BARRIER_ACK</span>	      <span class="o">=</span> <span class="mh">0x1c</span><span class="p">,</span>
	<span class="n">P_STATE_CHG_REPLY</span>     <span class="o">=</span> <span class="mh">0x1d</span><span class="p">,</span>

	<span class="cm">/* &quot;new&quot; commands, no longer fitting into the ordering scheme above */</span>

	<span class="n">P_OV_REQUEST</span>	      <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span> <span class="cm">/* data socket */</span>
	<span class="n">P_OV_REPLY</span>	      <span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
	<span class="n">P_OV_RESULT</span>	      <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span> <span class="cm">/* meta socket */</span>
	<span class="n">P_CSUM_RS_REQUEST</span>     <span class="o">=</span> <span class="mh">0x21</span><span class="p">,</span> <span class="cm">/* data socket */</span>
	<span class="n">P_RS_IS_IN_SYNC</span>	      <span class="o">=</span> <span class="mh">0x22</span><span class="p">,</span> <span class="cm">/* meta socket */</span>
	<span class="n">P_SYNC_PARAM89</span>	      <span class="o">=</span> <span class="mh">0x23</span><span class="p">,</span> <span class="cm">/* data socket, protocol version 89 replacement for P_SYNC_PARAM */</span>
	<span class="n">P_COMPRESSED_BITMAP</span>   <span class="o">=</span> <span class="mh">0x24</span><span class="p">,</span> <span class="cm">/* compressed or otherwise encoded bitmap transfer */</span>
	<span class="cm">/* P_CKPT_FENCE_REQ      = 0x25, * currently reserved for protocol D */</span>
	<span class="cm">/* P_CKPT_DISABLE_REQ    = 0x26, * currently reserved for protocol D */</span>
	<span class="n">P_DELAY_PROBE</span>         <span class="o">=</span> <span class="mh">0x27</span><span class="p">,</span> <span class="cm">/* is used on BOTH sockets */</span>
	<span class="n">P_OUT_OF_SYNC</span>         <span class="o">=</span> <span class="mh">0x28</span><span class="p">,</span> <span class="cm">/* Mark as out of sync (Outrunning), data socket */</span>
	<span class="n">P_RS_CANCEL</span>           <span class="o">=</span> <span class="mh">0x29</span><span class="p">,</span> <span class="cm">/* meta: Used to cancel RS_DATA_REQUEST packet by SyncSource */</span>

	<span class="n">P_MAX_CMD</span>	      <span class="o">=</span> <span class="mh">0x2A</span><span class="p">,</span>
	<span class="n">P_MAY_IGNORE</span>	      <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span> <span class="cm">/* Flag to test if (cmd &gt; P_MAY_IGNORE) ... */</span>
	<span class="n">P_MAX_OPT_CMD</span>	      <span class="o">=</span> <span class="mh">0x101</span><span class="p">,</span>

	<span class="cm">/* special command ids for handshake */</span>

	<span class="n">P_HAND_SHAKE_M</span>	      <span class="o">=</span> <span class="mh">0xfff1</span><span class="p">,</span> <span class="cm">/* First Packet on the MetaSock */</span>
	<span class="n">P_HAND_SHAKE_S</span>	      <span class="o">=</span> <span class="mh">0xfff2</span><span class="p">,</span> <span class="cm">/* First Packet on the Socket */</span>

	<span class="n">P_HAND_SHAKE</span>	      <span class="o">=</span> <span class="mh">0xfffe</span>	<span class="cm">/* FIXED for the next century! */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">cmdname</span><span class="p">(</span><span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* THINK may need to become several global tables</span>
<span class="cm">	 * when we want to support more than</span>
<span class="cm">	 * one PRO_VERSION */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdnames</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">P_DATA</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;Data&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_DATA_REPLY</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;DataReply&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_RS_DATA_REPLY</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;RSDataReply&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_BARRIER</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;Barrier&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_BITMAP</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;ReportBitMap&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_BECOME_SYNC_TARGET</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;BecomeSyncTarget&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_BECOME_SYNC_SOURCE</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;BecomeSyncSource&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_UNPLUG_REMOTE</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;UnplugRemote&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_DATA_REQUEST</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;DataRequest&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_RS_DATA_REQUEST</span><span class="p">]</span>     <span class="o">=</span> <span class="s">&quot;RSDataRequest&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_SYNC_PARAM</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;SyncParam&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_SYNC_PARAM89</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;SyncParam89&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_PROTOCOL</span><span class="p">]</span>            <span class="o">=</span> <span class="s">&quot;ReportProtocol&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_UUIDS</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;ReportUUIDs&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_SIZES</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;ReportSizes&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_STATE</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;ReportState&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_SYNC_UUID</span><span class="p">]</span>           <span class="o">=</span> <span class="s">&quot;ReportSyncUUID&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_AUTH_CHALLENGE</span><span class="p">]</span>      <span class="o">=</span> <span class="s">&quot;AuthChallenge&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_AUTH_RESPONSE</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;AuthResponse&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_PING</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;Ping&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_PING_ACK</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;PingAck&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_RECV_ACK</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;RecvAck&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_WRITE_ACK</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;WriteAck&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_RS_WRITE_ACK</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;RSWriteAck&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_DISCARD_ACK</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;DiscardAck&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_NEG_ACK</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;NegAck&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_NEG_DREPLY</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;NegDReply&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_NEG_RS_DREPLY</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;NegRSDReply&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_BARRIER_ACK</span><span class="p">]</span>	        <span class="o">=</span> <span class="s">&quot;BarrierAck&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_STATE_CHG_REQ</span><span class="p">]</span>       <span class="o">=</span> <span class="s">&quot;StateChgRequest&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_STATE_CHG_REPLY</span><span class="p">]</span>     <span class="o">=</span> <span class="s">&quot;StateChgReply&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_OV_REQUEST</span><span class="p">]</span>          <span class="o">=</span> <span class="s">&quot;OVRequest&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_OV_REPLY</span><span class="p">]</span>            <span class="o">=</span> <span class="s">&quot;OVReply&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_OV_RESULT</span><span class="p">]</span>           <span class="o">=</span> <span class="s">&quot;OVResult&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_CSUM_RS_REQUEST</span><span class="p">]</span>     <span class="o">=</span> <span class="s">&quot;CsumRSRequest&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_RS_IS_IN_SYNC</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;CsumRSIsInSync&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_COMPRESSED_BITMAP</span><span class="p">]</span>   <span class="o">=</span> <span class="s">&quot;CBitmap&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_DELAY_PROBE</span><span class="p">]</span>         <span class="o">=</span> <span class="s">&quot;DelayProbe&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_OUT_OF_SYNC</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;OutOfSync&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">P_MAX_CMD</span><span class="p">]</span>	        <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">P_HAND_SHAKE_M</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;HandShakeM&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">P_HAND_SHAKE_S</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;HandShakeS&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">P_HAND_SHAKE</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;HandShake&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">P_MAX_CMD</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cmdnames</span><span class="p">[</span><span class="n">cmd</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* for sending/receiving the bitmap,</span>
<span class="cm"> * possibly in some encoding scheme */</span>
<span class="k">struct</span> <span class="n">bm_xfer_ctx</span> <span class="p">{</span>
	<span class="cm">/* &quot;const&quot;</span>
<span class="cm">	 * stores total bits and long words</span>
<span class="cm">	 * of the bitmap, so we don&#39;t need to</span>
<span class="cm">	 * call the accessor functions over and again. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_words</span><span class="p">;</span>
	<span class="cm">/* during xfer, current position within the bitmap */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word_offset</span><span class="p">;</span>

	<span class="cm">/* statistics; index: (h-&gt;command == P_BITMAP) */</span>
	<span class="kt">unsigned</span> <span class="n">packets</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">INFO_bm_xfer_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">direction</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bm_xfer_ctx</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bm_xfer_ctx_bit_to_word_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bm_xfer_ctx</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* word_offset counts &quot;native long words&quot; (32 or 64 bit),</span>
<span class="cm">	 * aligned at 64 bit.</span>
<span class="cm">	 * Encoded packet may end at an unaligned bit offset.</span>
<span class="cm">	 * In case a fallback clear text packet is transmitted in</span>
<span class="cm">	 * between, we adjust this offset back to the last 64bit</span>
<span class="cm">	 * aligned &quot;native long word&quot;, which makes coding and decoding</span>
<span class="cm">	 * the plain text bitmap much more convenient.  */</span>
<span class="cp">#if BITS_PER_LONG == 64</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">word_offset</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bit_offset</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
<span class="cp">#elif BITS_PER_LONG == 32</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">word_offset</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bit_offset</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">word_offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># error &quot;unsupported BITS_PER_LONG&quot;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifndef __packed</span>
<span class="cp">#define __packed __attribute__((packed))</span>
<span class="cp">#endif</span>

<span class="cm">/* This is the layout for a packet on the wire.</span>
<span class="cm"> * The byteorder is the network byte order.</span>
<span class="cm"> *     (except block_id and barrier fields.</span>
<span class="cm"> *	these are pointers to local structs</span>
<span class="cm"> *	and have no relevance for the partner,</span>
<span class="cm"> *	which just echoes them as received.)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE that the payload starts at a long aligned offset,</span>
<span class="cm"> * regardless of 32 or 64 bit arch!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">p_header80</span> <span class="p">{</span>
	<span class="n">u32</span>	  <span class="n">magic</span><span class="p">;</span>
	<span class="n">u16</span>	  <span class="n">command</span><span class="p">;</span>
	<span class="n">u16</span>	  <span class="n">length</span><span class="p">;</span>	<span class="cm">/* bytes of data after this header */</span>
	<span class="n">u8</span>	  <span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Header for big packets, Used for data packets exceeding 64kB */</span>
<span class="k">struct</span> <span class="n">p_header95</span> <span class="p">{</span>
	<span class="n">u16</span>	  <span class="n">magic</span><span class="p">;</span>	<span class="cm">/* use DRBD_MAGIC_BIG here */</span>
	<span class="n">u16</span>	  <span class="n">command</span><span class="p">;</span>
	<span class="n">u32</span>	  <span class="n">length</span><span class="p">;</span>	<span class="cm">/* Use only 24 bits of that. Ignore the highest 8 bit. */</span>
	<span class="n">u8</span>	  <span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">union</span> <span class="n">p_header</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">h80</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">p_header95</span> <span class="n">h95</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * short commands, packets without payload, plain p_header:</span>
<span class="cm"> *   P_PING</span>
<span class="cm"> *   P_PING_ACK</span>
<span class="cm"> *   P_BECOME_SYNC_TARGET</span>
<span class="cm"> *   P_BECOME_SYNC_SOURCE</span>
<span class="cm"> *   P_UNPLUG_REMOTE</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * commands with out-of-struct payload:</span>
<span class="cm"> *   P_BITMAP    (no additional fields)</span>
<span class="cm"> *   P_DATA, P_DATA_REPLY (see p_data)</span>
<span class="cm"> *   P_COMPRESSED_BITMAP (see receive_compressed_bitmap)</span>
<span class="cm"> */</span>

<span class="cm">/* these defines must not be changed without changing the protocol version */</span>
<span class="cp">#define DP_HARDBARRIER	      1 </span><span class="cm">/* depricated */</span><span class="cp"></span>
<span class="cp">#define DP_RW_SYNC	      2 </span><span class="cm">/* equals REQ_SYNC    */</span><span class="cp"></span>
<span class="cp">#define DP_MAY_SET_IN_SYNC    4</span>
<span class="cp">#define DP_UNPLUG             8 </span><span class="cm">/* not used anymore   */</span><span class="cp"></span>
<span class="cp">#define DP_FUA               16 </span><span class="cm">/* equals REQ_FUA     */</span><span class="cp"></span>
<span class="cp">#define DP_FLUSH             32 </span><span class="cm">/* equals REQ_FLUSH   */</span><span class="cp"></span>
<span class="cp">#define DP_DISCARD           64 </span><span class="cm">/* equals REQ_DISCARD */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">p_data</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">p_header</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span>	    <span class="n">sector</span><span class="p">;</span>    <span class="cm">/* 64 bits sector number */</span>
	<span class="n">u64</span>	    <span class="n">block_id</span><span class="p">;</span>  <span class="cm">/* to identify the request in protocol B&amp;C */</span>
	<span class="n">u32</span>	    <span class="n">seq_num</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">dp_flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * commands which share a struct:</span>
<span class="cm"> *  p_block_ack:</span>
<span class="cm"> *   P_RECV_ACK (proto B), P_WRITE_ACK (proto C),</span>
<span class="cm"> *   P_DISCARD_ACK (proto C, two-primaries conflict detection)</span>
<span class="cm"> *  p_block_req:</span>
<span class="cm"> *   P_DATA_REQUEST, P_RS_DATA_REQUEST</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">p_block_ack</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span>	    <span class="n">sector</span><span class="p">;</span>
	<span class="n">u64</span>	    <span class="n">block_id</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">blksize</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">seq_num</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">p_block_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sector</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blksize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pad</span><span class="p">;</span>	<span class="cm">/* to multiple of 8 Byte */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * commands with their own struct for additional fields:</span>
<span class="cm"> *   P_HAND_SHAKE</span>
<span class="cm"> *   P_BARRIER</span>
<span class="cm"> *   P_BARRIER_ACK</span>
<span class="cm"> *   P_SYNC_PARAM</span>
<span class="cm"> *   ReportParams</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">p_handshake</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>	<span class="cm">/* 8 bytes */</span>
	<span class="n">u32</span> <span class="n">protocol_min</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">feature_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">protocol_max</span><span class="p">;</span>

	<span class="cm">/* should be more than enough for future enhancements</span>
<span class="cm">	 * for now, feature_flags and the reserverd array shall be zero.</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">_pad</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">reserverd</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>
<span class="cm">/* 80 bytes, FIXED for the next century */</span>

<span class="k">struct</span> <span class="n">p_barrier</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">barrier</span><span class="p">;</span>	<span class="cm">/* barrier number _handle_ only */</span>
	<span class="n">u32</span> <span class="n">pad</span><span class="p">;</span>	<span class="cm">/* to multiple of 8 Byte */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_barrier_ack</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">barrier</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">set_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_rs_param</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rate</span><span class="p">;</span>

	      <span class="cm">/* Since protocol version 88 and higher. */</span>
	<span class="kt">char</span> <span class="n">verify_alg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_rs_param_89</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rate</span><span class="p">;</span>
        <span class="cm">/* protocol version 89: */</span>
	<span class="kt">char</span> <span class="n">verify_alg</span><span class="p">[</span><span class="n">SHARED_SECRET_MAX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">csums_alg</span><span class="p">[</span><span class="n">SHARED_SECRET_MAX</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_rs_param_95</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rate</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">verify_alg</span><span class="p">[</span><span class="n">SHARED_SECRET_MAX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">csums_alg</span><span class="p">[</span><span class="n">SHARED_SECRET_MAX</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">c_plan_ahead</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">c_delay_target</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">c_fill_target</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">c_max_rate</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">drbd_conn_flags</span> <span class="p">{</span>
	<span class="n">CF_WANT_LOSE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CF_DRY_RUN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">p_protocol</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">after_sb_0p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">after_sb_1p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">after_sb_2p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">conn_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">two_primaries</span><span class="p">;</span>

              <span class="cm">/* Since protocol version 87 and higher. */</span>
	<span class="kt">char</span> <span class="n">integrity_alg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_uuids</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">uuid</span><span class="p">[</span><span class="n">UI_EXTENDED_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_rs_uuid</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span>	    <span class="n">uuid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_sizes</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span>	    <span class="n">d_size</span><span class="p">;</span>  <span class="cm">/* size of disk */</span>
	<span class="n">u64</span>	    <span class="n">u_size</span><span class="p">;</span>  <span class="cm">/* user requested size */</span>
	<span class="n">u64</span>	    <span class="n">c_size</span><span class="p">;</span>  <span class="cm">/* current exported size */</span>
	<span class="n">u32</span>	    <span class="n">max_bio_size</span><span class="p">;</span>  <span class="cm">/* Maximal size of a BIO */</span>
	<span class="n">u16</span>	    <span class="n">queue_order_type</span><span class="p">;</span>  <span class="cm">/* not yet implemented in DRBD*/</span>
	<span class="n">u16</span>	    <span class="n">dds_flags</span><span class="p">;</span> <span class="cm">/* use enum dds_flags here. */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_req_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">val</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_req_state_reply</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">retcode</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_drbd06_param</span> <span class="p">{</span>
	<span class="n">u64</span>	  <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span>	  <span class="n">state</span><span class="p">;</span>
	<span class="n">u32</span>	  <span class="n">blksize</span><span class="p">;</span>
	<span class="n">u32</span>	  <span class="n">protocol</span><span class="p">;</span>
	<span class="n">u32</span>	  <span class="n">version</span><span class="p">;</span>
	<span class="n">u32</span>	  <span class="n">gen_cnt</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">u32</span>	  <span class="n">bit_map_gen</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_discard</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span>	    <span class="n">block_id</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">seq_num</span><span class="p">;</span>
	<span class="n">u32</span>	    <span class="n">pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_block_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sector</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blksize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pad</span><span class="p">;</span>	<span class="cm">/* to multiple of 8 Byte */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Valid values for the encoding field.</span>
<span class="cm"> * Bump proto version when changing this. */</span>
<span class="k">enum</span> <span class="n">drbd_bitmap_code</span> <span class="p">{</span>
	<span class="cm">/* RLE_VLI_Bytes = 0,</span>
<span class="cm">	 * and other bit variants had been defined during</span>
<span class="cm">	 * algorithm evaluation. */</span>
	<span class="n">RLE_VLI_Bits</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">p_compressed_bm</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="cm">/* (encoding &amp; 0x0f): actual encoding, see enum drbd_bitmap_code</span>
<span class="cm">	 * (encoding &amp; 0x80): polarity (set/unset) of first runlength</span>
<span class="cm">	 * ((encoding &gt;&gt; 4) &amp; 0x07): pad_bits, number of trailing zero bits</span>
<span class="cm">	 * used to pad up to head.length bytes</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">encoding</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">p_delay_probe93</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span>     <span class="n">seq_num</span><span class="p">;</span> <span class="cm">/* sequence number to match the two probe packets */</span>
	<span class="n">u32</span>     <span class="n">offset</span><span class="p">;</span>  <span class="cm">/* usecs the probe got sent after the reference time point */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* DCBP: Drbd Compressed Bitmap Packet ... */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">drbd_bitmap_code</span>
<span class="nf">DCBP_get_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">p_compressed_bm</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">enum</span> <span class="n">drbd_bitmap_code</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">DCBP_set_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">p_compressed_bm</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_bitmap_code</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">code</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">)</span> <span class="o">|</span> <span class="n">code</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">DCBP_get_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">p_compressed_bm</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">DCBP_set_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">p_compressed_bm</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">set</span> <span class="o">?</span> <span class="mh">0x80</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">DCBP_get_pad_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">p_compressed_bm</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">DCBP_set_pad_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">p_compressed_bm</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x7</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* one bitmap packet, including the p_header,</span>
<span class="cm"> * should fit within one _architecture independend_ page.</span>
<span class="cm"> * so we need to use the fixed size 4KiB page size</span>
<span class="cm"> * most architectures have used for a long time.</span>
<span class="cm"> */</span>
<span class="cp">#define BM_PACKET_PAYLOAD_BYTES (4096 - sizeof(struct p_header80))</span>
<span class="cp">#define BM_PACKET_WORDS (BM_PACKET_PAYLOAD_BYTES/sizeof(long))</span>
<span class="cp">#define BM_PACKET_VLI_BYTES_MAX (4096 - sizeof(struct p_compressed_bm))</span>
<span class="cp">#if (PAGE_SIZE &lt; 4096)</span>
<span class="cm">/* drbd_send_bitmap / receive_bitmap would break horribly */</span>
<span class="cp">#error &quot;PAGE_SIZE too small&quot;</span>
<span class="cp">#endif</span>

<span class="k">union</span> <span class="n">p_polymorph</span> <span class="p">{</span>
        <span class="k">union</span> <span class="n">p_header</span>           <span class="n">header</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_handshake</span>       <span class="n">handshake</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_data</span>            <span class="n">data</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_block_ack</span>       <span class="n">block_ack</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_barrier</span>         <span class="n">barrier</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_barrier_ack</span>     <span class="n">barrier_ack</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_rs_param_89</span>     <span class="n">rs_param_89</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_rs_param_95</span>     <span class="n">rs_param_95</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_protocol</span>        <span class="n">protocol</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_sizes</span>           <span class="n">sizes</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_uuids</span>           <span class="n">uuids</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_state</span>           <span class="n">state</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_req_state</span>       <span class="n">req_state</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_req_state_reply</span> <span class="n">req_state_reply</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">p_block_req</span>       <span class="n">block_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">p_delay_probe93</span>   <span class="n">delay_probe93</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">p_rs_uuid</span>         <span class="n">rs_uuid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">p_block_desc</span>      <span class="n">block_desc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**********************************************************************/</span>
<span class="k">enum</span> <span class="n">drbd_thread_state</span> <span class="p">{</span>
	<span class="n">None</span><span class="p">,</span>
	<span class="n">Running</span><span class="p">,</span>
	<span class="n">Exiting</span><span class="p">,</span>
	<span class="n">Restarting</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_thread</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">t_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">stop</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">drbd_thread_state</span> <span class="n">t_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_cpu_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">drbd_thread_state</span> <span class="nf">get_t_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="n">thi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* THINK testing the t_state seems to be uncritical in all cases</span>
<span class="cm">	 * (but thread_{start,stop}), so we can read it *without* the lock.</span>
<span class="cm">	 *	--lge */</span>

	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">thi</span><span class="o">-&gt;</span><span class="n">t_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">drbd_work</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">drbd_work_cb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cancel</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">drbd_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">drbd_work_cb</span> <span class="n">cb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_tl_epoch</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drbd_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_work</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">;</span>

	<span class="cm">/* if local IO is not allowed, will be NULL.</span>
<span class="cm">	 * if local IO _is_ allowed, holds the locally submitted bio clone,</span>
<span class="cm">	 * or, after local IO completion, the ERR_PTR(error).</span>
<span class="cm">	 * see drbd_endio_pri(). */</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">private_bio</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">collision</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epoch</span><span class="p">;</span> <span class="cm">/* barrier_nr */</span>

	<span class="cm">/* barrier_nr: used to check on &quot;completion&quot; whether this req was in</span>
<span class="cm">	 * the current epoch, and we therefore have to close it,</span>
<span class="cm">	 * starting a new epoch...</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tl_requests</span><span class="p">;</span> <span class="cm">/* ring list in the transfer log */</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">master_bio</span><span class="p">;</span>       <span class="cm">/* master bio pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rq_state</span><span class="p">;</span> <span class="cm">/* see comments above _req_mod() */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_tl_epoch</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_work</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">requests</span><span class="p">;</span> <span class="cm">/* requests before */</span>
	<span class="k">struct</span> <span class="n">drbd_tl_epoch</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="cm">/* pointer to the next barrier */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">br_number</span><span class="p">;</span>  <span class="cm">/* the barriers identifier. */</span>
	<span class="kt">int</span> <span class="n">n_writes</span><span class="p">;</span>	<span class="cm">/* number of requests attached before this barrier */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_request</span><span class="p">;</span>

<span class="cm">/* These Tl_epoch_entries may be in one of 6 lists:</span>
<span class="cm">   active_ee .. data packet being written</span>
<span class="cm">   sync_ee   .. syncer block being written</span>
<span class="cm">   done_ee   .. block written, need to send P_WRITE_ACK</span>
<span class="cm">   read_ee   .. [RS]P_DATA_REQUEST being read</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">drbd_epoch</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">barrier_nr</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">epoch_size</span><span class="p">;</span> <span class="cm">/* increased on every request added. */</span>
	<span class="n">atomic_t</span> <span class="n">active</span><span class="p">;</span>     <span class="cm">/* increased on every req. added, and dec on every finished. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* drbd_epoch flag bits */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DE_HAVE_BARRIER_NUMBER</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">epoch_event</span> <span class="p">{</span>
	<span class="n">EV_PUT</span><span class="p">,</span>
	<span class="n">EV_GOT_BARRIER_NR</span><span class="p">,</span>
	<span class="n">EV_BECAME_LAST</span><span class="p">,</span>
	<span class="n">EV_CLEANUP</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="cm">/* used as flag */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_wq_barrier</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_work</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">done</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">digest_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">digest_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">digest</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_work</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">collision</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_epoch</span> <span class="o">*</span><span class="n">epoch</span><span class="p">;</span> <span class="cm">/* for writes */</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">pending_bios</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* see comments on ee flag bits below */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">block_id</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">digest_info</span> <span class="o">*</span><span class="n">digest</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/* ee flag bits.</span>
<span class="cm"> * While corresponding bios are in flight, the only modification will be</span>
<span class="cm"> * set_bit WAS_ERROR, which has to be atomic.</span>
<span class="cm"> * If no bios are in flight yet, or all have been completed,</span>
<span class="cm"> * non-atomic modification to ee-&gt;flags is ok.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">__EE_CALL_AL_COMPLETE_IO</span><span class="p">,</span>
	<span class="n">__EE_MAY_SET_IN_SYNC</span><span class="p">,</span>

	<span class="cm">/* In case a barrier failed,</span>
<span class="cm">	 * we need to resubmit without the barrier flag. */</span>
	<span class="n">__EE_RESUBMITTED</span><span class="p">,</span>

	<span class="cm">/* we may have several bios per epoch entry.</span>
<span class="cm">	 * if any of those fail, we set this flag atomically</span>
<span class="cm">	 * from the endio callback */</span>
	<span class="n">__EE_WAS_ERROR</span><span class="p">,</span>

	<span class="cm">/* This ee has a pointer to a digest instead of a block id */</span>
	<span class="n">__EE_HAS_DIGEST</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define EE_CALL_AL_COMPLETE_IO (1&lt;&lt;__EE_CALL_AL_COMPLETE_IO)</span>
<span class="cp">#define EE_MAY_SET_IN_SYNC     (1&lt;&lt;__EE_MAY_SET_IN_SYNC)</span>
<span class="cp">#define	EE_RESUBMITTED         (1&lt;&lt;__EE_RESUBMITTED)</span>
<span class="cp">#define EE_WAS_ERROR           (1&lt;&lt;__EE_WAS_ERROR)</span>
<span class="cp">#define EE_HAS_DIGEST          (1&lt;&lt;__EE_HAS_DIGEST)</span>

<span class="cm">/* global flag bits */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CREATE_BARRIER</span><span class="p">,</span>		<span class="cm">/* next P_DATA is preceded by a P_BARRIER */</span>
	<span class="n">SIGNAL_ASENDER</span><span class="p">,</span>		<span class="cm">/* whether asender wants to be interrupted */</span>
	<span class="n">SEND_PING</span><span class="p">,</span>		<span class="cm">/* whether asender should send a ping asap */</span>

	<span class="n">UNPLUG_QUEUED</span><span class="p">,</span>		<span class="cm">/* only relevant with kernel 2.4 */</span>
	<span class="n">UNPLUG_REMOTE</span><span class="p">,</span>		<span class="cm">/* sending a &quot;UnplugRemote&quot; could help */</span>
	<span class="n">MD_DIRTY</span><span class="p">,</span>		<span class="cm">/* current uuids and flags not yet on disk */</span>
	<span class="n">DISCARD_CONCURRENT</span><span class="p">,</span>	<span class="cm">/* Set on one node, cleared on the peer! */</span>
	<span class="n">USE_DEGR_WFC_T</span><span class="p">,</span>		<span class="cm">/* degr-wfc-timeout instead of wfc-timeout. */</span>
	<span class="n">CLUSTER_ST_CHANGE</span><span class="p">,</span>	<span class="cm">/* Cluster wide state change going on... */</span>
	<span class="n">CL_ST_CHG_SUCCESS</span><span class="p">,</span>
	<span class="n">CL_ST_CHG_FAIL</span><span class="p">,</span>
	<span class="n">CRASHED_PRIMARY</span><span class="p">,</span>	<span class="cm">/* This node was a crashed primary.</span>
<span class="cm">				 * Gets cleared when the state.conn</span>
<span class="cm">				 * goes into C_CONNECTED state. */</span>
	<span class="n">NO_BARRIER_SUPP</span><span class="p">,</span>	<span class="cm">/* underlying block device doesn&#39;t implement barriers */</span>
	<span class="n">CONSIDER_RESYNC</span><span class="p">,</span>

	<span class="n">MD_NO_FUA</span><span class="p">,</span>		<span class="cm">/* Users wants us to not use FUA/FLUSH on meta data dev */</span>
	<span class="n">SUSPEND_IO</span><span class="p">,</span>		<span class="cm">/* suspend application io */</span>
	<span class="n">BITMAP_IO</span><span class="p">,</span>		<span class="cm">/* suspend application io;</span>
<span class="cm">				   once no more io in flight, start bitmap io */</span>
	<span class="n">BITMAP_IO_QUEUED</span><span class="p">,</span>       <span class="cm">/* Started bitmap IO */</span>
	<span class="n">GO_DISKLESS</span><span class="p">,</span>		<span class="cm">/* Disk is being detached, on io-error or admin request. */</span>
	<span class="n">WAS_IO_ERROR</span><span class="p">,</span>		<span class="cm">/* Local disk failed returned IO error */</span>
	<span class="n">RESYNC_AFTER_NEG</span><span class="p">,</span>       <span class="cm">/* Resync after online grow after the attach&amp;negotiate finished. */</span>
	<span class="n">NET_CONGESTED</span><span class="p">,</span>		<span class="cm">/* The data socket is congested */</span>

	<span class="n">CONFIG_PENDING</span><span class="p">,</span>		<span class="cm">/* serialization of (re)configuration requests.</span>
<span class="cm">				 * if set, also prevents the device from dying */</span>
	<span class="n">DEVICE_DYING</span><span class="p">,</span>		<span class="cm">/* device became unconfigured,</span>
<span class="cm">				 * but worker thread is still handling the cleanup.</span>
<span class="cm">				 * reconfiguring (nl_disk_conf, nl_net_conf) is dissalowed,</span>
<span class="cm">				 * while this is set. */</span>
	<span class="n">RESIZE_PENDING</span><span class="p">,</span>		<span class="cm">/* Size change detected locally, waiting for the response from</span>
<span class="cm">				 * the peer, if it changed there as well. */</span>
	<span class="n">CONN_DRY_RUN</span><span class="p">,</span>		<span class="cm">/* Expect disconnect after resync handshake. */</span>
	<span class="n">GOT_PING_ACK</span><span class="p">,</span>		<span class="cm">/* set when we receive a ping_ack packet, misc wait gets woken */</span>
	<span class="n">NEW_CUR_UUID</span><span class="p">,</span>		<span class="cm">/* Create new current UUID when thawing IO */</span>
	<span class="n">AL_SUSPENDED</span><span class="p">,</span>		<span class="cm">/* Activity logging is currently suspended. */</span>
	<span class="n">AHEAD_TO_SYNC_SOURCE</span><span class="p">,</span>   <span class="cm">/* Ahead -&gt; SyncSource queued */</span>
	<span class="n">STATE_SENT</span><span class="p">,</span>		<span class="cm">/* Do not change state/UUIDs while this is set */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_bitmap</span><span class="p">;</span> <span class="cm">/* opaque for drbd_conf */</span>

<span class="cm">/* definition of bits in bm_flags to be used in drbd_bm_lock</span>
<span class="cm"> * and drbd_bitmap_io and friends. */</span>
<span class="k">enum</span> <span class="n">bm_flag</span> <span class="p">{</span>
	<span class="cm">/* do we need to kfree, or vfree bm_pages? */</span>
	<span class="n">BM_P_VMALLOCED</span> <span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="cm">/* internal use only, will be masked out */</span>

	<span class="cm">/* currently locked for bulk operation */</span>
	<span class="n">BM_LOCKED_MASK</span> <span class="o">=</span> <span class="mh">0xf</span><span class="p">,</span>

	<span class="cm">/* in detail, that is: */</span>
	<span class="n">BM_DONT_CLEAR</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">BM_DONT_SET</span>   <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">BM_DONT_TEST</span>  <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>

	<span class="cm">/* so we can mark it locked for bulk operation,</span>
<span class="cm">	 * and still allow all non-bulk operations */</span>
	<span class="n">BM_IS_LOCKED</span>  <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>

	<span class="cm">/* (test bit, count bit) allowed (common case) */</span>
	<span class="n">BM_LOCKED_TEST_ALLOWED</span> <span class="o">=</span> <span class="n">BM_DONT_CLEAR</span> <span class="o">|</span> <span class="n">BM_DONT_SET</span> <span class="o">|</span> <span class="n">BM_IS_LOCKED</span><span class="p">,</span>

	<span class="cm">/* testing bits, as well as setting new bits allowed, but clearing bits</span>
<span class="cm">	 * would be unexpected.  Used during bitmap receive.  Setting new bits</span>
<span class="cm">	 * requires sending of &quot;out-of-sync&quot; information, though. */</span>
	<span class="n">BM_LOCKED_SET_ALLOWED</span> <span class="o">=</span> <span class="n">BM_DONT_CLEAR</span> <span class="o">|</span> <span class="n">BM_IS_LOCKED</span><span class="p">,</span>

	<span class="cm">/* for drbd_bm_write_copy_pages, everything is allowed,</span>
<span class="cm">	 * only concurrent bulk operations are locked out. */</span>
	<span class="n">BM_LOCKED_CHANGE_ALLOWED</span> <span class="o">=</span> <span class="n">BM_IS_LOCKED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_work_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">semaphore</span> <span class="n">s</span><span class="p">;</span> <span class="cm">/* producers up it, worker down()s it */</span>
	<span class="n">spinlock_t</span> <span class="n">q_lock</span><span class="p">;</span>  <span class="cm">/* to protect the list. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_socket</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_work_queue</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span>    <span class="o">*</span><span class="n">socket</span><span class="p">;</span>
	<span class="cm">/* this way we get our</span>
<span class="cm">	 * send/receive buffers off the stack */</span>
	<span class="k">union</span> <span class="n">p_polymorph</span> <span class="n">sbuf</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">p_polymorph</span> <span class="n">rbuf</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_md</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">md_offset</span><span class="p">;</span>		<span class="cm">/* sector offset to &#39;super&#39; block */</span>

	<span class="n">u64</span> <span class="n">la_size_sect</span><span class="p">;</span>	<span class="cm">/* last agreed size, unit sectors */</span>
	<span class="n">u64</span> <span class="n">uuid</span><span class="p">[</span><span class="n">UI_SIZE</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">device_uuid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">md_size_sect</span><span class="p">;</span>

	<span class="n">s32</span> <span class="n">al_offset</span><span class="p">;</span>	<span class="cm">/* signed relative sector offset to al area */</span>
	<span class="n">s32</span> <span class="n">bm_offset</span><span class="p">;</span>	<span class="cm">/* signed relative sector offset to bitmap */</span>

	<span class="cm">/* u32 al_nr_extents;	   important for restoring the AL</span>
<span class="cm">	 * is stored into  sync_conf.al_extents, which in turn</span>
<span class="cm">	 * gets applied to act_log-&gt;nr_elements</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="cm">/* for sync_conf and other types... */</span>
<span class="cp">#define NL_PACKET(name, number, fields) struct name { fields };</span>
<span class="cp">#define NL_INTEGER(pn,pr,member) int member;</span>
<span class="cp">#define NL_INT64(pn,pr,member) __u64 member;</span>
<span class="cp">#define NL_BIT(pn,pr,member)   unsigned member:1;</span>
<span class="cp">#define NL_STRING(pn,pr,member,len) unsigned char member[len]; int member ## _len;</span>
<span class="cp">#include &lt;linux/drbd_nl.h&gt;</span>

<span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">backing_bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">md_bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_md</span> <span class="n">md</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_conf</span> <span class="n">dc</span><span class="p">;</span> <span class="cm">/* The user provided config... */</span>
	<span class="n">sector_t</span> <span class="n">known_size</span><span class="p">;</span> <span class="cm">/* last known size of that backing device */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_md_io</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bm_io_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_work</span> <span class="n">w</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">why</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">bm_flag</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">io_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">write_ordering_e</span> <span class="p">{</span>
	<span class="n">WO_none</span><span class="p">,</span>
	<span class="n">WO_drain_io</span><span class="p">,</span>
	<span class="n">WO_bdev_flush</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fifo_buffer</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">values</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="p">{</span>
	<span class="cm">/* things that are stored as / read from meta data on disk */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* configured by drbdsetup */</span>
	<span class="k">struct</span> <span class="n">net_conf</span> <span class="o">*</span><span class="n">net_conf</span><span class="p">;</span> <span class="cm">/* protected by get_net_conf() and put_net_conf() */</span>
	<span class="k">struct</span> <span class="n">syncer_conf</span> <span class="n">sync_conf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">ldev</span> <span class="n">__protected_by</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>

	<span class="n">sector_t</span> <span class="n">p_size</span><span class="p">;</span>     <span class="cm">/* partner&#39;s disk size */</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">rq_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">this_bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span>	    <span class="o">*</span><span class="n">vdisk</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drbd_socket</span> <span class="n">data</span><span class="p">;</span> <span class="cm">/* data/barrier/cstate/parameter packets */</span>
	<span class="k">struct</span> <span class="n">drbd_socket</span> <span class="n">meta</span><span class="p">;</span> <span class="cm">/* ping/ack (metadata) packets */</span>
	<span class="kt">int</span> <span class="n">agreed_pro_version</span><span class="p">;</span>  <span class="cm">/* actually used protocol version */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_received</span><span class="p">;</span> <span class="cm">/* in jiffies, either socket */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ko_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_work</span>  <span class="n">resync_work</span><span class="p">,</span>
			  <span class="n">unplug_work</span><span class="p">,</span>
			  <span class="n">go_diskless</span><span class="p">,</span>
			  <span class="n">md_sync_work</span><span class="p">,</span>
			  <span class="n">start_resync_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">resync_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">md_sync_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">start_resync_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">request_timer</span><span class="p">;</span>
<span class="cp">#ifdef DRBD_DEBUG_MD_SYNC</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">func</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">last_md_mark_dirty</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Used after attach while negotiating new disk state. */</span>
	<span class="k">union</span> <span class="n">drbd_state</span> <span class="n">new_state_tmp</span><span class="p">;</span>

	<span class="k">union</span> <span class="n">drbd_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">misc_wait</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">state_wait</span><span class="p">;</span>  <span class="cm">/* upon each state change. */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">net_cnt_wait</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">send_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recv_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">read_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">writ_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">al_writ_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bm_writ_cnt</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">ap_bio_cnt</span><span class="p">;</span>	 <span class="cm">/* Requests we need to complete */</span>
	<span class="n">atomic_t</span> <span class="n">ap_pending_cnt</span><span class="p">;</span> <span class="cm">/* AP data packets on the wire, ack expected */</span>
	<span class="n">atomic_t</span> <span class="n">rs_pending_cnt</span><span class="p">;</span> <span class="cm">/* RS request/data packets on the wire */</span>
	<span class="n">atomic_t</span> <span class="n">unacked_cnt</span><span class="p">;</span>	 <span class="cm">/* Need to send replys for */</span>
	<span class="n">atomic_t</span> <span class="n">local_cnt</span><span class="p">;</span>	 <span class="cm">/* Waiting for local completion */</span>
	<span class="n">atomic_t</span> <span class="n">net_cnt</span><span class="p">;</span>	 <span class="cm">/* Users of net_conf */</span>
	<span class="n">spinlock_t</span> <span class="n">req_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_tl_epoch</span> <span class="o">*</span><span class="n">unused_spare_tle</span><span class="p">;</span> <span class="cm">/* for pre-allocation */</span>
	<span class="k">struct</span> <span class="n">drbd_tl_epoch</span> <span class="o">*</span><span class="n">newest_tle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_tl_epoch</span> <span class="o">*</span><span class="n">oldest_tle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">out_of_sequence_requests</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">barrier_acked_requests</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">tl_hash</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tl_hash_s</span><span class="p">;</span>

	<span class="cm">/* blocks to resync in this run [unit BM_BLOCK_SIZE] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs_total</span><span class="p">;</span>
	<span class="cm">/* number of resync blocks that failed in this run */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs_failed</span><span class="p">;</span>
	<span class="cm">/* Syncer&#39;s start time [unit jiffies] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs_start</span><span class="p">;</span>
	<span class="cm">/* cumulated time in PausedSyncX state [unit jiffies] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs_paused</span><span class="p">;</span>
	<span class="cm">/* skipped because csum was equal [unit BM_BLOCK_SIZE] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs_same_csum</span><span class="p">;</span>
<span class="cp">#define DRBD_SYNC_MARKS 8</span>
<span class="cp">#define DRBD_SYNC_MARK_STEP (3*HZ)</span>
	<span class="cm">/* block not up-to-date at mark [unit BM_BLOCK_SIZE] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs_mark_left</span><span class="p">[</span><span class="n">DRBD_SYNC_MARKS</span><span class="p">];</span>
	<span class="cm">/* marks&#39;s time [unit jiffies] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs_mark_time</span><span class="p">[</span><span class="n">DRBD_SYNC_MARKS</span><span class="p">];</span>
	<span class="cm">/* current index into rs_mark_{left,time} */</span>
	<span class="kt">int</span> <span class="n">rs_last_mark</span><span class="p">;</span>

	<span class="cm">/* where does the admin want us to start? (sector) */</span>
	<span class="n">sector_t</span> <span class="n">ov_start_sector</span><span class="p">;</span>
	<span class="cm">/* where are we now? (sector) */</span>
	<span class="n">sector_t</span> <span class="n">ov_position</span><span class="p">;</span>
	<span class="cm">/* Start sector of out of sync range (to merge printk reporting). */</span>
	<span class="n">sector_t</span> <span class="n">ov_last_oos_start</span><span class="p">;</span>
	<span class="cm">/* size of out-of-sync range in sectors. */</span>
	<span class="n">sector_t</span> <span class="n">ov_last_oos_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ov_left</span><span class="p">;</span> <span class="cm">/* in bits */</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">csums_tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">verify_tfm</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_reattach_jif</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_reconnect_jif</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_thread</span> <span class="n">receiver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_thread</span> <span class="n">worker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_thread</span> <span class="n">asender</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_resync_fo</span><span class="p">;</span> <span class="cm">/* bit offset for drbd_bm_find_next */</span>

	<span class="cm">/* Used to track operations of resync... */</span>
	<span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">resync</span><span class="p">;</span>
	<span class="cm">/* Number of locked elements in resync LRU */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resync_locked</span><span class="p">;</span>
	<span class="cm">/* resync extent number waiting for application requests */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resync_wenr</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">open_cnt</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">p_uuid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_epoch</span> <span class="o">*</span><span class="n">current_epoch</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">epoch_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epochs</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">write_ordering_e</span> <span class="n">write_ordering</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">active_ee</span><span class="p">;</span> <span class="cm">/* IO in progress (P_DATA gets written to disk) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sync_ee</span><span class="p">;</span>   <span class="cm">/* IO in progress (P_RS_DATA_REPLY gets written to disk) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">done_ee</span><span class="p">;</span>   <span class="cm">/* send ack */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">read_ee</span><span class="p">;</span>   <span class="cm">/* IO in progress (any read) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">net_ee</span><span class="p">;</span>    <span class="cm">/* zero-copy network send in progress */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">ee_hash</span><span class="p">;</span> <span class="cm">/* is proteced by req_lock! */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ee_hash_s</span><span class="p">;</span>

	<span class="cm">/* this one is protected by ee_lock, single thread */</span>
	<span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="n">last_write_w_barrier</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">next_barrier_nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">app_reads_hash</span><span class="p">;</span> <span class="cm">/* is proteced by req_lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">resync_reads</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">pp_in_use</span><span class="p">;</span>		<span class="cm">/* allocated from page pool */</span>
	<span class="n">atomic_t</span> <span class="n">pp_in_use_by_net</span><span class="p">;</span>	<span class="cm">/* sendpage()d, still referenced by tcp */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">ee_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">md_io_page</span><span class="p">;</span>	<span class="cm">/* one page buffer for md_io */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">md_io_tmpp</span><span class="p">;</span>	<span class="cm">/* for logical_block_size != 512 */</span>
	<span class="k">struct</span> <span class="n">drbd_md_io</span> <span class="n">md_io</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">md_io_in_use</span><span class="p">;</span>		<span class="cm">/* protects the md_io, md_io_page and md_io_tmpp */</span>
	<span class="n">spinlock_t</span> <span class="n">al_lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">al_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">act_log</span><span class="p">;</span>	<span class="cm">/* activity log */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">al_tr_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">al_tr_cycle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">al_tr_pos</span><span class="p">;</span>   <span class="cm">/* position of the next transaction in the journal */</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">cram_hmac_tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">integrity_w_tfm</span><span class="p">;</span> <span class="cm">/* to be used by the worker thread */</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">integrity_r_tfm</span><span class="p">;</span> <span class="cm">/* to be used by the receiver thread */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">int_dig_out</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">int_dig_in</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">int_dig_vv</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">seq_wait</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">packet_seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">peer_seq</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">peer_seq_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">comm_bm_set</span><span class="p">;</span> <span class="cm">/* communicated number of set bits. */</span>
	<span class="n">cpumask_var_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bm_io_work</span> <span class="n">bm_io_work</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ed_uuid</span><span class="p">;</span> <span class="cm">/* UUID of the exposed data */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">state_mutex</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">congestion_reason</span><span class="p">;</span>  <span class="cm">/* Why we where congested... */</span>
	<span class="n">atomic_t</span> <span class="n">rs_sect_in</span><span class="p">;</span> <span class="cm">/* for incoming resync data rate, SyncTarget */</span>
	<span class="n">atomic_t</span> <span class="n">rs_sect_ev</span><span class="p">;</span> <span class="cm">/* for submitted resync data rate, both */</span>
	<span class="kt">int</span> <span class="n">rs_last_sect_ev</span><span class="p">;</span> <span class="cm">/* counter to compare with */</span>
	<span class="kt">int</span> <span class="n">rs_last_events</span><span class="p">;</span>  <span class="cm">/* counter of read or write &quot;events&quot; (unit sectors)</span>
<span class="cm">			      * on the lower level device when we last looked. */</span>
	<span class="kt">int</span> <span class="n">c_sync_rate</span><span class="p">;</span> <span class="cm">/* current resync rate after syncer throttle magic */</span>
	<span class="k">struct</span> <span class="n">fifo_buffer</span> <span class="n">rs_plan_s</span><span class="p">;</span> <span class="cm">/* correction values of resync planer */</span>
	<span class="kt">int</span> <span class="n">rs_in_flight</span><span class="p">;</span> <span class="cm">/* resync sectors in flight (to proxy, in proxy and from proxy) */</span>
	<span class="kt">int</span> <span class="n">rs_planed</span><span class="p">;</span>    <span class="cm">/* resync sectors already planned */</span>
	<span class="n">atomic_t</span> <span class="n">ap_in_flight</span><span class="p">;</span> <span class="cm">/* App sectors in flight (waiting for ack) */</span>
	<span class="kt">int</span> <span class="n">peer_max_bio_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">local_max_bio_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="nf">minor_to_mdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">;</span>

	<span class="n">mdev</span> <span class="o">=</span> <span class="n">minor</span> <span class="o">&lt;</span> <span class="n">minor_count</span> <span class="o">?</span> <span class="n">minor_table</span><span class="p">[</span><span class="n">minor</span><span class="p">]</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mdev_to_minor</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns 1 if it was successful,</span>
<span class="cm"> * returns 0 if there was no data socket.</span>
<span class="cm"> * so wherever you are going to use the data.socket, e.g. do</span>
<span class="cm"> * if (!drbd_get_data_sock(mdev))</span>
<span class="cm"> *	return 0;</span>
<span class="cm"> *	CODE();</span>
<span class="cm"> * drbd_put_data_sock(mdev);</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_get_data_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="cm">/* drbd_disconnect() could have called drbd_free_sock()</span>
<span class="cm">	 * while we were waiting in down()... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">socket</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_put_data_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * function declarations</span>
<span class="cm"> *************************/</span>

<span class="cm">/* drbd_main.c */</span>

<span class="k">enum</span> <span class="n">chg_state_flags</span> <span class="p">{</span>
	<span class="n">CS_HARD</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CS_VERBOSE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">CS_WAIT_COMPLETE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">CS_SERIALIZE</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">CS_ORDERED</span>      <span class="o">=</span> <span class="n">CS_WAIT_COMPLETE</span> <span class="o">+</span> <span class="n">CS_SERIALIZE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">dds_flags</span> <span class="p">{</span>
	<span class="n">DDSF_FORCED</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DDSF_NO_RESYNC</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* Do not run a resync for the new space */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_init_set_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">drbd_state_rv</span> <span class="n">drbd_change_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
					    <span class="k">enum</span> <span class="n">chg_state_flags</span> <span class="n">f</span><span class="p">,</span>
					    <span class="k">union</span> <span class="n">drbd_state</span> <span class="n">mask</span><span class="p">,</span>
					    <span class="k">union</span> <span class="n">drbd_state</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_force_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">drbd_state</span><span class="p">,</span>
			<span class="k">union</span> <span class="n">drbd_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">drbd_state_rv</span> <span class="n">_drbd_request_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span>
					      <span class="k">union</span> <span class="n">drbd_state</span><span class="p">,</span>
					      <span class="k">union</span> <span class="n">drbd_state</span><span class="p">,</span>
					      <span class="k">enum</span> <span class="n">chg_state_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">drbd_state_rv</span> <span class="n">__drbd_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">drbd_state</span><span class="p">,</span>
					   <span class="k">enum</span> <span class="n">chg_state_flags</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">done</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">print_st_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">drbd_state</span><span class="p">,</span>
			<span class="k">union</span> <span class="n">drbd_state</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_thread_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="n">thi</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_drbd_thread_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="n">thi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">restart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_thread_current_set_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_calc_cpu_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define drbd_thread_current_set_cpu(A) ({})</span>
<span class="cp">#define drbd_calc_cpu_mask(A) ({})</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_free_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tl_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">barrier_nr</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tl_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_tl_add_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_tl_epoch</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_free_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">msg_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_protocol</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_uuids</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_uuids_skip_initial_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_gen_and_send_sync_uuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trigger_reply</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dds_flags</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">union</span> <span class="n">drbd_state</span> <span class="n">s</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_current_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_drbd_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">p_header80</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">msg_flags</span><span class="p">);</span>
<span class="cp">#define USE_DATA_SOCKET 1</span>
<span class="cp">#define USE_META_SOCKET 0</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_data_socket</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">p_header80</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_cmd2</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_sync_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">syncer_conf</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_b_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">barrier_nr</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">set_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_ack_rp</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">p_block_req</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_ack_dp</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">p_data</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_ack_ex</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blksize</span><span class="p">,</span> <span class="n">u64</span> <span class="n">block_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_oos</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_dblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_drequest</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			      <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">block_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_drequest_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
				   <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">digest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">digest_size</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_ov_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span><span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_drbd_send_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_send_sr_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_state_rv</span> <span class="n">retcode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_free_bc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">ldev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_mdev_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drbd_print_uuids</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_md_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_md_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_uuid_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_drbd_uuid_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_uuid_new_current</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_drbd_uuid_new_current</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_uuid_set_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_md_set_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_md_clear_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span><span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_md_test_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#ifndef DRBD_DEBUG_MD_SYNC</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_md_mark_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define drbd_md_mark_dirty(m)	drbd_md_mark_dirty_(m, __LINE__ , __func__ )</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_md_mark_dirty_</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_queue_bitmap_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">io_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">),</span>
				 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">why</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bm_flag</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_bitmap_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">io_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">),</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">why</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bm_flag</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_bmio_set_n_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_bmio_clear_n_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_go_diskless</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_ldev_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>


<span class="cm">/* Meta data layout</span>
<span class="cm">   We reserve a 128MB Block (4k aligned)</span>
<span class="cm">   * either at the end of the backing device</span>
<span class="cm">   * or on a separate meta data device. */</span>

<span class="cp">#define MD_RESERVED_SECT (128LU &lt;&lt; 11)  </span><span class="cm">/* 128 MB, unit sectors */</span><span class="cp"></span>
<span class="cm">/* The following numbers are sectors */</span>
<span class="cp">#define MD_AL_OFFSET 8	    </span><span class="cm">/* 8 Sectors after start of meta area */</span><span class="cp"></span>
<span class="cp">#define MD_AL_MAX_SIZE 64   </span><span class="cm">/* = 32 kb LOG  ~ 3776 extents ~ 14 GB Storage */</span><span class="cp"></span>
<span class="cm">/* Allows up to about 3.8TB */</span>
<span class="cp">#define MD_BM_OFFSET (MD_AL_OFFSET + MD_AL_MAX_SIZE)</span>

<span class="cm">/* Since the smalles IO unit is usually 512 byte */</span>
<span class="cp">#define MD_SECTOR_SHIFT	 9</span>
<span class="cp">#define MD_SECTOR_SIZE	 (1&lt;&lt;MD_SECTOR_SHIFT)</span>

<span class="cm">/* activity log */</span>
<span class="cp">#define AL_EXTENTS_PT ((MD_SECTOR_SIZE-12)/8-1) </span><span class="cm">/* 61 ; Extents per 512B sector */</span><span class="cp"></span>
<span class="cp">#define AL_EXTENT_SHIFT 22		 </span><span class="cm">/* One extent represents 4M Storage */</span><span class="cp"></span>
<span class="cp">#define AL_EXTENT_SIZE (1&lt;&lt;AL_EXTENT_SHIFT)</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cp">#define LN2_BPL 5</span>
<span class="cp">#define cpu_to_lel(A) cpu_to_le32(A)</span>
<span class="cp">#define lel_to_cpu(A) le32_to_cpu(A)</span>
<span class="cp">#elif BITS_PER_LONG == 64</span>
<span class="cp">#define LN2_BPL 6</span>
<span class="cp">#define cpu_to_lel(A) cpu_to_le64(A)</span>
<span class="cp">#define lel_to_cpu(A) le64_to_cpu(A)</span>
<span class="cp">#else</span>
<span class="cp">#error &quot;LN2 of BITS_PER_LONG unknown!&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* resync bitmap */</span>
<span class="cm">/* 16MB sized &#39;bitmap extent&#39; to track syncer usage */</span>
<span class="k">struct</span> <span class="n">bm_extent</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">rs_left</span><span class="p">;</span> <span class="cm">/* number of bits set (out of sync) in this extent. */</span>
	<span class="kt">int</span> <span class="n">rs_failed</span><span class="p">;</span> <span class="cm">/* number of failed resync requests in this extent. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="n">lce</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define BME_NO_WRITES  0  </span><span class="cm">/* bm_extent.flags: no more requests on this one! */</span><span class="cp"></span>
<span class="cp">#define BME_LOCKED     1  </span><span class="cm">/* bm_extent.flags: syncer active on this one. */</span><span class="cp"></span>
<span class="cp">#define BME_PRIORITY   2  </span><span class="cm">/* finish resync IO on this extent ASAP! App IO waiting! */</span><span class="cp"></span>

<span class="cm">/* drbd_bitmap.c */</span>
<span class="cm">/*</span>
<span class="cm"> * We need to store one bit for a block.</span>
<span class="cm"> * Example: 1GB disk @ 4096 byte blocks ==&gt; we need 32 KB bitmap.</span>
<span class="cm"> * Bit 0 ==&gt; local node thinks this block is binary identical on both nodes</span>
<span class="cm"> * Bit 1 ==&gt; local node thinks this block needs to be synced.</span>
<span class="cm"> */</span>

<span class="cp">#define SLEEP_TIME (HZ/10)</span>

<span class="cp">#define BM_BLOCK_SHIFT  12			 </span><span class="cm">/* 4k per bit */</span><span class="cp"></span>
<span class="cp">#define BM_BLOCK_SIZE	 (1&lt;&lt;BM_BLOCK_SHIFT)</span>
<span class="cm">/* (9+3) : 512 bytes @ 8 bits; representing 16M storage</span>
<span class="cm"> * per sector of on disk bitmap */</span>
<span class="cp">#define BM_EXT_SHIFT	 (BM_BLOCK_SHIFT + MD_SECTOR_SHIFT + 3)  </span><span class="cm">/* = 24 */</span><span class="cp"></span>
<span class="cp">#define BM_EXT_SIZE	 (1&lt;&lt;BM_EXT_SHIFT)</span>

<span class="cp">#if (BM_EXT_SHIFT != 24) || (BM_BLOCK_SHIFT != 12)</span>
<span class="cp">#error &quot;HAVE YOU FIXED drbdmeta AS WELL??&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* thus many _storage_ sectors are described by one bit */</span>
<span class="cp">#define BM_SECT_TO_BIT(x)   ((x)&gt;&gt;(BM_BLOCK_SHIFT-9))</span>
<span class="cp">#define BM_BIT_TO_SECT(x)   ((sector_t)(x)&lt;&lt;(BM_BLOCK_SHIFT-9))</span>
<span class="cp">#define BM_SECT_PER_BIT     BM_BIT_TO_SECT(1)</span>

<span class="cm">/* bit to represented kilo byte conversion */</span>
<span class="cp">#define Bit2KB(bits) ((bits)&lt;&lt;(BM_BLOCK_SHIFT-10))</span>

<span class="cm">/* in which _bitmap_ extent (resp. sector) the bit for a certain</span>
<span class="cm"> * _storage_ sector is located in */</span>
<span class="cp">#define BM_SECT_TO_EXT(x)   ((x)&gt;&gt;(BM_EXT_SHIFT-9))</span>

<span class="cm">/* how much _storage_ sectors we have per bitmap sector */</span>
<span class="cp">#define BM_EXT_TO_SECT(x)   ((sector_t)(x) &lt;&lt; (BM_EXT_SHIFT-9))</span>
<span class="cp">#define BM_SECT_PER_EXT     BM_EXT_TO_SECT(1)</span>

<span class="cm">/* in one sector of the bitmap, we have this many activity_log extents. */</span>
<span class="cp">#define AL_EXT_PER_BM_SECT  (1 &lt;&lt; (BM_EXT_SHIFT - AL_EXTENT_SHIFT))</span>
<span class="cp">#define BM_WORDS_PER_AL_EXT (1 &lt;&lt; (AL_EXTENT_SHIFT-BM_BLOCK_SHIFT-LN2_BPL))</span>

<span class="cp">#define BM_BLOCKS_PER_BM_EXT_B (BM_EXT_SHIFT - BM_BLOCK_SHIFT)</span>
<span class="cp">#define BM_BLOCKS_PER_BM_EXT_MASK  ((1&lt;&lt;BM_BLOCKS_PER_BM_EXT_B) - 1)</span>

<span class="cm">/* the extent in &quot;PER_EXTENT&quot; below is an activity log extent</span>
<span class="cm"> * we need that many (long words/bytes) to store the bitmap</span>
<span class="cm"> *		     of one AL_EXTENT_SIZE chunk of storage.</span>
<span class="cm"> * we can store the bitmap for that many AL_EXTENTS within</span>
<span class="cm"> * one sector of the _on_disk_ bitmap:</span>
<span class="cm"> * bit	 0	  bit 37   bit 38	     bit (512*8)-1</span>
<span class="cm"> *	     ...|........|........|.. // ..|........|</span>
<span class="cm"> * sect. 0	 `296	  `304			   ^(512*8*8)-1</span>
<span class="cm"> *</span>
<span class="cm">#define BM_WORDS_PER_EXT    ( (AL_EXT_SIZE/BM_BLOCK_SIZE) / BITS_PER_LONG )</span>
<span class="cm">#define BM_BYTES_PER_EXT    ( (AL_EXT_SIZE/BM_BLOCK_SIZE) / 8 )  // 128</span>
<span class="cm">#define BM_EXT_PER_SECT	    ( 512 / BM_BYTES_PER_EXTENT )	 //   4</span>
<span class="cm"> */</span>

<span class="cp">#define DRBD_MAX_SECTORS_32 (0xffffffffLU)</span>
<span class="cp">#define DRBD_MAX_SECTORS_BM \</span>
<span class="cp">	  ((MD_RESERVED_SECT - MD_BM_OFFSET) * (1LL&lt;&lt;(BM_EXT_SHIFT-9)))</span>
<span class="cp">#if DRBD_MAX_SECTORS_BM &lt; DRBD_MAX_SECTORS_32</span>
<span class="cp">#define DRBD_MAX_SECTORS      DRBD_MAX_SECTORS_BM</span>
<span class="cp">#define DRBD_MAX_SECTORS_FLEX DRBD_MAX_SECTORS_BM</span>
<span class="cp">#elif !defined(CONFIG_LBDAF) &amp;&amp; BITS_PER_LONG == 32</span>
<span class="cp">#define DRBD_MAX_SECTORS      DRBD_MAX_SECTORS_32</span>
<span class="cp">#define DRBD_MAX_SECTORS_FLEX DRBD_MAX_SECTORS_32</span>
<span class="cp">#else</span>
<span class="cp">#define DRBD_MAX_SECTORS      DRBD_MAX_SECTORS_BM</span>
<span class="cm">/* 16 TB in units of sectors */</span>
<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cm">/* adjust by one page worth of bitmap,</span>
<span class="cm"> * so we won&#39;t wrap around in drbd_bm_find_next_bit.</span>
<span class="cm"> * you should use 64bit OS for that much storage, anyways. */</span>
<span class="cp">#define DRBD_MAX_SECTORS_FLEX BM_BIT_TO_SECT(0xffff7fff)</span>
<span class="cp">#else</span>
<span class="cm">/* we allow up to 1 PiB now on 64bit architecture with &quot;flexible&quot; meta data */</span>
<span class="cp">#define DRBD_MAX_SECTORS_FLEX (1UL &lt;&lt; 51)</span>
<span class="cm">/* corresponds to (1UL &lt;&lt; 38) bits right now. */</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/* Sector shift value for the &quot;hash&quot; functions of tl_hash and ee_hash tables.</span>
<span class="cm"> * With a value of 8 all IO in one 128K block make it to the same slot of the</span>
<span class="cm"> * hash table. */</span>
<span class="cp">#define HT_SHIFT 8</span>
<span class="cp">#define DRBD_MAX_BIO_SIZE (1U&lt;&lt;(9+HT_SHIFT))</span>
<span class="cp">#define DRBD_MAX_BIO_SIZE_SAFE (1 &lt;&lt; 12)       </span><span class="cm">/* Works always = 4k */</span><span class="cp"></span>

<span class="cp">#define DRBD_MAX_SIZE_H80_PACKET (1 &lt;&lt; 15) </span><span class="cm">/* The old header only allows packets up to 32Kib data */</span><span class="cp"></span>

<span class="cm">/* Number of elements in the app_reads_hash */</span>
<span class="cp">#define APP_R_HSIZE 15</span>

<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sectors</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_new_bits</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_bm_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_bm_set_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_bm_clear_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="cm">/* set/clear/test only a few bits at a time */</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_set_bits</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_clear_bits</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_bm_count_bits</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">);</span>
<span class="cm">/* bm_set_bits variant for use while holding drbd_bm_lock,</span>
<span class="cm"> * may process the whole bitmap in one go */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_drbd_bm_set_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_test_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitnr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_e_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">enr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">drbd_bm_write_copy_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drbd_bm_ALe_set_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">al_enr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span>	     <span class="n">drbd_bm_words</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drbd_bm_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">sector_t</span>      <span class="n">drbd_bm_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>

<span class="cp">#define DRBD_END_OF_BITMAP	(~(unsigned long)0)</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drbd_bm_find_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">);</span>
<span class="cm">/* bm_find_next variants for use while you hold drbd_bm_lock() */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_drbd_bm_find_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_drbd_bm_find_next_zero</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_drbd_bm_total_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drbd_bm_total_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_bm_rs_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="cm">/* for receive_bitmap */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_bm_merge_lel</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">number</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
<span class="cm">/* for _drbd_send_bitmap */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_bm_get_lel</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">number</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_bm_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">why</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bm_flag</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_bm_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="cm">/* drbd_main.c */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">drbd_request_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">drbd_ee_cache</span><span class="p">;</span>	<span class="cm">/* epoch entries */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">drbd_bm_ext_cache</span><span class="p">;</span>	<span class="cm">/* bitmap extents */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">drbd_al_ext_cache</span><span class="p">;</span>	<span class="cm">/* activity log extents */</span>
<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">drbd_request_mempool</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">drbd_ee_mempool</span><span class="p">;</span>

<span class="cm">/* drbd&#39;s page pool, used to buffer data received from the peer,</span>
<span class="cm"> * or data requested by the peer.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not have an emergency reserve.</span>
<span class="cm"> *</span>
<span class="cm"> * When allocating from this pool, it first takes pages from the pool.</span>
<span class="cm"> * Only if the pool is depleted will try to allocate from the system.</span>
<span class="cm"> *</span>
<span class="cm"> * The assumption is that pages taken from this pool will be processed,</span>
<span class="cm"> * and given back, &quot;quickly&quot;, and then can be recycled, so we can avoid</span>
<span class="cm"> * frequent calls to alloc_page(), and still will be able to make progress even</span>
<span class="cm"> * under memory pressure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">drbd_pp_pool</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span>   <span class="n">drbd_pp_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span>	    <span class="n">drbd_pp_vacant</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">wait_queue_head_t</span> <span class="n">drbd_pp_wait</span><span class="p">;</span>

<span class="cm">/* We also need a standard (emergency-reserve backed) page pool</span>
<span class="cm"> * for meta data IO (activity log, bitmap).</span>
<span class="cm"> * We can keep it global, as long as it is used as &quot;N pages at a time&quot;.</span>
<span class="cm"> * 128 should be plenty, currently we probably can get away with as few as 1.</span>
<span class="cm"> */</span>
<span class="cp">#define DRBD_MIN_POOL_PAGES	128</span>
<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">drbd_md_io_page_pool</span><span class="p">;</span>

<span class="cm">/* We also need to make sure we get a bio</span>
<span class="cm"> * when we need it for housekeeping purposes */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">drbd_md_io_bio_set</span><span class="p">;</span>
<span class="cm">/* to allocate from that set */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_alloc_drbd</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">rwlock_t</span> <span class="n">global_state_lock</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">drbd_new_device</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_free_mdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">proc_details</span><span class="p">;</span>

<span class="cm">/* drbd_req */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_read_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_merge_bvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="o">*</span><span class="n">bvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_valid_ar_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_request</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">);</span>


<span class="cm">/* drbd_nl.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_suspend_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_resume_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ppsize</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">drbd_new_dev_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">enum</span> <span class="n">determine_dev_size</span> <span class="p">{</span> <span class="n">dev_size_error</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">unchanged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shrunk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">grew</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">determine_dev_size</span> <span class="n">drbd_determine_dev_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dds_flags</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">resync_after_online_grow</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_reconsider_max_bio_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">drbd_state_rv</span> <span class="n">drbd_set_role</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">drbd_role</span> <span class="n">new_role</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">force</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">drbd_disk_state</span> <span class="n">drbd_try_outdate_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_try_outdate_peer_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_khelper</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/* drbd_worker.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="n">thi</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_alter_sa</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">na</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_start_resync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_conns</span> <span class="n">side</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">resume_next_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">suspend_other_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_resync_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="cm">/* maybe rather drbd_main.c ? */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">drbd_md_get_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_md_put_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_md_sync_page_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wait_until_done_or_disk_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">done</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_ov_oos_found</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span><span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_rs_controller_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ov_oos_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ov_last_oos_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;Out of sync: start=%llu, size=%lu (sectors)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ov_last_oos_start</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ov_last_oos_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ov_last_oos_size</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_csum_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_csum_ee</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* worker callbacks */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_req_cancel_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_read_retry_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_e_end_data_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_e_end_rsdata_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_e_end_csum_rs_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_e_end_ov_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_e_end_ov_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_ov_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_resync_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_resume_next_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_send_write_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_send_dblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_send_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_send_read_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_prev_work_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_e_reissue</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_restart_disk_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_send_oos</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">w_start_resync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">resync_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">start_resync_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/* drbd_receiver.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_rs_should_slow_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_submit_ee</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">rw</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">fault_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_release_ee</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="n">drbd_alloc_ee</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
					    <span class="n">u64</span> <span class="n">id</span><span class="p">,</span>
					    <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span>
					    <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_free_some_ee</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_net</span><span class="p">);</span>
<span class="cp">#define drbd_free_ee(m,e)	drbd_free_some_ee(m, e, 0)</span>
<span class="cp">#define drbd_free_net_ee(m,e)	drbd_free_some_ee(m, e, 1)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_wait_ee_list_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_drbd_wait_ee_list_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_set_recv_tcq</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tcq_enabled</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_drbd_clear_done_ee</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">to_be_freed</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_flush_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_free_tl_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>

<span class="cm">/* yes, there is kernel_setsockopt, but only since 2.6.18. we don&#39;t need to</span>
<span class="cm"> * mess with get_fs/set_fs, we know we are KERNEL_DS always. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">SOL_SOCKET</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
					    <span class="n">optlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_tcp_cork</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">drbd_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_CORK</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_tcp_uncork</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">drbd_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_CORK</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_tcp_nodelay</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">drbd_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_tcp_quickack</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">drbd_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_QUICKACK</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">drbd_bump_write_ordering</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">write_ordering_e</span> <span class="n">wo</span><span class="p">);</span>

<span class="cm">/* drbd_proc.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">drbd_proc</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">drbd_proc_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drbd_conn_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">drbd_conns</span> <span class="n">s</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drbd_role_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">drbd_role</span> <span class="n">s</span><span class="p">);</span>

<span class="cm">/* drbd_actlog.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_al_begin_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_al_complete_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_rs_complete_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_rs_begin_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_try_rs_begin_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_rs_cancel_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_rs_del_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_rs_failed_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drbd_al_read_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_advance_rs_marks</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">still_to_go</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__drbd_set_in_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">);</span>
<span class="cp">#define drbd_set_in_sync(mdev, sector, size) \</span>
<span class="cp">	__drbd_set_in_sync(mdev, sector, size, __FILE__, __LINE__)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__drbd_set_out_of_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">);</span>
<span class="cp">#define drbd_set_out_of_sync(mdev, sector, size) \</span>
<span class="cp">	__drbd_set_out_of_sync(mdev, sector, size, __FILE__, __LINE__)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_al_apply_to_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drbd_al_shrink</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>


<span class="cm">/* drbd_nl.c */</span>

<span class="kt">void</span> <span class="n">drbd_nl_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="n">drbd_nl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drbd_bcast_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">union</span> <span class="n">drbd_state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drbd_bcast_sync_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drbd_bcast_ee</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dgs</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">seen_hash</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">calc_hash</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">drbd_epoch_entry</span><span class="o">*</span> <span class="n">e</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: DRBD State macros</span>
<span class="cm"> *</span>
<span class="cm"> * These macros are used to express state changes in easily readable form.</span>
<span class="cm"> *</span>
<span class="cm"> * The NS macros expand to a mask and a value, that can be bit ored onto the</span>
<span class="cm"> * current state as soon as the spinlock (req_lock) was taken.</span>
<span class="cm"> *</span>
<span class="cm"> * The _NS macros are used for state functions that get called with the</span>
<span class="cm"> * spinlock. These macros expand directly to the new state value.</span>
<span class="cm"> *</span>
<span class="cm"> * Besides the basic forms NS() and _NS() additional _?NS[23] are defined</span>
<span class="cm"> * to express state changes that affect more than one aspect of the state.</span>
<span class="cm"> *</span>
<span class="cm"> * E.g. NS2(conn, C_CONNECTED, peer, R_SECONDARY)</span>
<span class="cm"> * Means that the network connection was established and that the peer</span>
<span class="cm"> * is in secondary role.</span>
<span class="cm"> */</span>
<span class="cp">#define role_MASK R_MASK</span>
<span class="cp">#define peer_MASK R_MASK</span>
<span class="cp">#define disk_MASK D_MASK</span>
<span class="cp">#define pdsk_MASK D_MASK</span>
<span class="cp">#define conn_MASK C_MASK</span>
<span class="cp">#define susp_MASK 1</span>
<span class="cp">#define user_isp_MASK 1</span>
<span class="cp">#define aftr_isp_MASK 1</span>
<span class="cp">#define susp_nod_MASK 1</span>
<span class="cp">#define susp_fen_MASK 1</span>

<span class="cp">#define NS(T, S) \</span>
<span class="cp">	({ union drbd_state mask; mask.i = 0; mask.T = T##_MASK; mask; }), \</span>
<span class="cp">	({ union drbd_state val; val.i = 0; val.T = (S); val; })</span>
<span class="cp">#define NS2(T1, S1, T2, S2) \</span>
<span class="cp">	({ union drbd_state mask; mask.i = 0; mask.T1 = T1##_MASK; \</span>
<span class="cp">	  mask.T2 = T2##_MASK; mask; }), \</span>
<span class="cp">	({ union drbd_state val; val.i = 0; val.T1 = (S1); \</span>
<span class="cp">	  val.T2 = (S2); val; })</span>
<span class="cp">#define NS3(T1, S1, T2, S2, T3, S3) \</span>
<span class="cp">	({ union drbd_state mask; mask.i = 0; mask.T1 = T1##_MASK; \</span>
<span class="cp">	  mask.T2 = T2##_MASK; mask.T3 = T3##_MASK; mask; }), \</span>
<span class="cp">	({ union drbd_state val;  val.i = 0; val.T1 = (S1); \</span>
<span class="cp">	  val.T2 = (S2); val.T3 = (S3); val; })</span>

<span class="cp">#define _NS(D, T, S) \</span>
<span class="cp">	D, ({ union drbd_state __ns; __ns.i = D-&gt;state.i; __ns.T = (S); __ns; })</span>
<span class="cp">#define _NS2(D, T1, S1, T2, S2) \</span>
<span class="cp">	D, ({ union drbd_state __ns; __ns.i = D-&gt;state.i; __ns.T1 = (S1); \</span>
<span class="cp">	__ns.T2 = (S2); __ns; })</span>
<span class="cp">#define _NS3(D, T1, S1, T2, S2, T3, S3) \</span>
<span class="cp">	D, ({ union drbd_state __ns; __ns.i = D-&gt;state.i; __ns.T1 = (S1); \</span>
<span class="cp">	__ns.T2 = (S2); __ns.T3 = (S3); __ns; })</span>

<span class="cm">/*</span>
<span class="cm"> * inline helper functions</span>
<span class="cm"> *************************/</span>

<span class="cm">/* see also page_chain_add and friends in drbd_receiver.c */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">page_chain_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define page_chain_for_each(page) \</span>
<span class="cp">	for (; page &amp;&amp; ({ prefetch(page_chain_next(page)); 1; }); \</span>
<span class="cp">			page = page_chain_next(page))</span>
<span class="cp">#define page_chain_for_each_safe(page, n) \</span>
<span class="cp">	for (; page &amp;&amp; ({ n = page_chain_next(page); 1; }); page = n)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_ee_has_active_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_epoch_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="n">page_chain_for_each</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_state_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">misc_wait</span><span class="p">,</span>
		   <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CLUSTER_ST_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_state_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CLUSTER_ST_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">misc_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">drbd_state_rv</span>
<span class="nf">_drbd_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">union</span> <span class="n">drbd_state</span> <span class="n">ns</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">chg_state_flags</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">done</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">drbd_state_rv</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_state_lock</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">__drbd_set_state</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_state_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_request_state() - Reqest a state change</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> * @mask:	mask of state bits to change.</span>
<span class="cm"> * @val:	value of new state bits.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the most graceful way of requesting a state change. It is verbose</span>
<span class="cm"> * quite verbose in case the state change is not possible, and all those</span>
<span class="cm"> * state changes are globally serialized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_request_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
				     <span class="k">union</span> <span class="n">drbd_state</span> <span class="n">mask</span><span class="p">,</span>
				     <span class="k">union</span> <span class="n">drbd_state</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_drbd_request_state</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">CS_VERBOSE</span> <span class="o">+</span> <span class="n">CS_ORDERED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __drbd_chk_io_error(m,f) __drbd_chk_io_error_(m,f, __func__)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__drbd_chk_io_error_</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forcedetach</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">dc</span><span class="p">.</span><span class="n">on_io_error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EP_PASS_ON</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forcedetach</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drbd_ratelimit_state</span><span class="p">))</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;Local IO failed in %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">disk</span> <span class="o">&gt;</span> <span class="n">D_INCONSISTENT</span><span class="p">)</span>
				<span class="n">_drbd_set_state</span><span class="p">(</span><span class="n">_NS</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">D_INCONSISTENT</span><span class="p">),</span> <span class="n">CS_HARD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* NOTE fall through to detach case if forcedetach set */</span>
	<span class="k">case</span> <span class="n">EP_DETACH</span>:
	<span class="k">case</span> <span class="n">EP_CALL_HELPER</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">WAS_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">disk</span> <span class="o">&gt;</span> <span class="n">D_FAILED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_drbd_set_state</span><span class="p">(</span><span class="n">_NS</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">D_FAILED</span><span class="p">),</span> <span class="n">CS_HARD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span>
				<span class="s">&quot;Local IO failed in %s. Detaching...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_chk_io_error: Handle the on_io_error setting, should be called from all io completion handlers</span>
<span class="cm"> * @mdev:	 DRBD device.</span>
<span class="cm"> * @error:	 Error code passed to the IO completion callback</span>
<span class="cm"> * @forcedetach: Force detach. I.e. the error happened while accessing the meta data</span>
<span class="cm"> *</span>
<span class="cm"> * See also drbd_main.c:after_state_ch() if (os.disk &gt; D_FAILED &amp;&amp; ns.disk == D_FAILED)</span>
<span class="cm"> */</span>
<span class="cp">#define drbd_chk_io_error(m,e,f) drbd_chk_io_error_(m,e,f, __func__)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_chk_io_error_</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forcedetach</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">__drbd_chk_io_error_</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">forcedetach</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * drbd_md_first_sector() - Returns the first sector number of the meta data area</span>
<span class="cm"> * @bdev:	Meta data block device.</span>
<span class="cm"> *</span>
<span class="cm"> * BTW, for internal meta data, this happens to be the maximum capacity</span>
<span class="cm"> * we could agree upon with our peer node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">drbd_md_first_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">dc</span><span class="p">.</span><span class="n">meta_dev_idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_INTERNAL</span>:
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_INT</span>:
		<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_offset</span> <span class="o">+</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">bm_offset</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_EXT</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_offset</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_md_last_sector() - Return the last sector number of the meta data area</span>
<span class="cm"> * @bdev:	Meta data block device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">drbd_md_last_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">dc</span><span class="p">.</span><span class="n">meta_dev_idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_INTERNAL</span>:
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_INT</span>:
		<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_offset</span> <span class="o">+</span> <span class="n">MD_AL_OFFSET</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_EXT</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_offset</span> <span class="o">+</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_size_sect</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Returns the number of 512 byte sectors of the device */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">drbd_get_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* return bdev ? get_capacity(bdev-&gt;bd_disk) : 0; */</span>
	<span class="k">return</span> <span class="n">bdev</span> <span class="o">?</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_get_max_capacity() - Returns the capacity we announce to out peer</span>
<span class="cm"> * @bdev:	Meta data block device.</span>
<span class="cm"> *</span>
<span class="cm"> * returns the capacity we announce to out peer.  we clip ourselves at the</span>
<span class="cm"> * various MAX_SECTORS, because if we don&#39;t, current implementation will</span>
<span class="cm"> * oops sooner or later</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">drbd_get_max_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">dc</span><span class="p">.</span><span class="n">meta_dev_idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_INTERNAL</span>:
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_INT</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="n">drbd_get_capacity</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">backing_bdev</span><span class="p">)</span>
			<span class="o">?</span> <span class="n">min_t</span><span class="p">(</span><span class="n">sector_t</span><span class="p">,</span> <span class="n">DRBD_MAX_SECTORS_FLEX</span><span class="p">,</span>
					<span class="n">drbd_md_first_sector</span><span class="p">(</span><span class="n">bdev</span><span class="p">))</span>
			<span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_EXT</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">sector_t</span><span class="p">,</span> <span class="n">DRBD_MAX_SECTORS_FLEX</span><span class="p">,</span>
				<span class="n">drbd_get_capacity</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">backing_bdev</span><span class="p">));</span>
		<span class="cm">/* clip at maximum size the meta device can support */</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">sector_t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
			<span class="n">BM_EXT_TO_SECT</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_size_sect</span>
				     <span class="o">-</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">bm_offset</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">sector_t</span><span class="p">,</span> <span class="n">DRBD_MAX_SECTORS</span><span class="p">,</span>
				<span class="n">drbd_get_capacity</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">backing_bdev</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_md_ss__() - Return the sector number of our meta data super block</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> * @bdev:	Meta data block device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">drbd_md_ss__</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">drbd_backing_dev</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">dc</span><span class="p">.</span><span class="n">meta_dev_idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span> <span class="cm">/* external, some index */</span>
		<span class="k">return</span> <span class="n">MD_RESERVED_SECT</span> <span class="o">*</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">dc</span><span class="p">.</span><span class="n">meta_dev_idx</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_INTERNAL</span>:
		<span class="cm">/* with drbd08, internal meta data is always &quot;flexible&quot; */</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_INT</span>:
		<span class="cm">/* sizeof(struct md_on_disk_07) == 4k</span>
<span class="cm">		 * position: last 4k aligned block of 4k size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">backing_bdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drbd_ratelimit_state</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bdev-&gt;backing_bdev==NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">dump_stack</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">drbd_get_capacity</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">backing_bdev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7ULL</span><span class="p">)</span>
			<span class="o">-</span> <span class="n">MD_AL_OFFSET</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRBD_MD_INDEX_FLEX_EXT</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drbd_queue_work_front</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_work_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span> <span class="cm">/* within the spinlock,</span>
<span class="cm">		      see comment near end of drbd_worker() */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drbd_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_work_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drbd_work</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span> <span class="cm">/* within the spinlock,</span>
<span class="cm">		      see comment near end of drbd_worker() */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wake_asender</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SIGNAL_ASENDER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">DRBD_SIG</span><span class="p">,</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">asender</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">request_ping</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SEND_PING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_asender</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_send_short_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">drbd_packets</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">drbd_send_cmd</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">USE_DATA_SOCKET</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_send_ping</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">drbd_send_cmd</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">USE_META_SOCKET</span><span class="p">,</span> <span class="n">P_PING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_send_ping_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">p_header80</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">drbd_send_cmd</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">USE_META_SOCKET</span><span class="p">,</span> <span class="n">P_PING_ACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_thread_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="n">thi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_drbd_thread_stop</span><span class="p">(</span><span class="n">thi</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_thread_stop_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="n">thi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_drbd_thread_stop</span><span class="p">(</span><span class="n">thi</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_thread_restart_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_thread</span> <span class="o">*</span><span class="n">thi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_drbd_thread_stop</span><span class="p">(</span><span class="n">thi</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* counts how many answer packets packets we expect from our peer,</span>
<span class="cm"> * for either explicit application requests,</span>
<span class="cm"> * or implicit barrier packets as necessary.</span>
<span class="cm"> * increased:</span>
<span class="cm"> *  w_send_barrier</span>
<span class="cm"> *  _req_mod(req, queue_for_net_write or queue_for_net_read);</span>
<span class="cm"> *    it is much easier and equally valid to count what we queue for the</span>
<span class="cm"> *    worker, even before it actually was queued or send.</span>
<span class="cm"> *    (drbd_make_request_common; recovery path on read io-error)</span>
<span class="cm"> * decreased:</span>
<span class="cm"> *  got_BarrierAck (respective tl_clear, tl_clear_barrier)</span>
<span class="cm"> *  _req_mod(req, data_received)</span>
<span class="cm"> *     [from receive_DataReply]</span>
<span class="cm"> *  _req_mod(req, write_acked_by_peer or recv_acked_by_peer or neg_acked)</span>
<span class="cm"> *     [from got_BlockAck (P_WRITE_ACK, P_RECV_ACK)]</span>
<span class="cm"> *     for some reason it is NOT decreased in got_NegAck,</span>
<span class="cm"> *     but in the resulting cleanup code from report_params.</span>
<span class="cm"> *     we should try to remember the reason for that...</span>
<span class="cm"> *  _req_mod(req, send_failed or send_canceled)</span>
<span class="cm"> *  _req_mod(req, connection_lost_while_pending)</span>
<span class="cm"> *     [from tl_clear_barrier]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_ap_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ap_pending_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ERR_IF_CNT_IS_NEGATIVE(which)				\</span>
<span class="cp">	if (atomic_read(&amp;mdev-&gt;which) &lt; 0)			\</span>
<span class="cp">		dev_err(DEV, &quot;in %s:%d: &quot; #which &quot; = %d &lt; 0 !\n&quot;,	\</span>
<span class="cp">		    __func__ , __LINE__ ,			\</span>
<span class="cp">		    atomic_read(&amp;mdev-&gt;which))</span>

<span class="cp">#define dec_ap_pending(mdev)	do {				\</span>
<span class="cp">	typecheck(struct drbd_conf *, mdev);			\</span>
<span class="cp">	if (atomic_dec_and_test(&amp;mdev-&gt;ap_pending_cnt))		\</span>
<span class="cp">		wake_up(&amp;mdev-&gt;misc_wait);			\</span>
<span class="cp">	ERR_IF_CNT_IS_NEGATIVE(ap_pending_cnt); } while (0)</span>

<span class="cm">/* counts how many resync-related answers we still expect from the peer</span>
<span class="cm"> *		     increase			decrease</span>
<span class="cm"> * C_SYNC_TARGET sends P_RS_DATA_REQUEST (and expects P_RS_DATA_REPLY)</span>
<span class="cm"> * C_SYNC_SOURCE sends P_RS_DATA_REPLY   (and expects P_WRITE_ACK with ID_SYNCER)</span>
<span class="cm"> *					   (or P_NEG_ACK with ID_SYNCER)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_rs_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_pending_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define dec_rs_pending(mdev)	do {				\</span>
<span class="cp">	typecheck(struct drbd_conf *, mdev);			\</span>
<span class="cp">	atomic_dec(&amp;mdev-&gt;rs_pending_cnt);			\</span>
<span class="cp">	ERR_IF_CNT_IS_NEGATIVE(rs_pending_cnt); } while (0)</span>

<span class="cm">/* counts how many answers we still need to send to the peer.</span>
<span class="cm"> * increased on</span>
<span class="cm"> *  receive_Data	unless protocol A;</span>
<span class="cm"> *			we need to send a P_RECV_ACK (proto B)</span>
<span class="cm"> *			or P_WRITE_ACK (proto C)</span>
<span class="cm"> *  receive_RSDataReply (recv_resync_read) we need to send a P_WRITE_ACK</span>
<span class="cm"> *  receive_DataRequest (receive_RSDataRequest) we need to send back P_DATA</span>
<span class="cm"> *  receive_Barrier_*	we need to send a P_BARRIER_ACK</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_unacked</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">unacked_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define dec_unacked(mdev)	do {				\</span>
<span class="cp">	typecheck(struct drbd_conf *, mdev);			\</span>
<span class="cp">	atomic_dec(&amp;mdev-&gt;unacked_cnt);				\</span>
<span class="cp">	ERR_IF_CNT_IS_NEGATIVE(unacked_cnt); } while (0)</span>

<span class="cp">#define sub_unacked(mdev, n)	do {				\</span>
<span class="cp">	typecheck(struct drbd_conf *, mdev);			\</span>
<span class="cp">	atomic_sub(n, &amp;mdev-&gt;unacked_cnt);			\</span>
<span class="cp">	ERR_IF_CNT_IS_NEGATIVE(unacked_cnt); } while (0)</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_net_conf</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">net_cnt</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">net_cnt_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_net_conf() - Increase ref count on mdev-&gt;net_conf; Returns 0 if nothing there</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> *</span>
<span class="cm"> * You have to call put_net_conf() when finished working with mdev-&gt;net_conf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_net_conf</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">have_net_conf</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">net_cnt</span><span class="p">);</span>
	<span class="n">have_net_conf</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">conn</span> <span class="o">&gt;=</span> <span class="n">C_UNCONNECTED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_net_conf</span><span class="p">)</span>
		<span class="n">put_net_conf</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">have_net_conf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_ldev() - Increase the ref count on mdev-&gt;ldev. Returns 0 if there is no ldev</span>
<span class="cm"> * @M:		DRBD device.</span>
<span class="cm"> *</span>
<span class="cm"> * You have to call put_ldev() when finished working with mdev-&gt;ldev.</span>
<span class="cm"> */</span>
<span class="cp">#define get_ldev(M) __cond_lock(local, _get_ldev_if_state(M,D_INCONSISTENT))</span>
<span class="cp">#define get_ldev_if_state(M,MINS) __cond_lock(local, _get_ldev_if_state(M,MINS))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_ldev</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">local_cnt</span><span class="p">);</span>

	<span class="cm">/* This may be called from some endio handler,</span>
<span class="cm">	 * so we must not sleep here. */</span>

	<span class="n">__release</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>
	<span class="n">D_ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">disk</span> <span class="o">==</span> <span class="n">D_DISKLESS</span><span class="p">)</span>
			<span class="cm">/* even internal references gone, safe to destroy */</span>
			<span class="n">drbd_ldev_destroy</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">disk</span> <span class="o">==</span> <span class="n">D_FAILED</span><span class="p">)</span>
			<span class="cm">/* all application IO references gone. */</span>
			<span class="n">drbd_go_diskless</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">misc_wait</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifndef __CHECKER__</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_get_ldev_if_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_disk_state</span> <span class="n">mins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">io_allowed</span><span class="p">;</span>

	<span class="cm">/* never get a reference while D_DISKLESS */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">disk</span> <span class="o">==</span> <span class="n">D_DISKLESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">local_cnt</span><span class="p">);</span>
	<span class="n">io_allowed</span> <span class="o">=</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">disk</span> <span class="o">&gt;=</span> <span class="n">mins</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_allowed</span><span class="p">)</span>
		<span class="n">put_ldev</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">io_allowed</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_get_ldev_if_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drbd_disk_state</span> <span class="n">mins</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* you must have an &quot;get_ldev&quot; reference */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_get_syncer_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bits_left</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">per_mil_done</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* this is to break it at compile time when we change that, in case we</span>
<span class="cm">	 * want to support more than (1&lt;&lt;32) bits on a 32bit arch. */</span>
	<span class="n">typecheck</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_total</span><span class="p">);</span>

	<span class="cm">/* note: both rs_total and rs_left are in bits, i.e. in</span>
<span class="cm">	 * units of BM_BLOCK_SIZE.</span>
<span class="cm">	 * for the percentage, we don&#39;t care. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">conn</span> <span class="o">==</span> <span class="n">C_VERIFY_S</span> <span class="o">||</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">conn</span> <span class="o">==</span> <span class="n">C_VERIFY_T</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bits_left</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ov_left</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">bits_left</span> <span class="o">=</span> <span class="n">drbd_bm_total_weight</span><span class="p">(</span><span class="n">mdev</span><span class="p">)</span> <span class="o">-</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_failed</span><span class="p">;</span>
	<span class="cm">/* &gt;&gt; 10 to prevent overflow,</span>
<span class="cm">	 * +1 to prevent division by zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bits_left</span> <span class="o">&gt;</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_total</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* doh. maybe a logic bug somewhere.</span>
<span class="cm">		 * may also be just a race condition</span>
<span class="cm">		 * between this and a disconnect during sync.</span>
<span class="cm">		 * for now, just prevent in-kernel buffer overflow.</span>
<span class="cm">		 */</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;cs:%s rs_left=%lu &gt; rs_total=%lu (rs_failed %lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drbd_conn_str</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">conn</span><span class="p">),</span>
				<span class="o">*</span><span class="n">bits_left</span><span class="p">,</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_total</span><span class="p">,</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_failed</span><span class="p">);</span>
		<span class="o">*</span><span class="n">per_mil_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Make sure the division happens in long context.</span>
<span class="cm">		 * We allow up to one petabyte storage right now,</span>
<span class="cm">		 * at a granularity of 4k per bit that is 2**38 bits.</span>
<span class="cm">		 * After shift right and multiplication by 1000,</span>
<span class="cm">		 * this should still fit easily into a 32bit long,</span>
<span class="cm">		 * so we don&#39;t need a 64bit division on 32bit arch.</span>
<span class="cm">		 * Note: currently we don&#39;t support such large bitmaps on 32bit</span>
<span class="cm">		 * arch anyways, but no harm done to be prepared for it here.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_total</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">10</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="o">*</span><span class="n">bits_left</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">+</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_total</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">1000UL</span> <span class="o">-</span> <span class="n">left</span> <span class="o">*</span> <span class="mi">1000UL</span><span class="o">/</span><span class="n">total</span><span class="p">;</span>
		<span class="o">*</span><span class="n">per_mil_done</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* this throttles on-the-fly application requests</span>
<span class="cm"> * according to max_buffers settings;</span>
<span class="cm"> * maybe re-implement using semaphores? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_get_max_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mxb</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span> <span class="cm">/* arbitrary limit on open requests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_net_conf</span><span class="p">(</span><span class="n">mdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mxb</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">net_conf</span><span class="o">-&gt;</span><span class="n">max_buffers</span><span class="p">;</span>
		<span class="n">put_net_conf</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mxb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_state_is_stable</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">drbd_state</span> <span class="n">s</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="cm">/* DO NOT add a default clause, we want the compiler to warn us</span>
<span class="cm">	 * for any newly introduced state we may have forgotten to add here */</span>

	<span class="k">switch</span> <span class="p">((</span><span class="k">enum</span> <span class="n">drbd_conns</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* new io only accepted when there is no connection, ... */</span>
	<span class="k">case</span> <span class="n">C_STANDALONE</span>:
	<span class="k">case</span> <span class="n">C_WF_CONNECTION</span>:
	<span class="cm">/* ... or there is a well established connection. */</span>
	<span class="k">case</span> <span class="n">C_CONNECTED</span>:
	<span class="k">case</span> <span class="n">C_SYNC_SOURCE</span>:
	<span class="k">case</span> <span class="n">C_SYNC_TARGET</span>:
	<span class="k">case</span> <span class="n">C_VERIFY_S</span>:
	<span class="k">case</span> <span class="n">C_VERIFY_T</span>:
	<span class="k">case</span> <span class="n">C_PAUSED_SYNC_S</span>:
	<span class="k">case</span> <span class="n">C_PAUSED_SYNC_T</span>:
	<span class="k">case</span> <span class="n">C_AHEAD</span>:
	<span class="k">case</span> <span class="n">C_BEHIND</span>:
		<span class="cm">/* transitional states, IO allowed */</span>
	<span class="k">case</span> <span class="n">C_DISCONNECTING</span>:
	<span class="k">case</span> <span class="n">C_UNCONNECTED</span>:
	<span class="k">case</span> <span class="n">C_TIMEOUT</span>:
	<span class="k">case</span> <span class="n">C_BROKEN_PIPE</span>:
	<span class="k">case</span> <span class="n">C_NETWORK_FAILURE</span>:
	<span class="k">case</span> <span class="n">C_PROTOCOL_ERROR</span>:
	<span class="k">case</span> <span class="n">C_TEAR_DOWN</span>:
	<span class="k">case</span> <span class="n">C_WF_REPORT_PARAMS</span>:
	<span class="k">case</span> <span class="n">C_STARTING_SYNC_S</span>:
	<span class="k">case</span> <span class="n">C_STARTING_SYNC_T</span>:
		<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Allow IO in BM exchange states with new protocols */</span>
	<span class="k">case</span> <span class="n">C_WF_BITMAP_S</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">agreed_pro_version</span> <span class="o">&lt;</span> <span class="mi">96</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* no new io accepted in these states */</span>
	<span class="k">case</span> <span class="n">C_WF_BITMAP_T</span>:
	<span class="k">case</span> <span class="n">C_WF_SYNC_UUID</span>:
	<span class="k">case</span> <span class="n">C_MASK</span>:
		<span class="cm">/* not &quot;stable&quot; */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">((</span><span class="k">enum</span> <span class="n">drbd_disk_state</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">disk</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">D_DISKLESS</span>:
	<span class="k">case</span> <span class="n">D_INCONSISTENT</span>:
	<span class="k">case</span> <span class="n">D_OUTDATED</span>:
	<span class="k">case</span> <span class="n">D_CONSISTENT</span>:
	<span class="k">case</span> <span class="n">D_UP_TO_DATE</span>:
	<span class="k">case</span> <span class="n">D_FAILED</span>:
		<span class="cm">/* disk state is stable as well. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* no new io accepted during tansitional states */</span>
	<span class="k">case</span> <span class="n">D_ATTACHING</span>:
	<span class="k">case</span> <span class="n">D_NEGOTIATING</span>:
	<span class="k">case</span> <span class="n">D_UNKNOWN</span>:
	<span class="k">case</span> <span class="n">D_MASK</span>:
		<span class="cm">/* not &quot;stable&quot; */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_susp</span><span class="p">(</span><span class="k">union</span> <span class="n">drbd_state</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">susp</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">susp_nod</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">susp_fen</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">may_inc_ap_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mxb</span> <span class="o">=</span> <span class="n">drbd_get_max_buffers</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_susp</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SUSPEND_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* to avoid potential deadlock or bitmap corruption,</span>
<span class="cm">	 * in various places, we only allow new application io</span>
<span class="cm">	 * to start during &quot;stable&quot; states. */</span>

	<span class="cm">/* no new io accepted when attaching or detaching the disk */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drbd_state_is_stable</span><span class="p">(</span><span class="n">mdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* since some older kernels don&#39;t have atomic_add_unless,</span>
<span class="cm">	 * and we are within the spinlock anyways, we have this workaround.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ap_bio_cnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mxb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BITMAP_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">inc_ap_bio_cond</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">rv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">may_inc_ap_bio</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ap_bio_cnt</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_ap_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we wait here</span>
<span class="cm">	 *    as long as the device is suspended</span>
<span class="cm">	 *    until the bitmap is no longer on the fly during connection</span>
<span class="cm">	 *    handshake as long as we would exeed the max_buffer limit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * to avoid races with the reconnect code,</span>
<span class="cm">	 * we need to atomic_inc within the spinlock. */</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">misc_wait</span><span class="p">,</span> <span class="n">inc_ap_bio_cond</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">count</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dec_ap_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mxb</span> <span class="o">=</span> <span class="n">drbd_get_max_buffers</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ap_bio</span> <span class="o">=</span> <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ap_bio_cnt</span><span class="p">);</span>

	<span class="n">D_ASSERT</span><span class="p">(</span><span class="n">ap_bio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* this currently does wake_up for every dec_ap_bio!</span>
<span class="cm">	 * maybe rather introduce some type of hysteresis?</span>
<span class="cm">	 * e.g. (ap_bio == mxb/2 || ap_bio == 0) ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap_bio</span> <span class="o">&lt;</span> <span class="n">mxb</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">misc_wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap_bio</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BITMAP_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">BITMAP_IO_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">drbd_queue_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bm_io_work</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_set_ed_uuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ed_uuid</span> <span class="o">!=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ed_uuid</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">seq_cmp</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">,</span> <span class="n">u32</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we assume wrap around at 32bit.</span>
<span class="cm">	 * for wrap around at 24bit (old atomic_t),</span>
<span class="cm">	 * we&#39;d have to</span>
<span class="cm">	 *  a &lt;&lt;= 8; b &lt;&lt;= 8;</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define seq_lt(a, b) (seq_cmp((a), (b)) &lt; 0)</span>
<span class="cp">#define seq_gt(a, b) (seq_cmp((a), (b)) &gt; 0)</span>
<span class="cp">#define seq_ge(a, b) (seq_cmp((a), (b)) &gt;= 0)</span>
<span class="cp">#define seq_le(a, b) (seq_cmp((a), (b)) &lt;= 0)</span>
<span class="cm">/* CAUTION: please no side effects in arguments! */</span>
<span class="cp">#define seq_max(a, b) ((u32)(seq_gt((a), (b)) ? (a) : (b)))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_peer_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">peer_seq_lock</span><span class="p">);</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">seq_max</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">peer_seq</span><span class="p">,</span> <span class="n">new_seq</span><span class="p">);</span>
	<span class="n">mdev</span><span class="o">-&gt;</span><span class="n">peer_seq</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">peer_seq_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">new_seq</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">seq_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_update_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NET_CONGESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drbd_queue_order_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* sorry, we currently have no working implementation</span>
<span class="cm">	 * of distributed TCQ stuff */</span>
<span class="cp">#ifndef QUEUE_ORDERED_NONE</span>
<span class="cp">#define QUEUE_ORDERED_NONE 0</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">QUEUE_ORDERED_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drbd_md_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MD_NO_FUA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">blkdev_issue_flush</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">md_bdev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MD_NO_FUA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;meta data flush failed with status %d, disabling md-flushes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
